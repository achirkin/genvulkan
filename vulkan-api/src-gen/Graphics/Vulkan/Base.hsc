#include "vulkan/vulkan.h"
{-# OPTIONS_GHC -fno-warn-missing-methods#-}
{-# OPTIONS_GHC -fno-warn-unticked-promoted-constructors#-}
{-# LANGUAGE DataKinds            #-}
{-# LANGUAGE FlexibleContexts     #-}
{-# LANGUAGE FlexibleInstances    #-}
{-# LANGUAGE MagicHash            #-}
{-# LANGUAGE Strict               #-}
{-# LANGUAGE TypeFamilies         #-}
{-# LANGUAGE TypeOperators        #-}
{-# LANGUAGE UnboxedTuples        #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE UnliftedFFITypes     #-}
module Graphics.Vulkan.Base
       (-- > ##include "vulkan.h"
        --
        -- > ##include <X11/Xlib.h>
        --
        -- > ##include <X11/extensions/Xrandr.h>
        --
        -- > ##include <android/native_window.h>
        --
        -- > ##include <mir_toolkit/client_types.h>
        --
        -- > ##include <wayland-client.h>
        --
        -- > ##include <windows.h>
        --
        -- > ##include <xcb/xcb.h>
        HasVkX(..), HasVkY(..), VkOffset2D(..), HasVkZ(..),
        VkOffset3D(..), HasVkWidth(..), HasVkHeight(..), VkExtent2D(..),
        HasVkDepth(..), VkExtent3D(..), HasVkMinDepth(..),
        HasVkMaxDepth(..), VkViewport(..), HasVkOffset(..),
        HasVkExtent(..), VkRect2D(..), HasVkRect(..),
        HasVkBaseArrayLayer(..), HasVkLayerCount(..), VkClearRect(..),
        HasVkR(..), HasVkG(..), HasVkB(..), HasVkA(..),
        VkComponentMapping(..), HasVkApiVersion(..),
        HasVkDriverVersion(..), HasVkVendorID(..), HasVkDeviceID(..),
        HasVkDeviceType(..), HasVkDeviceNameArray(..),
        HasVkPipelineCacheUUIDArray(..), HasVkLimits(..),
        HasVkSparseProperties(..), VkPhysicalDeviceProperties(..),
        HasVkExtensionNameArray(..), HasVkSpecVersion(..),
        VkExtensionProperties(..), HasVkLayerNameArray(..),
        HasVkImplementationVersion(..), HasVkDescriptionArray(..),
        VkLayerProperties(..), HasVkSType(..), HasVkPNext(..),
        HasVkPApplicationName(..), HasVkApplicationVersion(..),
        HasVkPEngineName(..), HasVkEngineVersion(..),
        VkApplicationInfo(..), HasVkPUserData(..), HasVkPfnAllocation(..),
        HasVkPfnReallocation(..), HasVkPfnFree(..),
        HasVkPfnInternalAllocation(..), HasVkPfnInternalFree(..),
        VkAllocationCallbacks(..), HasVkFlags(..),
        HasVkQueueFamilyIndex(..), HasVkQueueCount(..),
        HasVkPQueuePriorities(..), VkDeviceQueueCreateInfo(..),
        HasVkQueueCreateInfoCount(..), HasVkPQueueCreateInfos(..),
        HasVkEnabledLayerCount(..), HasVkPpEnabledLayerNames(..),
        HasVkEnabledExtensionCount(..), HasVkPpEnabledExtensionNames(..),
        HasVkPEnabledFeatures(..), VkDeviceCreateInfo(..),
        HasVkPApplicationInfo(..), VkInstanceCreateInfo(..),
        HasVkQueueFlags(..), HasVkTimestampValidBits(..),
        HasVkMinImageTransferGranularity(..), VkQueueFamilyProperties(..),
        HasVkMemoryTypeCount(..), HasVkMemoryTypesArray(..),
        HasVkMemoryHeapCount(..), HasVkMemoryHeapsArray(..),
        VkPhysicalDeviceMemoryProperties(..), HasVkAllocationSize(..),
        HasVkMemoryTypeIndex(..), VkMemoryAllocateInfo(..), HasVkSize(..),
        HasVkAlignment(..), HasVkMemoryTypeBits(..),
        VkMemoryRequirements(..), HasVkAspectMask(..),
        HasVkImageGranularity(..), VkSparseImageFormatProperties(..),
        HasVkFormatProperties(..), HasVkImageMipTailFirstLod(..),
        HasVkImageMipTailSize(..), HasVkImageMipTailOffset(..),
        HasVkImageMipTailStride(..), VkSparseImageMemoryRequirements(..),
        HasVkPropertyFlags(..), HasVkHeapIndex(..), VkMemoryType(..),
        VkMemoryHeap(..), HasVkMemory(..), VkMappedMemoryRange(..),
        HasVkLinearTilingFeatures(..), HasVkOptimalTilingFeatures(..),
        HasVkBufferFeatures(..), VkFormatProperties(..),
        HasVkMaxExtent(..), HasVkMaxMipLevels(..), HasVkMaxArrayLayers(..),
        HasVkSampleCounts(..), HasVkMaxResourceSize(..),
        VkImageFormatProperties(..), HasVkBuffer(..), HasVkRange(..),
        VkDescriptorBufferInfo(..), HasVkSampler(..), HasVkImageView(..),
        HasVkImageLayout(..), VkDescriptorImageInfo(..), HasVkDstSet(..),
        HasVkDstBinding(..), HasVkDstArrayElement(..),
        HasVkDescriptorCount(..), HasVkDescriptorType(..),
        HasVkPImageInfo(..), HasVkPBufferInfo(..),
        HasVkPTexelBufferView(..), VkWriteDescriptorSet(..),
        HasVkSrcSet(..), HasVkSrcBinding(..), HasVkSrcArrayElement(..),
        VkCopyDescriptorSet(..), HasVkUsage(..), HasVkSharingMode(..),
        HasVkQueueFamilyIndexCount(..), HasVkPQueueFamilyIndices(..),
        VkBufferCreateInfo(..), HasVkFormat(..),
        VkBufferViewCreateInfo(..), HasVkMipLevel(..), HasVkArrayLayer(..),
        VkImageSubresource(..), VkImageSubresourceLayers(..),
        HasVkBaseMipLevel(..), HasVkLevelCount(..),
        VkImageSubresourceRange(..), HasVkImageType(..),
        HasVkMipLevels(..), HasVkArrayLayers(..), HasVkSamples(..),
        HasVkTiling(..), HasVkInitialLayout(..), VkImageCreateInfo(..),
        HasVkRowPitch(..), HasVkArrayPitch(..), HasVkDepthPitch(..),
        VkSubresourceLayout(..), HasVkImage(..), HasVkViewType(..),
        HasVkComponents(..), HasVkSubresourceRange(..),
        VkImageViewCreateInfo(..), HasVkSrcOffset(..), HasVkDstOffset(..),
        VkBufferCopy(..), HasVkResourceOffset(..), HasVkMemoryOffset(..),
        VkSparseMemoryBind(..), HasVkSubresource(..),
        VkSparseImageMemoryBind(..), HasVkBindCount(..), HasVkPBinds(..),
        VkSparseBufferMemoryBindInfo(..),
        VkSparseImageOpaqueMemoryBindInfo(..),
        VkSparseImageMemoryBindInfo(..), HasVkWaitSemaphoreCount(..),
        HasVkPWaitSemaphores(..), HasVkBufferBindCount(..),
        HasVkPBufferBinds(..), HasVkImageOpaqueBindCount(..),
        HasVkPImageOpaqueBinds(..), HasVkImageBindCount(..),
        HasVkPImageBinds(..), HasVkSignalSemaphoreCount(..),
        HasVkPSignalSemaphores(..), VkBindSparseInfo(..),
        HasVkSrcSubresource(..), HasVkDstSubresource(..), VkImageCopy(..),
        HasVkSrcOffsetsArray(..), HasVkDstOffsetsArray(..),
        VkImageBlit(..), HasVkBufferOffset(..), HasVkBufferRowLength(..),
        HasVkBufferImageHeight(..), HasVkImageSubresource(..),
        HasVkImageOffset(..), HasVkImageExtent(..), VkBufferImageCopy(..),
        VkImageResolve(..), HasVkCodeSize(..), HasVkPCode(..),
        VkShaderModuleCreateInfo(..), HasVkBinding(..),
        HasVkStageFlags(..), HasVkPImmutableSamplers(..),
        VkDescriptorSetLayoutBinding(..), HasVkBindingCount(..),
        HasVkPBindings(..), VkDescriptorSetLayoutCreateInfo(..),
        HasVkType(..), VkDescriptorPoolSize(..), HasVkMaxSets(..),
        HasVkPoolSizeCount(..), HasVkPPoolSizes(..),
        VkDescriptorPoolCreateInfo(..), HasVkDescriptorPool(..),
        HasVkDescriptorSetCount(..), HasVkPSetLayouts(..),
        VkDescriptorSetAllocateInfo(..), HasVkConstantID(..),
        VkSpecializationMapEntry(..), HasVkMapEntryCount(..),
        HasVkPMapEntries(..), HasVkDataSize(..), HasVkPData(..),
        VkSpecializationInfo(..), HasVkStage(..), HasVkModule(..),
        HasVkPName(..), HasVkPSpecializationInfo(..),
        VkPipelineShaderStageCreateInfo(..), HasVkLayout(..),
        HasVkBasePipelineHandle(..), HasVkBasePipelineIndex(..),
        VkComputePipelineCreateInfo(..), HasVkStride(..),
        HasVkInputRate(..), VkVertexInputBindingDescription(..),
        HasVkLocation(..), VkVertexInputAttributeDescription(..),
        HasVkVertexBindingDescriptionCount(..),
        HasVkPVertexBindingDescriptions(..),
        HasVkVertexAttributeDescriptionCount(..),
        HasVkPVertexAttributeDescriptions(..),
        VkPipelineVertexInputStateCreateInfo(..), HasVkTopology(..),
        HasVkPrimitiveRestartEnable(..),
        VkPipelineInputAssemblyStateCreateInfo(..),
        HasVkPatchControlPoints(..),
        VkPipelineTessellationStateCreateInfo(..), HasVkViewportCount(..),
        HasVkPViewports(..), HasVkScissorCount(..), HasVkPScissors(..),
        VkPipelineViewportStateCreateInfo(..), HasVkDepthClampEnable(..),
        HasVkRasterizerDiscardEnable(..), HasVkPolygonMode(..),
        HasVkCullMode(..), HasVkFrontFace(..), HasVkDepthBiasEnable(..),
        HasVkDepthBiasConstantFactor(..), HasVkDepthBiasClamp(..),
        HasVkDepthBiasSlopeFactor(..), HasVkLineWidth(..),
        VkPipelineRasterizationStateCreateInfo(..),
        HasVkRasterizationSamples(..), HasVkSampleShadingEnable(..),
        HasVkMinSampleShading(..), HasVkPSampleMask(..),
        HasVkAlphaToCoverageEnable(..), HasVkAlphaToOneEnable(..),
        VkPipelineMultisampleStateCreateInfo(..), HasVkBlendEnable(..),
        HasVkSrcColorBlendFactor(..), HasVkDstColorBlendFactor(..),
        HasVkColorBlendOp(..), HasVkSrcAlphaBlendFactor(..),
        HasVkDstAlphaBlendFactor(..), HasVkAlphaBlendOp(..),
        HasVkColorWriteMask(..), VkPipelineColorBlendAttachmentState(..),
        HasVkLogicOpEnable(..), HasVkLogicOp(..), HasVkAttachmentCount(..),
        HasVkPAttachments(..), HasVkBlendConstantsArray(..),
        VkPipelineColorBlendStateCreateInfo(..),
        HasVkDynamicStateCount(..), HasVkPDynamicStates(..),
        VkPipelineDynamicStateCreateInfo(..), HasVkFailOp(..),
        HasVkPassOp(..), HasVkDepthFailOp(..), HasVkCompareOp(..),
        HasVkCompareMask(..), HasVkWriteMask(..), HasVkReference(..),
        VkStencilOpState(..), HasVkDepthTestEnable(..),
        HasVkDepthWriteEnable(..), HasVkDepthCompareOp(..),
        HasVkDepthBoundsTestEnable(..), HasVkStencilTestEnable(..),
        HasVkFront(..), HasVkBack(..), HasVkMinDepthBounds(..),
        HasVkMaxDepthBounds(..), VkPipelineDepthStencilStateCreateInfo(..),
        HasVkStageCount(..), HasVkPStages(..), HasVkPVertexInputState(..),
        HasVkPInputAssemblyState(..), HasVkPTessellationState(..),
        HasVkPViewportState(..), HasVkPRasterizationState(..),
        HasVkPMultisampleState(..), HasVkPDepthStencilState(..),
        HasVkPColorBlendState(..), HasVkPDynamicState(..),
        HasVkRenderPass(..), HasVkSubpass(..),
        VkGraphicsPipelineCreateInfo(..), HasVkInitialDataSize(..),
        HasVkPInitialData(..), VkPipelineCacheCreateInfo(..),
        VkPushConstantRange(..), HasVkSetLayoutCount(..),
        HasVkPushConstantRangeCount(..), HasVkPPushConstantRanges(..),
        VkPipelineLayoutCreateInfo(..), HasVkMagFilter(..),
        HasVkMinFilter(..), HasVkMipmapMode(..), HasVkAddressModeU(..),
        HasVkAddressModeV(..), HasVkAddressModeW(..), HasVkMipLodBias(..),
        HasVkAnisotropyEnable(..), HasVkMaxAnisotropy(..),
        HasVkCompareEnable(..), HasVkMinLod(..), HasVkMaxLod(..),
        HasVkBorderColor(..), HasVkUnnormalizedCoordinates(..),
        VkSamplerCreateInfo(..), VkCommandPoolCreateInfo(..),
        HasVkCommandPool(..), HasVkLevel(..), HasVkCommandBufferCount(..),
        VkCommandBufferAllocateInfo(..), HasVkFramebuffer(..),
        HasVkOcclusionQueryEnable(..), HasVkQueryFlags(..),
        HasVkPipelineStatistics(..), VkCommandBufferInheritanceInfo(..),
        HasVkPInheritanceInfo(..), VkCommandBufferBeginInfo(..),
        HasVkRenderArea(..), HasVkClearValueCount(..),
        HasVkPClearValues(..), VkRenderPassBeginInfo(..),
        HasVkFloat32Array(..), HasVkInt32Array(..), HasVkUint32Array(..),
        VkClearColorValue(..), HasVkStencil(..),
        VkClearDepthStencilValue(..), HasVkColor(..),
        HasVkDepthStencil(..), VkClearValue(..), HasVkColorAttachment(..),
        HasVkClearValue(..), VkClearAttachment(..), HasVkLoadOp(..),
        HasVkStoreOp(..), HasVkStencilLoadOp(..), HasVkStencilStoreOp(..),
        HasVkFinalLayout(..), VkAttachmentDescription(..),
        HasVkAttachment(..), VkAttachmentReference(..),
        HasVkPipelineBindPoint(..), HasVkInputAttachmentCount(..),
        HasVkPInputAttachments(..), HasVkColorAttachmentCount(..),
        HasVkPColorAttachments(..), HasVkPResolveAttachments(..),
        HasVkPDepthStencilAttachment(..), HasVkPreserveAttachmentCount(..),
        HasVkPPreserveAttachments(..), VkSubpassDescription(..),
        HasVkSrcSubpass(..), HasVkDstSubpass(..), HasVkSrcStageMask(..),
        HasVkDstStageMask(..), HasVkSrcAccessMask(..),
        HasVkDstAccessMask(..), HasVkDependencyFlags(..),
        VkSubpassDependency(..), HasVkSubpassCount(..),
        HasVkPSubpasses(..), HasVkDependencyCount(..),
        HasVkPDependencies(..), VkRenderPassCreateInfo(..),
        VkEventCreateInfo(..), VkFenceCreateInfo(..),
        HasVkRobustBufferAccess(..), HasVkFullDrawIndexUint32(..),
        HasVkImageCubeArray(..), HasVkIndependentBlend(..),
        HasVkGeometryShader(..), HasVkTessellationShader(..),
        HasVkSampleRateShading(..), HasVkDualSrcBlend(..),
        HasVkMultiDrawIndirect(..), HasVkDrawIndirectFirstInstance(..),
        HasVkDepthClamp(..), HasVkFillModeNonSolid(..),
        HasVkDepthBounds(..), HasVkWideLines(..), HasVkLargePoints(..),
        HasVkAlphaToOne(..), HasVkMultiViewport(..),
        HasVkSamplerAnisotropy(..), HasVkTextureCompressionETC2(..),
        HasVkTextureCompressionASTC_LDR(..), HasVkTextureCompressionBC(..),
        HasVkOcclusionQueryPrecise(..), HasVkPipelineStatisticsQuery(..),
        HasVkVertexPipelineStoresAndAtomics(..),
        HasVkFragmentStoresAndAtomics(..),
        HasVkShaderTessellationAndGeometryPointSize(..),
        HasVkShaderImageGatherExtended(..),
        HasVkShaderStorageImageExtendedFormats(..),
        HasVkShaderStorageImageMultisample(..),
        HasVkShaderStorageImageReadWithoutFormat(..),
        HasVkShaderStorageImageWriteWithoutFormat(..),
        HasVkShaderUniformBufferArrayDynamicIndexing(..),
        HasVkShaderSampledImageArrayDynamicIndexing(..),
        HasVkShaderStorageBufferArrayDynamicIndexing(..),
        HasVkShaderStorageImageArrayDynamicIndexing(..),
        HasVkShaderClipDistance(..), HasVkShaderCullDistance(..),
        HasVkShaderFloat64(..), HasVkShaderInt64(..), HasVkShaderInt16(..),
        HasVkShaderResourceResidency(..), HasVkShaderResourceMinLod(..),
        HasVkSparseBinding(..), HasVkSparseResidencyBuffer(..),
        HasVkSparseResidencyImage2D(..), HasVkSparseResidencyImage3D(..),
        HasVkSparseResidency2Samples(..), HasVkSparseResidency4Samples(..),
        HasVkSparseResidency8Samples(..),
        HasVkSparseResidency16Samples(..), HasVkSparseResidencyAliased(..),
        HasVkVariableMultisampleRate(..), HasVkInheritedQueries(..),
        VkPhysicalDeviceFeatures(..),
        HasVkResidencyStandard2DBlockShape(..),
        HasVkResidencyStandard2DMultisampleBlockShape(..),
        HasVkResidencyStandard3DBlockShape(..),
        HasVkResidencyAlignedMipSize(..),
        HasVkResidencyNonResidentStrict(..),
        VkPhysicalDeviceSparseProperties(..), HasVkMaxImageDimension1D(..),
        HasVkMaxImageDimension2D(..), HasVkMaxImageDimension3D(..),
        HasVkMaxImageDimensionCube(..), HasVkMaxImageArrayLayers(..),
        HasVkMaxTexelBufferElements(..), HasVkMaxUniformBufferRange(..),
        HasVkMaxStorageBufferRange(..), HasVkMaxPushConstantsSize(..),
        HasVkMaxMemoryAllocationCount(..),
        HasVkMaxSamplerAllocationCount(..),
        HasVkBufferImageGranularity(..), HasVkSparseAddressSpaceSize(..),
        HasVkMaxBoundDescriptorSets(..),
        HasVkMaxPerStageDescriptorSamplers(..),
        HasVkMaxPerStageDescriptorUniformBuffers(..),
        HasVkMaxPerStageDescriptorStorageBuffers(..),
        HasVkMaxPerStageDescriptorSampledImages(..),
        HasVkMaxPerStageDescriptorStorageImages(..),
        HasVkMaxPerStageDescriptorInputAttachments(..),
        HasVkMaxPerStageResources(..), HasVkMaxDescriptorSetSamplers(..),
        HasVkMaxDescriptorSetUniformBuffers(..),
        HasVkMaxDescriptorSetUniformBuffersDynamic(..),
        HasVkMaxDescriptorSetStorageBuffers(..),
        HasVkMaxDescriptorSetStorageBuffersDynamic(..),
        HasVkMaxDescriptorSetSampledImages(..),
        HasVkMaxDescriptorSetStorageImages(..),
        HasVkMaxDescriptorSetInputAttachments(..),
        HasVkMaxVertexInputAttributes(..), HasVkMaxVertexInputBindings(..),
        HasVkMaxVertexInputAttributeOffset(..),
        HasVkMaxVertexInputBindingStride(..),
        HasVkMaxVertexOutputComponents(..),
        HasVkMaxTessellationGenerationLevel(..),
        HasVkMaxTessellationPatchSize(..),
        HasVkMaxTessellationControlPerVertexInputComponents(..),
        HasVkMaxTessellationControlPerVertexOutputComponents(..),
        HasVkMaxTessellationControlPerPatchOutputComponents(..),
        HasVkMaxTessellationControlTotalOutputComponents(..),
        HasVkMaxTessellationEvaluationInputComponents(..),
        HasVkMaxTessellationEvaluationOutputComponents(..),
        HasVkMaxGeometryShaderInvocations(..),
        HasVkMaxGeometryInputComponents(..),
        HasVkMaxGeometryOutputComponents(..),
        HasVkMaxGeometryOutputVertices(..),
        HasVkMaxGeometryTotalOutputComponents(..),
        HasVkMaxFragmentInputComponents(..),
        HasVkMaxFragmentOutputAttachments(..),
        HasVkMaxFragmentDualSrcAttachments(..),
        HasVkMaxFragmentCombinedOutputResources(..),
        HasVkMaxComputeSharedMemorySize(..),
        HasVkMaxComputeWorkGroupCountArray(..),
        HasVkMaxComputeWorkGroupInvocations(..),
        HasVkMaxComputeWorkGroupSizeArray(..),
        HasVkSubPixelPrecisionBits(..), HasVkSubTexelPrecisionBits(..),
        HasVkMipmapPrecisionBits(..), HasVkMaxDrawIndexedIndexValue(..),
        HasVkMaxDrawIndirectCount(..), HasVkMaxSamplerLodBias(..),
        HasVkMaxSamplerAnisotropy(..), HasVkMaxViewports(..),
        HasVkMaxViewportDimensionsArray(..),
        HasVkViewportBoundsRangeArray(..), HasVkViewportSubPixelBits(..),
        HasVkMinMemoryMapAlignment(..),
        HasVkMinTexelBufferOffsetAlignment(..),
        HasVkMinUniformBufferOffsetAlignment(..),
        HasVkMinStorageBufferOffsetAlignment(..), HasVkMinTexelOffset(..),
        HasVkMaxTexelOffset(..), HasVkMinTexelGatherOffset(..),
        HasVkMaxTexelGatherOffset(..), HasVkMinInterpolationOffset(..),
        HasVkMaxInterpolationOffset(..),
        HasVkSubPixelInterpolationOffsetBits(..),
        HasVkMaxFramebufferWidth(..), HasVkMaxFramebufferHeight(..),
        HasVkMaxFramebufferLayers(..),
        HasVkFramebufferColorSampleCounts(..),
        HasVkFramebufferDepthSampleCounts(..),
        HasVkFramebufferStencilSampleCounts(..),
        HasVkFramebufferNoAttachmentsSampleCounts(..),
        HasVkMaxColorAttachments(..),
        HasVkSampledImageColorSampleCounts(..),
        HasVkSampledImageIntegerSampleCounts(..),
        HasVkSampledImageDepthSampleCounts(..),
        HasVkSampledImageStencilSampleCounts(..),
        HasVkStorageImageSampleCounts(..), HasVkMaxSampleMaskWords(..),
        HasVkTimestampComputeAndGraphics(..), HasVkTimestampPeriod(..),
        HasVkMaxClipDistances(..), HasVkMaxCullDistances(..),
        HasVkMaxCombinedClipAndCullDistances(..),
        HasVkDiscreteQueuePriorities(..), HasVkPointSizeRangeArray(..),
        HasVkLineWidthRangeArray(..), HasVkPointSizeGranularity(..),
        HasVkLineWidthGranularity(..), HasVkStrictLines(..),
        HasVkStandardSampleLocations(..),
        HasVkOptimalBufferCopyOffsetAlignment(..),
        HasVkOptimalBufferCopyRowPitchAlignment(..),
        HasVkNonCoherentAtomSize(..), VkPhysicalDeviceLimits(..),
        VkSemaphoreCreateInfo(..), HasVkQueryType(..), HasVkQueryCount(..),
        VkQueryPoolCreateInfo(..), HasVkLayers(..),
        VkFramebufferCreateInfo(..), HasVkPWaitDstStageMask(..),
        HasVkPCommandBuffers(..), VkSubmitInfo(..), HasVkMinImageCount(..),
        HasVkMaxImageCount(..), HasVkCurrentExtent(..),
        HasVkMinImageExtent(..), HasVkMaxImageExtent(..),
        HasVkSupportedTransforms(..), HasVkCurrentTransform(..),
        HasVkSupportedCompositeAlpha(..), HasVkSupportedUsageFlags(..),
        VkSurfaceCapabilitiesKHR(..), HasVkColorSpace(..),
        VkSurfaceFormatKHR(..), HasVkSurface(..), HasVkImageFormat(..),
        HasVkImageColorSpace(..), HasVkImageArrayLayers(..),
        HasVkImageUsage(..), HasVkImageSharingMode(..),
        HasVkPreTransform(..), HasVkCompositeAlpha(..),
        HasVkPresentMode(..), HasVkClipped(..), HasVkOldSwapchain(..),
        VkSwapchainCreateInfoKHR(..), HasVkSwapchainCount(..),
        HasVkPSwapchains(..), HasVkPImageIndices(..), HasVkPResults(..),
        VkPresentInfoKHR(..))
       where
import           Data.Int                         (Int32)
import           Data.Void                        (Void)
import           Data.Word                        (Word32, Word64, Word8)
import           Foreign.C.Types                  (CChar, CFloat, CInt, CSize)
import           Foreign.Ptr                      (Ptr)
import           Foreign.Storable                 (Storable (..))
import           GHC.ForeignPtr                   (ForeignPtr (..),
                                                   ForeignPtrContents (..),
                                                   newForeignPtr_)
import           GHC.Prim
import           GHC.Ptr                          (Ptr (..))
import           GHC.TypeLits                     (ErrorMessage (..), TypeError)
import           GHC.Types                        (IO (..), Int (..))
import           Graphics.Vulkan.Common
import           Graphics.Vulkan.Marshal
import           Graphics.Vulkan.Marshal.Internal
import           System.IO.Unsafe                 (unsafeDupablePerformIO)

data VkOffset2D = VkOffset2D## ByteArray##

instance Eq VkOffset2D where
        (VkOffset2D## a) == (VkOffset2D## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkOffset2D where
        (VkOffset2D## a) `compare` (VkOffset2D## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkOffset2D where
        sizeOf ~_ = #{size VkOffset2D}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkOffset2D}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkOffset2D),
            I## a <- alignment (undefined :: VkOffset2D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkOffset2D## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkOffset2D## ba)
          | I## n <- sizeOf (undefined :: VkOffset2D) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkOffset2D where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkOffset2D),
            I## a <- alignment (undefined :: VkOffset2D) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkOffset2D##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkOffset2D## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkOffset2D##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkOffset2D## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkOffset2D## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkOffset2D## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkX a where
        type VkXMType a :: *

        vkX :: a -> VkXMType a

        vkXByteOffset :: a -> Int

        readVkX :: Ptr a -> IO (VkXMType a)

        writeVkX :: Ptr a -> VkXMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'x'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkX a

instance {-# OVERLAPPING #-} HasVkX VkOffset2D where
        type VkXMType VkOffset2D = Data.Int.Int32

        {-# NOINLINE vkX #-}
        vkX x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkOffset2D, x})

        {-# INLINE vkXByteOffset #-}
        vkXByteOffset ~_ = #{offset VkOffset2D, x}

        {-# INLINE readVkX #-}
        readVkX p = peekByteOff p #{offset VkOffset2D, x}

        {-# INLINE writeVkX #-}
        writeVkX p = pokeByteOff p #{offset VkOffset2D, x}

class HasVkY a where
        type VkYMType a :: *

        vkY :: a -> VkYMType a

        vkYByteOffset :: a -> Int

        readVkY :: Ptr a -> IO (VkYMType a)

        writeVkY :: Ptr a -> VkYMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'y'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkY a

instance {-# OVERLAPPING #-} HasVkY VkOffset2D where
        type VkYMType VkOffset2D = Data.Int.Int32

        {-# NOINLINE vkY #-}
        vkY x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkOffset2D, y})

        {-# INLINE vkYByteOffset #-}
        vkYByteOffset ~_ = #{offset VkOffset2D, y}

        {-# INLINE readVkY #-}
        readVkY p = peekByteOff p #{offset VkOffset2D, y}

        {-# INLINE writeVkY #-}
        writeVkY p = pokeByteOff p #{offset VkOffset2D, y}

instance Show VkOffset2D where
        showsPrec d x
          = showString "VkOffset2D {" .
              showString "vkX = " .
                showsPrec d (vkX x) .
                  showString ", " .
                    showString "vkY = " . showsPrec d (vkY x) . showChar '}'

data VkOffset3D = VkOffset3D## ByteArray##

instance Eq VkOffset3D where
        (VkOffset3D## a) == (VkOffset3D## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkOffset3D where
        (VkOffset3D## a) `compare` (VkOffset3D## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkOffset3D where
        sizeOf ~_ = #{size VkOffset3D}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkOffset3D}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkOffset3D),
            I## a <- alignment (undefined :: VkOffset3D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkOffset3D## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkOffset3D## ba)
          | I## n <- sizeOf (undefined :: VkOffset3D) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkOffset3D where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkOffset3D),
            I## a <- alignment (undefined :: VkOffset3D) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkOffset3D##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkOffset3D## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkOffset3D##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkOffset3D## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkOffset3D## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkOffset3D## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkX VkOffset3D where
        type VkXMType VkOffset3D = Data.Int.Int32

        {-# NOINLINE vkX #-}
        vkX x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkOffset3D, x})

        {-# INLINE vkXByteOffset #-}
        vkXByteOffset ~_ = #{offset VkOffset3D, x}

        {-# INLINE readVkX #-}
        readVkX p = peekByteOff p #{offset VkOffset3D, x}

        {-# INLINE writeVkX #-}
        writeVkX p = pokeByteOff p #{offset VkOffset3D, x}

instance {-# OVERLAPPING #-} HasVkY VkOffset3D where
        type VkYMType VkOffset3D = Data.Int.Int32

        {-# NOINLINE vkY #-}
        vkY x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkOffset3D, y})

        {-# INLINE vkYByteOffset #-}
        vkYByteOffset ~_ = #{offset VkOffset3D, y}

        {-# INLINE readVkY #-}
        readVkY p = peekByteOff p #{offset VkOffset3D, y}

        {-# INLINE writeVkY #-}
        writeVkY p = pokeByteOff p #{offset VkOffset3D, y}

class HasVkZ a where
        type VkZMType a :: *

        vkZ :: a -> VkZMType a

        vkZByteOffset :: a -> Int

        readVkZ :: Ptr a -> IO (VkZMType a)

        writeVkZ :: Ptr a -> VkZMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'z'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkZ a

instance {-# OVERLAPPING #-} HasVkZ VkOffset3D where
        type VkZMType VkOffset3D = Data.Int.Int32

        {-# NOINLINE vkZ #-}
        vkZ x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkOffset3D, z})

        {-# INLINE vkZByteOffset #-}
        vkZByteOffset ~_ = #{offset VkOffset3D, z}

        {-# INLINE readVkZ #-}
        readVkZ p = peekByteOff p #{offset VkOffset3D, z}

        {-# INLINE writeVkZ #-}
        writeVkZ p = pokeByteOff p #{offset VkOffset3D, z}

instance Show VkOffset3D where
        showsPrec d x
          = showString "VkOffset3D {" .
              showString "vkX = " .
                showsPrec d (vkX x) .
                  showString ", " .
                    showString "vkY = " .
                      showsPrec d (vkY x) .
                        showString ", " .
                          showString "vkZ = " . showsPrec d (vkZ x) . showChar '}'

data VkExtent2D = VkExtent2D## ByteArray##

instance Eq VkExtent2D where
        (VkExtent2D## a) == (VkExtent2D## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkExtent2D where
        (VkExtent2D## a) `compare` (VkExtent2D## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkExtent2D where
        sizeOf ~_ = #{size VkExtent2D}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkExtent2D}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkExtent2D),
            I## a <- alignment (undefined :: VkExtent2D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkExtent2D## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkExtent2D## ba)
          | I## n <- sizeOf (undefined :: VkExtent2D) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkExtent2D where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkExtent2D),
            I## a <- alignment (undefined :: VkExtent2D) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkExtent2D##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkExtent2D## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkExtent2D##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkExtent2D## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkExtent2D## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkExtent2D## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkWidth a where
        type VkWidthMType a :: *

        vkWidth :: a -> VkWidthMType a

        vkWidthByteOffset :: a -> Int

        readVkWidth :: Ptr a -> IO (VkWidthMType a)

        writeVkWidth :: Ptr a -> VkWidthMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'width'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkWidth a

instance {-# OVERLAPPING #-} HasVkWidth VkExtent2D where
        type VkWidthMType VkExtent2D = Data.Word.Word32

        {-# NOINLINE vkWidth #-}
        vkWidth x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkExtent2D, width})

        {-# INLINE vkWidthByteOffset #-}
        vkWidthByteOffset ~_ = #{offset VkExtent2D, width}

        {-# INLINE readVkWidth #-}
        readVkWidth p = peekByteOff p #{offset VkExtent2D, width}

        {-# INLINE writeVkWidth #-}
        writeVkWidth p = pokeByteOff p #{offset VkExtent2D, width}

class HasVkHeight a where
        type VkHeightMType a :: *

        vkHeight :: a -> VkHeightMType a

        vkHeightByteOffset :: a -> Int

        readVkHeight :: Ptr a -> IO (VkHeightMType a)

        writeVkHeight :: Ptr a -> VkHeightMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'height'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkHeight a

instance {-# OVERLAPPING #-} HasVkHeight VkExtent2D where
        type VkHeightMType VkExtent2D = Data.Word.Word32

        {-# NOINLINE vkHeight #-}
        vkHeight x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkExtent2D, height})

        {-# INLINE vkHeightByteOffset #-}
        vkHeightByteOffset ~_ = #{offset VkExtent2D, height}

        {-# INLINE readVkHeight #-}
        readVkHeight p
          = peekByteOff p #{offset VkExtent2D, height}

        {-# INLINE writeVkHeight #-}
        writeVkHeight p
          = pokeByteOff p #{offset VkExtent2D, height}

instance Show VkExtent2D where
        showsPrec d x
          = showString "VkExtent2D {" .
              showString "vkWidth = " .
                showsPrec d (vkWidth x) .
                  showString ", " .
                    showString "vkHeight = " . showsPrec d (vkHeight x) . showChar '}'

data VkExtent3D = VkExtent3D## ByteArray##

instance Eq VkExtent3D where
        (VkExtent3D## a) == (VkExtent3D## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkExtent3D where
        (VkExtent3D## a) `compare` (VkExtent3D## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkExtent3D where
        sizeOf ~_ = #{size VkExtent3D}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkExtent3D}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkExtent3D),
            I## a <- alignment (undefined :: VkExtent3D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkExtent3D## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkExtent3D## ba)
          | I## n <- sizeOf (undefined :: VkExtent3D) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkExtent3D where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkExtent3D),
            I## a <- alignment (undefined :: VkExtent3D) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkExtent3D##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkExtent3D## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkExtent3D##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkExtent3D## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkExtent3D## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkExtent3D## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkWidth VkExtent3D where
        type VkWidthMType VkExtent3D = Data.Word.Word32

        {-# NOINLINE vkWidth #-}
        vkWidth x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkExtent3D, width})

        {-# INLINE vkWidthByteOffset #-}
        vkWidthByteOffset ~_ = #{offset VkExtent3D, width}

        {-# INLINE readVkWidth #-}
        readVkWidth p = peekByteOff p #{offset VkExtent3D, width}

        {-# INLINE writeVkWidth #-}
        writeVkWidth p = pokeByteOff p #{offset VkExtent3D, width}

instance {-# OVERLAPPING #-} HasVkHeight VkExtent3D where
        type VkHeightMType VkExtent3D = Data.Word.Word32

        {-# NOINLINE vkHeight #-}
        vkHeight x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkExtent3D, height})

        {-# INLINE vkHeightByteOffset #-}
        vkHeightByteOffset ~_ = #{offset VkExtent3D, height}

        {-# INLINE readVkHeight #-}
        readVkHeight p
          = peekByteOff p #{offset VkExtent3D, height}

        {-# INLINE writeVkHeight #-}
        writeVkHeight p
          = pokeByteOff p #{offset VkExtent3D, height}

class HasVkDepth a where
        type VkDepthMType a :: *

        vkDepth :: a -> VkDepthMType a

        vkDepthByteOffset :: a -> Int

        readVkDepth :: Ptr a -> IO (VkDepthMType a)

        writeVkDepth :: Ptr a -> VkDepthMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depth'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepth a

instance {-# OVERLAPPING #-} HasVkDepth VkExtent3D where
        type VkDepthMType VkExtent3D = Data.Word.Word32

        {-# NOINLINE vkDepth #-}
        vkDepth x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkExtent3D, depth})

        {-# INLINE vkDepthByteOffset #-}
        vkDepthByteOffset ~_ = #{offset VkExtent3D, depth}

        {-# INLINE readVkDepth #-}
        readVkDepth p = peekByteOff p #{offset VkExtent3D, depth}

        {-# INLINE writeVkDepth #-}
        writeVkDepth p = pokeByteOff p #{offset VkExtent3D, depth}

instance Show VkExtent3D where
        showsPrec d x
          = showString "VkExtent3D {" .
              showString "vkWidth = " .
                showsPrec d (vkWidth x) .
                  showString ", " .
                    showString "vkHeight = " .
                      showsPrec d (vkHeight x) .
                        showString ", " .
                          showString "vkDepth = " . showsPrec d (vkDepth x) . showChar '}'

data VkViewport = VkViewport## ByteArray##

instance Eq VkViewport where
        (VkViewport## a) == (VkViewport## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkViewport where
        (VkViewport## a) `compare` (VkViewport## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkViewport where
        sizeOf ~_ = #{size VkViewport}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkViewport}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkViewport),
            I## a <- alignment (undefined :: VkViewport) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkViewport## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkViewport## ba)
          | I## n <- sizeOf (undefined :: VkViewport) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkViewport where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkViewport),
            I## a <- alignment (undefined :: VkViewport) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkViewport##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkViewport## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkViewport##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkViewport## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkViewport## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkViewport## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkX VkViewport where
        type VkXMType VkViewport = Foreign.C.Types.CFloat

        {-# NOINLINE vkX #-}
        vkX x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkViewport, x})

        {-# INLINE vkXByteOffset #-}
        vkXByteOffset ~_ = #{offset VkViewport, x}

        {-# INLINE readVkX #-}
        readVkX p = peekByteOff p #{offset VkViewport, x}

        {-# INLINE writeVkX #-}
        writeVkX p = pokeByteOff p #{offset VkViewport, x}

instance {-# OVERLAPPING #-} HasVkY VkViewport where
        type VkYMType VkViewport = Foreign.C.Types.CFloat

        {-# NOINLINE vkY #-}
        vkY x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkViewport, y})

        {-# INLINE vkYByteOffset #-}
        vkYByteOffset ~_ = #{offset VkViewport, y}

        {-# INLINE readVkY #-}
        readVkY p = peekByteOff p #{offset VkViewport, y}

        {-# INLINE writeVkY #-}
        writeVkY p = pokeByteOff p #{offset VkViewport, y}

instance {-# OVERLAPPING #-} HasVkWidth VkViewport where
        type VkWidthMType VkViewport = Foreign.C.Types.CFloat

        {-# NOINLINE vkWidth #-}
        vkWidth x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkViewport, width})

        {-# INLINE vkWidthByteOffset #-}
        vkWidthByteOffset ~_ = #{offset VkViewport, width}

        {-# INLINE readVkWidth #-}
        readVkWidth p = peekByteOff p #{offset VkViewport, width}

        {-# INLINE writeVkWidth #-}
        writeVkWidth p = pokeByteOff p #{offset VkViewport, width}

instance {-# OVERLAPPING #-} HasVkHeight VkViewport where
        type VkHeightMType VkViewport = Foreign.C.Types.CFloat

        {-# NOINLINE vkHeight #-}
        vkHeight x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkViewport, height})

        {-# INLINE vkHeightByteOffset #-}
        vkHeightByteOffset ~_ = #{offset VkViewport, height}

        {-# INLINE readVkHeight #-}
        readVkHeight p
          = peekByteOff p #{offset VkViewport, height}

        {-# INLINE writeVkHeight #-}
        writeVkHeight p
          = pokeByteOff p #{offset VkViewport, height}

class HasVkMinDepth a where
        type VkMinDepthMType a :: *

        vkMinDepth :: a -> VkMinDepthMType a

        vkMinDepthByteOffset :: a -> Int

        readVkMinDepth :: Ptr a -> IO (VkMinDepthMType a)

        writeVkMinDepth :: Ptr a -> VkMinDepthMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minDepth'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinDepth a

instance {-# OVERLAPPING #-} HasVkMinDepth VkViewport where
        type VkMinDepthMType VkViewport = Foreign.C.Types.CFloat

        {-# NOINLINE vkMinDepth #-}
        vkMinDepth x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkViewport, minDepth})

        {-# INLINE vkMinDepthByteOffset #-}
        vkMinDepthByteOffset ~_ = #{offset VkViewport, minDepth}

        {-# INLINE readVkMinDepth #-}
        readVkMinDepth p
          = peekByteOff p #{offset VkViewport, minDepth}

        {-# INLINE writeVkMinDepth #-}
        writeVkMinDepth p
          = pokeByteOff p #{offset VkViewport, minDepth}

class HasVkMaxDepth a where
        type VkMaxDepthMType a :: *

        vkMaxDepth :: a -> VkMaxDepthMType a

        vkMaxDepthByteOffset :: a -> Int

        readVkMaxDepth :: Ptr a -> IO (VkMaxDepthMType a)

        writeVkMaxDepth :: Ptr a -> VkMaxDepthMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxDepth'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDepth a

instance {-# OVERLAPPING #-} HasVkMaxDepth VkViewport where
        type VkMaxDepthMType VkViewport = Foreign.C.Types.CFloat

        {-# NOINLINE vkMaxDepth #-}
        vkMaxDepth x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkViewport, maxDepth})

        {-# INLINE vkMaxDepthByteOffset #-}
        vkMaxDepthByteOffset ~_ = #{offset VkViewport, maxDepth}

        {-# INLINE readVkMaxDepth #-}
        readVkMaxDepth p
          = peekByteOff p #{offset VkViewport, maxDepth}

        {-# INLINE writeVkMaxDepth #-}
        writeVkMaxDepth p
          = pokeByteOff p #{offset VkViewport, maxDepth}

instance Show VkViewport where
        showsPrec d x
          = showString "VkViewport {" .
              showString "vkX = " .
                showsPrec d (vkX x) .
                  showString ", " .
                    showString "vkY = " .
                      showsPrec d (vkY x) .
                        showString ", " .
                          showString "vkWidth = " .
                            showsPrec d (vkWidth x) .
                              showString ", " .
                                showString "vkHeight = " .
                                  showsPrec d (vkHeight x) .
                                    showString ", " .
                                      showString "vkMinDepth = " .
                                        showsPrec d (vkMinDepth x) .
                                          showString ", " .
                                            showString "vkMaxDepth = " .
                                              showsPrec d (vkMaxDepth x) . showChar '}'

data VkRect2D = VkRect2D## ByteArray##

instance Eq VkRect2D where
        (VkRect2D## a) == (VkRect2D## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkRect2D where
        (VkRect2D## a) `compare` (VkRect2D## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkRect2D where
        sizeOf ~_ = #{size VkRect2D}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkRect2D}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkRect2D),
            I## a <- alignment (undefined :: VkRect2D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkRect2D## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkRect2D## ba)
          | I## n <- sizeOf (undefined :: VkRect2D) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkRect2D where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkRect2D),
            I## a <- alignment (undefined :: VkRect2D) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkRect2D##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkRect2D## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkRect2D##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkRect2D## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkRect2D## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkRect2D## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkOffset a where
        type VkOffsetMType a :: *

        vkOffset :: a -> VkOffsetMType a

        vkOffsetByteOffset :: a -> Int

        readVkOffset :: Ptr a -> IO (VkOffsetMType a)

        writeVkOffset :: Ptr a -> VkOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'offset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkOffset a

instance {-# OVERLAPPING #-} HasVkOffset VkRect2D where
        type VkOffsetMType VkRect2D = VkOffset2D

        {-# NOINLINE vkOffset #-}
        vkOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkRect2D, offset})

        {-# INLINE vkOffsetByteOffset #-}
        vkOffsetByteOffset ~_ = #{offset VkRect2D, offset}

        {-# INLINE readVkOffset #-}
        readVkOffset p = peekByteOff p #{offset VkRect2D, offset}

        {-# INLINE writeVkOffset #-}
        writeVkOffset p = pokeByteOff p #{offset VkRect2D, offset}

class HasVkExtent a where
        type VkExtentMType a :: *

        vkExtent :: a -> VkExtentMType a

        vkExtentByteOffset :: a -> Int

        readVkExtent :: Ptr a -> IO (VkExtentMType a)

        writeVkExtent :: Ptr a -> VkExtentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'extent'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkExtent a

instance {-# OVERLAPPING #-} HasVkExtent VkRect2D where
        type VkExtentMType VkRect2D = VkExtent2D

        {-# NOINLINE vkExtent #-}
        vkExtent x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkRect2D, extent})

        {-# INLINE vkExtentByteOffset #-}
        vkExtentByteOffset ~_ = #{offset VkRect2D, extent}

        {-# INLINE readVkExtent #-}
        readVkExtent p = peekByteOff p #{offset VkRect2D, extent}

        {-# INLINE writeVkExtent #-}
        writeVkExtent p = pokeByteOff p #{offset VkRect2D, extent}

instance Show VkRect2D where
        showsPrec d x
          = showString "VkRect2D {" .
              showString "vkOffset = " .
                showsPrec d (vkOffset x) .
                  showString ", " .
                    showString "vkExtent = " . showsPrec d (vkExtent x) . showChar '}'

data VkClearRect = VkClearRect## ByteArray##

instance Eq VkClearRect where
        (VkClearRect## a) == (VkClearRect## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkClearRect where
        (VkClearRect## a) `compare` (VkClearRect## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkClearRect where
        sizeOf ~_ = #{size VkClearRect}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkClearRect}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkClearRect),
            I## a <- alignment (undefined :: VkClearRect) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkClearRect## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkClearRect## ba)
          | I## n <- sizeOf (undefined :: VkClearRect) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkClearRect where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkClearRect),
            I## a <- alignment (undefined :: VkClearRect) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkClearRect##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkClearRect## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkClearRect##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkClearRect## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkClearRect## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkClearRect## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkRect a where
        type VkRectMType a :: *

        vkRect :: a -> VkRectMType a

        vkRectByteOffset :: a -> Int

        readVkRect :: Ptr a -> IO (VkRectMType a)

        writeVkRect :: Ptr a -> VkRectMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'rect'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRect a

instance {-# OVERLAPPING #-} HasVkRect VkClearRect where
        type VkRectMType VkClearRect = VkRect2D

        {-# NOINLINE vkRect #-}
        vkRect x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkClearRect, rect})

        {-# INLINE vkRectByteOffset #-}
        vkRectByteOffset ~_ = #{offset VkClearRect, rect}

        {-# INLINE readVkRect #-}
        readVkRect p = peekByteOff p #{offset VkClearRect, rect}

        {-# INLINE writeVkRect #-}
        writeVkRect p = pokeByteOff p #{offset VkClearRect, rect}

class HasVkBaseArrayLayer a where
        type VkBaseArrayLayerMType a :: *

        vkBaseArrayLayer :: a -> VkBaseArrayLayerMType a

        vkBaseArrayLayerByteOffset :: a -> Int

        readVkBaseArrayLayer :: Ptr a -> IO (VkBaseArrayLayerMType a)

        writeVkBaseArrayLayer :: Ptr a -> VkBaseArrayLayerMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'baseArrayLayer'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBaseArrayLayer a

instance {-# OVERLAPPING #-} HasVkBaseArrayLayer VkClearRect where
        type VkBaseArrayLayerMType VkClearRect = Data.Word.Word32

        {-# NOINLINE vkBaseArrayLayer #-}
        vkBaseArrayLayer x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkClearRect, baseArrayLayer})

        {-# INLINE vkBaseArrayLayerByteOffset #-}
        vkBaseArrayLayerByteOffset ~_
          = #{offset VkClearRect, baseArrayLayer}

        {-# INLINE readVkBaseArrayLayer #-}
        readVkBaseArrayLayer p
          = peekByteOff p #{offset VkClearRect, baseArrayLayer}

        {-# INLINE writeVkBaseArrayLayer #-}
        writeVkBaseArrayLayer p
          = pokeByteOff p #{offset VkClearRect, baseArrayLayer}

class HasVkLayerCount a where
        type VkLayerCountMType a :: *

        vkLayerCount :: a -> VkLayerCountMType a

        vkLayerCountByteOffset :: a -> Int

        readVkLayerCount :: Ptr a -> IO (VkLayerCountMType a)

        writeVkLayerCount :: Ptr a -> VkLayerCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'layerCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLayerCount a

instance {-# OVERLAPPING #-} HasVkLayerCount VkClearRect where
        type VkLayerCountMType VkClearRect = Data.Word.Word32

        {-# NOINLINE vkLayerCount #-}
        vkLayerCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkClearRect, layerCount})

        {-# INLINE vkLayerCountByteOffset #-}
        vkLayerCountByteOffset ~_
          = #{offset VkClearRect, layerCount}

        {-# INLINE readVkLayerCount #-}
        readVkLayerCount p
          = peekByteOff p #{offset VkClearRect, layerCount}

        {-# INLINE writeVkLayerCount #-}
        writeVkLayerCount p
          = pokeByteOff p #{offset VkClearRect, layerCount}

instance Show VkClearRect where
        showsPrec d x
          = showString "VkClearRect {" .
              showString "vkRect = " .
                showsPrec d (vkRect x) .
                  showString ", " .
                    showString "vkBaseArrayLayer = " .
                      showsPrec d (vkBaseArrayLayer x) .
                        showString ", " .
                          showString "vkLayerCount = " .
                            showsPrec d (vkLayerCount x) . showChar '}'

data VkComponentMapping = VkComponentMapping## ByteArray##

instance Eq VkComponentMapping where
        (VkComponentMapping## a) == (VkComponentMapping## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkComponentMapping where
        (VkComponentMapping## a) `compare` (VkComponentMapping## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkComponentMapping where
        sizeOf ~_ = #{size VkComponentMapping}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkComponentMapping}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkComponentMapping),
            I## a <- alignment (undefined :: VkComponentMapping) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkComponentMapping## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkComponentMapping## ba)
          | I## n <- sizeOf (undefined :: VkComponentMapping) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkComponentMapping where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkComponentMapping),
            I## a <- alignment (undefined :: VkComponentMapping) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkComponentMapping##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkComponentMapping## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkComponentMapping##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkComponentMapping## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkComponentMapping## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkComponentMapping## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkR a where
        type VkRMType a :: *

        vkR :: a -> VkRMType a

        vkRByteOffset :: a -> Int

        readVkR :: Ptr a -> IO (VkRMType a)

        writeVkR :: Ptr a -> VkRMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'r'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkR a

instance {-# OVERLAPPING #-} HasVkR VkComponentMapping where
        type VkRMType VkComponentMapping = VkComponentSwizzle

        {-# NOINLINE vkR #-}
        vkR x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkComponentMapping, r})

        {-# INLINE vkRByteOffset #-}
        vkRByteOffset ~_ = #{offset VkComponentMapping, r}

        {-# INLINE readVkR #-}
        readVkR p = peekByteOff p #{offset VkComponentMapping, r}

        {-# INLINE writeVkR #-}
        writeVkR p = pokeByteOff p #{offset VkComponentMapping, r}

class HasVkG a where
        type VkGMType a :: *

        vkG :: a -> VkGMType a

        vkGByteOffset :: a -> Int

        readVkG :: Ptr a -> IO (VkGMType a)

        writeVkG :: Ptr a -> VkGMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'g'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkG a

instance {-# OVERLAPPING #-} HasVkG VkComponentMapping where
        type VkGMType VkComponentMapping = VkComponentSwizzle

        {-# NOINLINE vkG #-}
        vkG x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkComponentMapping, g})

        {-# INLINE vkGByteOffset #-}
        vkGByteOffset ~_ = #{offset VkComponentMapping, g}

        {-# INLINE readVkG #-}
        readVkG p = peekByteOff p #{offset VkComponentMapping, g}

        {-# INLINE writeVkG #-}
        writeVkG p = pokeByteOff p #{offset VkComponentMapping, g}

class HasVkB a where
        type VkBMType a :: *

        vkB :: a -> VkBMType a

        vkBByteOffset :: a -> Int

        readVkB :: Ptr a -> IO (VkBMType a)

        writeVkB :: Ptr a -> VkBMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'b'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkB a

instance {-# OVERLAPPING #-} HasVkB VkComponentMapping where
        type VkBMType VkComponentMapping = VkComponentSwizzle

        {-# NOINLINE vkB #-}
        vkB x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkComponentMapping, b})

        {-# INLINE vkBByteOffset #-}
        vkBByteOffset ~_ = #{offset VkComponentMapping, b}

        {-# INLINE readVkB #-}
        readVkB p = peekByteOff p #{offset VkComponentMapping, b}

        {-# INLINE writeVkB #-}
        writeVkB p = pokeByteOff p #{offset VkComponentMapping, b}

class HasVkA a where
        type VkAMType a :: *

        vkA :: a -> VkAMType a

        vkAByteOffset :: a -> Int

        readVkA :: Ptr a -> IO (VkAMType a)

        writeVkA :: Ptr a -> VkAMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'a'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkA a

instance {-# OVERLAPPING #-} HasVkA VkComponentMapping where
        type VkAMType VkComponentMapping = VkComponentSwizzle

        {-# NOINLINE vkA #-}
        vkA x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkComponentMapping, a})

        {-# INLINE vkAByteOffset #-}
        vkAByteOffset ~_ = #{offset VkComponentMapping, a}

        {-# INLINE readVkA #-}
        readVkA p = peekByteOff p #{offset VkComponentMapping, a}

        {-# INLINE writeVkA #-}
        writeVkA p = pokeByteOff p #{offset VkComponentMapping, a}

instance Show VkComponentMapping where
        showsPrec d x
          = showString "VkComponentMapping {" .
              showString "vkR = " .
                showsPrec d (vkR x) .
                  showString ", " .
                    showString "vkG = " .
                      showsPrec d (vkG x) .
                        showString ", " .
                          showString "vkB = " .
                            showsPrec d (vkB x) .
                              showString ", " .
                                showString "vkA = " . showsPrec d (vkA x) . showChar '}'

data VkPhysicalDeviceProperties = VkPhysicalDeviceProperties## ByteArray##

instance Eq VkPhysicalDeviceProperties where
        (VkPhysicalDeviceProperties## a) == (VkPhysicalDeviceProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPhysicalDeviceProperties where
        (VkPhysicalDeviceProperties## a) `compare`
          (VkPhysicalDeviceProperties## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPhysicalDeviceProperties where
        sizeOf ~_ = #{size VkPhysicalDeviceProperties}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPhysicalDeviceProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPhysicalDeviceProperties##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPhysicalDeviceProperties## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPhysicalDeviceProperties where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceProperties) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPhysicalDeviceProperties##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPhysicalDeviceProperties## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkPhysicalDeviceProperties##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPhysicalDeviceProperties## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPhysicalDeviceProperties## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPhysicalDeviceProperties## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkApiVersion a where
        type VkApiVersionMType a :: *

        vkApiVersion :: a -> VkApiVersionMType a

        vkApiVersionByteOffset :: a -> Int

        readVkApiVersion :: Ptr a -> IO (VkApiVersionMType a)

        writeVkApiVersion :: Ptr a -> VkApiVersionMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'apiVersion'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkApiVersion a

instance {-# OVERLAPPING #-}
         HasVkApiVersion VkPhysicalDeviceProperties where
        type VkApiVersionMType VkPhysicalDeviceProperties =
             Data.Word.Word32

        {-# NOINLINE vkApiVersion #-}
        vkApiVersion x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceProperties, apiVersion})

        {-# INLINE vkApiVersionByteOffset #-}
        vkApiVersionByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, apiVersion}

        {-# INLINE readVkApiVersion #-}
        readVkApiVersion p
          = peekByteOff p
              #{offset VkPhysicalDeviceProperties, apiVersion}

        {-# INLINE writeVkApiVersion #-}
        writeVkApiVersion p
          = pokeByteOff p
              #{offset VkPhysicalDeviceProperties, apiVersion}

class HasVkDriverVersion a where
        type VkDriverVersionMType a :: *

        vkDriverVersion :: a -> VkDriverVersionMType a

        vkDriverVersionByteOffset :: a -> Int

        readVkDriverVersion :: Ptr a -> IO (VkDriverVersionMType a)

        writeVkDriverVersion :: Ptr a -> VkDriverVersionMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'driverVersion'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDriverVersion a

instance {-# OVERLAPPING #-}
         HasVkDriverVersion VkPhysicalDeviceProperties where
        type VkDriverVersionMType VkPhysicalDeviceProperties =
             Data.Word.Word32

        {-# NOINLINE vkDriverVersion #-}
        vkDriverVersion x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceProperties, driverVersion})

        {-# INLINE vkDriverVersionByteOffset #-}
        vkDriverVersionByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, driverVersion}

        {-# INLINE readVkDriverVersion #-}
        readVkDriverVersion p
          = peekByteOff p
              #{offset VkPhysicalDeviceProperties, driverVersion}

        {-# INLINE writeVkDriverVersion #-}
        writeVkDriverVersion p
          = pokeByteOff p
              #{offset VkPhysicalDeviceProperties, driverVersion}

class HasVkVendorID a where
        type VkVendorIDMType a :: *

        vkVendorID :: a -> VkVendorIDMType a

        vkVendorIDByteOffset :: a -> Int

        readVkVendorID :: Ptr a -> IO (VkVendorIDMType a)

        writeVkVendorID :: Ptr a -> VkVendorIDMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'vendorID'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkVendorID a

instance {-# OVERLAPPING #-}
         HasVkVendorID VkPhysicalDeviceProperties where
        type VkVendorIDMType VkPhysicalDeviceProperties = Data.Word.Word32

        {-# NOINLINE vkVendorID #-}
        vkVendorID x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceProperties, vendorID})

        {-# INLINE vkVendorIDByteOffset #-}
        vkVendorIDByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, vendorID}

        {-# INLINE readVkVendorID #-}
        readVkVendorID p
          = peekByteOff p
              #{offset VkPhysicalDeviceProperties, vendorID}

        {-# INLINE writeVkVendorID #-}
        writeVkVendorID p
          = pokeByteOff p
              #{offset VkPhysicalDeviceProperties, vendorID}

class HasVkDeviceID a where
        type VkDeviceIDMType a :: *

        vkDeviceID :: a -> VkDeviceIDMType a

        vkDeviceIDByteOffset :: a -> Int

        readVkDeviceID :: Ptr a -> IO (VkDeviceIDMType a)

        writeVkDeviceID :: Ptr a -> VkDeviceIDMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'deviceID'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDeviceID a

instance {-# OVERLAPPING #-}
         HasVkDeviceID VkPhysicalDeviceProperties where
        type VkDeviceIDMType VkPhysicalDeviceProperties = Data.Word.Word32

        {-# NOINLINE vkDeviceID #-}
        vkDeviceID x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceProperties, deviceID})

        {-# INLINE vkDeviceIDByteOffset #-}
        vkDeviceIDByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, deviceID}

        {-# INLINE readVkDeviceID #-}
        readVkDeviceID p
          = peekByteOff p
              #{offset VkPhysicalDeviceProperties, deviceID}

        {-# INLINE writeVkDeviceID #-}
        writeVkDeviceID p
          = pokeByteOff p
              #{offset VkPhysicalDeviceProperties, deviceID}

class HasVkDeviceType a where
        type VkDeviceTypeMType a :: *

        vkDeviceType :: a -> VkDeviceTypeMType a

        vkDeviceTypeByteOffset :: a -> Int

        readVkDeviceType :: Ptr a -> IO (VkDeviceTypeMType a)

        writeVkDeviceType :: Ptr a -> VkDeviceTypeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'deviceType'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDeviceType a

instance {-# OVERLAPPING #-}
         HasVkDeviceType VkPhysicalDeviceProperties where
        type VkDeviceTypeMType VkPhysicalDeviceProperties =
             VkPhysicalDeviceType

        {-# NOINLINE vkDeviceType #-}
        vkDeviceType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceProperties, deviceType})

        {-# INLINE vkDeviceTypeByteOffset #-}
        vkDeviceTypeByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, deviceType}

        {-# INLINE readVkDeviceType #-}
        readVkDeviceType p
          = peekByteOff p
              #{offset VkPhysicalDeviceProperties, deviceType}

        {-# INLINE writeVkDeviceType #-}
        writeVkDeviceType p
          = pokeByteOff p
              #{offset VkPhysicalDeviceProperties, deviceType}

class HasVkDeviceNameArray a where
        type VkDeviceNameArrayMType a :: *

        vkDeviceNameArray :: a -> Int -> VkDeviceNameArrayMType a

        vkDeviceNameArrayByteOffset :: a -> Int

        readVkDeviceNameArray ::
                              Ptr a -> Int -> IO (VkDeviceNameArrayMType a)

        writeVkDeviceNameArray ::
                               Ptr a -> Int -> VkDeviceNameArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'deviceName'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDeviceNameArray a

instance {-# OVERLAPPING #-}
         HasVkDeviceNameArray VkPhysicalDeviceProperties where
        type VkDeviceNameArrayMType VkPhysicalDeviceProperties =
             Foreign.C.Types.CChar

        {-# NOINLINE vkDeviceNameArray #-}
        vkDeviceNameArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Foreign.C.Types.CChar) +
                    #{offset VkPhysicalDeviceProperties, deviceName}))

        {-# INLINE vkDeviceNameArrayByteOffset #-}
        vkDeviceNameArrayByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, deviceName}

        {-# INLINE readVkDeviceNameArray #-}
        readVkDeviceNameArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CChar) +
                 #{offset VkPhysicalDeviceProperties, deviceName})

        {-# INLINE writeVkDeviceNameArray #-}
        writeVkDeviceNameArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CChar) +
                 #{offset VkPhysicalDeviceProperties, deviceName})

class HasVkPipelineCacheUUIDArray a where
        type VkPipelineCacheUUIDArrayMType a :: *

        vkPipelineCacheUUIDArray ::
                                 a -> Int -> VkPipelineCacheUUIDArrayMType a

        vkPipelineCacheUUIDArrayByteOffset :: a -> Int

        readVkPipelineCacheUUIDArray ::
                                     Ptr a -> Int -> IO (VkPipelineCacheUUIDArrayMType a)

        writeVkPipelineCacheUUIDArray ::
                                      Ptr a -> Int -> VkPipelineCacheUUIDArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pipelineCacheUUID'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPipelineCacheUUIDArray a

instance {-# OVERLAPPING #-}
         HasVkPipelineCacheUUIDArray VkPhysicalDeviceProperties where
        type VkPipelineCacheUUIDArrayMType VkPhysicalDeviceProperties =
             Data.Word.Word8

        {-# NOINLINE vkPipelineCacheUUIDArray #-}
        vkPipelineCacheUUIDArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Data.Word.Word8) +
                    #{offset VkPhysicalDeviceProperties, pipelineCacheUUID}))

        {-# INLINE vkPipelineCacheUUIDArrayByteOffset #-}
        vkPipelineCacheUUIDArrayByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, pipelineCacheUUID}

        {-# INLINE readVkPipelineCacheUUIDArray #-}
        readVkPipelineCacheUUIDArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Data.Word.Word8) +
                 #{offset VkPhysicalDeviceProperties, pipelineCacheUUID})

        {-# INLINE writeVkPipelineCacheUUIDArray #-}
        writeVkPipelineCacheUUIDArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Data.Word.Word8) +
                 #{offset VkPhysicalDeviceProperties, pipelineCacheUUID})

class HasVkLimits a where
        type VkLimitsMType a :: *

        vkLimits :: a -> VkLimitsMType a

        vkLimitsByteOffset :: a -> Int

        readVkLimits :: Ptr a -> IO (VkLimitsMType a)

        writeVkLimits :: Ptr a -> VkLimitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'limits'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLimits a

instance {-# OVERLAPPING #-} HasVkLimits VkPhysicalDeviceProperties
         where
        type VkLimitsMType VkPhysicalDeviceProperties =
             VkPhysicalDeviceLimits

        {-# NOINLINE vkLimits #-}
        vkLimits x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceProperties, limits})

        {-# INLINE vkLimitsByteOffset #-}
        vkLimitsByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, limits}

        {-# INLINE readVkLimits #-}
        readVkLimits p
          = peekByteOff p
              #{offset VkPhysicalDeviceProperties, limits}

        {-# INLINE writeVkLimits #-}
        writeVkLimits p
          = pokeByteOff p
              #{offset VkPhysicalDeviceProperties, limits}

class HasVkSparseProperties a where
        type VkSparsePropertiesMType a :: *

        vkSparseProperties :: a -> VkSparsePropertiesMType a

        vkSparsePropertiesByteOffset :: a -> Int

        readVkSparseProperties :: Ptr a -> IO (VkSparsePropertiesMType a)

        writeVkSparseProperties ::
                                Ptr a -> VkSparsePropertiesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseProperties'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseProperties a

instance {-# OVERLAPPING #-}
         HasVkSparseProperties VkPhysicalDeviceProperties where
        type VkSparsePropertiesMType VkPhysicalDeviceProperties =
             VkPhysicalDeviceSparseProperties

        {-# NOINLINE vkSparseProperties #-}
        vkSparseProperties x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceProperties, sparseProperties})

        {-# INLINE vkSparsePropertiesByteOffset #-}
        vkSparsePropertiesByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, sparseProperties}

        {-# INLINE readVkSparseProperties #-}
        readVkSparseProperties p
          = peekByteOff p
              #{offset VkPhysicalDeviceProperties, sparseProperties}

        {-# INLINE writeVkSparseProperties #-}
        writeVkSparseProperties p
          = pokeByteOff p
              #{offset VkPhysicalDeviceProperties, sparseProperties}

instance Show VkPhysicalDeviceProperties where
        showsPrec d x
          = showString "VkPhysicalDeviceProperties {" .
              showString "vkApiVersion = " .
                showsPrec d (vkApiVersion x) .
                  showString ", " .
                    showString "vkDriverVersion = " .
                      showsPrec d (vkDriverVersion x) .
                        showString ", " .
                          showString "vkVendorID = " .
                            showsPrec d (vkVendorID x) .
                              showString ", " .
                                showString "vkDeviceID = " .
                                  showsPrec d (vkDeviceID x) .
                                    showString ", " .
                                      showString "vkDeviceType = " .
                                        showsPrec d (vkDeviceType x) .
                                          showString ", " .
                                            showString "vkDeviceNameArray = [" .
                                              showsPrec d
                                                (map (vkDeviceNameArray x)
                                                   [1 .. VK_MAX_PHYSICAL_DEVICE_NAME_SIZE])
                                                .
                                                showChar ']' .
                                                  showString ", " .
                                                    showString "vkPipelineCacheUUIDArray = [" .
                                                      showsPrec d
                                                        (map (vkPipelineCacheUUIDArray x)
                                                           [1 .. VK_UUID_SIZE])
                                                        .
                                                        showChar ']' .
                                                          showString ", " .
                                                            showString "vkLimits = " .
                                                              showsPrec d (vkLimits x) .
                                                                showString ", " .
                                                                  showString "vkSparseProperties = "
                                                                    .
                                                                    showsPrec d
                                                                      (vkSparseProperties x)
                                                                      . showChar '}'

data VkExtensionProperties = VkExtensionProperties## ByteArray##

instance Eq VkExtensionProperties where
        (VkExtensionProperties## a) == (VkExtensionProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkExtensionProperties where
        (VkExtensionProperties## a) `compare` (VkExtensionProperties## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkExtensionProperties where
        sizeOf ~_ = #{size VkExtensionProperties}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkExtensionProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkExtensionProperties),
            I## a <- alignment (undefined :: VkExtensionProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkExtensionProperties## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkExtensionProperties## ba)
          | I## n <- sizeOf (undefined :: VkExtensionProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkExtensionProperties where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkExtensionProperties),
            I## a <- alignment (undefined :: VkExtensionProperties) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkExtensionProperties##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkExtensionProperties## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkExtensionProperties##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkExtensionProperties## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkExtensionProperties## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkExtensionProperties## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkExtensionNameArray a where
        type VkExtensionNameArrayMType a :: *

        vkExtensionNameArray :: a -> Int -> VkExtensionNameArrayMType a

        vkExtensionNameArrayByteOffset :: a -> Int

        readVkExtensionNameArray ::
                                 Ptr a -> Int -> IO (VkExtensionNameArrayMType a)

        writeVkExtensionNameArray ::
                                  Ptr a -> Int -> VkExtensionNameArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'extensionName'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkExtensionNameArray a

instance {-# OVERLAPPING #-}
         HasVkExtensionNameArray VkExtensionProperties where
        type VkExtensionNameArrayMType VkExtensionProperties =
             Foreign.C.Types.CChar

        {-# NOINLINE vkExtensionNameArray #-}
        vkExtensionNameArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Foreign.C.Types.CChar) +
                    #{offset VkExtensionProperties, extensionName}))

        {-# INLINE vkExtensionNameArrayByteOffset #-}
        vkExtensionNameArrayByteOffset ~_
          = #{offset VkExtensionProperties, extensionName}

        {-# INLINE readVkExtensionNameArray #-}
        readVkExtensionNameArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CChar) +
                 #{offset VkExtensionProperties, extensionName})

        {-# INLINE writeVkExtensionNameArray #-}
        writeVkExtensionNameArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CChar) +
                 #{offset VkExtensionProperties, extensionName})

class HasVkSpecVersion a where
        type VkSpecVersionMType a :: *

        vkSpecVersion :: a -> VkSpecVersionMType a

        vkSpecVersionByteOffset :: a -> Int

        readVkSpecVersion :: Ptr a -> IO (VkSpecVersionMType a)

        writeVkSpecVersion :: Ptr a -> VkSpecVersionMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'specVersion'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSpecVersion a

instance {-# OVERLAPPING #-} HasVkSpecVersion VkExtensionProperties
         where
        type VkSpecVersionMType VkExtensionProperties = Data.Word.Word32

        {-# NOINLINE vkSpecVersion #-}
        vkSpecVersion x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkExtensionProperties, specVersion})

        {-# INLINE vkSpecVersionByteOffset #-}
        vkSpecVersionByteOffset ~_
          = #{offset VkExtensionProperties, specVersion}

        {-# INLINE readVkSpecVersion #-}
        readVkSpecVersion p
          = peekByteOff p
              #{offset VkExtensionProperties, specVersion}

        {-# INLINE writeVkSpecVersion #-}
        writeVkSpecVersion p
          = pokeByteOff p
              #{offset VkExtensionProperties, specVersion}

instance Show VkExtensionProperties where
        showsPrec d x
          = showString "VkExtensionProperties {" .
              showString "vkExtensionNameArray = [" .
                showsPrec d
                  (map (vkExtensionNameArray x) [1 .. VK_MAX_EXTENSION_NAME_SIZE])
                  .
                  showChar ']' .
                    showString ", " .
                      showString "vkSpecVersion = " .
                        showsPrec d (vkSpecVersion x) . showChar '}'

data VkLayerProperties = VkLayerProperties## ByteArray##

instance Eq VkLayerProperties where
        (VkLayerProperties## a) == (VkLayerProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkLayerProperties where
        (VkLayerProperties## a) `compare` (VkLayerProperties## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkLayerProperties where
        sizeOf ~_ = #{size VkLayerProperties}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkLayerProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkLayerProperties),
            I## a <- alignment (undefined :: VkLayerProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkLayerProperties## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkLayerProperties## ba)
          | I## n <- sizeOf (undefined :: VkLayerProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkLayerProperties where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkLayerProperties),
            I## a <- alignment (undefined :: VkLayerProperties) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkLayerProperties##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkLayerProperties## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkLayerProperties##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkLayerProperties## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkLayerProperties## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkLayerProperties## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkLayerNameArray a where
        type VkLayerNameArrayMType a :: *

        vkLayerNameArray :: a -> Int -> VkLayerNameArrayMType a

        vkLayerNameArrayByteOffset :: a -> Int

        readVkLayerNameArray ::
                             Ptr a -> Int -> IO (VkLayerNameArrayMType a)

        writeVkLayerNameArray ::
                              Ptr a -> Int -> VkLayerNameArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'layerName'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLayerNameArray a

instance {-# OVERLAPPING #-} HasVkLayerNameArray VkLayerProperties
         where
        type VkLayerNameArrayMType VkLayerProperties =
             Foreign.C.Types.CChar

        {-# NOINLINE vkLayerNameArray #-}
        vkLayerNameArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Foreign.C.Types.CChar) +
                    #{offset VkLayerProperties, layerName}))

        {-# INLINE vkLayerNameArrayByteOffset #-}
        vkLayerNameArrayByteOffset ~_
          = #{offset VkLayerProperties, layerName}

        {-# INLINE readVkLayerNameArray #-}
        readVkLayerNameArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CChar) +
                 #{offset VkLayerProperties, layerName})

        {-# INLINE writeVkLayerNameArray #-}
        writeVkLayerNameArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CChar) +
                 #{offset VkLayerProperties, layerName})

instance {-# OVERLAPPING #-} HasVkSpecVersion VkLayerProperties
         where
        type VkSpecVersionMType VkLayerProperties = Data.Word.Word32

        {-# NOINLINE vkSpecVersion #-}
        vkSpecVersion x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkLayerProperties, specVersion})

        {-# INLINE vkSpecVersionByteOffset #-}
        vkSpecVersionByteOffset ~_
          = #{offset VkLayerProperties, specVersion}

        {-# INLINE readVkSpecVersion #-}
        readVkSpecVersion p
          = peekByteOff p #{offset VkLayerProperties, specVersion}

        {-# INLINE writeVkSpecVersion #-}
        writeVkSpecVersion p
          = pokeByteOff p #{offset VkLayerProperties, specVersion}

class HasVkImplementationVersion a where
        type VkImplementationVersionMType a :: *

        vkImplementationVersion :: a -> VkImplementationVersionMType a

        vkImplementationVersionByteOffset :: a -> Int

        readVkImplementationVersion ::
                                    Ptr a -> IO (VkImplementationVersionMType a)

        writeVkImplementationVersion ::
                                     Ptr a -> VkImplementationVersionMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'implementationVersion'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImplementationVersion a

instance {-# OVERLAPPING #-}
         HasVkImplementationVersion VkLayerProperties where
        type VkImplementationVersionMType VkLayerProperties =
             Data.Word.Word32

        {-# NOINLINE vkImplementationVersion #-}
        vkImplementationVersion x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkLayerProperties, implementationVersion})

        {-# INLINE vkImplementationVersionByteOffset #-}
        vkImplementationVersionByteOffset ~_
          = #{offset VkLayerProperties, implementationVersion}

        {-# INLINE readVkImplementationVersion #-}
        readVkImplementationVersion p
          = peekByteOff p
              #{offset VkLayerProperties, implementationVersion}

        {-# INLINE writeVkImplementationVersion #-}
        writeVkImplementationVersion p
          = pokeByteOff p
              #{offset VkLayerProperties, implementationVersion}

class HasVkDescriptionArray a where
        type VkDescriptionArrayMType a :: *

        vkDescriptionArray :: a -> Int -> VkDescriptionArrayMType a

        vkDescriptionArrayByteOffset :: a -> Int

        readVkDescriptionArray ::
                               Ptr a -> Int -> IO (VkDescriptionArrayMType a)

        writeVkDescriptionArray ::
                                Ptr a -> Int -> VkDescriptionArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'description'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDescriptionArray a

instance {-# OVERLAPPING #-}
         HasVkDescriptionArray VkLayerProperties where
        type VkDescriptionArrayMType VkLayerProperties =
             Foreign.C.Types.CChar

        {-# NOINLINE vkDescriptionArray #-}
        vkDescriptionArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Foreign.C.Types.CChar) +
                    #{offset VkLayerProperties, description}))

        {-# INLINE vkDescriptionArrayByteOffset #-}
        vkDescriptionArrayByteOffset ~_
          = #{offset VkLayerProperties, description}

        {-# INLINE readVkDescriptionArray #-}
        readVkDescriptionArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CChar) +
                 #{offset VkLayerProperties, description})

        {-# INLINE writeVkDescriptionArray #-}
        writeVkDescriptionArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CChar) +
                 #{offset VkLayerProperties, description})

instance Show VkLayerProperties where
        showsPrec d x
          = showString "VkLayerProperties {" .
              showString "vkLayerNameArray = [" .
                showsPrec d
                  (map (vkLayerNameArray x) [1 .. VK_MAX_EXTENSION_NAME_SIZE])
                  .
                  showChar ']' .
                    showString ", " .
                      showString "vkSpecVersion = " .
                        showsPrec d (vkSpecVersion x) .
                          showString ", " .
                            showString "vkImplementationVersion = " .
                              showsPrec d (vkImplementationVersion x) .
                                showString ", " .
                                  showString "vkDescriptionArray = [" .
                                    showsPrec d
                                      (map (vkDescriptionArray x) [1 .. VK_MAX_DESCRIPTION_SIZE])
                                      . showChar ']' . showChar '}'

data VkApplicationInfo = VkApplicationInfo## ByteArray##

instance Eq VkApplicationInfo where
        (VkApplicationInfo## a) == (VkApplicationInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkApplicationInfo where
        (VkApplicationInfo## a) `compare` (VkApplicationInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkApplicationInfo where
        sizeOf ~_ = #{size VkApplicationInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkApplicationInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkApplicationInfo),
            I## a <- alignment (undefined :: VkApplicationInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkApplicationInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkApplicationInfo## ba)
          | I## n <- sizeOf (undefined :: VkApplicationInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkApplicationInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkApplicationInfo),
            I## a <- alignment (undefined :: VkApplicationInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkApplicationInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkApplicationInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkApplicationInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkApplicationInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkApplicationInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkApplicationInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkSType a where
        type VkSTypeMType a :: *

        vkSType :: a -> VkSTypeMType a

        vkSTypeByteOffset :: a -> Int

        readVkSType :: Ptr a -> IO (VkSTypeMType a)

        writeVkSType :: Ptr a -> VkSTypeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sType'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSType a

instance {-# OVERLAPPING #-} HasVkSType VkApplicationInfo where
        type VkSTypeMType VkApplicationInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkApplicationInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_ = #{offset VkApplicationInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkApplicationInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkApplicationInfo, sType}

class HasVkPNext a where
        type VkPNextMType a :: *

        vkPNext :: a -> VkPNextMType a

        vkPNextByteOffset :: a -> Int

        readVkPNext :: Ptr a -> IO (VkPNextMType a)

        writeVkPNext :: Ptr a -> VkPNextMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pNext'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPNext a

instance {-# OVERLAPPING #-} HasVkPNext VkApplicationInfo where
        type VkPNextMType VkApplicationInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkApplicationInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_ = #{offset VkApplicationInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkApplicationInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkApplicationInfo, pNext}

class HasVkPApplicationName a where
        type VkPApplicationNameMType a :: *

        vkPApplicationName :: a -> VkPApplicationNameMType a

        vkPApplicationNameByteOffset :: a -> Int

        readVkPApplicationName :: Ptr a -> IO (VkPApplicationNameMType a)

        writeVkPApplicationName ::
                                Ptr a -> VkPApplicationNameMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pApplicationName'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPApplicationName a

instance {-# OVERLAPPING #-}
         HasVkPApplicationName VkApplicationInfo where
        type VkPApplicationNameMType VkApplicationInfo =
             Foreign.Ptr.Ptr Foreign.C.Types.CChar

        {-# NOINLINE vkPApplicationName #-}
        vkPApplicationName x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkApplicationInfo, pApplicationName})

        {-# INLINE vkPApplicationNameByteOffset #-}
        vkPApplicationNameByteOffset ~_
          = #{offset VkApplicationInfo, pApplicationName}

        {-# INLINE readVkPApplicationName #-}
        readVkPApplicationName p
          = peekByteOff p
              #{offset VkApplicationInfo, pApplicationName}

        {-# INLINE writeVkPApplicationName #-}
        writeVkPApplicationName p
          = pokeByteOff p
              #{offset VkApplicationInfo, pApplicationName}

class HasVkApplicationVersion a where
        type VkApplicationVersionMType a :: *

        vkApplicationVersion :: a -> VkApplicationVersionMType a

        vkApplicationVersionByteOffset :: a -> Int

        readVkApplicationVersion ::
                                 Ptr a -> IO (VkApplicationVersionMType a)

        writeVkApplicationVersion ::
                                  Ptr a -> VkApplicationVersionMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'applicationVersion'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkApplicationVersion a

instance {-# OVERLAPPING #-}
         HasVkApplicationVersion VkApplicationInfo where
        type VkApplicationVersionMType VkApplicationInfo = Data.Word.Word32

        {-# NOINLINE vkApplicationVersion #-}
        vkApplicationVersion x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkApplicationInfo, applicationVersion})

        {-# INLINE vkApplicationVersionByteOffset #-}
        vkApplicationVersionByteOffset ~_
          = #{offset VkApplicationInfo, applicationVersion}

        {-# INLINE readVkApplicationVersion #-}
        readVkApplicationVersion p
          = peekByteOff p
              #{offset VkApplicationInfo, applicationVersion}

        {-# INLINE writeVkApplicationVersion #-}
        writeVkApplicationVersion p
          = pokeByteOff p
              #{offset VkApplicationInfo, applicationVersion}

class HasVkPEngineName a where
        type VkPEngineNameMType a :: *

        vkPEngineName :: a -> VkPEngineNameMType a

        vkPEngineNameByteOffset :: a -> Int

        readVkPEngineName :: Ptr a -> IO (VkPEngineNameMType a)

        writeVkPEngineName :: Ptr a -> VkPEngineNameMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pEngineName'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPEngineName a

instance {-# OVERLAPPING #-} HasVkPEngineName VkApplicationInfo
         where
        type VkPEngineNameMType VkApplicationInfo =
             Foreign.Ptr.Ptr Foreign.C.Types.CChar

        {-# NOINLINE vkPEngineName #-}
        vkPEngineName x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkApplicationInfo, pEngineName})

        {-# INLINE vkPEngineNameByteOffset #-}
        vkPEngineNameByteOffset ~_
          = #{offset VkApplicationInfo, pEngineName}

        {-# INLINE readVkPEngineName #-}
        readVkPEngineName p
          = peekByteOff p #{offset VkApplicationInfo, pEngineName}

        {-# INLINE writeVkPEngineName #-}
        writeVkPEngineName p
          = pokeByteOff p #{offset VkApplicationInfo, pEngineName}

class HasVkEngineVersion a where
        type VkEngineVersionMType a :: *

        vkEngineVersion :: a -> VkEngineVersionMType a

        vkEngineVersionByteOffset :: a -> Int

        readVkEngineVersion :: Ptr a -> IO (VkEngineVersionMType a)

        writeVkEngineVersion :: Ptr a -> VkEngineVersionMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'engineVersion'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkEngineVersion a

instance {-# OVERLAPPING #-} HasVkEngineVersion VkApplicationInfo
         where
        type VkEngineVersionMType VkApplicationInfo = Data.Word.Word32

        {-# NOINLINE vkEngineVersion #-}
        vkEngineVersion x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkApplicationInfo, engineVersion})

        {-# INLINE vkEngineVersionByteOffset #-}
        vkEngineVersionByteOffset ~_
          = #{offset VkApplicationInfo, engineVersion}

        {-# INLINE readVkEngineVersion #-}
        readVkEngineVersion p
          = peekByteOff p #{offset VkApplicationInfo, engineVersion}

        {-# INLINE writeVkEngineVersion #-}
        writeVkEngineVersion p
          = pokeByteOff p #{offset VkApplicationInfo, engineVersion}

instance {-# OVERLAPPING #-} HasVkApiVersion VkApplicationInfo
         where
        type VkApiVersionMType VkApplicationInfo = Data.Word.Word32

        {-# NOINLINE vkApiVersion #-}
        vkApiVersion x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkApplicationInfo, apiVersion})

        {-# INLINE vkApiVersionByteOffset #-}
        vkApiVersionByteOffset ~_
          = #{offset VkApplicationInfo, apiVersion}

        {-# INLINE readVkApiVersion #-}
        readVkApiVersion p
          = peekByteOff p #{offset VkApplicationInfo, apiVersion}

        {-# INLINE writeVkApiVersion #-}
        writeVkApiVersion p
          = pokeByteOff p #{offset VkApplicationInfo, apiVersion}

instance Show VkApplicationInfo where
        showsPrec d x
          = showString "VkApplicationInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkPApplicationName = " .
                            showsPrec d (vkPApplicationName x) .
                              showString ", " .
                                showString "vkApplicationVersion = " .
                                  showsPrec d (vkApplicationVersion x) .
                                    showString ", " .
                                      showString "vkPEngineName = " .
                                        showsPrec d (vkPEngineName x) .
                                          showString ", " .
                                            showString "vkEngineVersion = " .
                                              showsPrec d (vkEngineVersion x) .
                                                showString ", " .
                                                  showString "vkApiVersion = " .
                                                    showsPrec d (vkApiVersion x) . showChar '}'

data VkAllocationCallbacks = VkAllocationCallbacks## ByteArray##

instance Eq VkAllocationCallbacks where
        (VkAllocationCallbacks## a) == (VkAllocationCallbacks## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkAllocationCallbacks where
        (VkAllocationCallbacks## a) `compare` (VkAllocationCallbacks## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkAllocationCallbacks where
        sizeOf ~_ = #{size VkAllocationCallbacks}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkAllocationCallbacks}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkAllocationCallbacks),
            I## a <- alignment (undefined :: VkAllocationCallbacks) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkAllocationCallbacks## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkAllocationCallbacks## ba)
          | I## n <- sizeOf (undefined :: VkAllocationCallbacks) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkAllocationCallbacks where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkAllocationCallbacks),
            I## a <- alignment (undefined :: VkAllocationCallbacks) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkAllocationCallbacks##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkAllocationCallbacks## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkAllocationCallbacks##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkAllocationCallbacks## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkAllocationCallbacks## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkAllocationCallbacks## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkPUserData a where
        type VkPUserDataMType a :: *

        vkPUserData :: a -> VkPUserDataMType a

        vkPUserDataByteOffset :: a -> Int

        readVkPUserData :: Ptr a -> IO (VkPUserDataMType a)

        writeVkPUserData :: Ptr a -> VkPUserDataMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pUserData'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPUserData a

instance {-# OVERLAPPING #-} HasVkPUserData VkAllocationCallbacks
         where
        type VkPUserDataMType VkAllocationCallbacks =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPUserData #-}
        vkPUserData x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAllocationCallbacks, pUserData})

        {-# INLINE vkPUserDataByteOffset #-}
        vkPUserDataByteOffset ~_
          = #{offset VkAllocationCallbacks, pUserData}

        {-# INLINE readVkPUserData #-}
        readVkPUserData p
          = peekByteOff p #{offset VkAllocationCallbacks, pUserData}

        {-# INLINE writeVkPUserData #-}
        writeVkPUserData p
          = pokeByteOff p #{offset VkAllocationCallbacks, pUserData}

class HasVkPfnAllocation a where
        type VkPfnAllocationMType a :: *

        vkPfnAllocation :: a -> VkPfnAllocationMType a

        vkPfnAllocationByteOffset :: a -> Int

        readVkPfnAllocation :: Ptr a -> IO (VkPfnAllocationMType a)

        writeVkPfnAllocation :: Ptr a -> VkPfnAllocationMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pfnAllocation'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPfnAllocation a

instance {-# OVERLAPPING #-}
         HasVkPfnAllocation VkAllocationCallbacks where
        type VkPfnAllocationMType VkAllocationCallbacks =
             PFN_vkAllocationFunction

        {-# NOINLINE vkPfnAllocation #-}
        vkPfnAllocation x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAllocationCallbacks, pfnAllocation})

        {-# INLINE vkPfnAllocationByteOffset #-}
        vkPfnAllocationByteOffset ~_
          = #{offset VkAllocationCallbacks, pfnAllocation}

        {-# INLINE readVkPfnAllocation #-}
        readVkPfnAllocation p
          = peekByteOff p
              #{offset VkAllocationCallbacks, pfnAllocation}

        {-# INLINE writeVkPfnAllocation #-}
        writeVkPfnAllocation p
          = pokeByteOff p
              #{offset VkAllocationCallbacks, pfnAllocation}

class HasVkPfnReallocation a where
        type VkPfnReallocationMType a :: *

        vkPfnReallocation :: a -> VkPfnReallocationMType a

        vkPfnReallocationByteOffset :: a -> Int

        readVkPfnReallocation :: Ptr a -> IO (VkPfnReallocationMType a)

        writeVkPfnReallocation ::
                               Ptr a -> VkPfnReallocationMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pfnReallocation'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPfnReallocation a

instance {-# OVERLAPPING #-}
         HasVkPfnReallocation VkAllocationCallbacks where
        type VkPfnReallocationMType VkAllocationCallbacks =
             PFN_vkReallocationFunction

        {-# NOINLINE vkPfnReallocation #-}
        vkPfnReallocation x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAllocationCallbacks, pfnReallocation})

        {-# INLINE vkPfnReallocationByteOffset #-}
        vkPfnReallocationByteOffset ~_
          = #{offset VkAllocationCallbacks, pfnReallocation}

        {-# INLINE readVkPfnReallocation #-}
        readVkPfnReallocation p
          = peekByteOff p
              #{offset VkAllocationCallbacks, pfnReallocation}

        {-# INLINE writeVkPfnReallocation #-}
        writeVkPfnReallocation p
          = pokeByteOff p
              #{offset VkAllocationCallbacks, pfnReallocation}

class HasVkPfnFree a where
        type VkPfnFreeMType a :: *

        vkPfnFree :: a -> VkPfnFreeMType a

        vkPfnFreeByteOffset :: a -> Int

        readVkPfnFree :: Ptr a -> IO (VkPfnFreeMType a)

        writeVkPfnFree :: Ptr a -> VkPfnFreeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pfnFree'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPfnFree a

instance {-# OVERLAPPING #-} HasVkPfnFree VkAllocationCallbacks
         where
        type VkPfnFreeMType VkAllocationCallbacks = PFN_vkFreeFunction

        {-# NOINLINE vkPfnFree #-}
        vkPfnFree x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAllocationCallbacks, pfnFree})

        {-# INLINE vkPfnFreeByteOffset #-}
        vkPfnFreeByteOffset ~_
          = #{offset VkAllocationCallbacks, pfnFree}

        {-# INLINE readVkPfnFree #-}
        readVkPfnFree p
          = peekByteOff p #{offset VkAllocationCallbacks, pfnFree}

        {-# INLINE writeVkPfnFree #-}
        writeVkPfnFree p
          = pokeByteOff p #{offset VkAllocationCallbacks, pfnFree}

class HasVkPfnInternalAllocation a where
        type VkPfnInternalAllocationMType a :: *

        vkPfnInternalAllocation :: a -> VkPfnInternalAllocationMType a

        vkPfnInternalAllocationByteOffset :: a -> Int

        readVkPfnInternalAllocation ::
                                    Ptr a -> IO (VkPfnInternalAllocationMType a)

        writeVkPfnInternalAllocation ::
                                     Ptr a -> VkPfnInternalAllocationMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pfnInternalAllocation'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPfnInternalAllocation a

instance {-# OVERLAPPING #-}
         HasVkPfnInternalAllocation VkAllocationCallbacks where
        type VkPfnInternalAllocationMType VkAllocationCallbacks =
             PFN_vkInternalAllocationNotification

        {-# NOINLINE vkPfnInternalAllocation #-}
        vkPfnInternalAllocation x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAllocationCallbacks, pfnInternalAllocation})

        {-# INLINE vkPfnInternalAllocationByteOffset #-}
        vkPfnInternalAllocationByteOffset ~_
          = #{offset VkAllocationCallbacks, pfnInternalAllocation}

        {-# INLINE readVkPfnInternalAllocation #-}
        readVkPfnInternalAllocation p
          = peekByteOff p
              #{offset VkAllocationCallbacks, pfnInternalAllocation}

        {-# INLINE writeVkPfnInternalAllocation #-}
        writeVkPfnInternalAllocation p
          = pokeByteOff p
              #{offset VkAllocationCallbacks, pfnInternalAllocation}

class HasVkPfnInternalFree a where
        type VkPfnInternalFreeMType a :: *

        vkPfnInternalFree :: a -> VkPfnInternalFreeMType a

        vkPfnInternalFreeByteOffset :: a -> Int

        readVkPfnInternalFree :: Ptr a -> IO (VkPfnInternalFreeMType a)

        writeVkPfnInternalFree ::
                               Ptr a -> VkPfnInternalFreeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pfnInternalFree'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPfnInternalFree a

instance {-# OVERLAPPING #-}
         HasVkPfnInternalFree VkAllocationCallbacks where
        type VkPfnInternalFreeMType VkAllocationCallbacks =
             PFN_vkInternalFreeNotification

        {-# NOINLINE vkPfnInternalFree #-}
        vkPfnInternalFree x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAllocationCallbacks, pfnInternalFree})

        {-# INLINE vkPfnInternalFreeByteOffset #-}
        vkPfnInternalFreeByteOffset ~_
          = #{offset VkAllocationCallbacks, pfnInternalFree}

        {-# INLINE readVkPfnInternalFree #-}
        readVkPfnInternalFree p
          = peekByteOff p
              #{offset VkAllocationCallbacks, pfnInternalFree}

        {-# INLINE writeVkPfnInternalFree #-}
        writeVkPfnInternalFree p
          = pokeByteOff p
              #{offset VkAllocationCallbacks, pfnInternalFree}

instance Show VkAllocationCallbacks where
        showsPrec d x
          = showString "VkAllocationCallbacks {" .
              showString "vkPUserData = " .
                showsPrec d (vkPUserData x) .
                  showString ", " .
                    showString "vkPfnAllocation = " .
                      showsPrec d (vkPfnAllocation x) .
                        showString ", " .
                          showString "vkPfnReallocation = " .
                            showsPrec d (vkPfnReallocation x) .
                              showString ", " .
                                showString "vkPfnFree = " .
                                  showsPrec d (vkPfnFree x) .
                                    showString ", " .
                                      showString "vkPfnInternalAllocation = " .
                                        showsPrec d (vkPfnInternalAllocation x) .
                                          showString ", " .
                                            showString "vkPfnInternalFree = " .
                                              showsPrec d (vkPfnInternalFree x) . showChar '}'

data VkDeviceQueueCreateInfo = VkDeviceQueueCreateInfo## ByteArray##

instance Eq VkDeviceQueueCreateInfo where
        (VkDeviceQueueCreateInfo## a) == (VkDeviceQueueCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDeviceQueueCreateInfo where
        (VkDeviceQueueCreateInfo## a) `compare` (VkDeviceQueueCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDeviceQueueCreateInfo where
        sizeOf ~_ = #{size VkDeviceQueueCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDeviceQueueCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDeviceQueueCreateInfo),
            I## a <- alignment (undefined :: VkDeviceQueueCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDeviceQueueCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDeviceQueueCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDeviceQueueCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDeviceQueueCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkDeviceQueueCreateInfo),
            I## a <- alignment (undefined :: VkDeviceQueueCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkDeviceQueueCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkDeviceQueueCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkDeviceQueueCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkDeviceQueueCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkDeviceQueueCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkDeviceQueueCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkDeviceQueueCreateInfo
         where
        type VkSTypeMType VkDeviceQueueCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceQueueCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkDeviceQueueCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkDeviceQueueCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkDeviceQueueCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkDeviceQueueCreateInfo
         where
        type VkPNextMType VkDeviceQueueCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceQueueCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkDeviceQueueCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkDeviceQueueCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkDeviceQueueCreateInfo, pNext}

class HasVkFlags a where
        type VkFlagsMType a :: *

        vkFlags :: a -> VkFlagsMType a

        vkFlagsByteOffset :: a -> Int

        readVkFlags :: Ptr a -> IO (VkFlagsMType a)

        writeVkFlags :: Ptr a -> VkFlagsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'flags'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFlags a

instance {-# OVERLAPPING #-} HasVkFlags VkDeviceQueueCreateInfo
         where
        type VkFlagsMType VkDeviceQueueCreateInfo =
             VkDeviceQueueCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceQueueCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkDeviceQueueCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkDeviceQueueCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkDeviceQueueCreateInfo, flags}

class HasVkQueueFamilyIndex a where
        type VkQueueFamilyIndexMType a :: *

        vkQueueFamilyIndex :: a -> VkQueueFamilyIndexMType a

        vkQueueFamilyIndexByteOffset :: a -> Int

        readVkQueueFamilyIndex :: Ptr a -> IO (VkQueueFamilyIndexMType a)

        writeVkQueueFamilyIndex ::
                                Ptr a -> VkQueueFamilyIndexMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queueFamilyIndex'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueueFamilyIndex a

instance {-# OVERLAPPING #-}
         HasVkQueueFamilyIndex VkDeviceQueueCreateInfo where
        type VkQueueFamilyIndexMType VkDeviceQueueCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkQueueFamilyIndex #-}
        vkQueueFamilyIndex x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceQueueCreateInfo, queueFamilyIndex})

        {-# INLINE vkQueueFamilyIndexByteOffset #-}
        vkQueueFamilyIndexByteOffset ~_
          = #{offset VkDeviceQueueCreateInfo, queueFamilyIndex}

        {-# INLINE readVkQueueFamilyIndex #-}
        readVkQueueFamilyIndex p
          = peekByteOff p
              #{offset VkDeviceQueueCreateInfo, queueFamilyIndex}

        {-# INLINE writeVkQueueFamilyIndex #-}
        writeVkQueueFamilyIndex p
          = pokeByteOff p
              #{offset VkDeviceQueueCreateInfo, queueFamilyIndex}

class HasVkQueueCount a where
        type VkQueueCountMType a :: *

        vkQueueCount :: a -> VkQueueCountMType a

        vkQueueCountByteOffset :: a -> Int

        readVkQueueCount :: Ptr a -> IO (VkQueueCountMType a)

        writeVkQueueCount :: Ptr a -> VkQueueCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queueCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueueCount a

instance {-# OVERLAPPING #-}
         HasVkQueueCount VkDeviceQueueCreateInfo where
        type VkQueueCountMType VkDeviceQueueCreateInfo = Data.Word.Word32

        {-# NOINLINE vkQueueCount #-}
        vkQueueCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceQueueCreateInfo, queueCount})

        {-# INLINE vkQueueCountByteOffset #-}
        vkQueueCountByteOffset ~_
          = #{offset VkDeviceQueueCreateInfo, queueCount}

        {-# INLINE readVkQueueCount #-}
        readVkQueueCount p
          = peekByteOff p
              #{offset VkDeviceQueueCreateInfo, queueCount}

        {-# INLINE writeVkQueueCount #-}
        writeVkQueueCount p
          = pokeByteOff p
              #{offset VkDeviceQueueCreateInfo, queueCount}

class HasVkPQueuePriorities a where
        type VkPQueuePrioritiesMType a :: *

        vkPQueuePriorities :: a -> VkPQueuePrioritiesMType a

        vkPQueuePrioritiesByteOffset :: a -> Int

        readVkPQueuePriorities :: Ptr a -> IO (VkPQueuePrioritiesMType a)

        writeVkPQueuePriorities ::
                                Ptr a -> VkPQueuePrioritiesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pQueuePriorities'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPQueuePriorities a

instance {-# OVERLAPPING #-}
         HasVkPQueuePriorities VkDeviceQueueCreateInfo where
        type VkPQueuePrioritiesMType VkDeviceQueueCreateInfo =
             Foreign.Ptr.Ptr Foreign.C.Types.CFloat

        {-# NOINLINE vkPQueuePriorities #-}
        vkPQueuePriorities x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceQueueCreateInfo, pQueuePriorities})

        {-# INLINE vkPQueuePrioritiesByteOffset #-}
        vkPQueuePrioritiesByteOffset ~_
          = #{offset VkDeviceQueueCreateInfo, pQueuePriorities}

        {-# INLINE readVkPQueuePriorities #-}
        readVkPQueuePriorities p
          = peekByteOff p
              #{offset VkDeviceQueueCreateInfo, pQueuePriorities}

        {-# INLINE writeVkPQueuePriorities #-}
        writeVkPQueuePriorities p
          = pokeByteOff p
              #{offset VkDeviceQueueCreateInfo, pQueuePriorities}

instance Show VkDeviceQueueCreateInfo where
        showsPrec d x
          = showString "VkDeviceQueueCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkQueueFamilyIndex = " .
                                  showsPrec d (vkQueueFamilyIndex x) .
                                    showString ", " .
                                      showString "vkQueueCount = " .
                                        showsPrec d (vkQueueCount x) .
                                          showString ", " .
                                            showString "vkPQueuePriorities = " .
                                              showsPrec d (vkPQueuePriorities x) . showChar '}'

data VkDeviceCreateInfo = VkDeviceCreateInfo## ByteArray##

instance Eq VkDeviceCreateInfo where
        (VkDeviceCreateInfo## a) == (VkDeviceCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDeviceCreateInfo where
        (VkDeviceCreateInfo## a) `compare` (VkDeviceCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDeviceCreateInfo where
        sizeOf ~_ = #{size VkDeviceCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDeviceCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDeviceCreateInfo),
            I## a <- alignment (undefined :: VkDeviceCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDeviceCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDeviceCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDeviceCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDeviceCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkDeviceCreateInfo),
            I## a <- alignment (undefined :: VkDeviceCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkDeviceCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkDeviceCreateInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkDeviceCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkDeviceCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkDeviceCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkDeviceCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkDeviceCreateInfo where
        type VkSTypeMType VkDeviceCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_ = #{offset VkDeviceCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkDeviceCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkDeviceCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkDeviceCreateInfo where
        type VkPNextMType VkDeviceCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_ = #{offset VkDeviceCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkDeviceCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkDeviceCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkDeviceCreateInfo where
        type VkFlagsMType VkDeviceCreateInfo = VkDeviceCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_ = #{offset VkDeviceCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkDeviceCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkDeviceCreateInfo, flags}

class HasVkQueueCreateInfoCount a where
        type VkQueueCreateInfoCountMType a :: *

        vkQueueCreateInfoCount :: a -> VkQueueCreateInfoCountMType a

        vkQueueCreateInfoCountByteOffset :: a -> Int

        readVkQueueCreateInfoCount ::
                                   Ptr a -> IO (VkQueueCreateInfoCountMType a)

        writeVkQueueCreateInfoCount ::
                                    Ptr a -> VkQueueCreateInfoCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queueCreateInfoCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueueCreateInfoCount a

instance {-# OVERLAPPING #-}
         HasVkQueueCreateInfoCount VkDeviceCreateInfo where
        type VkQueueCreateInfoCountMType VkDeviceCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkQueueCreateInfoCount #-}
        vkQueueCreateInfoCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceCreateInfo, queueCreateInfoCount})

        {-# INLINE vkQueueCreateInfoCountByteOffset #-}
        vkQueueCreateInfoCountByteOffset ~_
          = #{offset VkDeviceCreateInfo, queueCreateInfoCount}

        {-# INLINE readVkQueueCreateInfoCount #-}
        readVkQueueCreateInfoCount p
          = peekByteOff p
              #{offset VkDeviceCreateInfo, queueCreateInfoCount}

        {-# INLINE writeVkQueueCreateInfoCount #-}
        writeVkQueueCreateInfoCount p
          = pokeByteOff p
              #{offset VkDeviceCreateInfo, queueCreateInfoCount}

class HasVkPQueueCreateInfos a where
        type VkPQueueCreateInfosMType a :: *

        vkPQueueCreateInfos :: a -> VkPQueueCreateInfosMType a

        vkPQueueCreateInfosByteOffset :: a -> Int

        readVkPQueueCreateInfos :: Ptr a -> IO (VkPQueueCreateInfosMType a)

        writeVkPQueueCreateInfos ::
                                 Ptr a -> VkPQueueCreateInfosMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pQueueCreateInfos'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPQueueCreateInfos a

instance {-# OVERLAPPING #-}
         HasVkPQueueCreateInfos VkDeviceCreateInfo where
        type VkPQueueCreateInfosMType VkDeviceCreateInfo =
             Foreign.Ptr.Ptr VkDeviceQueueCreateInfo

        {-# NOINLINE vkPQueueCreateInfos #-}
        vkPQueueCreateInfos x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceCreateInfo, pQueueCreateInfos})

        {-# INLINE vkPQueueCreateInfosByteOffset #-}
        vkPQueueCreateInfosByteOffset ~_
          = #{offset VkDeviceCreateInfo, pQueueCreateInfos}

        {-# INLINE readVkPQueueCreateInfos #-}
        readVkPQueueCreateInfos p
          = peekByteOff p
              #{offset VkDeviceCreateInfo, pQueueCreateInfos}

        {-# INLINE writeVkPQueueCreateInfos #-}
        writeVkPQueueCreateInfos p
          = pokeByteOff p
              #{offset VkDeviceCreateInfo, pQueueCreateInfos}

class HasVkEnabledLayerCount a where
        type VkEnabledLayerCountMType a :: *

        vkEnabledLayerCount :: a -> VkEnabledLayerCountMType a

        vkEnabledLayerCountByteOffset :: a -> Int

        readVkEnabledLayerCount :: Ptr a -> IO (VkEnabledLayerCountMType a)

        writeVkEnabledLayerCount ::
                                 Ptr a -> VkEnabledLayerCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'enabledLayerCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkEnabledLayerCount a

instance {-# OVERLAPPING #-}
         HasVkEnabledLayerCount VkDeviceCreateInfo where
        type VkEnabledLayerCountMType VkDeviceCreateInfo = Data.Word.Word32

        {-# NOINLINE vkEnabledLayerCount #-}
        vkEnabledLayerCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceCreateInfo, enabledLayerCount})

        {-# INLINE vkEnabledLayerCountByteOffset #-}
        vkEnabledLayerCountByteOffset ~_
          = #{offset VkDeviceCreateInfo, enabledLayerCount}

        {-# INLINE readVkEnabledLayerCount #-}
        readVkEnabledLayerCount p
          = peekByteOff p
              #{offset VkDeviceCreateInfo, enabledLayerCount}

        {-# INLINE writeVkEnabledLayerCount #-}
        writeVkEnabledLayerCount p
          = pokeByteOff p
              #{offset VkDeviceCreateInfo, enabledLayerCount}

class HasVkPpEnabledLayerNames a where
        type VkPpEnabledLayerNamesMType a :: *

        vkPpEnabledLayerNames :: a -> VkPpEnabledLayerNamesMType a

        vkPpEnabledLayerNamesByteOffset :: a -> Int

        readVkPpEnabledLayerNames ::
                                  Ptr a -> IO (VkPpEnabledLayerNamesMType a)

        writeVkPpEnabledLayerNames ::
                                   Ptr a -> VkPpEnabledLayerNamesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'ppEnabledLayerNames'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPpEnabledLayerNames a

instance {-# OVERLAPPING #-}
         HasVkPpEnabledLayerNames VkDeviceCreateInfo where
        type VkPpEnabledLayerNamesMType VkDeviceCreateInfo =
             Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)

        {-# NOINLINE vkPpEnabledLayerNames #-}
        vkPpEnabledLayerNames x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceCreateInfo, ppEnabledLayerNames})

        {-# INLINE vkPpEnabledLayerNamesByteOffset #-}
        vkPpEnabledLayerNamesByteOffset ~_
          = #{offset VkDeviceCreateInfo, ppEnabledLayerNames}

        {-# INLINE readVkPpEnabledLayerNames #-}
        readVkPpEnabledLayerNames p
          = peekByteOff p
              #{offset VkDeviceCreateInfo, ppEnabledLayerNames}

        {-# INLINE writeVkPpEnabledLayerNames #-}
        writeVkPpEnabledLayerNames p
          = pokeByteOff p
              #{offset VkDeviceCreateInfo, ppEnabledLayerNames}

class HasVkEnabledExtensionCount a where
        type VkEnabledExtensionCountMType a :: *

        vkEnabledExtensionCount :: a -> VkEnabledExtensionCountMType a

        vkEnabledExtensionCountByteOffset :: a -> Int

        readVkEnabledExtensionCount ::
                                    Ptr a -> IO (VkEnabledExtensionCountMType a)

        writeVkEnabledExtensionCount ::
                                     Ptr a -> VkEnabledExtensionCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'enabledExtensionCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkEnabledExtensionCount a

instance {-# OVERLAPPING #-}
         HasVkEnabledExtensionCount VkDeviceCreateInfo where
        type VkEnabledExtensionCountMType VkDeviceCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkEnabledExtensionCount #-}
        vkEnabledExtensionCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceCreateInfo, enabledExtensionCount})

        {-# INLINE vkEnabledExtensionCountByteOffset #-}
        vkEnabledExtensionCountByteOffset ~_
          = #{offset VkDeviceCreateInfo, enabledExtensionCount}

        {-# INLINE readVkEnabledExtensionCount #-}
        readVkEnabledExtensionCount p
          = peekByteOff p
              #{offset VkDeviceCreateInfo, enabledExtensionCount}

        {-# INLINE writeVkEnabledExtensionCount #-}
        writeVkEnabledExtensionCount p
          = pokeByteOff p
              #{offset VkDeviceCreateInfo, enabledExtensionCount}

class HasVkPpEnabledExtensionNames a where
        type VkPpEnabledExtensionNamesMType a :: *

        vkPpEnabledExtensionNames :: a -> VkPpEnabledExtensionNamesMType a

        vkPpEnabledExtensionNamesByteOffset :: a -> Int

        readVkPpEnabledExtensionNames ::
                                      Ptr a -> IO (VkPpEnabledExtensionNamesMType a)

        writeVkPpEnabledExtensionNames ::
                                       Ptr a -> VkPpEnabledExtensionNamesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'ppEnabledExtensionNames'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPpEnabledExtensionNames a

instance {-# OVERLAPPING #-}
         HasVkPpEnabledExtensionNames VkDeviceCreateInfo where
        type VkPpEnabledExtensionNamesMType VkDeviceCreateInfo =
             Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)

        {-# NOINLINE vkPpEnabledExtensionNames #-}
        vkPpEnabledExtensionNames x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceCreateInfo, ppEnabledExtensionNames})

        {-# INLINE vkPpEnabledExtensionNamesByteOffset #-}
        vkPpEnabledExtensionNamesByteOffset ~_
          = #{offset VkDeviceCreateInfo, ppEnabledExtensionNames}

        {-# INLINE readVkPpEnabledExtensionNames #-}
        readVkPpEnabledExtensionNames p
          = peekByteOff p
              #{offset VkDeviceCreateInfo, ppEnabledExtensionNames}

        {-# INLINE writeVkPpEnabledExtensionNames #-}
        writeVkPpEnabledExtensionNames p
          = pokeByteOff p
              #{offset VkDeviceCreateInfo, ppEnabledExtensionNames}

class HasVkPEnabledFeatures a where
        type VkPEnabledFeaturesMType a :: *

        vkPEnabledFeatures :: a -> VkPEnabledFeaturesMType a

        vkPEnabledFeaturesByteOffset :: a -> Int

        readVkPEnabledFeatures :: Ptr a -> IO (VkPEnabledFeaturesMType a)

        writeVkPEnabledFeatures ::
                                Ptr a -> VkPEnabledFeaturesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pEnabledFeatures'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPEnabledFeatures a

instance {-# OVERLAPPING #-}
         HasVkPEnabledFeatures VkDeviceCreateInfo where
        type VkPEnabledFeaturesMType VkDeviceCreateInfo =
             Foreign.Ptr.Ptr VkPhysicalDeviceFeatures

        {-# NOINLINE vkPEnabledFeatures #-}
        vkPEnabledFeatures x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDeviceCreateInfo, pEnabledFeatures})

        {-# INLINE vkPEnabledFeaturesByteOffset #-}
        vkPEnabledFeaturesByteOffset ~_
          = #{offset VkDeviceCreateInfo, pEnabledFeatures}

        {-# INLINE readVkPEnabledFeatures #-}
        readVkPEnabledFeatures p
          = peekByteOff p
              #{offset VkDeviceCreateInfo, pEnabledFeatures}

        {-# INLINE writeVkPEnabledFeatures #-}
        writeVkPEnabledFeatures p
          = pokeByteOff p
              #{offset VkDeviceCreateInfo, pEnabledFeatures}

instance Show VkDeviceCreateInfo where
        showsPrec d x
          = showString "VkDeviceCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkQueueCreateInfoCount = " .
                                  showsPrec d (vkQueueCreateInfoCount x) .
                                    showString ", " .
                                      showString "vkPQueueCreateInfos = " .
                                        showsPrec d (vkPQueueCreateInfos x) .
                                          showString ", " .
                                            showString "vkEnabledLayerCount = " .
                                              showsPrec d (vkEnabledLayerCount x) .
                                                showString ", " .
                                                  showString "vkPpEnabledLayerNames = " .
                                                    showsPrec d (vkPpEnabledLayerNames x) .
                                                      showString ", " .
                                                        showString "vkEnabledExtensionCount = " .
                                                          showsPrec d (vkEnabledExtensionCount x) .
                                                            showString ", " .
                                                              showString
                                                                "vkPpEnabledExtensionNames = "
                                                                .
                                                                showsPrec d
                                                                  (vkPpEnabledExtensionNames x)
                                                                  .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkPEnabledFeatures = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkPEnabledFeatures x)
                                                                        . showChar '}'

data VkInstanceCreateInfo = VkInstanceCreateInfo## ByteArray##

instance Eq VkInstanceCreateInfo where
        (VkInstanceCreateInfo## a) == (VkInstanceCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkInstanceCreateInfo where
        (VkInstanceCreateInfo## a) `compare` (VkInstanceCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkInstanceCreateInfo where
        sizeOf ~_ = #{size VkInstanceCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkInstanceCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkInstanceCreateInfo),
            I## a <- alignment (undefined :: VkInstanceCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkInstanceCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkInstanceCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkInstanceCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkInstanceCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkInstanceCreateInfo),
            I## a <- alignment (undefined :: VkInstanceCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkInstanceCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkInstanceCreateInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkInstanceCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkInstanceCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkInstanceCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkInstanceCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkInstanceCreateInfo where
        type VkSTypeMType VkInstanceCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkInstanceCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkInstanceCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkInstanceCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkInstanceCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkInstanceCreateInfo where
        type VkPNextMType VkInstanceCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkInstanceCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkInstanceCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkInstanceCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkInstanceCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkInstanceCreateInfo where
        type VkFlagsMType VkInstanceCreateInfo = VkInstanceCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkInstanceCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkInstanceCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkInstanceCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkInstanceCreateInfo, flags}

class HasVkPApplicationInfo a where
        type VkPApplicationInfoMType a :: *

        vkPApplicationInfo :: a -> VkPApplicationInfoMType a

        vkPApplicationInfoByteOffset :: a -> Int

        readVkPApplicationInfo :: Ptr a -> IO (VkPApplicationInfoMType a)

        writeVkPApplicationInfo ::
                                Ptr a -> VkPApplicationInfoMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pApplicationInfo'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPApplicationInfo a

instance {-# OVERLAPPING #-}
         HasVkPApplicationInfo VkInstanceCreateInfo where
        type VkPApplicationInfoMType VkInstanceCreateInfo =
             Foreign.Ptr.Ptr VkApplicationInfo

        {-# NOINLINE vkPApplicationInfo #-}
        vkPApplicationInfo x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkInstanceCreateInfo, pApplicationInfo})

        {-# INLINE vkPApplicationInfoByteOffset #-}
        vkPApplicationInfoByteOffset ~_
          = #{offset VkInstanceCreateInfo, pApplicationInfo}

        {-# INLINE readVkPApplicationInfo #-}
        readVkPApplicationInfo p
          = peekByteOff p
              #{offset VkInstanceCreateInfo, pApplicationInfo}

        {-# INLINE writeVkPApplicationInfo #-}
        writeVkPApplicationInfo p
          = pokeByteOff p
              #{offset VkInstanceCreateInfo, pApplicationInfo}

instance {-# OVERLAPPING #-}
         HasVkEnabledLayerCount VkInstanceCreateInfo where
        type VkEnabledLayerCountMType VkInstanceCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkEnabledLayerCount #-}
        vkEnabledLayerCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkInstanceCreateInfo, enabledLayerCount})

        {-# INLINE vkEnabledLayerCountByteOffset #-}
        vkEnabledLayerCountByteOffset ~_
          = #{offset VkInstanceCreateInfo, enabledLayerCount}

        {-# INLINE readVkEnabledLayerCount #-}
        readVkEnabledLayerCount p
          = peekByteOff p
              #{offset VkInstanceCreateInfo, enabledLayerCount}

        {-# INLINE writeVkEnabledLayerCount #-}
        writeVkEnabledLayerCount p
          = pokeByteOff p
              #{offset VkInstanceCreateInfo, enabledLayerCount}

instance {-# OVERLAPPING #-}
         HasVkPpEnabledLayerNames VkInstanceCreateInfo where
        type VkPpEnabledLayerNamesMType VkInstanceCreateInfo =
             Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)

        {-# NOINLINE vkPpEnabledLayerNames #-}
        vkPpEnabledLayerNames x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkInstanceCreateInfo, ppEnabledLayerNames})

        {-# INLINE vkPpEnabledLayerNamesByteOffset #-}
        vkPpEnabledLayerNamesByteOffset ~_
          = #{offset VkInstanceCreateInfo, ppEnabledLayerNames}

        {-# INLINE readVkPpEnabledLayerNames #-}
        readVkPpEnabledLayerNames p
          = peekByteOff p
              #{offset VkInstanceCreateInfo, ppEnabledLayerNames}

        {-# INLINE writeVkPpEnabledLayerNames #-}
        writeVkPpEnabledLayerNames p
          = pokeByteOff p
              #{offset VkInstanceCreateInfo, ppEnabledLayerNames}

instance {-# OVERLAPPING #-}
         HasVkEnabledExtensionCount VkInstanceCreateInfo where
        type VkEnabledExtensionCountMType VkInstanceCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkEnabledExtensionCount #-}
        vkEnabledExtensionCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkInstanceCreateInfo, enabledExtensionCount})

        {-# INLINE vkEnabledExtensionCountByteOffset #-}
        vkEnabledExtensionCountByteOffset ~_
          = #{offset VkInstanceCreateInfo, enabledExtensionCount}

        {-# INLINE readVkEnabledExtensionCount #-}
        readVkEnabledExtensionCount p
          = peekByteOff p
              #{offset VkInstanceCreateInfo, enabledExtensionCount}

        {-# INLINE writeVkEnabledExtensionCount #-}
        writeVkEnabledExtensionCount p
          = pokeByteOff p
              #{offset VkInstanceCreateInfo, enabledExtensionCount}

instance {-# OVERLAPPING #-}
         HasVkPpEnabledExtensionNames VkInstanceCreateInfo where
        type VkPpEnabledExtensionNamesMType VkInstanceCreateInfo =
             Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)

        {-# NOINLINE vkPpEnabledExtensionNames #-}
        vkPpEnabledExtensionNames x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkInstanceCreateInfo, ppEnabledExtensionNames})

        {-# INLINE vkPpEnabledExtensionNamesByteOffset #-}
        vkPpEnabledExtensionNamesByteOffset ~_
          = #{offset VkInstanceCreateInfo, ppEnabledExtensionNames}

        {-# INLINE readVkPpEnabledExtensionNames #-}
        readVkPpEnabledExtensionNames p
          = peekByteOff p
              #{offset VkInstanceCreateInfo, ppEnabledExtensionNames}

        {-# INLINE writeVkPpEnabledExtensionNames #-}
        writeVkPpEnabledExtensionNames p
          = pokeByteOff p
              #{offset VkInstanceCreateInfo, ppEnabledExtensionNames}

instance Show VkInstanceCreateInfo where
        showsPrec d x
          = showString "VkInstanceCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkPApplicationInfo = " .
                                  showsPrec d (vkPApplicationInfo x) .
                                    showString ", " .
                                      showString "vkEnabledLayerCount = " .
                                        showsPrec d (vkEnabledLayerCount x) .
                                          showString ", " .
                                            showString "vkPpEnabledLayerNames = " .
                                              showsPrec d (vkPpEnabledLayerNames x) .
                                                showString ", " .
                                                  showString "vkEnabledExtensionCount = " .
                                                    showsPrec d (vkEnabledExtensionCount x) .
                                                      showString ", " .
                                                        showString "vkPpEnabledExtensionNames = " .
                                                          showsPrec d (vkPpEnabledExtensionNames x)
                                                            . showChar '}'

data VkQueueFamilyProperties = VkQueueFamilyProperties## ByteArray##

instance Eq VkQueueFamilyProperties where
        (VkQueueFamilyProperties## a) == (VkQueueFamilyProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkQueueFamilyProperties where
        (VkQueueFamilyProperties## a) `compare` (VkQueueFamilyProperties## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkQueueFamilyProperties where
        sizeOf ~_ = #{size VkQueueFamilyProperties}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkQueueFamilyProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkQueueFamilyProperties),
            I## a <- alignment (undefined :: VkQueueFamilyProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkQueueFamilyProperties##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkQueueFamilyProperties## ba)
          | I## n <- sizeOf (undefined :: VkQueueFamilyProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkQueueFamilyProperties where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkQueueFamilyProperties),
            I## a <- alignment (undefined :: VkQueueFamilyProperties) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkQueueFamilyProperties##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkQueueFamilyProperties## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkQueueFamilyProperties##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkQueueFamilyProperties## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkQueueFamilyProperties## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkQueueFamilyProperties## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkQueueFlags a where
        type VkQueueFlagsMType a :: *

        vkQueueFlags :: a -> VkQueueFlagsMType a

        vkQueueFlagsByteOffset :: a -> Int

        readVkQueueFlags :: Ptr a -> IO (VkQueueFlagsMType a)

        writeVkQueueFlags :: Ptr a -> VkQueueFlagsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queueFlags'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueueFlags a

instance {-# OVERLAPPING #-}
         HasVkQueueFlags VkQueueFamilyProperties where
        type VkQueueFlagsMType VkQueueFamilyProperties = VkQueueFlags

        {-# NOINLINE vkQueueFlags #-}
        vkQueueFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkQueueFamilyProperties, queueFlags})

        {-# INLINE vkQueueFlagsByteOffset #-}
        vkQueueFlagsByteOffset ~_
          = #{offset VkQueueFamilyProperties, queueFlags}

        {-# INLINE readVkQueueFlags #-}
        readVkQueueFlags p
          = peekByteOff p
              #{offset VkQueueFamilyProperties, queueFlags}

        {-# INLINE writeVkQueueFlags #-}
        writeVkQueueFlags p
          = pokeByteOff p
              #{offset VkQueueFamilyProperties, queueFlags}

instance {-# OVERLAPPING #-}
         HasVkQueueCount VkQueueFamilyProperties where
        type VkQueueCountMType VkQueueFamilyProperties = Data.Word.Word32

        {-# NOINLINE vkQueueCount #-}
        vkQueueCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkQueueFamilyProperties, queueCount})

        {-# INLINE vkQueueCountByteOffset #-}
        vkQueueCountByteOffset ~_
          = #{offset VkQueueFamilyProperties, queueCount}

        {-# INLINE readVkQueueCount #-}
        readVkQueueCount p
          = peekByteOff p
              #{offset VkQueueFamilyProperties, queueCount}

        {-# INLINE writeVkQueueCount #-}
        writeVkQueueCount p
          = pokeByteOff p
              #{offset VkQueueFamilyProperties, queueCount}

class HasVkTimestampValidBits a where
        type VkTimestampValidBitsMType a :: *

        vkTimestampValidBits :: a -> VkTimestampValidBitsMType a

        vkTimestampValidBitsByteOffset :: a -> Int

        readVkTimestampValidBits ::
                                 Ptr a -> IO (VkTimestampValidBitsMType a)

        writeVkTimestampValidBits ::
                                  Ptr a -> VkTimestampValidBitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'timestampValidBits'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTimestampValidBits a

instance {-# OVERLAPPING #-}
         HasVkTimestampValidBits VkQueueFamilyProperties where
        type VkTimestampValidBitsMType VkQueueFamilyProperties =
             Data.Word.Word32

        {-# NOINLINE vkTimestampValidBits #-}
        vkTimestampValidBits x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkQueueFamilyProperties, timestampValidBits})

        {-# INLINE vkTimestampValidBitsByteOffset #-}
        vkTimestampValidBitsByteOffset ~_
          = #{offset VkQueueFamilyProperties, timestampValidBits}

        {-# INLINE readVkTimestampValidBits #-}
        readVkTimestampValidBits p
          = peekByteOff p
              #{offset VkQueueFamilyProperties, timestampValidBits}

        {-# INLINE writeVkTimestampValidBits #-}
        writeVkTimestampValidBits p
          = pokeByteOff p
              #{offset VkQueueFamilyProperties, timestampValidBits}

class HasVkMinImageTransferGranularity a where
        type VkMinImageTransferGranularityMType a :: *

        vkMinImageTransferGranularity ::
                                      a -> VkMinImageTransferGranularityMType a

        vkMinImageTransferGranularityByteOffset :: a -> Int

        readVkMinImageTransferGranularity ::
                                          Ptr a -> IO (VkMinImageTransferGranularityMType a)

        writeVkMinImageTransferGranularity ::
                                           Ptr a -> VkMinImageTransferGranularityMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minImageTransferGranularity'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinImageTransferGranularity a

instance {-# OVERLAPPING #-}
         HasVkMinImageTransferGranularity VkQueueFamilyProperties where
        type VkMinImageTransferGranularityMType VkQueueFamilyProperties =
             VkExtent3D

        {-# NOINLINE vkMinImageTransferGranularity #-}
        vkMinImageTransferGranularity x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkQueueFamilyProperties, minImageTransferGranularity})

        {-# INLINE vkMinImageTransferGranularityByteOffset #-}
        vkMinImageTransferGranularityByteOffset ~_
          = #{offset VkQueueFamilyProperties, minImageTransferGranularity}

        {-# INLINE readVkMinImageTransferGranularity #-}
        readVkMinImageTransferGranularity p
          = peekByteOff p
              #{offset VkQueueFamilyProperties, minImageTransferGranularity}

        {-# INLINE writeVkMinImageTransferGranularity #-}
        writeVkMinImageTransferGranularity p
          = pokeByteOff p
              #{offset VkQueueFamilyProperties, minImageTransferGranularity}

instance Show VkQueueFamilyProperties where
        showsPrec d x
          = showString "VkQueueFamilyProperties {" .
              showString "vkQueueFlags = " .
                showsPrec d (vkQueueFlags x) .
                  showString ", " .
                    showString "vkQueueCount = " .
                      showsPrec d (vkQueueCount x) .
                        showString ", " .
                          showString "vkTimestampValidBits = " .
                            showsPrec d (vkTimestampValidBits x) .
                              showString ", " .
                                showString "vkMinImageTransferGranularity = " .
                                  showsPrec d (vkMinImageTransferGranularity x) . showChar '}'

data VkPhysicalDeviceMemoryProperties = VkPhysicalDeviceMemoryProperties## ByteArray##

instance Eq VkPhysicalDeviceMemoryProperties where
        (VkPhysicalDeviceMemoryProperties## a) ==
          (VkPhysicalDeviceMemoryProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPhysicalDeviceMemoryProperties where
        (VkPhysicalDeviceMemoryProperties## a) `compare`
          (VkPhysicalDeviceMemoryProperties## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPhysicalDeviceMemoryProperties where
        sizeOf ~_ = #{size VkPhysicalDeviceMemoryProperties}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPhysicalDeviceMemoryProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceMemoryProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceMemoryProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPhysicalDeviceMemoryProperties##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPhysicalDeviceMemoryProperties## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceMemoryProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPhysicalDeviceMemoryProperties where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceMemoryProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceMemoryProperties) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPhysicalDeviceMemoryProperties##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPhysicalDeviceMemoryProperties## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkPhysicalDeviceMemoryProperties##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPhysicalDeviceMemoryProperties## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPhysicalDeviceMemoryProperties## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPhysicalDeviceMemoryProperties## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkMemoryTypeCount a where
        type VkMemoryTypeCountMType a :: *

        vkMemoryTypeCount :: a -> VkMemoryTypeCountMType a

        vkMemoryTypeCountByteOffset :: a -> Int

        readVkMemoryTypeCount :: Ptr a -> IO (VkMemoryTypeCountMType a)

        writeVkMemoryTypeCount ::
                               Ptr a -> VkMemoryTypeCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memoryTypeCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemoryTypeCount a

instance {-# OVERLAPPING #-}
         HasVkMemoryTypeCount VkPhysicalDeviceMemoryProperties where
        type VkMemoryTypeCountMType VkPhysicalDeviceMemoryProperties =
             Data.Word.Word32

        {-# NOINLINE vkMemoryTypeCount #-}
        vkMemoryTypeCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceMemoryProperties, memoryTypeCount})

        {-# INLINE vkMemoryTypeCountByteOffset #-}
        vkMemoryTypeCountByteOffset ~_
          = #{offset VkPhysicalDeviceMemoryProperties, memoryTypeCount}

        {-# INLINE readVkMemoryTypeCount #-}
        readVkMemoryTypeCount p
          = peekByteOff p
              #{offset VkPhysicalDeviceMemoryProperties, memoryTypeCount}

        {-# INLINE writeVkMemoryTypeCount #-}
        writeVkMemoryTypeCount p
          = pokeByteOff p
              #{offset VkPhysicalDeviceMemoryProperties, memoryTypeCount}

class HasVkMemoryTypesArray a where
        type VkMemoryTypesArrayMType a :: *

        vkMemoryTypesArray :: a -> Int -> VkMemoryTypesArrayMType a

        vkMemoryTypesArrayByteOffset :: a -> Int

        readVkMemoryTypesArray ::
                               Ptr a -> Int -> IO (VkMemoryTypesArrayMType a)

        writeVkMemoryTypesArray ::
                                Ptr a -> Int -> VkMemoryTypesArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memoryTypes'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemoryTypesArray a

instance {-# OVERLAPPING #-}
         HasVkMemoryTypesArray VkPhysicalDeviceMemoryProperties where
        type VkMemoryTypesArrayMType VkPhysicalDeviceMemoryProperties =
             VkMemoryType

        {-# NOINLINE vkMemoryTypesArray #-}
        vkMemoryTypesArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: VkMemoryType) +
                    #{offset VkPhysicalDeviceMemoryProperties, memoryTypes}))

        {-# INLINE vkMemoryTypesArrayByteOffset #-}
        vkMemoryTypesArrayByteOffset ~_
          = #{offset VkPhysicalDeviceMemoryProperties, memoryTypes}

        {-# INLINE readVkMemoryTypesArray #-}
        readVkMemoryTypesArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: VkMemoryType) +
                 #{offset VkPhysicalDeviceMemoryProperties, memoryTypes})

        {-# INLINE writeVkMemoryTypesArray #-}
        writeVkMemoryTypesArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: VkMemoryType) +
                 #{offset VkPhysicalDeviceMemoryProperties, memoryTypes})

class HasVkMemoryHeapCount a where
        type VkMemoryHeapCountMType a :: *

        vkMemoryHeapCount :: a -> VkMemoryHeapCountMType a

        vkMemoryHeapCountByteOffset :: a -> Int

        readVkMemoryHeapCount :: Ptr a -> IO (VkMemoryHeapCountMType a)

        writeVkMemoryHeapCount ::
                               Ptr a -> VkMemoryHeapCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memoryHeapCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemoryHeapCount a

instance {-# OVERLAPPING #-}
         HasVkMemoryHeapCount VkPhysicalDeviceMemoryProperties where
        type VkMemoryHeapCountMType VkPhysicalDeviceMemoryProperties =
             Data.Word.Word32

        {-# NOINLINE vkMemoryHeapCount #-}
        vkMemoryHeapCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceMemoryProperties, memoryHeapCount})

        {-# INLINE vkMemoryHeapCountByteOffset #-}
        vkMemoryHeapCountByteOffset ~_
          = #{offset VkPhysicalDeviceMemoryProperties, memoryHeapCount}

        {-# INLINE readVkMemoryHeapCount #-}
        readVkMemoryHeapCount p
          = peekByteOff p
              #{offset VkPhysicalDeviceMemoryProperties, memoryHeapCount}

        {-# INLINE writeVkMemoryHeapCount #-}
        writeVkMemoryHeapCount p
          = pokeByteOff p
              #{offset VkPhysicalDeviceMemoryProperties, memoryHeapCount}

class HasVkMemoryHeapsArray a where
        type VkMemoryHeapsArrayMType a :: *

        vkMemoryHeapsArray :: a -> Int -> VkMemoryHeapsArrayMType a

        vkMemoryHeapsArrayByteOffset :: a -> Int

        readVkMemoryHeapsArray ::
                               Ptr a -> Int -> IO (VkMemoryHeapsArrayMType a)

        writeVkMemoryHeapsArray ::
                                Ptr a -> Int -> VkMemoryHeapsArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memoryHeaps'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemoryHeapsArray a

instance {-# OVERLAPPING #-}
         HasVkMemoryHeapsArray VkPhysicalDeviceMemoryProperties where
        type VkMemoryHeapsArrayMType VkPhysicalDeviceMemoryProperties =
             VkMemoryHeap

        {-# NOINLINE vkMemoryHeapsArray #-}
        vkMemoryHeapsArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: VkMemoryHeap) +
                    #{offset VkPhysicalDeviceMemoryProperties, memoryHeaps}))

        {-# INLINE vkMemoryHeapsArrayByteOffset #-}
        vkMemoryHeapsArrayByteOffset ~_
          = #{offset VkPhysicalDeviceMemoryProperties, memoryHeaps}

        {-# INLINE readVkMemoryHeapsArray #-}
        readVkMemoryHeapsArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: VkMemoryHeap) +
                 #{offset VkPhysicalDeviceMemoryProperties, memoryHeaps})

        {-# INLINE writeVkMemoryHeapsArray #-}
        writeVkMemoryHeapsArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: VkMemoryHeap) +
                 #{offset VkPhysicalDeviceMemoryProperties, memoryHeaps})

instance Show VkPhysicalDeviceMemoryProperties where
        showsPrec d x
          = showString "VkPhysicalDeviceMemoryProperties {" .
              showString "vkMemoryTypeCount = " .
                showsPrec d (vkMemoryTypeCount x) .
                  showString ", " .
                    showString "vkMemoryTypesArray = [" .
                      showsPrec d (map (vkMemoryTypesArray x) [1 .. VK_MAX_MEMORY_TYPES])
                        .
                        showChar ']' .
                          showString ", " .
                            showString "vkMemoryHeapCount = " .
                              showsPrec d (vkMemoryHeapCount x) .
                                showString ", " .
                                  showString "vkMemoryHeapsArray = [" .
                                    showsPrec d
                                      (map (vkMemoryHeapsArray x) [1 .. VK_MAX_MEMORY_HEAPS])
                                      . showChar ']' . showChar '}'

data VkMemoryAllocateInfo = VkMemoryAllocateInfo## ByteArray##

instance Eq VkMemoryAllocateInfo where
        (VkMemoryAllocateInfo## a) == (VkMemoryAllocateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkMemoryAllocateInfo where
        (VkMemoryAllocateInfo## a) `compare` (VkMemoryAllocateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkMemoryAllocateInfo where
        sizeOf ~_ = #{size VkMemoryAllocateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkMemoryAllocateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkMemoryAllocateInfo),
            I## a <- alignment (undefined :: VkMemoryAllocateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkMemoryAllocateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkMemoryAllocateInfo## ba)
          | I## n <- sizeOf (undefined :: VkMemoryAllocateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkMemoryAllocateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkMemoryAllocateInfo),
            I## a <- alignment (undefined :: VkMemoryAllocateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkMemoryAllocateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkMemoryAllocateInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkMemoryAllocateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkMemoryAllocateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkMemoryAllocateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkMemoryAllocateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkMemoryAllocateInfo where
        type VkSTypeMType VkMemoryAllocateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkMemoryAllocateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkMemoryAllocateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkMemoryAllocateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkMemoryAllocateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkMemoryAllocateInfo where
        type VkPNextMType VkMemoryAllocateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkMemoryAllocateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkMemoryAllocateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkMemoryAllocateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkMemoryAllocateInfo, pNext}

class HasVkAllocationSize a where
        type VkAllocationSizeMType a :: *

        vkAllocationSize :: a -> VkAllocationSizeMType a

        vkAllocationSizeByteOffset :: a -> Int

        readVkAllocationSize :: Ptr a -> IO (VkAllocationSizeMType a)

        writeVkAllocationSize :: Ptr a -> VkAllocationSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'allocationSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAllocationSize a

instance {-# OVERLAPPING #-}
         HasVkAllocationSize VkMemoryAllocateInfo where
        type VkAllocationSizeMType VkMemoryAllocateInfo = VkDeviceSize

        {-# NOINLINE vkAllocationSize #-}
        vkAllocationSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkMemoryAllocateInfo, allocationSize})

        {-# INLINE vkAllocationSizeByteOffset #-}
        vkAllocationSizeByteOffset ~_
          = #{offset VkMemoryAllocateInfo, allocationSize}

        {-# INLINE readVkAllocationSize #-}
        readVkAllocationSize p
          = peekByteOff p
              #{offset VkMemoryAllocateInfo, allocationSize}

        {-# INLINE writeVkAllocationSize #-}
        writeVkAllocationSize p
          = pokeByteOff p
              #{offset VkMemoryAllocateInfo, allocationSize}

class HasVkMemoryTypeIndex a where
        type VkMemoryTypeIndexMType a :: *

        vkMemoryTypeIndex :: a -> VkMemoryTypeIndexMType a

        vkMemoryTypeIndexByteOffset :: a -> Int

        readVkMemoryTypeIndex :: Ptr a -> IO (VkMemoryTypeIndexMType a)

        writeVkMemoryTypeIndex ::
                               Ptr a -> VkMemoryTypeIndexMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memoryTypeIndex'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemoryTypeIndex a

instance {-# OVERLAPPING #-}
         HasVkMemoryTypeIndex VkMemoryAllocateInfo where
        type VkMemoryTypeIndexMType VkMemoryAllocateInfo = Data.Word.Word32

        {-# NOINLINE vkMemoryTypeIndex #-}
        vkMemoryTypeIndex x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkMemoryAllocateInfo, memoryTypeIndex})

        {-# INLINE vkMemoryTypeIndexByteOffset #-}
        vkMemoryTypeIndexByteOffset ~_
          = #{offset VkMemoryAllocateInfo, memoryTypeIndex}

        {-# INLINE readVkMemoryTypeIndex #-}
        readVkMemoryTypeIndex p
          = peekByteOff p
              #{offset VkMemoryAllocateInfo, memoryTypeIndex}

        {-# INLINE writeVkMemoryTypeIndex #-}
        writeVkMemoryTypeIndex p
          = pokeByteOff p
              #{offset VkMemoryAllocateInfo, memoryTypeIndex}

instance Show VkMemoryAllocateInfo where
        showsPrec d x
          = showString "VkMemoryAllocateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkAllocationSize = " .
                            showsPrec d (vkAllocationSize x) .
                              showString ", " .
                                showString "vkMemoryTypeIndex = " .
                                  showsPrec d (vkMemoryTypeIndex x) . showChar '}'

data VkMemoryRequirements = VkMemoryRequirements## ByteArray##

instance Eq VkMemoryRequirements where
        (VkMemoryRequirements## a) == (VkMemoryRequirements## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkMemoryRequirements where
        (VkMemoryRequirements## a) `compare` (VkMemoryRequirements## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkMemoryRequirements where
        sizeOf ~_ = #{size VkMemoryRequirements}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkMemoryRequirements}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkMemoryRequirements),
            I## a <- alignment (undefined :: VkMemoryRequirements) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkMemoryRequirements## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkMemoryRequirements## ba)
          | I## n <- sizeOf (undefined :: VkMemoryRequirements) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkMemoryRequirements where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkMemoryRequirements),
            I## a <- alignment (undefined :: VkMemoryRequirements) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkMemoryRequirements##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkMemoryRequirements## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkMemoryRequirements##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkMemoryRequirements## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkMemoryRequirements## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkMemoryRequirements## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkSize a where
        type VkSizeMType a :: *

        vkSize :: a -> VkSizeMType a

        vkSizeByteOffset :: a -> Int

        readVkSize :: Ptr a -> IO (VkSizeMType a)

        writeVkSize :: Ptr a -> VkSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'size'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSize a

instance {-# OVERLAPPING #-} HasVkSize VkMemoryRequirements where
        type VkSizeMType VkMemoryRequirements = VkDeviceSize

        {-# NOINLINE vkSize #-}
        vkSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkMemoryRequirements, size})

        {-# INLINE vkSizeByteOffset #-}
        vkSizeByteOffset ~_ = #{offset VkMemoryRequirements, size}

        {-# INLINE readVkSize #-}
        readVkSize p
          = peekByteOff p #{offset VkMemoryRequirements, size}

        {-# INLINE writeVkSize #-}
        writeVkSize p
          = pokeByteOff p #{offset VkMemoryRequirements, size}

class HasVkAlignment a where
        type VkAlignmentMType a :: *

        vkAlignment :: a -> VkAlignmentMType a

        vkAlignmentByteOffset :: a -> Int

        readVkAlignment :: Ptr a -> IO (VkAlignmentMType a)

        writeVkAlignment :: Ptr a -> VkAlignmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'alignment'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAlignment a

instance {-# OVERLAPPING #-} HasVkAlignment VkMemoryRequirements
         where
        type VkAlignmentMType VkMemoryRequirements = VkDeviceSize

        {-# NOINLINE vkAlignment #-}
        vkAlignment x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkMemoryRequirements, alignment})

        {-# INLINE vkAlignmentByteOffset #-}
        vkAlignmentByteOffset ~_
          = #{offset VkMemoryRequirements, alignment}

        {-# INLINE readVkAlignment #-}
        readVkAlignment p
          = peekByteOff p #{offset VkMemoryRequirements, alignment}

        {-# INLINE writeVkAlignment #-}
        writeVkAlignment p
          = pokeByteOff p #{offset VkMemoryRequirements, alignment}

class HasVkMemoryTypeBits a where
        type VkMemoryTypeBitsMType a :: *

        vkMemoryTypeBits :: a -> VkMemoryTypeBitsMType a

        vkMemoryTypeBitsByteOffset :: a -> Int

        readVkMemoryTypeBits :: Ptr a -> IO (VkMemoryTypeBitsMType a)

        writeVkMemoryTypeBits :: Ptr a -> VkMemoryTypeBitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memoryTypeBits'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemoryTypeBits a

instance {-# OVERLAPPING #-}
         HasVkMemoryTypeBits VkMemoryRequirements where
        type VkMemoryTypeBitsMType VkMemoryRequirements = Data.Word.Word32

        {-# NOINLINE vkMemoryTypeBits #-}
        vkMemoryTypeBits x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkMemoryRequirements, memoryTypeBits})

        {-# INLINE vkMemoryTypeBitsByteOffset #-}
        vkMemoryTypeBitsByteOffset ~_
          = #{offset VkMemoryRequirements, memoryTypeBits}

        {-# INLINE readVkMemoryTypeBits #-}
        readVkMemoryTypeBits p
          = peekByteOff p
              #{offset VkMemoryRequirements, memoryTypeBits}

        {-# INLINE writeVkMemoryTypeBits #-}
        writeVkMemoryTypeBits p
          = pokeByteOff p
              #{offset VkMemoryRequirements, memoryTypeBits}

instance Show VkMemoryRequirements where
        showsPrec d x
          = showString "VkMemoryRequirements {" .
              showString "vkSize = " .
                showsPrec d (vkSize x) .
                  showString ", " .
                    showString "vkAlignment = " .
                      showsPrec d (vkAlignment x) .
                        showString ", " .
                          showString "vkMemoryTypeBits = " .
                            showsPrec d (vkMemoryTypeBits x) . showChar '}'

data VkSparseImageFormatProperties = VkSparseImageFormatProperties## ByteArray##

instance Eq VkSparseImageFormatProperties where
        (VkSparseImageFormatProperties## a) ==
          (VkSparseImageFormatProperties## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSparseImageFormatProperties where
        (VkSparseImageFormatProperties## a) `compare`
          (VkSparseImageFormatProperties## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSparseImageFormatProperties where
        sizeOf ~_ = #{size VkSparseImageFormatProperties}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSparseImageFormatProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSparseImageFormatProperties),
            I## a <- alignment (undefined :: VkSparseImageFormatProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSparseImageFormatProperties##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSparseImageFormatProperties## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageFormatProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSparseImageFormatProperties where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSparseImageFormatProperties),
            I## a <- alignment (undefined :: VkSparseImageFormatProperties) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSparseImageFormatProperties##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSparseImageFormatProperties## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSparseImageFormatProperties##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSparseImageFormatProperties## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSparseImageFormatProperties## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSparseImageFormatProperties## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkAspectMask a where
        type VkAspectMaskMType a :: *

        vkAspectMask :: a -> VkAspectMaskMType a

        vkAspectMaskByteOffset :: a -> Int

        readVkAspectMask :: Ptr a -> IO (VkAspectMaskMType a)

        writeVkAspectMask :: Ptr a -> VkAspectMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'aspectMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAspectMask a

instance {-# OVERLAPPING #-}
         HasVkAspectMask VkSparseImageFormatProperties where
        type VkAspectMaskMType VkSparseImageFormatProperties =
             VkImageAspectFlags

        {-# NOINLINE vkAspectMask #-}
        vkAspectMask x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageFormatProperties, aspectMask})

        {-# INLINE vkAspectMaskByteOffset #-}
        vkAspectMaskByteOffset ~_
          = #{offset VkSparseImageFormatProperties, aspectMask}

        {-# INLINE readVkAspectMask #-}
        readVkAspectMask p
          = peekByteOff p
              #{offset VkSparseImageFormatProperties, aspectMask}

        {-# INLINE writeVkAspectMask #-}
        writeVkAspectMask p
          = pokeByteOff p
              #{offset VkSparseImageFormatProperties, aspectMask}

class HasVkImageGranularity a where
        type VkImageGranularityMType a :: *

        vkImageGranularity :: a -> VkImageGranularityMType a

        vkImageGranularityByteOffset :: a -> Int

        readVkImageGranularity :: Ptr a -> IO (VkImageGranularityMType a)

        writeVkImageGranularity ::
                                Ptr a -> VkImageGranularityMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageGranularity'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageGranularity a

instance {-# OVERLAPPING #-}
         HasVkImageGranularity VkSparseImageFormatProperties where
        type VkImageGranularityMType VkSparseImageFormatProperties =
             VkExtent3D

        {-# NOINLINE vkImageGranularity #-}
        vkImageGranularity x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageFormatProperties, imageGranularity})

        {-# INLINE vkImageGranularityByteOffset #-}
        vkImageGranularityByteOffset ~_
          = #{offset VkSparseImageFormatProperties, imageGranularity}

        {-# INLINE readVkImageGranularity #-}
        readVkImageGranularity p
          = peekByteOff p
              #{offset VkSparseImageFormatProperties, imageGranularity}

        {-# INLINE writeVkImageGranularity #-}
        writeVkImageGranularity p
          = pokeByteOff p
              #{offset VkSparseImageFormatProperties, imageGranularity}

instance {-# OVERLAPPING #-}
         HasVkFlags VkSparseImageFormatProperties where
        type VkFlagsMType VkSparseImageFormatProperties =
             VkSparseImageFormatFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageFormatProperties, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkSparseImageFormatProperties, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkSparseImageFormatProperties, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkSparseImageFormatProperties, flags}

instance Show VkSparseImageFormatProperties where
        showsPrec d x
          = showString "VkSparseImageFormatProperties {" .
              showString "vkAspectMask = " .
                showsPrec d (vkAspectMask x) .
                  showString ", " .
                    showString "vkImageGranularity = " .
                      showsPrec d (vkImageGranularity x) .
                        showString ", " .
                          showString "vkFlags = " . showsPrec d (vkFlags x) . showChar '}'

data VkSparseImageMemoryRequirements = VkSparseImageMemoryRequirements## ByteArray##

instance Eq VkSparseImageMemoryRequirements where
        (VkSparseImageMemoryRequirements## a) ==
          (VkSparseImageMemoryRequirements## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSparseImageMemoryRequirements where
        (VkSparseImageMemoryRequirements## a) `compare`
          (VkSparseImageMemoryRequirements## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSparseImageMemoryRequirements where
        sizeOf ~_ = #{size VkSparseImageMemoryRequirements}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSparseImageMemoryRequirements}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryRequirements),
            I## a <- alignment (undefined :: VkSparseImageMemoryRequirements) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSparseImageMemoryRequirements##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSparseImageMemoryRequirements## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryRequirements) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSparseImageMemoryRequirements where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryRequirements),
            I## a <- alignment (undefined :: VkSparseImageMemoryRequirements) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSparseImageMemoryRequirements##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSparseImageMemoryRequirements## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSparseImageMemoryRequirements##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSparseImageMemoryRequirements## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSparseImageMemoryRequirements## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSparseImageMemoryRequirements## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkFormatProperties a where
        type VkFormatPropertiesMType a :: *

        vkFormatProperties :: a -> VkFormatPropertiesMType a

        vkFormatPropertiesByteOffset :: a -> Int

        readVkFormatProperties :: Ptr a -> IO (VkFormatPropertiesMType a)

        writeVkFormatProperties ::
                                Ptr a -> VkFormatPropertiesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'formatProperties'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFormatProperties a

instance {-# OVERLAPPING #-}
         HasVkFormatProperties VkSparseImageMemoryRequirements where
        type VkFormatPropertiesMType VkSparseImageMemoryRequirements =
             VkSparseImageFormatProperties

        {-# NOINLINE vkFormatProperties #-}
        vkFormatProperties x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageMemoryRequirements, formatProperties})

        {-# INLINE vkFormatPropertiesByteOffset #-}
        vkFormatPropertiesByteOffset ~_
          = #{offset VkSparseImageMemoryRequirements, formatProperties}

        {-# INLINE readVkFormatProperties #-}
        readVkFormatProperties p
          = peekByteOff p
              #{offset VkSparseImageMemoryRequirements, formatProperties}

        {-# INLINE writeVkFormatProperties #-}
        writeVkFormatProperties p
          = pokeByteOff p
              #{offset VkSparseImageMemoryRequirements, formatProperties}

class HasVkImageMipTailFirstLod a where
        type VkImageMipTailFirstLodMType a :: *

        vkImageMipTailFirstLod :: a -> VkImageMipTailFirstLodMType a

        vkImageMipTailFirstLodByteOffset :: a -> Int

        readVkImageMipTailFirstLod ::
                                   Ptr a -> IO (VkImageMipTailFirstLodMType a)

        writeVkImageMipTailFirstLod ::
                                    Ptr a -> VkImageMipTailFirstLodMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageMipTailFirstLod'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageMipTailFirstLod a

instance {-# OVERLAPPING #-}
         HasVkImageMipTailFirstLod VkSparseImageMemoryRequirements where
        type VkImageMipTailFirstLodMType VkSparseImageMemoryRequirements =
             Data.Word.Word32

        {-# NOINLINE vkImageMipTailFirstLod #-}
        vkImageMipTailFirstLod x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageMemoryRequirements, imageMipTailFirstLod})

        {-# INLINE vkImageMipTailFirstLodByteOffset #-}
        vkImageMipTailFirstLodByteOffset ~_
          = #{offset VkSparseImageMemoryRequirements, imageMipTailFirstLod}

        {-# INLINE readVkImageMipTailFirstLod #-}
        readVkImageMipTailFirstLod p
          = peekByteOff p
              #{offset VkSparseImageMemoryRequirements, imageMipTailFirstLod}

        {-# INLINE writeVkImageMipTailFirstLod #-}
        writeVkImageMipTailFirstLod p
          = pokeByteOff p
              #{offset VkSparseImageMemoryRequirements, imageMipTailFirstLod}

class HasVkImageMipTailSize a where
        type VkImageMipTailSizeMType a :: *

        vkImageMipTailSize :: a -> VkImageMipTailSizeMType a

        vkImageMipTailSizeByteOffset :: a -> Int

        readVkImageMipTailSize :: Ptr a -> IO (VkImageMipTailSizeMType a)

        writeVkImageMipTailSize ::
                                Ptr a -> VkImageMipTailSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageMipTailSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageMipTailSize a

instance {-# OVERLAPPING #-}
         HasVkImageMipTailSize VkSparseImageMemoryRequirements where
        type VkImageMipTailSizeMType VkSparseImageMemoryRequirements =
             VkDeviceSize

        {-# NOINLINE vkImageMipTailSize #-}
        vkImageMipTailSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageMemoryRequirements, imageMipTailSize})

        {-# INLINE vkImageMipTailSizeByteOffset #-}
        vkImageMipTailSizeByteOffset ~_
          = #{offset VkSparseImageMemoryRequirements, imageMipTailSize}

        {-# INLINE readVkImageMipTailSize #-}
        readVkImageMipTailSize p
          = peekByteOff p
              #{offset VkSparseImageMemoryRequirements, imageMipTailSize}

        {-# INLINE writeVkImageMipTailSize #-}
        writeVkImageMipTailSize p
          = pokeByteOff p
              #{offset VkSparseImageMemoryRequirements, imageMipTailSize}

class HasVkImageMipTailOffset a where
        type VkImageMipTailOffsetMType a :: *

        vkImageMipTailOffset :: a -> VkImageMipTailOffsetMType a

        vkImageMipTailOffsetByteOffset :: a -> Int

        readVkImageMipTailOffset ::
                                 Ptr a -> IO (VkImageMipTailOffsetMType a)

        writeVkImageMipTailOffset ::
                                  Ptr a -> VkImageMipTailOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageMipTailOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageMipTailOffset a

instance {-# OVERLAPPING #-}
         HasVkImageMipTailOffset VkSparseImageMemoryRequirements where
        type VkImageMipTailOffsetMType VkSparseImageMemoryRequirements =
             VkDeviceSize

        {-# NOINLINE vkImageMipTailOffset #-}
        vkImageMipTailOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageMemoryRequirements, imageMipTailOffset})

        {-# INLINE vkImageMipTailOffsetByteOffset #-}
        vkImageMipTailOffsetByteOffset ~_
          = #{offset VkSparseImageMemoryRequirements, imageMipTailOffset}

        {-# INLINE readVkImageMipTailOffset #-}
        readVkImageMipTailOffset p
          = peekByteOff p
              #{offset VkSparseImageMemoryRequirements, imageMipTailOffset}

        {-# INLINE writeVkImageMipTailOffset #-}
        writeVkImageMipTailOffset p
          = pokeByteOff p
              #{offset VkSparseImageMemoryRequirements, imageMipTailOffset}

class HasVkImageMipTailStride a where
        type VkImageMipTailStrideMType a :: *

        vkImageMipTailStride :: a -> VkImageMipTailStrideMType a

        vkImageMipTailStrideByteOffset :: a -> Int

        readVkImageMipTailStride ::
                                 Ptr a -> IO (VkImageMipTailStrideMType a)

        writeVkImageMipTailStride ::
                                  Ptr a -> VkImageMipTailStrideMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageMipTailStride'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageMipTailStride a

instance {-# OVERLAPPING #-}
         HasVkImageMipTailStride VkSparseImageMemoryRequirements where
        type VkImageMipTailStrideMType VkSparseImageMemoryRequirements =
             VkDeviceSize

        {-# NOINLINE vkImageMipTailStride #-}
        vkImageMipTailStride x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageMemoryRequirements, imageMipTailStride})

        {-# INLINE vkImageMipTailStrideByteOffset #-}
        vkImageMipTailStrideByteOffset ~_
          = #{offset VkSparseImageMemoryRequirements, imageMipTailStride}

        {-# INLINE readVkImageMipTailStride #-}
        readVkImageMipTailStride p
          = peekByteOff p
              #{offset VkSparseImageMemoryRequirements, imageMipTailStride}

        {-# INLINE writeVkImageMipTailStride #-}
        writeVkImageMipTailStride p
          = pokeByteOff p
              #{offset VkSparseImageMemoryRequirements, imageMipTailStride}

instance Show VkSparseImageMemoryRequirements where
        showsPrec d x
          = showString "VkSparseImageMemoryRequirements {" .
              showString "vkFormatProperties = " .
                showsPrec d (vkFormatProperties x) .
                  showString ", " .
                    showString "vkImageMipTailFirstLod = " .
                      showsPrec d (vkImageMipTailFirstLod x) .
                        showString ", " .
                          showString "vkImageMipTailSize = " .
                            showsPrec d (vkImageMipTailSize x) .
                              showString ", " .
                                showString "vkImageMipTailOffset = " .
                                  showsPrec d (vkImageMipTailOffset x) .
                                    showString ", " .
                                      showString "vkImageMipTailStride = " .
                                        showsPrec d (vkImageMipTailStride x) . showChar '}'

data VkMemoryType = VkMemoryType## ByteArray##

instance Eq VkMemoryType where
        (VkMemoryType## a) == (VkMemoryType## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkMemoryType where
        (VkMemoryType## a) `compare` (VkMemoryType## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkMemoryType where
        sizeOf ~_ = #{size VkMemoryType}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkMemoryType}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkMemoryType),
            I## a <- alignment (undefined :: VkMemoryType) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkMemoryType## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkMemoryType## ba)
          | I## n <- sizeOf (undefined :: VkMemoryType) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkMemoryType where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkMemoryType),
            I## a <- alignment (undefined :: VkMemoryType) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkMemoryType##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkMemoryType## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkMemoryType##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkMemoryType## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkMemoryType## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkMemoryType## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkPropertyFlags a where
        type VkPropertyFlagsMType a :: *

        vkPropertyFlags :: a -> VkPropertyFlagsMType a

        vkPropertyFlagsByteOffset :: a -> Int

        readVkPropertyFlags :: Ptr a -> IO (VkPropertyFlagsMType a)

        writeVkPropertyFlags :: Ptr a -> VkPropertyFlagsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'propertyFlags'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPropertyFlags a

instance {-# OVERLAPPING #-} HasVkPropertyFlags VkMemoryType where
        type VkPropertyFlagsMType VkMemoryType = VkMemoryPropertyFlags

        {-# NOINLINE vkPropertyFlags #-}
        vkPropertyFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkMemoryType, propertyFlags})

        {-# INLINE vkPropertyFlagsByteOffset #-}
        vkPropertyFlagsByteOffset ~_
          = #{offset VkMemoryType, propertyFlags}

        {-# INLINE readVkPropertyFlags #-}
        readVkPropertyFlags p
          = peekByteOff p #{offset VkMemoryType, propertyFlags}

        {-# INLINE writeVkPropertyFlags #-}
        writeVkPropertyFlags p
          = pokeByteOff p #{offset VkMemoryType, propertyFlags}

class HasVkHeapIndex a where
        type VkHeapIndexMType a :: *

        vkHeapIndex :: a -> VkHeapIndexMType a

        vkHeapIndexByteOffset :: a -> Int

        readVkHeapIndex :: Ptr a -> IO (VkHeapIndexMType a)

        writeVkHeapIndex :: Ptr a -> VkHeapIndexMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'heapIndex'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkHeapIndex a

instance {-# OVERLAPPING #-} HasVkHeapIndex VkMemoryType where
        type VkHeapIndexMType VkMemoryType = Data.Word.Word32

        {-# NOINLINE vkHeapIndex #-}
        vkHeapIndex x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkMemoryType, heapIndex})

        {-# INLINE vkHeapIndexByteOffset #-}
        vkHeapIndexByteOffset ~_
          = #{offset VkMemoryType, heapIndex}

        {-# INLINE readVkHeapIndex #-}
        readVkHeapIndex p
          = peekByteOff p #{offset VkMemoryType, heapIndex}

        {-# INLINE writeVkHeapIndex #-}
        writeVkHeapIndex p
          = pokeByteOff p #{offset VkMemoryType, heapIndex}

instance Show VkMemoryType where
        showsPrec d x
          = showString "VkMemoryType {" .
              showString "vkPropertyFlags = " .
                showsPrec d (vkPropertyFlags x) .
                  showString ", " .
                    showString "vkHeapIndex = " .
                      showsPrec d (vkHeapIndex x) . showChar '}'

data VkMemoryHeap = VkMemoryHeap## ByteArray##

instance Eq VkMemoryHeap where
        (VkMemoryHeap## a) == (VkMemoryHeap## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkMemoryHeap where
        (VkMemoryHeap## a) `compare` (VkMemoryHeap## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkMemoryHeap where
        sizeOf ~_ = #{size VkMemoryHeap}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkMemoryHeap}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkMemoryHeap),
            I## a <- alignment (undefined :: VkMemoryHeap) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkMemoryHeap## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkMemoryHeap## ba)
          | I## n <- sizeOf (undefined :: VkMemoryHeap) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkMemoryHeap where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkMemoryHeap),
            I## a <- alignment (undefined :: VkMemoryHeap) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkMemoryHeap##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkMemoryHeap## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkMemoryHeap##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkMemoryHeap## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkMemoryHeap## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkMemoryHeap## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSize VkMemoryHeap where
        type VkSizeMType VkMemoryHeap = VkDeviceSize

        {-# NOINLINE vkSize #-}
        vkSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkMemoryHeap, size})

        {-# INLINE vkSizeByteOffset #-}
        vkSizeByteOffset ~_ = #{offset VkMemoryHeap, size}

        {-# INLINE readVkSize #-}
        readVkSize p = peekByteOff p #{offset VkMemoryHeap, size}

        {-# INLINE writeVkSize #-}
        writeVkSize p = pokeByteOff p #{offset VkMemoryHeap, size}

instance {-# OVERLAPPING #-} HasVkFlags VkMemoryHeap where
        type VkFlagsMType VkMemoryHeap = VkMemoryHeapFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkMemoryHeap, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_ = #{offset VkMemoryHeap, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkMemoryHeap, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkMemoryHeap, flags}

instance Show VkMemoryHeap where
        showsPrec d x
          = showString "VkMemoryHeap {" .
              showString "vkSize = " .
                showsPrec d (vkSize x) .
                  showString ", " .
                    showString "vkFlags = " . showsPrec d (vkFlags x) . showChar '}'

data VkMappedMemoryRange = VkMappedMemoryRange## ByteArray##

instance Eq VkMappedMemoryRange where
        (VkMappedMemoryRange## a) == (VkMappedMemoryRange## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkMappedMemoryRange where
        (VkMappedMemoryRange## a) `compare` (VkMappedMemoryRange## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkMappedMemoryRange where
        sizeOf ~_ = #{size VkMappedMemoryRange}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkMappedMemoryRange}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkMappedMemoryRange),
            I## a <- alignment (undefined :: VkMappedMemoryRange) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkMappedMemoryRange## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkMappedMemoryRange## ba)
          | I## n <- sizeOf (undefined :: VkMappedMemoryRange) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkMappedMemoryRange where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkMappedMemoryRange),
            I## a <- alignment (undefined :: VkMappedMemoryRange) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkMappedMemoryRange##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkMappedMemoryRange## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkMappedMemoryRange##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkMappedMemoryRange## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkMappedMemoryRange## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkMappedMemoryRange## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkMappedMemoryRange where
        type VkSTypeMType VkMappedMemoryRange = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkMappedMemoryRange, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkMappedMemoryRange, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkMappedMemoryRange, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkMappedMemoryRange, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkMappedMemoryRange where
        type VkPNextMType VkMappedMemoryRange =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkMappedMemoryRange, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkMappedMemoryRange, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkMappedMemoryRange, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkMappedMemoryRange, pNext}

class HasVkMemory a where
        type VkMemoryMType a :: *

        vkMemory :: a -> VkMemoryMType a

        vkMemoryByteOffset :: a -> Int

        readVkMemory :: Ptr a -> IO (VkMemoryMType a)

        writeVkMemory :: Ptr a -> VkMemoryMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memory'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemory a

instance {-# OVERLAPPING #-} HasVkMemory VkMappedMemoryRange where
        type VkMemoryMType VkMappedMemoryRange = VkDeviceMemory

        {-# NOINLINE vkMemory #-}
        vkMemory x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkMappedMemoryRange, memory})

        {-# INLINE vkMemoryByteOffset #-}
        vkMemoryByteOffset ~_
          = #{offset VkMappedMemoryRange, memory}

        {-# INLINE readVkMemory #-}
        readVkMemory p
          = peekByteOff p #{offset VkMappedMemoryRange, memory}

        {-# INLINE writeVkMemory #-}
        writeVkMemory p
          = pokeByteOff p #{offset VkMappedMemoryRange, memory}

instance {-# OVERLAPPING #-} HasVkOffset VkMappedMemoryRange where
        type VkOffsetMType VkMappedMemoryRange = VkDeviceSize

        {-# NOINLINE vkOffset #-}
        vkOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkMappedMemoryRange, offset})

        {-# INLINE vkOffsetByteOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkMappedMemoryRange, offset}

        {-# INLINE readVkOffset #-}
        readVkOffset p
          = peekByteOff p #{offset VkMappedMemoryRange, offset}

        {-# INLINE writeVkOffset #-}
        writeVkOffset p
          = pokeByteOff p #{offset VkMappedMemoryRange, offset}

instance {-# OVERLAPPING #-} HasVkSize VkMappedMemoryRange where
        type VkSizeMType VkMappedMemoryRange = VkDeviceSize

        {-# NOINLINE vkSize #-}
        vkSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkMappedMemoryRange, size})

        {-# INLINE vkSizeByteOffset #-}
        vkSizeByteOffset ~_ = #{offset VkMappedMemoryRange, size}

        {-# INLINE readVkSize #-}
        readVkSize p
          = peekByteOff p #{offset VkMappedMemoryRange, size}

        {-# INLINE writeVkSize #-}
        writeVkSize p
          = pokeByteOff p #{offset VkMappedMemoryRange, size}

instance Show VkMappedMemoryRange where
        showsPrec d x
          = showString "VkMappedMemoryRange {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkMemory = " .
                            showsPrec d (vkMemory x) .
                              showString ", " .
                                showString "vkOffset = " .
                                  showsPrec d (vkOffset x) .
                                    showString ", " .
                                      showString "vkSize = " . showsPrec d (vkSize x) . showChar '}'

data VkFormatProperties = VkFormatProperties## ByteArray##

instance Eq VkFormatProperties where
        (VkFormatProperties## a) == (VkFormatProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkFormatProperties where
        (VkFormatProperties## a) `compare` (VkFormatProperties## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkFormatProperties where
        sizeOf ~_ = #{size VkFormatProperties}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkFormatProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkFormatProperties),
            I## a <- alignment (undefined :: VkFormatProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkFormatProperties## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkFormatProperties## ba)
          | I## n <- sizeOf (undefined :: VkFormatProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkFormatProperties where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkFormatProperties),
            I## a <- alignment (undefined :: VkFormatProperties) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkFormatProperties##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkFormatProperties## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkFormatProperties##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkFormatProperties## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkFormatProperties## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkFormatProperties## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkLinearTilingFeatures a where
        type VkLinearTilingFeaturesMType a :: *

        vkLinearTilingFeatures :: a -> VkLinearTilingFeaturesMType a

        vkLinearTilingFeaturesByteOffset :: a -> Int

        readVkLinearTilingFeatures ::
                                   Ptr a -> IO (VkLinearTilingFeaturesMType a)

        writeVkLinearTilingFeatures ::
                                    Ptr a -> VkLinearTilingFeaturesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'linearTilingFeatures'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLinearTilingFeatures a

instance {-# OVERLAPPING #-}
         HasVkLinearTilingFeatures VkFormatProperties where
        type VkLinearTilingFeaturesMType VkFormatProperties =
             VkFormatFeatureFlags

        {-# NOINLINE vkLinearTilingFeatures #-}
        vkLinearTilingFeatures x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFormatProperties, linearTilingFeatures})

        {-# INLINE vkLinearTilingFeaturesByteOffset #-}
        vkLinearTilingFeaturesByteOffset ~_
          = #{offset VkFormatProperties, linearTilingFeatures}

        {-# INLINE readVkLinearTilingFeatures #-}
        readVkLinearTilingFeatures p
          = peekByteOff p
              #{offset VkFormatProperties, linearTilingFeatures}

        {-# INLINE writeVkLinearTilingFeatures #-}
        writeVkLinearTilingFeatures p
          = pokeByteOff p
              #{offset VkFormatProperties, linearTilingFeatures}

class HasVkOptimalTilingFeatures a where
        type VkOptimalTilingFeaturesMType a :: *

        vkOptimalTilingFeatures :: a -> VkOptimalTilingFeaturesMType a

        vkOptimalTilingFeaturesByteOffset :: a -> Int

        readVkOptimalTilingFeatures ::
                                    Ptr a -> IO (VkOptimalTilingFeaturesMType a)

        writeVkOptimalTilingFeatures ::
                                     Ptr a -> VkOptimalTilingFeaturesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'optimalTilingFeatures'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkOptimalTilingFeatures a

instance {-# OVERLAPPING #-}
         HasVkOptimalTilingFeatures VkFormatProperties where
        type VkOptimalTilingFeaturesMType VkFormatProperties =
             VkFormatFeatureFlags

        {-# NOINLINE vkOptimalTilingFeatures #-}
        vkOptimalTilingFeatures x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFormatProperties, optimalTilingFeatures})

        {-# INLINE vkOptimalTilingFeaturesByteOffset #-}
        vkOptimalTilingFeaturesByteOffset ~_
          = #{offset VkFormatProperties, optimalTilingFeatures}

        {-# INLINE readVkOptimalTilingFeatures #-}
        readVkOptimalTilingFeatures p
          = peekByteOff p
              #{offset VkFormatProperties, optimalTilingFeatures}

        {-# INLINE writeVkOptimalTilingFeatures #-}
        writeVkOptimalTilingFeatures p
          = pokeByteOff p
              #{offset VkFormatProperties, optimalTilingFeatures}

class HasVkBufferFeatures a where
        type VkBufferFeaturesMType a :: *

        vkBufferFeatures :: a -> VkBufferFeaturesMType a

        vkBufferFeaturesByteOffset :: a -> Int

        readVkBufferFeatures :: Ptr a -> IO (VkBufferFeaturesMType a)

        writeVkBufferFeatures :: Ptr a -> VkBufferFeaturesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bufferFeatures'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBufferFeatures a

instance {-# OVERLAPPING #-} HasVkBufferFeatures VkFormatProperties
         where
        type VkBufferFeaturesMType VkFormatProperties =
             VkFormatFeatureFlags

        {-# NOINLINE vkBufferFeatures #-}
        vkBufferFeatures x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFormatProperties, bufferFeatures})

        {-# INLINE vkBufferFeaturesByteOffset #-}
        vkBufferFeaturesByteOffset ~_
          = #{offset VkFormatProperties, bufferFeatures}

        {-# INLINE readVkBufferFeatures #-}
        readVkBufferFeatures p
          = peekByteOff p
              #{offset VkFormatProperties, bufferFeatures}

        {-# INLINE writeVkBufferFeatures #-}
        writeVkBufferFeatures p
          = pokeByteOff p
              #{offset VkFormatProperties, bufferFeatures}

instance Show VkFormatProperties where
        showsPrec d x
          = showString "VkFormatProperties {" .
              showString "vkLinearTilingFeatures = " .
                showsPrec d (vkLinearTilingFeatures x) .
                  showString ", " .
                    showString "vkOptimalTilingFeatures = " .
                      showsPrec d (vkOptimalTilingFeatures x) .
                        showString ", " .
                          showString "vkBufferFeatures = " .
                            showsPrec d (vkBufferFeatures x) . showChar '}'

data VkImageFormatProperties = VkImageFormatProperties## ByteArray##

instance Eq VkImageFormatProperties where
        (VkImageFormatProperties## a) == (VkImageFormatProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageFormatProperties where
        (VkImageFormatProperties## a) `compare` (VkImageFormatProperties## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageFormatProperties where
        sizeOf ~_ = #{size VkImageFormatProperties}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageFormatProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageFormatProperties),
            I## a <- alignment (undefined :: VkImageFormatProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkImageFormatProperties##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageFormatProperties## ba)
          | I## n <- sizeOf (undefined :: VkImageFormatProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageFormatProperties where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkImageFormatProperties),
            I## a <- alignment (undefined :: VkImageFormatProperties) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkImageFormatProperties##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkImageFormatProperties## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkImageFormatProperties##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkImageFormatProperties## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkImageFormatProperties## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkImageFormatProperties## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkMaxExtent a where
        type VkMaxExtentMType a :: *

        vkMaxExtent :: a -> VkMaxExtentMType a

        vkMaxExtentByteOffset :: a -> Int

        readVkMaxExtent :: Ptr a -> IO (VkMaxExtentMType a)

        writeVkMaxExtent :: Ptr a -> VkMaxExtentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxExtent'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxExtent a

instance {-# OVERLAPPING #-} HasVkMaxExtent VkImageFormatProperties
         where
        type VkMaxExtentMType VkImageFormatProperties = VkExtent3D

        {-# NOINLINE vkMaxExtent #-}
        vkMaxExtent x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageFormatProperties, maxExtent})

        {-# INLINE vkMaxExtentByteOffset #-}
        vkMaxExtentByteOffset ~_
          = #{offset VkImageFormatProperties, maxExtent}

        {-# INLINE readVkMaxExtent #-}
        readVkMaxExtent p
          = peekByteOff p
              #{offset VkImageFormatProperties, maxExtent}

        {-# INLINE writeVkMaxExtent #-}
        writeVkMaxExtent p
          = pokeByteOff p
              #{offset VkImageFormatProperties, maxExtent}

class HasVkMaxMipLevels a where
        type VkMaxMipLevelsMType a :: *

        vkMaxMipLevels :: a -> VkMaxMipLevelsMType a

        vkMaxMipLevelsByteOffset :: a -> Int

        readVkMaxMipLevels :: Ptr a -> IO (VkMaxMipLevelsMType a)

        writeVkMaxMipLevels :: Ptr a -> VkMaxMipLevelsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxMipLevels'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxMipLevels a

instance {-# OVERLAPPING #-}
         HasVkMaxMipLevels VkImageFormatProperties where
        type VkMaxMipLevelsMType VkImageFormatProperties = Data.Word.Word32

        {-# NOINLINE vkMaxMipLevels #-}
        vkMaxMipLevels x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageFormatProperties, maxMipLevels})

        {-# INLINE vkMaxMipLevelsByteOffset #-}
        vkMaxMipLevelsByteOffset ~_
          = #{offset VkImageFormatProperties, maxMipLevels}

        {-# INLINE readVkMaxMipLevels #-}
        readVkMaxMipLevels p
          = peekByteOff p
              #{offset VkImageFormatProperties, maxMipLevels}

        {-# INLINE writeVkMaxMipLevels #-}
        writeVkMaxMipLevels p
          = pokeByteOff p
              #{offset VkImageFormatProperties, maxMipLevels}

class HasVkMaxArrayLayers a where
        type VkMaxArrayLayersMType a :: *

        vkMaxArrayLayers :: a -> VkMaxArrayLayersMType a

        vkMaxArrayLayersByteOffset :: a -> Int

        readVkMaxArrayLayers :: Ptr a -> IO (VkMaxArrayLayersMType a)

        writeVkMaxArrayLayers :: Ptr a -> VkMaxArrayLayersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxArrayLayers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxArrayLayers a

instance {-# OVERLAPPING #-}
         HasVkMaxArrayLayers VkImageFormatProperties where
        type VkMaxArrayLayersMType VkImageFormatProperties =
             Data.Word.Word32

        {-# NOINLINE vkMaxArrayLayers #-}
        vkMaxArrayLayers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageFormatProperties, maxArrayLayers})

        {-# INLINE vkMaxArrayLayersByteOffset #-}
        vkMaxArrayLayersByteOffset ~_
          = #{offset VkImageFormatProperties, maxArrayLayers}

        {-# INLINE readVkMaxArrayLayers #-}
        readVkMaxArrayLayers p
          = peekByteOff p
              #{offset VkImageFormatProperties, maxArrayLayers}

        {-# INLINE writeVkMaxArrayLayers #-}
        writeVkMaxArrayLayers p
          = pokeByteOff p
              #{offset VkImageFormatProperties, maxArrayLayers}

class HasVkSampleCounts a where
        type VkSampleCountsMType a :: *

        vkSampleCounts :: a -> VkSampleCountsMType a

        vkSampleCountsByteOffset :: a -> Int

        readVkSampleCounts :: Ptr a -> IO (VkSampleCountsMType a)

        writeVkSampleCounts :: Ptr a -> VkSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sampleCounts'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkSampleCounts VkImageFormatProperties where
        type VkSampleCountsMType VkImageFormatProperties =
             VkSampleCountFlags

        {-# NOINLINE vkSampleCounts #-}
        vkSampleCounts x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageFormatProperties, sampleCounts})

        {-# INLINE vkSampleCountsByteOffset #-}
        vkSampleCountsByteOffset ~_
          = #{offset VkImageFormatProperties, sampleCounts}

        {-# INLINE readVkSampleCounts #-}
        readVkSampleCounts p
          = peekByteOff p
              #{offset VkImageFormatProperties, sampleCounts}

        {-# INLINE writeVkSampleCounts #-}
        writeVkSampleCounts p
          = pokeByteOff p
              #{offset VkImageFormatProperties, sampleCounts}

class HasVkMaxResourceSize a where
        type VkMaxResourceSizeMType a :: *

        vkMaxResourceSize :: a -> VkMaxResourceSizeMType a

        vkMaxResourceSizeByteOffset :: a -> Int

        readVkMaxResourceSize :: Ptr a -> IO (VkMaxResourceSizeMType a)

        writeVkMaxResourceSize ::
                               Ptr a -> VkMaxResourceSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxResourceSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxResourceSize a

instance {-# OVERLAPPING #-}
         HasVkMaxResourceSize VkImageFormatProperties where
        type VkMaxResourceSizeMType VkImageFormatProperties = VkDeviceSize

        {-# NOINLINE vkMaxResourceSize #-}
        vkMaxResourceSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageFormatProperties, maxResourceSize})

        {-# INLINE vkMaxResourceSizeByteOffset #-}
        vkMaxResourceSizeByteOffset ~_
          = #{offset VkImageFormatProperties, maxResourceSize}

        {-# INLINE readVkMaxResourceSize #-}
        readVkMaxResourceSize p
          = peekByteOff p
              #{offset VkImageFormatProperties, maxResourceSize}

        {-# INLINE writeVkMaxResourceSize #-}
        writeVkMaxResourceSize p
          = pokeByteOff p
              #{offset VkImageFormatProperties, maxResourceSize}

instance Show VkImageFormatProperties where
        showsPrec d x
          = showString "VkImageFormatProperties {" .
              showString "vkMaxExtent = " .
                showsPrec d (vkMaxExtent x) .
                  showString ", " .
                    showString "vkMaxMipLevels = " .
                      showsPrec d (vkMaxMipLevels x) .
                        showString ", " .
                          showString "vkMaxArrayLayers = " .
                            showsPrec d (vkMaxArrayLayers x) .
                              showString ", " .
                                showString "vkSampleCounts = " .
                                  showsPrec d (vkSampleCounts x) .
                                    showString ", " .
                                      showString "vkMaxResourceSize = " .
                                        showsPrec d (vkMaxResourceSize x) . showChar '}'

data VkDescriptorBufferInfo = VkDescriptorBufferInfo## ByteArray##

instance Eq VkDescriptorBufferInfo where
        (VkDescriptorBufferInfo## a) == (VkDescriptorBufferInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDescriptorBufferInfo where
        (VkDescriptorBufferInfo## a) `compare` (VkDescriptorBufferInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDescriptorBufferInfo where
        sizeOf ~_ = #{size VkDescriptorBufferInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDescriptorBufferInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDescriptorBufferInfo),
            I## a <- alignment (undefined :: VkDescriptorBufferInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDescriptorBufferInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDescriptorBufferInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorBufferInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDescriptorBufferInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkDescriptorBufferInfo),
            I## a <- alignment (undefined :: VkDescriptorBufferInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkDescriptorBufferInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkDescriptorBufferInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkDescriptorBufferInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkDescriptorBufferInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkDescriptorBufferInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkDescriptorBufferInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkBuffer a where
        type VkBufferMType a :: *

        vkBuffer :: a -> VkBufferMType a

        vkBufferByteOffset :: a -> Int

        readVkBuffer :: Ptr a -> IO (VkBufferMType a)

        writeVkBuffer :: Ptr a -> VkBufferMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'buffer'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBuffer a

instance {-# OVERLAPPING #-} HasVkBuffer VkDescriptorBufferInfo
         where
        type VkBufferMType VkDescriptorBufferInfo = VkBuffer

        {-# NOINLINE vkBuffer #-}
        vkBuffer x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorBufferInfo, buffer})

        {-# INLINE vkBufferByteOffset #-}
        vkBufferByteOffset ~_
          = #{offset VkDescriptorBufferInfo, buffer}

        {-# INLINE readVkBuffer #-}
        readVkBuffer p
          = peekByteOff p #{offset VkDescriptorBufferInfo, buffer}

        {-# INLINE writeVkBuffer #-}
        writeVkBuffer p
          = pokeByteOff p #{offset VkDescriptorBufferInfo, buffer}

instance {-# OVERLAPPING #-} HasVkOffset VkDescriptorBufferInfo
         where
        type VkOffsetMType VkDescriptorBufferInfo = VkDeviceSize

        {-# NOINLINE vkOffset #-}
        vkOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorBufferInfo, offset})

        {-# INLINE vkOffsetByteOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkDescriptorBufferInfo, offset}

        {-# INLINE readVkOffset #-}
        readVkOffset p
          = peekByteOff p #{offset VkDescriptorBufferInfo, offset}

        {-# INLINE writeVkOffset #-}
        writeVkOffset p
          = pokeByteOff p #{offset VkDescriptorBufferInfo, offset}

class HasVkRange a where
        type VkRangeMType a :: *

        vkRange :: a -> VkRangeMType a

        vkRangeByteOffset :: a -> Int

        readVkRange :: Ptr a -> IO (VkRangeMType a)

        writeVkRange :: Ptr a -> VkRangeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'range'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRange a

instance {-# OVERLAPPING #-} HasVkRange VkDescriptorBufferInfo
         where
        type VkRangeMType VkDescriptorBufferInfo = VkDeviceSize

        {-# NOINLINE vkRange #-}
        vkRange x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorBufferInfo, range})

        {-# INLINE vkRangeByteOffset #-}
        vkRangeByteOffset ~_
          = #{offset VkDescriptorBufferInfo, range}

        {-# INLINE readVkRange #-}
        readVkRange p
          = peekByteOff p #{offset VkDescriptorBufferInfo, range}

        {-# INLINE writeVkRange #-}
        writeVkRange p
          = pokeByteOff p #{offset VkDescriptorBufferInfo, range}

instance Show VkDescriptorBufferInfo where
        showsPrec d x
          = showString "VkDescriptorBufferInfo {" .
              showString "vkBuffer = " .
                showsPrec d (vkBuffer x) .
                  showString ", " .
                    showString "vkOffset = " .
                      showsPrec d (vkOffset x) .
                        showString ", " .
                          showString "vkRange = " . showsPrec d (vkRange x) . showChar '}'

data VkDescriptorImageInfo = VkDescriptorImageInfo## ByteArray##

instance Eq VkDescriptorImageInfo where
        (VkDescriptorImageInfo## a) == (VkDescriptorImageInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDescriptorImageInfo where
        (VkDescriptorImageInfo## a) `compare` (VkDescriptorImageInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDescriptorImageInfo where
        sizeOf ~_ = #{size VkDescriptorImageInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDescriptorImageInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDescriptorImageInfo),
            I## a <- alignment (undefined :: VkDescriptorImageInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDescriptorImageInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDescriptorImageInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorImageInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDescriptorImageInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkDescriptorImageInfo),
            I## a <- alignment (undefined :: VkDescriptorImageInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkDescriptorImageInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkDescriptorImageInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkDescriptorImageInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkDescriptorImageInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkDescriptorImageInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkDescriptorImageInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkSampler a where
        type VkSamplerMType a :: *

        vkSampler :: a -> VkSamplerMType a

        vkSamplerByteOffset :: a -> Int

        readVkSampler :: Ptr a -> IO (VkSamplerMType a)

        writeVkSampler :: Ptr a -> VkSamplerMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sampler'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampler a

instance {-# OVERLAPPING #-} HasVkSampler VkDescriptorImageInfo
         where
        type VkSamplerMType VkDescriptorImageInfo = VkSampler

        {-# NOINLINE vkSampler #-}
        vkSampler x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorImageInfo, sampler})

        {-# INLINE vkSamplerByteOffset #-}
        vkSamplerByteOffset ~_
          = #{offset VkDescriptorImageInfo, sampler}

        {-# INLINE readVkSampler #-}
        readVkSampler p
          = peekByteOff p #{offset VkDescriptorImageInfo, sampler}

        {-# INLINE writeVkSampler #-}
        writeVkSampler p
          = pokeByteOff p #{offset VkDescriptorImageInfo, sampler}

class HasVkImageView a where
        type VkImageViewMType a :: *

        vkImageView :: a -> VkImageViewMType a

        vkImageViewByteOffset :: a -> Int

        readVkImageView :: Ptr a -> IO (VkImageViewMType a)

        writeVkImageView :: Ptr a -> VkImageViewMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageView'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageView a

instance {-# OVERLAPPING #-} HasVkImageView VkDescriptorImageInfo
         where
        type VkImageViewMType VkDescriptorImageInfo = VkImageView

        {-# NOINLINE vkImageView #-}
        vkImageView x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorImageInfo, imageView})

        {-# INLINE vkImageViewByteOffset #-}
        vkImageViewByteOffset ~_
          = #{offset VkDescriptorImageInfo, imageView}

        {-# INLINE readVkImageView #-}
        readVkImageView p
          = peekByteOff p #{offset VkDescriptorImageInfo, imageView}

        {-# INLINE writeVkImageView #-}
        writeVkImageView p
          = pokeByteOff p #{offset VkDescriptorImageInfo, imageView}

class HasVkImageLayout a where
        type VkImageLayoutMType a :: *

        vkImageLayout :: a -> VkImageLayoutMType a

        vkImageLayoutByteOffset :: a -> Int

        readVkImageLayout :: Ptr a -> IO (VkImageLayoutMType a)

        writeVkImageLayout :: Ptr a -> VkImageLayoutMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageLayout'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageLayout a

instance {-# OVERLAPPING #-} HasVkImageLayout VkDescriptorImageInfo
         where
        type VkImageLayoutMType VkDescriptorImageInfo = VkImageLayout

        {-# NOINLINE vkImageLayout #-}
        vkImageLayout x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorImageInfo, imageLayout})

        {-# INLINE vkImageLayoutByteOffset #-}
        vkImageLayoutByteOffset ~_
          = #{offset VkDescriptorImageInfo, imageLayout}

        {-# INLINE readVkImageLayout #-}
        readVkImageLayout p
          = peekByteOff p
              #{offset VkDescriptorImageInfo, imageLayout}

        {-# INLINE writeVkImageLayout #-}
        writeVkImageLayout p
          = pokeByteOff p
              #{offset VkDescriptorImageInfo, imageLayout}

instance Show VkDescriptorImageInfo where
        showsPrec d x
          = showString "VkDescriptorImageInfo {" .
              showString "vkSampler = " .
                showsPrec d (vkSampler x) .
                  showString ", " .
                    showString "vkImageView = " .
                      showsPrec d (vkImageView x) .
                        showString ", " .
                          showString "vkImageLayout = " .
                            showsPrec d (vkImageLayout x) . showChar '}'

data VkWriteDescriptorSet = VkWriteDescriptorSet## ByteArray##

instance Eq VkWriteDescriptorSet where
        (VkWriteDescriptorSet## a) == (VkWriteDescriptorSet## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkWriteDescriptorSet where
        (VkWriteDescriptorSet## a) `compare` (VkWriteDescriptorSet## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkWriteDescriptorSet where
        sizeOf ~_ = #{size VkWriteDescriptorSet}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkWriteDescriptorSet}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkWriteDescriptorSet),
            I## a <- alignment (undefined :: VkWriteDescriptorSet) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkWriteDescriptorSet## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkWriteDescriptorSet## ba)
          | I## n <- sizeOf (undefined :: VkWriteDescriptorSet) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkWriteDescriptorSet where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkWriteDescriptorSet),
            I## a <- alignment (undefined :: VkWriteDescriptorSet) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkWriteDescriptorSet##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkWriteDescriptorSet## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkWriteDescriptorSet##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkWriteDescriptorSet## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkWriteDescriptorSet## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkWriteDescriptorSet## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkWriteDescriptorSet where
        type VkSTypeMType VkWriteDescriptorSet = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkWriteDescriptorSet, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkWriteDescriptorSet, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkWriteDescriptorSet, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkWriteDescriptorSet, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkWriteDescriptorSet where
        type VkPNextMType VkWriteDescriptorSet =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkWriteDescriptorSet, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkWriteDescriptorSet, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkWriteDescriptorSet, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkWriteDescriptorSet, pNext}

class HasVkDstSet a where
        type VkDstSetMType a :: *

        vkDstSet :: a -> VkDstSetMType a

        vkDstSetByteOffset :: a -> Int

        readVkDstSet :: Ptr a -> IO (VkDstSetMType a)

        writeVkDstSet :: Ptr a -> VkDstSetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstSet'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstSet a

instance {-# OVERLAPPING #-} HasVkDstSet VkWriteDescriptorSet where
        type VkDstSetMType VkWriteDescriptorSet = VkDescriptorSet

        {-# NOINLINE vkDstSet #-}
        vkDstSet x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkWriteDescriptorSet, dstSet})

        {-# INLINE vkDstSetByteOffset #-}
        vkDstSetByteOffset ~_
          = #{offset VkWriteDescriptorSet, dstSet}

        {-# INLINE readVkDstSet #-}
        readVkDstSet p
          = peekByteOff p #{offset VkWriteDescriptorSet, dstSet}

        {-# INLINE writeVkDstSet #-}
        writeVkDstSet p
          = pokeByteOff p #{offset VkWriteDescriptorSet, dstSet}

class HasVkDstBinding a where
        type VkDstBindingMType a :: *

        vkDstBinding :: a -> VkDstBindingMType a

        vkDstBindingByteOffset :: a -> Int

        readVkDstBinding :: Ptr a -> IO (VkDstBindingMType a)

        writeVkDstBinding :: Ptr a -> VkDstBindingMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstBinding'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstBinding a

instance {-# OVERLAPPING #-} HasVkDstBinding VkWriteDescriptorSet
         where
        type VkDstBindingMType VkWriteDescriptorSet = Data.Word.Word32

        {-# NOINLINE vkDstBinding #-}
        vkDstBinding x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkWriteDescriptorSet, dstBinding})

        {-# INLINE vkDstBindingByteOffset #-}
        vkDstBindingByteOffset ~_
          = #{offset VkWriteDescriptorSet, dstBinding}

        {-# INLINE readVkDstBinding #-}
        readVkDstBinding p
          = peekByteOff p #{offset VkWriteDescriptorSet, dstBinding}

        {-# INLINE writeVkDstBinding #-}
        writeVkDstBinding p
          = pokeByteOff p #{offset VkWriteDescriptorSet, dstBinding}

class HasVkDstArrayElement a where
        type VkDstArrayElementMType a :: *

        vkDstArrayElement :: a -> VkDstArrayElementMType a

        vkDstArrayElementByteOffset :: a -> Int

        readVkDstArrayElement :: Ptr a -> IO (VkDstArrayElementMType a)

        writeVkDstArrayElement ::
                               Ptr a -> VkDstArrayElementMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstArrayElement'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstArrayElement a

instance {-# OVERLAPPING #-}
         HasVkDstArrayElement VkWriteDescriptorSet where
        type VkDstArrayElementMType VkWriteDescriptorSet = Data.Word.Word32

        {-# NOINLINE vkDstArrayElement #-}
        vkDstArrayElement x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkWriteDescriptorSet, dstArrayElement})

        {-# INLINE vkDstArrayElementByteOffset #-}
        vkDstArrayElementByteOffset ~_
          = #{offset VkWriteDescriptorSet, dstArrayElement}

        {-# INLINE readVkDstArrayElement #-}
        readVkDstArrayElement p
          = peekByteOff p
              #{offset VkWriteDescriptorSet, dstArrayElement}

        {-# INLINE writeVkDstArrayElement #-}
        writeVkDstArrayElement p
          = pokeByteOff p
              #{offset VkWriteDescriptorSet, dstArrayElement}

class HasVkDescriptorCount a where
        type VkDescriptorCountMType a :: *

        vkDescriptorCount :: a -> VkDescriptorCountMType a

        vkDescriptorCountByteOffset :: a -> Int

        readVkDescriptorCount :: Ptr a -> IO (VkDescriptorCountMType a)

        writeVkDescriptorCount ::
                               Ptr a -> VkDescriptorCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'descriptorCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDescriptorCount a

instance {-# OVERLAPPING #-}
         HasVkDescriptorCount VkWriteDescriptorSet where
        type VkDescriptorCountMType VkWriteDescriptorSet = Data.Word.Word32

        {-# NOINLINE vkDescriptorCount #-}
        vkDescriptorCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkWriteDescriptorSet, descriptorCount})

        {-# INLINE vkDescriptorCountByteOffset #-}
        vkDescriptorCountByteOffset ~_
          = #{offset VkWriteDescriptorSet, descriptorCount}

        {-# INLINE readVkDescriptorCount #-}
        readVkDescriptorCount p
          = peekByteOff p
              #{offset VkWriteDescriptorSet, descriptorCount}

        {-# INLINE writeVkDescriptorCount #-}
        writeVkDescriptorCount p
          = pokeByteOff p
              #{offset VkWriteDescriptorSet, descriptorCount}

class HasVkDescriptorType a where
        type VkDescriptorTypeMType a :: *

        vkDescriptorType :: a -> VkDescriptorTypeMType a

        vkDescriptorTypeByteOffset :: a -> Int

        readVkDescriptorType :: Ptr a -> IO (VkDescriptorTypeMType a)

        writeVkDescriptorType :: Ptr a -> VkDescriptorTypeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'descriptorType'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDescriptorType a

instance {-# OVERLAPPING #-}
         HasVkDescriptorType VkWriteDescriptorSet where
        type VkDescriptorTypeMType VkWriteDescriptorSet = VkDescriptorType

        {-# NOINLINE vkDescriptorType #-}
        vkDescriptorType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkWriteDescriptorSet, descriptorType})

        {-# INLINE vkDescriptorTypeByteOffset #-}
        vkDescriptorTypeByteOffset ~_
          = #{offset VkWriteDescriptorSet, descriptorType}

        {-# INLINE readVkDescriptorType #-}
        readVkDescriptorType p
          = peekByteOff p
              #{offset VkWriteDescriptorSet, descriptorType}

        {-# INLINE writeVkDescriptorType #-}
        writeVkDescriptorType p
          = pokeByteOff p
              #{offset VkWriteDescriptorSet, descriptorType}

class HasVkPImageInfo a where
        type VkPImageInfoMType a :: *

        vkPImageInfo :: a -> VkPImageInfoMType a

        vkPImageInfoByteOffset :: a -> Int

        readVkPImageInfo :: Ptr a -> IO (VkPImageInfoMType a)

        writeVkPImageInfo :: Ptr a -> VkPImageInfoMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pImageInfo'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPImageInfo a

instance {-# OVERLAPPING #-} HasVkPImageInfo VkWriteDescriptorSet
         where
        type VkPImageInfoMType VkWriteDescriptorSet =
             Foreign.Ptr.Ptr VkDescriptorImageInfo

        {-# NOINLINE vkPImageInfo #-}
        vkPImageInfo x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkWriteDescriptorSet, pImageInfo})

        {-# INLINE vkPImageInfoByteOffset #-}
        vkPImageInfoByteOffset ~_
          = #{offset VkWriteDescriptorSet, pImageInfo}

        {-# INLINE readVkPImageInfo #-}
        readVkPImageInfo p
          = peekByteOff p #{offset VkWriteDescriptorSet, pImageInfo}

        {-# INLINE writeVkPImageInfo #-}
        writeVkPImageInfo p
          = pokeByteOff p #{offset VkWriteDescriptorSet, pImageInfo}

class HasVkPBufferInfo a where
        type VkPBufferInfoMType a :: *

        vkPBufferInfo :: a -> VkPBufferInfoMType a

        vkPBufferInfoByteOffset :: a -> Int

        readVkPBufferInfo :: Ptr a -> IO (VkPBufferInfoMType a)

        writeVkPBufferInfo :: Ptr a -> VkPBufferInfoMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pBufferInfo'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPBufferInfo a

instance {-# OVERLAPPING #-} HasVkPBufferInfo VkWriteDescriptorSet
         where
        type VkPBufferInfoMType VkWriteDescriptorSet =
             Foreign.Ptr.Ptr VkDescriptorBufferInfo

        {-# NOINLINE vkPBufferInfo #-}
        vkPBufferInfo x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkWriteDescriptorSet, pBufferInfo})

        {-# INLINE vkPBufferInfoByteOffset #-}
        vkPBufferInfoByteOffset ~_
          = #{offset VkWriteDescriptorSet, pBufferInfo}

        {-# INLINE readVkPBufferInfo #-}
        readVkPBufferInfo p
          = peekByteOff p
              #{offset VkWriteDescriptorSet, pBufferInfo}

        {-# INLINE writeVkPBufferInfo #-}
        writeVkPBufferInfo p
          = pokeByteOff p
              #{offset VkWriteDescriptorSet, pBufferInfo}

class HasVkPTexelBufferView a where
        type VkPTexelBufferViewMType a :: *

        vkPTexelBufferView :: a -> VkPTexelBufferViewMType a

        vkPTexelBufferViewByteOffset :: a -> Int

        readVkPTexelBufferView :: Ptr a -> IO (VkPTexelBufferViewMType a)

        writeVkPTexelBufferView ::
                                Ptr a -> VkPTexelBufferViewMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pTexelBufferView'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPTexelBufferView a

instance {-# OVERLAPPING #-}
         HasVkPTexelBufferView VkWriteDescriptorSet where
        type VkPTexelBufferViewMType VkWriteDescriptorSet =
             Foreign.Ptr.Ptr VkBufferView

        {-# NOINLINE vkPTexelBufferView #-}
        vkPTexelBufferView x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkWriteDescriptorSet, pTexelBufferView})

        {-# INLINE vkPTexelBufferViewByteOffset #-}
        vkPTexelBufferViewByteOffset ~_
          = #{offset VkWriteDescriptorSet, pTexelBufferView}

        {-# INLINE readVkPTexelBufferView #-}
        readVkPTexelBufferView p
          = peekByteOff p
              #{offset VkWriteDescriptorSet, pTexelBufferView}

        {-# INLINE writeVkPTexelBufferView #-}
        writeVkPTexelBufferView p
          = pokeByteOff p
              #{offset VkWriteDescriptorSet, pTexelBufferView}

instance Show VkWriteDescriptorSet where
        showsPrec d x
          = showString "VkWriteDescriptorSet {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkDstSet = " .
                            showsPrec d (vkDstSet x) .
                              showString ", " .
                                showString "vkDstBinding = " .
                                  showsPrec d (vkDstBinding x) .
                                    showString ", " .
                                      showString "vkDstArrayElement = " .
                                        showsPrec d (vkDstArrayElement x) .
                                          showString ", " .
                                            showString "vkDescriptorCount = " .
                                              showsPrec d (vkDescriptorCount x) .
                                                showString ", " .
                                                  showString "vkDescriptorType = " .
                                                    showsPrec d (vkDescriptorType x) .
                                                      showString ", " .
                                                        showString "vkPImageInfo = " .
                                                          showsPrec d (vkPImageInfo x) .
                                                            showString ", " .
                                                              showString "vkPBufferInfo = " .
                                                                showsPrec d (vkPBufferInfo x) .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkPTexelBufferView = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkPTexelBufferView x)
                                                                        . showChar '}'

data VkCopyDescriptorSet = VkCopyDescriptorSet## ByteArray##

instance Eq VkCopyDescriptorSet where
        (VkCopyDescriptorSet## a) == (VkCopyDescriptorSet## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkCopyDescriptorSet where
        (VkCopyDescriptorSet## a) `compare` (VkCopyDescriptorSet## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkCopyDescriptorSet where
        sizeOf ~_ = #{size VkCopyDescriptorSet}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkCopyDescriptorSet}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkCopyDescriptorSet),
            I## a <- alignment (undefined :: VkCopyDescriptorSet) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkCopyDescriptorSet## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkCopyDescriptorSet## ba)
          | I## n <- sizeOf (undefined :: VkCopyDescriptorSet) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkCopyDescriptorSet where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkCopyDescriptorSet),
            I## a <- alignment (undefined :: VkCopyDescriptorSet) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkCopyDescriptorSet##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkCopyDescriptorSet## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkCopyDescriptorSet##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkCopyDescriptorSet## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkCopyDescriptorSet## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkCopyDescriptorSet## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkCopyDescriptorSet where
        type VkSTypeMType VkCopyDescriptorSet = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCopyDescriptorSet, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkCopyDescriptorSet, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkCopyDescriptorSet, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkCopyDescriptorSet, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkCopyDescriptorSet where
        type VkPNextMType VkCopyDescriptorSet =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCopyDescriptorSet, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkCopyDescriptorSet, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkCopyDescriptorSet, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkCopyDescriptorSet, pNext}

class HasVkSrcSet a where
        type VkSrcSetMType a :: *

        vkSrcSet :: a -> VkSrcSetMType a

        vkSrcSetByteOffset :: a -> Int

        readVkSrcSet :: Ptr a -> IO (VkSrcSetMType a)

        writeVkSrcSet :: Ptr a -> VkSrcSetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcSet'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcSet a

instance {-# OVERLAPPING #-} HasVkSrcSet VkCopyDescriptorSet where
        type VkSrcSetMType VkCopyDescriptorSet = VkDescriptorSet

        {-# NOINLINE vkSrcSet #-}
        vkSrcSet x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCopyDescriptorSet, srcSet})

        {-# INLINE vkSrcSetByteOffset #-}
        vkSrcSetByteOffset ~_
          = #{offset VkCopyDescriptorSet, srcSet}

        {-# INLINE readVkSrcSet #-}
        readVkSrcSet p
          = peekByteOff p #{offset VkCopyDescriptorSet, srcSet}

        {-# INLINE writeVkSrcSet #-}
        writeVkSrcSet p
          = pokeByteOff p #{offset VkCopyDescriptorSet, srcSet}

class HasVkSrcBinding a where
        type VkSrcBindingMType a :: *

        vkSrcBinding :: a -> VkSrcBindingMType a

        vkSrcBindingByteOffset :: a -> Int

        readVkSrcBinding :: Ptr a -> IO (VkSrcBindingMType a)

        writeVkSrcBinding :: Ptr a -> VkSrcBindingMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcBinding'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcBinding a

instance {-# OVERLAPPING #-} HasVkSrcBinding VkCopyDescriptorSet
         where
        type VkSrcBindingMType VkCopyDescriptorSet = Data.Word.Word32

        {-# NOINLINE vkSrcBinding #-}
        vkSrcBinding x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCopyDescriptorSet, srcBinding})

        {-# INLINE vkSrcBindingByteOffset #-}
        vkSrcBindingByteOffset ~_
          = #{offset VkCopyDescriptorSet, srcBinding}

        {-# INLINE readVkSrcBinding #-}
        readVkSrcBinding p
          = peekByteOff p #{offset VkCopyDescriptorSet, srcBinding}

        {-# INLINE writeVkSrcBinding #-}
        writeVkSrcBinding p
          = pokeByteOff p #{offset VkCopyDescriptorSet, srcBinding}

class HasVkSrcArrayElement a where
        type VkSrcArrayElementMType a :: *

        vkSrcArrayElement :: a -> VkSrcArrayElementMType a

        vkSrcArrayElementByteOffset :: a -> Int

        readVkSrcArrayElement :: Ptr a -> IO (VkSrcArrayElementMType a)

        writeVkSrcArrayElement ::
                               Ptr a -> VkSrcArrayElementMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcArrayElement'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcArrayElement a

instance {-# OVERLAPPING #-}
         HasVkSrcArrayElement VkCopyDescriptorSet where
        type VkSrcArrayElementMType VkCopyDescriptorSet = Data.Word.Word32

        {-# NOINLINE vkSrcArrayElement #-}
        vkSrcArrayElement x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCopyDescriptorSet, srcArrayElement})

        {-# INLINE vkSrcArrayElementByteOffset #-}
        vkSrcArrayElementByteOffset ~_
          = #{offset VkCopyDescriptorSet, srcArrayElement}

        {-# INLINE readVkSrcArrayElement #-}
        readVkSrcArrayElement p
          = peekByteOff p
              #{offset VkCopyDescriptorSet, srcArrayElement}

        {-# INLINE writeVkSrcArrayElement #-}
        writeVkSrcArrayElement p
          = pokeByteOff p
              #{offset VkCopyDescriptorSet, srcArrayElement}

instance {-# OVERLAPPING #-} HasVkDstSet VkCopyDescriptorSet where
        type VkDstSetMType VkCopyDescriptorSet = VkDescriptorSet

        {-# NOINLINE vkDstSet #-}
        vkDstSet x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCopyDescriptorSet, dstSet})

        {-# INLINE vkDstSetByteOffset #-}
        vkDstSetByteOffset ~_
          = #{offset VkCopyDescriptorSet, dstSet}

        {-# INLINE readVkDstSet #-}
        readVkDstSet p
          = peekByteOff p #{offset VkCopyDescriptorSet, dstSet}

        {-# INLINE writeVkDstSet #-}
        writeVkDstSet p
          = pokeByteOff p #{offset VkCopyDescriptorSet, dstSet}

instance {-# OVERLAPPING #-} HasVkDstBinding VkCopyDescriptorSet
         where
        type VkDstBindingMType VkCopyDescriptorSet = Data.Word.Word32

        {-# NOINLINE vkDstBinding #-}
        vkDstBinding x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCopyDescriptorSet, dstBinding})

        {-# INLINE vkDstBindingByteOffset #-}
        vkDstBindingByteOffset ~_
          = #{offset VkCopyDescriptorSet, dstBinding}

        {-# INLINE readVkDstBinding #-}
        readVkDstBinding p
          = peekByteOff p #{offset VkCopyDescriptorSet, dstBinding}

        {-# INLINE writeVkDstBinding #-}
        writeVkDstBinding p
          = pokeByteOff p #{offset VkCopyDescriptorSet, dstBinding}

instance {-# OVERLAPPING #-}
         HasVkDstArrayElement VkCopyDescriptorSet where
        type VkDstArrayElementMType VkCopyDescriptorSet = Data.Word.Word32

        {-# NOINLINE vkDstArrayElement #-}
        vkDstArrayElement x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCopyDescriptorSet, dstArrayElement})

        {-# INLINE vkDstArrayElementByteOffset #-}
        vkDstArrayElementByteOffset ~_
          = #{offset VkCopyDescriptorSet, dstArrayElement}

        {-# INLINE readVkDstArrayElement #-}
        readVkDstArrayElement p
          = peekByteOff p
              #{offset VkCopyDescriptorSet, dstArrayElement}

        {-# INLINE writeVkDstArrayElement #-}
        writeVkDstArrayElement p
          = pokeByteOff p
              #{offset VkCopyDescriptorSet, dstArrayElement}

instance {-# OVERLAPPING #-}
         HasVkDescriptorCount VkCopyDescriptorSet where
        type VkDescriptorCountMType VkCopyDescriptorSet = Data.Word.Word32

        {-# NOINLINE vkDescriptorCount #-}
        vkDescriptorCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCopyDescriptorSet, descriptorCount})

        {-# INLINE vkDescriptorCountByteOffset #-}
        vkDescriptorCountByteOffset ~_
          = #{offset VkCopyDescriptorSet, descriptorCount}

        {-# INLINE readVkDescriptorCount #-}
        readVkDescriptorCount p
          = peekByteOff p
              #{offset VkCopyDescriptorSet, descriptorCount}

        {-# INLINE writeVkDescriptorCount #-}
        writeVkDescriptorCount p
          = pokeByteOff p
              #{offset VkCopyDescriptorSet, descriptorCount}

instance Show VkCopyDescriptorSet where
        showsPrec d x
          = showString "VkCopyDescriptorSet {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkSrcSet = " .
                            showsPrec d (vkSrcSet x) .
                              showString ", " .
                                showString "vkSrcBinding = " .
                                  showsPrec d (vkSrcBinding x) .
                                    showString ", " .
                                      showString "vkSrcArrayElement = " .
                                        showsPrec d (vkSrcArrayElement x) .
                                          showString ", " .
                                            showString "vkDstSet = " .
                                              showsPrec d (vkDstSet x) .
                                                showString ", " .
                                                  showString "vkDstBinding = " .
                                                    showsPrec d (vkDstBinding x) .
                                                      showString ", " .
                                                        showString "vkDstArrayElement = " .
                                                          showsPrec d (vkDstArrayElement x) .
                                                            showString ", " .
                                                              showString "vkDescriptorCount = " .
                                                                showsPrec d (vkDescriptorCount x) .
                                                                  showChar '}'

data VkBufferCreateInfo = VkBufferCreateInfo## ByteArray##

instance Eq VkBufferCreateInfo where
        (VkBufferCreateInfo## a) == (VkBufferCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkBufferCreateInfo where
        (VkBufferCreateInfo## a) `compare` (VkBufferCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkBufferCreateInfo where
        sizeOf ~_ = #{size VkBufferCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkBufferCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkBufferCreateInfo),
            I## a <- alignment (undefined :: VkBufferCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkBufferCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkBufferCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkBufferCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkBufferCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkBufferCreateInfo),
            I## a <- alignment (undefined :: VkBufferCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkBufferCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkBufferCreateInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkBufferCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkBufferCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkBufferCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkBufferCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkBufferCreateInfo where
        type VkSTypeMType VkBufferCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_ = #{offset VkBufferCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkBufferCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkBufferCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkBufferCreateInfo where
        type VkPNextMType VkBufferCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_ = #{offset VkBufferCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkBufferCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkBufferCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkBufferCreateInfo where
        type VkFlagsMType VkBufferCreateInfo = VkBufferCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_ = #{offset VkBufferCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkBufferCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkBufferCreateInfo, flags}

instance {-# OVERLAPPING #-} HasVkSize VkBufferCreateInfo where
        type VkSizeMType VkBufferCreateInfo = VkDeviceSize

        {-# NOINLINE vkSize #-}
        vkSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferCreateInfo, size})

        {-# INLINE vkSizeByteOffset #-}
        vkSizeByteOffset ~_ = #{offset VkBufferCreateInfo, size}

        {-# INLINE readVkSize #-}
        readVkSize p
          = peekByteOff p #{offset VkBufferCreateInfo, size}

        {-# INLINE writeVkSize #-}
        writeVkSize p
          = pokeByteOff p #{offset VkBufferCreateInfo, size}

class HasVkUsage a where
        type VkUsageMType a :: *

        vkUsage :: a -> VkUsageMType a

        vkUsageByteOffset :: a -> Int

        readVkUsage :: Ptr a -> IO (VkUsageMType a)

        writeVkUsage :: Ptr a -> VkUsageMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'usage'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkUsage a

instance {-# OVERLAPPING #-} HasVkUsage VkBufferCreateInfo where
        type VkUsageMType VkBufferCreateInfo = VkBufferUsageFlags

        {-# NOINLINE vkUsage #-}
        vkUsage x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferCreateInfo, usage})

        {-# INLINE vkUsageByteOffset #-}
        vkUsageByteOffset ~_ = #{offset VkBufferCreateInfo, usage}

        {-# INLINE readVkUsage #-}
        readVkUsage p
          = peekByteOff p #{offset VkBufferCreateInfo, usage}

        {-# INLINE writeVkUsage #-}
        writeVkUsage p
          = pokeByteOff p #{offset VkBufferCreateInfo, usage}

class HasVkSharingMode a where
        type VkSharingModeMType a :: *

        vkSharingMode :: a -> VkSharingModeMType a

        vkSharingModeByteOffset :: a -> Int

        readVkSharingMode :: Ptr a -> IO (VkSharingModeMType a)

        writeVkSharingMode :: Ptr a -> VkSharingModeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sharingMode'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSharingMode a

instance {-# OVERLAPPING #-} HasVkSharingMode VkBufferCreateInfo
         where
        type VkSharingModeMType VkBufferCreateInfo = VkSharingMode

        {-# NOINLINE vkSharingMode #-}
        vkSharingMode x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferCreateInfo, sharingMode})

        {-# INLINE vkSharingModeByteOffset #-}
        vkSharingModeByteOffset ~_
          = #{offset VkBufferCreateInfo, sharingMode}

        {-# INLINE readVkSharingMode #-}
        readVkSharingMode p
          = peekByteOff p #{offset VkBufferCreateInfo, sharingMode}

        {-# INLINE writeVkSharingMode #-}
        writeVkSharingMode p
          = pokeByteOff p #{offset VkBufferCreateInfo, sharingMode}

class HasVkQueueFamilyIndexCount a where
        type VkQueueFamilyIndexCountMType a :: *

        vkQueueFamilyIndexCount :: a -> VkQueueFamilyIndexCountMType a

        vkQueueFamilyIndexCountByteOffset :: a -> Int

        readVkQueueFamilyIndexCount ::
                                    Ptr a -> IO (VkQueueFamilyIndexCountMType a)

        writeVkQueueFamilyIndexCount ::
                                     Ptr a -> VkQueueFamilyIndexCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queueFamilyIndexCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueueFamilyIndexCount a

instance {-# OVERLAPPING #-}
         HasVkQueueFamilyIndexCount VkBufferCreateInfo where
        type VkQueueFamilyIndexCountMType VkBufferCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkQueueFamilyIndexCount #-}
        vkQueueFamilyIndexCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferCreateInfo, queueFamilyIndexCount})

        {-# INLINE vkQueueFamilyIndexCountByteOffset #-}
        vkQueueFamilyIndexCountByteOffset ~_
          = #{offset VkBufferCreateInfo, queueFamilyIndexCount}

        {-# INLINE readVkQueueFamilyIndexCount #-}
        readVkQueueFamilyIndexCount p
          = peekByteOff p
              #{offset VkBufferCreateInfo, queueFamilyIndexCount}

        {-# INLINE writeVkQueueFamilyIndexCount #-}
        writeVkQueueFamilyIndexCount p
          = pokeByteOff p
              #{offset VkBufferCreateInfo, queueFamilyIndexCount}

class HasVkPQueueFamilyIndices a where
        type VkPQueueFamilyIndicesMType a :: *

        vkPQueueFamilyIndices :: a -> VkPQueueFamilyIndicesMType a

        vkPQueueFamilyIndicesByteOffset :: a -> Int

        readVkPQueueFamilyIndices ::
                                  Ptr a -> IO (VkPQueueFamilyIndicesMType a)

        writeVkPQueueFamilyIndices ::
                                   Ptr a -> VkPQueueFamilyIndicesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pQueueFamilyIndices'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPQueueFamilyIndices a

instance {-# OVERLAPPING #-}
         HasVkPQueueFamilyIndices VkBufferCreateInfo where
        type VkPQueueFamilyIndicesMType VkBufferCreateInfo =
             Foreign.Ptr.Ptr Data.Word.Word32

        {-# NOINLINE vkPQueueFamilyIndices #-}
        vkPQueueFamilyIndices x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferCreateInfo, pQueueFamilyIndices})

        {-# INLINE vkPQueueFamilyIndicesByteOffset #-}
        vkPQueueFamilyIndicesByteOffset ~_
          = #{offset VkBufferCreateInfo, pQueueFamilyIndices}

        {-# INLINE readVkPQueueFamilyIndices #-}
        readVkPQueueFamilyIndices p
          = peekByteOff p
              #{offset VkBufferCreateInfo, pQueueFamilyIndices}

        {-# INLINE writeVkPQueueFamilyIndices #-}
        writeVkPQueueFamilyIndices p
          = pokeByteOff p
              #{offset VkBufferCreateInfo, pQueueFamilyIndices}

instance Show VkBufferCreateInfo where
        showsPrec d x
          = showString "VkBufferCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkSize = " .
                                  showsPrec d (vkSize x) .
                                    showString ", " .
                                      showString "vkUsage = " .
                                        showsPrec d (vkUsage x) .
                                          showString ", " .
                                            showString "vkSharingMode = " .
                                              showsPrec d (vkSharingMode x) .
                                                showString ", " .
                                                  showString "vkQueueFamilyIndexCount = " .
                                                    showsPrec d (vkQueueFamilyIndexCount x) .
                                                      showString ", " .
                                                        showString "vkPQueueFamilyIndices = " .
                                                          showsPrec d (vkPQueueFamilyIndices x) .
                                                            showChar '}'

data VkBufferViewCreateInfo = VkBufferViewCreateInfo## ByteArray##

instance Eq VkBufferViewCreateInfo where
        (VkBufferViewCreateInfo## a) == (VkBufferViewCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkBufferViewCreateInfo where
        (VkBufferViewCreateInfo## a) `compare` (VkBufferViewCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkBufferViewCreateInfo where
        sizeOf ~_ = #{size VkBufferViewCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkBufferViewCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkBufferViewCreateInfo),
            I## a <- alignment (undefined :: VkBufferViewCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkBufferViewCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkBufferViewCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkBufferViewCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkBufferViewCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkBufferViewCreateInfo),
            I## a <- alignment (undefined :: VkBufferViewCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkBufferViewCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkBufferViewCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkBufferViewCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkBufferViewCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkBufferViewCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkBufferViewCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkBufferViewCreateInfo
         where
        type VkSTypeMType VkBufferViewCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferViewCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkBufferViewCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkBufferViewCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkBufferViewCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkBufferViewCreateInfo
         where
        type VkPNextMType VkBufferViewCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferViewCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkBufferViewCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkBufferViewCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkBufferViewCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkBufferViewCreateInfo
         where
        type VkFlagsMType VkBufferViewCreateInfo = VkBufferViewCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferViewCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkBufferViewCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkBufferViewCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkBufferViewCreateInfo, flags}

instance {-# OVERLAPPING #-} HasVkBuffer VkBufferViewCreateInfo
         where
        type VkBufferMType VkBufferViewCreateInfo = VkBuffer

        {-# NOINLINE vkBuffer #-}
        vkBuffer x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferViewCreateInfo, buffer})

        {-# INLINE vkBufferByteOffset #-}
        vkBufferByteOffset ~_
          = #{offset VkBufferViewCreateInfo, buffer}

        {-# INLINE readVkBuffer #-}
        readVkBuffer p
          = peekByteOff p #{offset VkBufferViewCreateInfo, buffer}

        {-# INLINE writeVkBuffer #-}
        writeVkBuffer p
          = pokeByteOff p #{offset VkBufferViewCreateInfo, buffer}

class HasVkFormat a where
        type VkFormatMType a :: *

        vkFormat :: a -> VkFormatMType a

        vkFormatByteOffset :: a -> Int

        readVkFormat :: Ptr a -> IO (VkFormatMType a)

        writeVkFormat :: Ptr a -> VkFormatMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'format'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFormat a

instance {-# OVERLAPPING #-} HasVkFormat VkBufferViewCreateInfo
         where
        type VkFormatMType VkBufferViewCreateInfo = VkFormat

        {-# NOINLINE vkFormat #-}
        vkFormat x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferViewCreateInfo, format})

        {-# INLINE vkFormatByteOffset #-}
        vkFormatByteOffset ~_
          = #{offset VkBufferViewCreateInfo, format}

        {-# INLINE readVkFormat #-}
        readVkFormat p
          = peekByteOff p #{offset VkBufferViewCreateInfo, format}

        {-# INLINE writeVkFormat #-}
        writeVkFormat p
          = pokeByteOff p #{offset VkBufferViewCreateInfo, format}

instance {-# OVERLAPPING #-} HasVkOffset VkBufferViewCreateInfo
         where
        type VkOffsetMType VkBufferViewCreateInfo = VkDeviceSize

        {-# NOINLINE vkOffset #-}
        vkOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferViewCreateInfo, offset})

        {-# INLINE vkOffsetByteOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkBufferViewCreateInfo, offset}

        {-# INLINE readVkOffset #-}
        readVkOffset p
          = peekByteOff p #{offset VkBufferViewCreateInfo, offset}

        {-# INLINE writeVkOffset #-}
        writeVkOffset p
          = pokeByteOff p #{offset VkBufferViewCreateInfo, offset}

instance {-# OVERLAPPING #-} HasVkRange VkBufferViewCreateInfo
         where
        type VkRangeMType VkBufferViewCreateInfo = VkDeviceSize

        {-# NOINLINE vkRange #-}
        vkRange x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferViewCreateInfo, range})

        {-# INLINE vkRangeByteOffset #-}
        vkRangeByteOffset ~_
          = #{offset VkBufferViewCreateInfo, range}

        {-# INLINE readVkRange #-}
        readVkRange p
          = peekByteOff p #{offset VkBufferViewCreateInfo, range}

        {-# INLINE writeVkRange #-}
        writeVkRange p
          = pokeByteOff p #{offset VkBufferViewCreateInfo, range}

instance Show VkBufferViewCreateInfo where
        showsPrec d x
          = showString "VkBufferViewCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkBuffer = " .
                                  showsPrec d (vkBuffer x) .
                                    showString ", " .
                                      showString "vkFormat = " .
                                        showsPrec d (vkFormat x) .
                                          showString ", " .
                                            showString "vkOffset = " .
                                              showsPrec d (vkOffset x) .
                                                showString ", " .
                                                  showString "vkRange = " .
                                                    showsPrec d (vkRange x) . showChar '}'

data VkImageSubresource = VkImageSubresource## ByteArray##

instance Eq VkImageSubresource where
        (VkImageSubresource## a) == (VkImageSubresource## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageSubresource where
        (VkImageSubresource## a) `compare` (VkImageSubresource## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageSubresource where
        sizeOf ~_ = #{size VkImageSubresource}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageSubresource}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageSubresource),
            I## a <- alignment (undefined :: VkImageSubresource) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkImageSubresource## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageSubresource## ba)
          | I## n <- sizeOf (undefined :: VkImageSubresource) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageSubresource where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkImageSubresource),
            I## a <- alignment (undefined :: VkImageSubresource) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkImageSubresource##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkImageSubresource## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkImageSubresource##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkImageSubresource## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkImageSubresource## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkImageSubresource## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkAspectMask VkImageSubresource
         where
        type VkAspectMaskMType VkImageSubresource = VkImageAspectFlags

        {-# NOINLINE vkAspectMask #-}
        vkAspectMask x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageSubresource, aspectMask})

        {-# INLINE vkAspectMaskByteOffset #-}
        vkAspectMaskByteOffset ~_
          = #{offset VkImageSubresource, aspectMask}

        {-# INLINE readVkAspectMask #-}
        readVkAspectMask p
          = peekByteOff p #{offset VkImageSubresource, aspectMask}

        {-# INLINE writeVkAspectMask #-}
        writeVkAspectMask p
          = pokeByteOff p #{offset VkImageSubresource, aspectMask}

class HasVkMipLevel a where
        type VkMipLevelMType a :: *

        vkMipLevel :: a -> VkMipLevelMType a

        vkMipLevelByteOffset :: a -> Int

        readVkMipLevel :: Ptr a -> IO (VkMipLevelMType a)

        writeVkMipLevel :: Ptr a -> VkMipLevelMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'mipLevel'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMipLevel a

instance {-# OVERLAPPING #-} HasVkMipLevel VkImageSubresource where
        type VkMipLevelMType VkImageSubresource = Data.Word.Word32

        {-# NOINLINE vkMipLevel #-}
        vkMipLevel x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageSubresource, mipLevel})

        {-# INLINE vkMipLevelByteOffset #-}
        vkMipLevelByteOffset ~_
          = #{offset VkImageSubresource, mipLevel}

        {-# INLINE readVkMipLevel #-}
        readVkMipLevel p
          = peekByteOff p #{offset VkImageSubresource, mipLevel}

        {-# INLINE writeVkMipLevel #-}
        writeVkMipLevel p
          = pokeByteOff p #{offset VkImageSubresource, mipLevel}

class HasVkArrayLayer a where
        type VkArrayLayerMType a :: *

        vkArrayLayer :: a -> VkArrayLayerMType a

        vkArrayLayerByteOffset :: a -> Int

        readVkArrayLayer :: Ptr a -> IO (VkArrayLayerMType a)

        writeVkArrayLayer :: Ptr a -> VkArrayLayerMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'arrayLayer'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkArrayLayer a

instance {-# OVERLAPPING #-} HasVkArrayLayer VkImageSubresource
         where
        type VkArrayLayerMType VkImageSubresource = Data.Word.Word32

        {-# NOINLINE vkArrayLayer #-}
        vkArrayLayer x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageSubresource, arrayLayer})

        {-# INLINE vkArrayLayerByteOffset #-}
        vkArrayLayerByteOffset ~_
          = #{offset VkImageSubresource, arrayLayer}

        {-# INLINE readVkArrayLayer #-}
        readVkArrayLayer p
          = peekByteOff p #{offset VkImageSubresource, arrayLayer}

        {-# INLINE writeVkArrayLayer #-}
        writeVkArrayLayer p
          = pokeByteOff p #{offset VkImageSubresource, arrayLayer}

instance Show VkImageSubresource where
        showsPrec d x
          = showString "VkImageSubresource {" .
              showString "vkAspectMask = " .
                showsPrec d (vkAspectMask x) .
                  showString ", " .
                    showString "vkMipLevel = " .
                      showsPrec d (vkMipLevel x) .
                        showString ", " .
                          showString "vkArrayLayer = " .
                            showsPrec d (vkArrayLayer x) . showChar '}'

data VkImageSubresourceLayers = VkImageSubresourceLayers## ByteArray##

instance Eq VkImageSubresourceLayers where
        (VkImageSubresourceLayers## a) == (VkImageSubresourceLayers## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageSubresourceLayers where
        (VkImageSubresourceLayers## a) `compare`
          (VkImageSubresourceLayers## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageSubresourceLayers where
        sizeOf ~_ = #{size VkImageSubresourceLayers}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageSubresourceLayers}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## a <- alignment (undefined :: VkImageSubresourceLayers) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkImageSubresourceLayers##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageSubresourceLayers## ba)
          | I## n <- sizeOf (undefined :: VkImageSubresourceLayers) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageSubresourceLayers where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## a <- alignment (undefined :: VkImageSubresourceLayers) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkImageSubresourceLayers##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkImageSubresourceLayers## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkImageSubresourceLayers##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkImageSubresourceLayers## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkImageSubresourceLayers## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkImageSubresourceLayers## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkAspectMask VkImageSubresourceLayers where
        type VkAspectMaskMType VkImageSubresourceLayers =
             VkImageAspectFlags

        {-# NOINLINE vkAspectMask #-}
        vkAspectMask x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageSubresourceLayers, aspectMask})

        {-# INLINE vkAspectMaskByteOffset #-}
        vkAspectMaskByteOffset ~_
          = #{offset VkImageSubresourceLayers, aspectMask}

        {-# INLINE readVkAspectMask #-}
        readVkAspectMask p
          = peekByteOff p
              #{offset VkImageSubresourceLayers, aspectMask}

        {-# INLINE writeVkAspectMask #-}
        writeVkAspectMask p
          = pokeByteOff p
              #{offset VkImageSubresourceLayers, aspectMask}

instance {-# OVERLAPPING #-} HasVkMipLevel VkImageSubresourceLayers
         where
        type VkMipLevelMType VkImageSubresourceLayers = Data.Word.Word32

        {-# NOINLINE vkMipLevel #-}
        vkMipLevel x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageSubresourceLayers, mipLevel})

        {-# INLINE vkMipLevelByteOffset #-}
        vkMipLevelByteOffset ~_
          = #{offset VkImageSubresourceLayers, mipLevel}

        {-# INLINE readVkMipLevel #-}
        readVkMipLevel p
          = peekByteOff p
              #{offset VkImageSubresourceLayers, mipLevel}

        {-# INLINE writeVkMipLevel #-}
        writeVkMipLevel p
          = pokeByteOff p
              #{offset VkImageSubresourceLayers, mipLevel}

instance {-# OVERLAPPING #-}
         HasVkBaseArrayLayer VkImageSubresourceLayers where
        type VkBaseArrayLayerMType VkImageSubresourceLayers =
             Data.Word.Word32

        {-# NOINLINE vkBaseArrayLayer #-}
        vkBaseArrayLayer x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageSubresourceLayers, baseArrayLayer})

        {-# INLINE vkBaseArrayLayerByteOffset #-}
        vkBaseArrayLayerByteOffset ~_
          = #{offset VkImageSubresourceLayers, baseArrayLayer}

        {-# INLINE readVkBaseArrayLayer #-}
        readVkBaseArrayLayer p
          = peekByteOff p
              #{offset VkImageSubresourceLayers, baseArrayLayer}

        {-# INLINE writeVkBaseArrayLayer #-}
        writeVkBaseArrayLayer p
          = pokeByteOff p
              #{offset VkImageSubresourceLayers, baseArrayLayer}

instance {-# OVERLAPPING #-}
         HasVkLayerCount VkImageSubresourceLayers where
        type VkLayerCountMType VkImageSubresourceLayers = Data.Word.Word32

        {-# NOINLINE vkLayerCount #-}
        vkLayerCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageSubresourceLayers, layerCount})

        {-# INLINE vkLayerCountByteOffset #-}
        vkLayerCountByteOffset ~_
          = #{offset VkImageSubresourceLayers, layerCount}

        {-# INLINE readVkLayerCount #-}
        readVkLayerCount p
          = peekByteOff p
              #{offset VkImageSubresourceLayers, layerCount}

        {-# INLINE writeVkLayerCount #-}
        writeVkLayerCount p
          = pokeByteOff p
              #{offset VkImageSubresourceLayers, layerCount}

instance Show VkImageSubresourceLayers where
        showsPrec d x
          = showString "VkImageSubresourceLayers {" .
              showString "vkAspectMask = " .
                showsPrec d (vkAspectMask x) .
                  showString ", " .
                    showString "vkMipLevel = " .
                      showsPrec d (vkMipLevel x) .
                        showString ", " .
                          showString "vkBaseArrayLayer = " .
                            showsPrec d (vkBaseArrayLayer x) .
                              showString ", " .
                                showString "vkLayerCount = " .
                                  showsPrec d (vkLayerCount x) . showChar '}'

data VkImageSubresourceRange = VkImageSubresourceRange## ByteArray##

instance Eq VkImageSubresourceRange where
        (VkImageSubresourceRange## a) == (VkImageSubresourceRange## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageSubresourceRange where
        (VkImageSubresourceRange## a) `compare` (VkImageSubresourceRange## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageSubresourceRange where
        sizeOf ~_ = #{size VkImageSubresourceRange}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageSubresourceRange}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageSubresourceRange),
            I## a <- alignment (undefined :: VkImageSubresourceRange) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkImageSubresourceRange##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageSubresourceRange## ba)
          | I## n <- sizeOf (undefined :: VkImageSubresourceRange) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageSubresourceRange where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkImageSubresourceRange),
            I## a <- alignment (undefined :: VkImageSubresourceRange) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkImageSubresourceRange##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkImageSubresourceRange## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkImageSubresourceRange##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkImageSubresourceRange## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkImageSubresourceRange## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkImageSubresourceRange## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkAspectMask VkImageSubresourceRange where
        type VkAspectMaskMType VkImageSubresourceRange = VkImageAspectFlags

        {-# NOINLINE vkAspectMask #-}
        vkAspectMask x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageSubresourceRange, aspectMask})

        {-# INLINE vkAspectMaskByteOffset #-}
        vkAspectMaskByteOffset ~_
          = #{offset VkImageSubresourceRange, aspectMask}

        {-# INLINE readVkAspectMask #-}
        readVkAspectMask p
          = peekByteOff p
              #{offset VkImageSubresourceRange, aspectMask}

        {-# INLINE writeVkAspectMask #-}
        writeVkAspectMask p
          = pokeByteOff p
              #{offset VkImageSubresourceRange, aspectMask}

class HasVkBaseMipLevel a where
        type VkBaseMipLevelMType a :: *

        vkBaseMipLevel :: a -> VkBaseMipLevelMType a

        vkBaseMipLevelByteOffset :: a -> Int

        readVkBaseMipLevel :: Ptr a -> IO (VkBaseMipLevelMType a)

        writeVkBaseMipLevel :: Ptr a -> VkBaseMipLevelMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'baseMipLevel'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBaseMipLevel a

instance {-# OVERLAPPING #-}
         HasVkBaseMipLevel VkImageSubresourceRange where
        type VkBaseMipLevelMType VkImageSubresourceRange = Data.Word.Word32

        {-# NOINLINE vkBaseMipLevel #-}
        vkBaseMipLevel x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageSubresourceRange, baseMipLevel})

        {-# INLINE vkBaseMipLevelByteOffset #-}
        vkBaseMipLevelByteOffset ~_
          = #{offset VkImageSubresourceRange, baseMipLevel}

        {-# INLINE readVkBaseMipLevel #-}
        readVkBaseMipLevel p
          = peekByteOff p
              #{offset VkImageSubresourceRange, baseMipLevel}

        {-# INLINE writeVkBaseMipLevel #-}
        writeVkBaseMipLevel p
          = pokeByteOff p
              #{offset VkImageSubresourceRange, baseMipLevel}

class HasVkLevelCount a where
        type VkLevelCountMType a :: *

        vkLevelCount :: a -> VkLevelCountMType a

        vkLevelCountByteOffset :: a -> Int

        readVkLevelCount :: Ptr a -> IO (VkLevelCountMType a)

        writeVkLevelCount :: Ptr a -> VkLevelCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'levelCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLevelCount a

instance {-# OVERLAPPING #-}
         HasVkLevelCount VkImageSubresourceRange where
        type VkLevelCountMType VkImageSubresourceRange = Data.Word.Word32

        {-# NOINLINE vkLevelCount #-}
        vkLevelCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageSubresourceRange, levelCount})

        {-# INLINE vkLevelCountByteOffset #-}
        vkLevelCountByteOffset ~_
          = #{offset VkImageSubresourceRange, levelCount}

        {-# INLINE readVkLevelCount #-}
        readVkLevelCount p
          = peekByteOff p
              #{offset VkImageSubresourceRange, levelCount}

        {-# INLINE writeVkLevelCount #-}
        writeVkLevelCount p
          = pokeByteOff p
              #{offset VkImageSubresourceRange, levelCount}

instance {-# OVERLAPPING #-}
         HasVkBaseArrayLayer VkImageSubresourceRange where
        type VkBaseArrayLayerMType VkImageSubresourceRange =
             Data.Word.Word32

        {-# NOINLINE vkBaseArrayLayer #-}
        vkBaseArrayLayer x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageSubresourceRange, baseArrayLayer})

        {-# INLINE vkBaseArrayLayerByteOffset #-}
        vkBaseArrayLayerByteOffset ~_
          = #{offset VkImageSubresourceRange, baseArrayLayer}

        {-# INLINE readVkBaseArrayLayer #-}
        readVkBaseArrayLayer p
          = peekByteOff p
              #{offset VkImageSubresourceRange, baseArrayLayer}

        {-# INLINE writeVkBaseArrayLayer #-}
        writeVkBaseArrayLayer p
          = pokeByteOff p
              #{offset VkImageSubresourceRange, baseArrayLayer}

instance {-# OVERLAPPING #-}
         HasVkLayerCount VkImageSubresourceRange where
        type VkLayerCountMType VkImageSubresourceRange = Data.Word.Word32

        {-# NOINLINE vkLayerCount #-}
        vkLayerCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageSubresourceRange, layerCount})

        {-# INLINE vkLayerCountByteOffset #-}
        vkLayerCountByteOffset ~_
          = #{offset VkImageSubresourceRange, layerCount}

        {-# INLINE readVkLayerCount #-}
        readVkLayerCount p
          = peekByteOff p
              #{offset VkImageSubresourceRange, layerCount}

        {-# INLINE writeVkLayerCount #-}
        writeVkLayerCount p
          = pokeByteOff p
              #{offset VkImageSubresourceRange, layerCount}

instance Show VkImageSubresourceRange where
        showsPrec d x
          = showString "VkImageSubresourceRange {" .
              showString "vkAspectMask = " .
                showsPrec d (vkAspectMask x) .
                  showString ", " .
                    showString "vkBaseMipLevel = " .
                      showsPrec d (vkBaseMipLevel x) .
                        showString ", " .
                          showString "vkLevelCount = " .
                            showsPrec d (vkLevelCount x) .
                              showString ", " .
                                showString "vkBaseArrayLayer = " .
                                  showsPrec d (vkBaseArrayLayer x) .
                                    showString ", " .
                                      showString "vkLayerCount = " .
                                        showsPrec d (vkLayerCount x) . showChar '}'

data VkImageCreateInfo = VkImageCreateInfo## ByteArray##

instance Eq VkImageCreateInfo where
        (VkImageCreateInfo## a) == (VkImageCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageCreateInfo where
        (VkImageCreateInfo## a) `compare` (VkImageCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageCreateInfo where
        sizeOf ~_ = #{size VkImageCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageCreateInfo),
            I## a <- alignment (undefined :: VkImageCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkImageCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkImageCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkImageCreateInfo),
            I## a <- alignment (undefined :: VkImageCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkImageCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkImageCreateInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkImageCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkImageCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkImageCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkImageCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkImageCreateInfo where
        type VkSTypeMType VkImageCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_ = #{offset VkImageCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkImageCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkImageCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkImageCreateInfo where
        type VkPNextMType VkImageCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_ = #{offset VkImageCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkImageCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkImageCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkImageCreateInfo where
        type VkFlagsMType VkImageCreateInfo = VkImageCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_ = #{offset VkImageCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkImageCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkImageCreateInfo, flags}

class HasVkImageType a where
        type VkImageTypeMType a :: *

        vkImageType :: a -> VkImageTypeMType a

        vkImageTypeByteOffset :: a -> Int

        readVkImageType :: Ptr a -> IO (VkImageTypeMType a)

        writeVkImageType :: Ptr a -> VkImageTypeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageType'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageType a

instance {-# OVERLAPPING #-} HasVkImageType VkImageCreateInfo where
        type VkImageTypeMType VkImageCreateInfo = VkImageType

        {-# NOINLINE vkImageType #-}
        vkImageType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, imageType})

        {-# INLINE vkImageTypeByteOffset #-}
        vkImageTypeByteOffset ~_
          = #{offset VkImageCreateInfo, imageType}

        {-# INLINE readVkImageType #-}
        readVkImageType p
          = peekByteOff p #{offset VkImageCreateInfo, imageType}

        {-# INLINE writeVkImageType #-}
        writeVkImageType p
          = pokeByteOff p #{offset VkImageCreateInfo, imageType}

instance {-# OVERLAPPING #-} HasVkFormat VkImageCreateInfo where
        type VkFormatMType VkImageCreateInfo = VkFormat

        {-# NOINLINE vkFormat #-}
        vkFormat x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, format})

        {-# INLINE vkFormatByteOffset #-}
        vkFormatByteOffset ~_
          = #{offset VkImageCreateInfo, format}

        {-# INLINE readVkFormat #-}
        readVkFormat p
          = peekByteOff p #{offset VkImageCreateInfo, format}

        {-# INLINE writeVkFormat #-}
        writeVkFormat p
          = pokeByteOff p #{offset VkImageCreateInfo, format}

instance {-# OVERLAPPING #-} HasVkExtent VkImageCreateInfo where
        type VkExtentMType VkImageCreateInfo = VkExtent3D

        {-# NOINLINE vkExtent #-}
        vkExtent x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, extent})

        {-# INLINE vkExtentByteOffset #-}
        vkExtentByteOffset ~_
          = #{offset VkImageCreateInfo, extent}

        {-# INLINE readVkExtent #-}
        readVkExtent p
          = peekByteOff p #{offset VkImageCreateInfo, extent}

        {-# INLINE writeVkExtent #-}
        writeVkExtent p
          = pokeByteOff p #{offset VkImageCreateInfo, extent}

class HasVkMipLevels a where
        type VkMipLevelsMType a :: *

        vkMipLevels :: a -> VkMipLevelsMType a

        vkMipLevelsByteOffset :: a -> Int

        readVkMipLevels :: Ptr a -> IO (VkMipLevelsMType a)

        writeVkMipLevels :: Ptr a -> VkMipLevelsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'mipLevels'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMipLevels a

instance {-# OVERLAPPING #-} HasVkMipLevels VkImageCreateInfo where
        type VkMipLevelsMType VkImageCreateInfo = Data.Word.Word32

        {-# NOINLINE vkMipLevels #-}
        vkMipLevels x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, mipLevels})

        {-# INLINE vkMipLevelsByteOffset #-}
        vkMipLevelsByteOffset ~_
          = #{offset VkImageCreateInfo, mipLevels}

        {-# INLINE readVkMipLevels #-}
        readVkMipLevels p
          = peekByteOff p #{offset VkImageCreateInfo, mipLevels}

        {-# INLINE writeVkMipLevels #-}
        writeVkMipLevels p
          = pokeByteOff p #{offset VkImageCreateInfo, mipLevels}

class HasVkArrayLayers a where
        type VkArrayLayersMType a :: *

        vkArrayLayers :: a -> VkArrayLayersMType a

        vkArrayLayersByteOffset :: a -> Int

        readVkArrayLayers :: Ptr a -> IO (VkArrayLayersMType a)

        writeVkArrayLayers :: Ptr a -> VkArrayLayersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'arrayLayers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkArrayLayers a

instance {-# OVERLAPPING #-} HasVkArrayLayers VkImageCreateInfo
         where
        type VkArrayLayersMType VkImageCreateInfo = Data.Word.Word32

        {-# NOINLINE vkArrayLayers #-}
        vkArrayLayers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, arrayLayers})

        {-# INLINE vkArrayLayersByteOffset #-}
        vkArrayLayersByteOffset ~_
          = #{offset VkImageCreateInfo, arrayLayers}

        {-# INLINE readVkArrayLayers #-}
        readVkArrayLayers p
          = peekByteOff p #{offset VkImageCreateInfo, arrayLayers}

        {-# INLINE writeVkArrayLayers #-}
        writeVkArrayLayers p
          = pokeByteOff p #{offset VkImageCreateInfo, arrayLayers}

class HasVkSamples a where
        type VkSamplesMType a :: *

        vkSamples :: a -> VkSamplesMType a

        vkSamplesByteOffset :: a -> Int

        readVkSamples :: Ptr a -> IO (VkSamplesMType a)

        writeVkSamples :: Ptr a -> VkSamplesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'samples'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSamples a

instance {-# OVERLAPPING #-} HasVkSamples VkImageCreateInfo where
        type VkSamplesMType VkImageCreateInfo = VkSampleCountFlagBits

        {-# NOINLINE vkSamples #-}
        vkSamples x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, samples})

        {-# INLINE vkSamplesByteOffset #-}
        vkSamplesByteOffset ~_
          = #{offset VkImageCreateInfo, samples}

        {-# INLINE readVkSamples #-}
        readVkSamples p
          = peekByteOff p #{offset VkImageCreateInfo, samples}

        {-# INLINE writeVkSamples #-}
        writeVkSamples p
          = pokeByteOff p #{offset VkImageCreateInfo, samples}

class HasVkTiling a where
        type VkTilingMType a :: *

        vkTiling :: a -> VkTilingMType a

        vkTilingByteOffset :: a -> Int

        readVkTiling :: Ptr a -> IO (VkTilingMType a)

        writeVkTiling :: Ptr a -> VkTilingMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'tiling'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTiling a

instance {-# OVERLAPPING #-} HasVkTiling VkImageCreateInfo where
        type VkTilingMType VkImageCreateInfo = VkImageTiling

        {-# NOINLINE vkTiling #-}
        vkTiling x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, tiling})

        {-# INLINE vkTilingByteOffset #-}
        vkTilingByteOffset ~_
          = #{offset VkImageCreateInfo, tiling}

        {-# INLINE readVkTiling #-}
        readVkTiling p
          = peekByteOff p #{offset VkImageCreateInfo, tiling}

        {-# INLINE writeVkTiling #-}
        writeVkTiling p
          = pokeByteOff p #{offset VkImageCreateInfo, tiling}

instance {-# OVERLAPPING #-} HasVkUsage VkImageCreateInfo where
        type VkUsageMType VkImageCreateInfo = VkImageUsageFlags

        {-# NOINLINE vkUsage #-}
        vkUsage x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, usage})

        {-# INLINE vkUsageByteOffset #-}
        vkUsageByteOffset ~_ = #{offset VkImageCreateInfo, usage}

        {-# INLINE readVkUsage #-}
        readVkUsage p
          = peekByteOff p #{offset VkImageCreateInfo, usage}

        {-# INLINE writeVkUsage #-}
        writeVkUsage p
          = pokeByteOff p #{offset VkImageCreateInfo, usage}

instance {-# OVERLAPPING #-} HasVkSharingMode VkImageCreateInfo
         where
        type VkSharingModeMType VkImageCreateInfo = VkSharingMode

        {-# NOINLINE vkSharingMode #-}
        vkSharingMode x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, sharingMode})

        {-# INLINE vkSharingModeByteOffset #-}
        vkSharingModeByteOffset ~_
          = #{offset VkImageCreateInfo, sharingMode}

        {-# INLINE readVkSharingMode #-}
        readVkSharingMode p
          = peekByteOff p #{offset VkImageCreateInfo, sharingMode}

        {-# INLINE writeVkSharingMode #-}
        writeVkSharingMode p
          = pokeByteOff p #{offset VkImageCreateInfo, sharingMode}

instance {-# OVERLAPPING #-}
         HasVkQueueFamilyIndexCount VkImageCreateInfo where
        type VkQueueFamilyIndexCountMType VkImageCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkQueueFamilyIndexCount #-}
        vkQueueFamilyIndexCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, queueFamilyIndexCount})

        {-# INLINE vkQueueFamilyIndexCountByteOffset #-}
        vkQueueFamilyIndexCountByteOffset ~_
          = #{offset VkImageCreateInfo, queueFamilyIndexCount}

        {-# INLINE readVkQueueFamilyIndexCount #-}
        readVkQueueFamilyIndexCount p
          = peekByteOff p
              #{offset VkImageCreateInfo, queueFamilyIndexCount}

        {-# INLINE writeVkQueueFamilyIndexCount #-}
        writeVkQueueFamilyIndexCount p
          = pokeByteOff p
              #{offset VkImageCreateInfo, queueFamilyIndexCount}

instance {-# OVERLAPPING #-}
         HasVkPQueueFamilyIndices VkImageCreateInfo where
        type VkPQueueFamilyIndicesMType VkImageCreateInfo =
             Foreign.Ptr.Ptr Data.Word.Word32

        {-# NOINLINE vkPQueueFamilyIndices #-}
        vkPQueueFamilyIndices x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, pQueueFamilyIndices})

        {-# INLINE vkPQueueFamilyIndicesByteOffset #-}
        vkPQueueFamilyIndicesByteOffset ~_
          = #{offset VkImageCreateInfo, pQueueFamilyIndices}

        {-# INLINE readVkPQueueFamilyIndices #-}
        readVkPQueueFamilyIndices p
          = peekByteOff p
              #{offset VkImageCreateInfo, pQueueFamilyIndices}

        {-# INLINE writeVkPQueueFamilyIndices #-}
        writeVkPQueueFamilyIndices p
          = pokeByteOff p
              #{offset VkImageCreateInfo, pQueueFamilyIndices}

class HasVkInitialLayout a where
        type VkInitialLayoutMType a :: *

        vkInitialLayout :: a -> VkInitialLayoutMType a

        vkInitialLayoutByteOffset :: a -> Int

        readVkInitialLayout :: Ptr a -> IO (VkInitialLayoutMType a)

        writeVkInitialLayout :: Ptr a -> VkInitialLayoutMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'initialLayout'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkInitialLayout a

instance {-# OVERLAPPING #-} HasVkInitialLayout VkImageCreateInfo
         where
        type VkInitialLayoutMType VkImageCreateInfo = VkImageLayout

        {-# NOINLINE vkInitialLayout #-}
        vkInitialLayout x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCreateInfo, initialLayout})

        {-# INLINE vkInitialLayoutByteOffset #-}
        vkInitialLayoutByteOffset ~_
          = #{offset VkImageCreateInfo, initialLayout}

        {-# INLINE readVkInitialLayout #-}
        readVkInitialLayout p
          = peekByteOff p #{offset VkImageCreateInfo, initialLayout}

        {-# INLINE writeVkInitialLayout #-}
        writeVkInitialLayout p
          = pokeByteOff p #{offset VkImageCreateInfo, initialLayout}

instance Show VkImageCreateInfo where
        showsPrec d x
          = showString "VkImageCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkImageType = " .
                                  showsPrec d (vkImageType x) .
                                    showString ", " .
                                      showString "vkFormat = " .
                                        showsPrec d (vkFormat x) .
                                          showString ", " .
                                            showString "vkExtent = " .
                                              showsPrec d (vkExtent x) .
                                                showString ", " .
                                                  showString "vkMipLevels = " .
                                                    showsPrec d (vkMipLevels x) .
                                                      showString ", " .
                                                        showString "vkArrayLayers = " .
                                                          showsPrec d (vkArrayLayers x) .
                                                            showString ", " .
                                                              showString "vkSamples = " .
                                                                showsPrec d (vkSamples x) .
                                                                  showString ", " .
                                                                    showString "vkTiling = " .
                                                                      showsPrec d (vkTiling x) .
                                                                        showString ", " .
                                                                          showString "vkUsage = " .
                                                                            showsPrec d (vkUsage x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkSharingMode = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkSharingMode
                                                                                       x)
                                                                                    .
                                                                                    showString ", "
                                                                                      .
                                                                                      showString
                                                                                        "vkQueueFamilyIndexCount = "
                                                                                        .
                                                                                        showsPrec d
                                                                                          (vkQueueFamilyIndexCount
                                                                                             x)
                                                                                          .
                                                                                          showString
                                                                                            ", "
                                                                                            .
                                                                                            showString
                                                                                              "vkPQueueFamilyIndices = "
                                                                                              .
                                                                                              showsPrec
                                                                                                d
                                                                                                (vkPQueueFamilyIndices
                                                                                                   x)
                                                                                                .
                                                                                                showString
                                                                                                  ", "
                                                                                                  .
                                                                                                  showString
                                                                                                    "vkInitialLayout = "
                                                                                                    .
                                                                                                    showsPrec
                                                                                                      d
                                                                                                      (vkInitialLayout
                                                                                                         x)
                                                                                                      .
                                                                                                      showChar
                                                                                                        '}'

data VkSubresourceLayout = VkSubresourceLayout## ByteArray##

instance Eq VkSubresourceLayout where
        (VkSubresourceLayout## a) == (VkSubresourceLayout## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSubresourceLayout where
        (VkSubresourceLayout## a) `compare` (VkSubresourceLayout## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSubresourceLayout where
        sizeOf ~_ = #{size VkSubresourceLayout}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSubresourceLayout}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSubresourceLayout),
            I## a <- alignment (undefined :: VkSubresourceLayout) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSubresourceLayout## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSubresourceLayout## ba)
          | I## n <- sizeOf (undefined :: VkSubresourceLayout) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSubresourceLayout where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSubresourceLayout),
            I## a <- alignment (undefined :: VkSubresourceLayout) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSubresourceLayout##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSubresourceLayout## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSubresourceLayout##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSubresourceLayout## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSubresourceLayout## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSubresourceLayout## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkOffset VkSubresourceLayout where
        type VkOffsetMType VkSubresourceLayout = VkDeviceSize

        {-# NOINLINE vkOffset #-}
        vkOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubresourceLayout, offset})

        {-# INLINE vkOffsetByteOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkSubresourceLayout, offset}

        {-# INLINE readVkOffset #-}
        readVkOffset p
          = peekByteOff p #{offset VkSubresourceLayout, offset}

        {-# INLINE writeVkOffset #-}
        writeVkOffset p
          = pokeByteOff p #{offset VkSubresourceLayout, offset}

instance {-# OVERLAPPING #-} HasVkSize VkSubresourceLayout where
        type VkSizeMType VkSubresourceLayout = VkDeviceSize

        {-# NOINLINE vkSize #-}
        vkSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubresourceLayout, size})

        {-# INLINE vkSizeByteOffset #-}
        vkSizeByteOffset ~_ = #{offset VkSubresourceLayout, size}

        {-# INLINE readVkSize #-}
        readVkSize p
          = peekByteOff p #{offset VkSubresourceLayout, size}

        {-# INLINE writeVkSize #-}
        writeVkSize p
          = pokeByteOff p #{offset VkSubresourceLayout, size}

class HasVkRowPitch a where
        type VkRowPitchMType a :: *

        vkRowPitch :: a -> VkRowPitchMType a

        vkRowPitchByteOffset :: a -> Int

        readVkRowPitch :: Ptr a -> IO (VkRowPitchMType a)

        writeVkRowPitch :: Ptr a -> VkRowPitchMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'rowPitch'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRowPitch a

instance {-# OVERLAPPING #-} HasVkRowPitch VkSubresourceLayout
         where
        type VkRowPitchMType VkSubresourceLayout = VkDeviceSize

        {-# NOINLINE vkRowPitch #-}
        vkRowPitch x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubresourceLayout, rowPitch})

        {-# INLINE vkRowPitchByteOffset #-}
        vkRowPitchByteOffset ~_
          = #{offset VkSubresourceLayout, rowPitch}

        {-# INLINE readVkRowPitch #-}
        readVkRowPitch p
          = peekByteOff p #{offset VkSubresourceLayout, rowPitch}

        {-# INLINE writeVkRowPitch #-}
        writeVkRowPitch p
          = pokeByteOff p #{offset VkSubresourceLayout, rowPitch}

class HasVkArrayPitch a where
        type VkArrayPitchMType a :: *

        vkArrayPitch :: a -> VkArrayPitchMType a

        vkArrayPitchByteOffset :: a -> Int

        readVkArrayPitch :: Ptr a -> IO (VkArrayPitchMType a)

        writeVkArrayPitch :: Ptr a -> VkArrayPitchMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'arrayPitch'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkArrayPitch a

instance {-# OVERLAPPING #-} HasVkArrayPitch VkSubresourceLayout
         where
        type VkArrayPitchMType VkSubresourceLayout = VkDeviceSize

        {-# NOINLINE vkArrayPitch #-}
        vkArrayPitch x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubresourceLayout, arrayPitch})

        {-# INLINE vkArrayPitchByteOffset #-}
        vkArrayPitchByteOffset ~_
          = #{offset VkSubresourceLayout, arrayPitch}

        {-# INLINE readVkArrayPitch #-}
        readVkArrayPitch p
          = peekByteOff p #{offset VkSubresourceLayout, arrayPitch}

        {-# INLINE writeVkArrayPitch #-}
        writeVkArrayPitch p
          = pokeByteOff p #{offset VkSubresourceLayout, arrayPitch}

class HasVkDepthPitch a where
        type VkDepthPitchMType a :: *

        vkDepthPitch :: a -> VkDepthPitchMType a

        vkDepthPitchByteOffset :: a -> Int

        readVkDepthPitch :: Ptr a -> IO (VkDepthPitchMType a)

        writeVkDepthPitch :: Ptr a -> VkDepthPitchMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthPitch'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthPitch a

instance {-# OVERLAPPING #-} HasVkDepthPitch VkSubresourceLayout
         where
        type VkDepthPitchMType VkSubresourceLayout = VkDeviceSize

        {-# NOINLINE vkDepthPitch #-}
        vkDepthPitch x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubresourceLayout, depthPitch})

        {-# INLINE vkDepthPitchByteOffset #-}
        vkDepthPitchByteOffset ~_
          = #{offset VkSubresourceLayout, depthPitch}

        {-# INLINE readVkDepthPitch #-}
        readVkDepthPitch p
          = peekByteOff p #{offset VkSubresourceLayout, depthPitch}

        {-# INLINE writeVkDepthPitch #-}
        writeVkDepthPitch p
          = pokeByteOff p #{offset VkSubresourceLayout, depthPitch}

instance Show VkSubresourceLayout where
        showsPrec d x
          = showString "VkSubresourceLayout {" .
              showString "vkOffset = " .
                showsPrec d (vkOffset x) .
                  showString ", " .
                    showString "vkSize = " .
                      showsPrec d (vkSize x) .
                        showString ", " .
                          showString "vkRowPitch = " .
                            showsPrec d (vkRowPitch x) .
                              showString ", " .
                                showString "vkArrayPitch = " .
                                  showsPrec d (vkArrayPitch x) .
                                    showString ", " .
                                      showString "vkDepthPitch = " .
                                        showsPrec d (vkDepthPitch x) . showChar '}'

data VkImageViewCreateInfo = VkImageViewCreateInfo## ByteArray##

instance Eq VkImageViewCreateInfo where
        (VkImageViewCreateInfo## a) == (VkImageViewCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageViewCreateInfo where
        (VkImageViewCreateInfo## a) `compare` (VkImageViewCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageViewCreateInfo where
        sizeOf ~_ = #{size VkImageViewCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageViewCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageViewCreateInfo),
            I## a <- alignment (undefined :: VkImageViewCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkImageViewCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageViewCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkImageViewCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageViewCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkImageViewCreateInfo),
            I## a <- alignment (undefined :: VkImageViewCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkImageViewCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkImageViewCreateInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkImageViewCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkImageViewCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkImageViewCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkImageViewCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkImageViewCreateInfo where
        type VkSTypeMType VkImageViewCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageViewCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkImageViewCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkImageViewCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkImageViewCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkImageViewCreateInfo where
        type VkPNextMType VkImageViewCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageViewCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkImageViewCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkImageViewCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkImageViewCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkImageViewCreateInfo where
        type VkFlagsMType VkImageViewCreateInfo = VkImageViewCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageViewCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkImageViewCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkImageViewCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkImageViewCreateInfo, flags}

class HasVkImage a where
        type VkImageMType a :: *

        vkImage :: a -> VkImageMType a

        vkImageByteOffset :: a -> Int

        readVkImage :: Ptr a -> IO (VkImageMType a)

        writeVkImage :: Ptr a -> VkImageMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'image'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImage a

instance {-# OVERLAPPING #-} HasVkImage VkImageViewCreateInfo where
        type VkImageMType VkImageViewCreateInfo = VkImage

        {-# NOINLINE vkImage #-}
        vkImage x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageViewCreateInfo, image})

        {-# INLINE vkImageByteOffset #-}
        vkImageByteOffset ~_
          = #{offset VkImageViewCreateInfo, image}

        {-# INLINE readVkImage #-}
        readVkImage p
          = peekByteOff p #{offset VkImageViewCreateInfo, image}

        {-# INLINE writeVkImage #-}
        writeVkImage p
          = pokeByteOff p #{offset VkImageViewCreateInfo, image}

class HasVkViewType a where
        type VkViewTypeMType a :: *

        vkViewType :: a -> VkViewTypeMType a

        vkViewTypeByteOffset :: a -> Int

        readVkViewType :: Ptr a -> IO (VkViewTypeMType a)

        writeVkViewType :: Ptr a -> VkViewTypeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'viewType'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkViewType a

instance {-# OVERLAPPING #-} HasVkViewType VkImageViewCreateInfo
         where
        type VkViewTypeMType VkImageViewCreateInfo = VkImageViewType

        {-# NOINLINE vkViewType #-}
        vkViewType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageViewCreateInfo, viewType})

        {-# INLINE vkViewTypeByteOffset #-}
        vkViewTypeByteOffset ~_
          = #{offset VkImageViewCreateInfo, viewType}

        {-# INLINE readVkViewType #-}
        readVkViewType p
          = peekByteOff p #{offset VkImageViewCreateInfo, viewType}

        {-# INLINE writeVkViewType #-}
        writeVkViewType p
          = pokeByteOff p #{offset VkImageViewCreateInfo, viewType}

instance {-# OVERLAPPING #-} HasVkFormat VkImageViewCreateInfo
         where
        type VkFormatMType VkImageViewCreateInfo = VkFormat

        {-# NOINLINE vkFormat #-}
        vkFormat x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageViewCreateInfo, format})

        {-# INLINE vkFormatByteOffset #-}
        vkFormatByteOffset ~_
          = #{offset VkImageViewCreateInfo, format}

        {-# INLINE readVkFormat #-}
        readVkFormat p
          = peekByteOff p #{offset VkImageViewCreateInfo, format}

        {-# INLINE writeVkFormat #-}
        writeVkFormat p
          = pokeByteOff p #{offset VkImageViewCreateInfo, format}

class HasVkComponents a where
        type VkComponentsMType a :: *

        vkComponents :: a -> VkComponentsMType a

        vkComponentsByteOffset :: a -> Int

        readVkComponents :: Ptr a -> IO (VkComponentsMType a)

        writeVkComponents :: Ptr a -> VkComponentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'components'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkComponents a

instance {-# OVERLAPPING #-} HasVkComponents VkImageViewCreateInfo
         where
        type VkComponentsMType VkImageViewCreateInfo = VkComponentMapping

        {-# NOINLINE vkComponents #-}
        vkComponents x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageViewCreateInfo, components})

        {-# INLINE vkComponentsByteOffset #-}
        vkComponentsByteOffset ~_
          = #{offset VkImageViewCreateInfo, components}

        {-# INLINE readVkComponents #-}
        readVkComponents p
          = peekByteOff p
              #{offset VkImageViewCreateInfo, components}

        {-# INLINE writeVkComponents #-}
        writeVkComponents p
          = pokeByteOff p
              #{offset VkImageViewCreateInfo, components}

class HasVkSubresourceRange a where
        type VkSubresourceRangeMType a :: *

        vkSubresourceRange :: a -> VkSubresourceRangeMType a

        vkSubresourceRangeByteOffset :: a -> Int

        readVkSubresourceRange :: Ptr a -> IO (VkSubresourceRangeMType a)

        writeVkSubresourceRange ::
                                Ptr a -> VkSubresourceRangeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'subresourceRange'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSubresourceRange a

instance {-# OVERLAPPING #-}
         HasVkSubresourceRange VkImageViewCreateInfo where
        type VkSubresourceRangeMType VkImageViewCreateInfo =
             VkImageSubresourceRange

        {-# NOINLINE vkSubresourceRange #-}
        vkSubresourceRange x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageViewCreateInfo, subresourceRange})

        {-# INLINE vkSubresourceRangeByteOffset #-}
        vkSubresourceRangeByteOffset ~_
          = #{offset VkImageViewCreateInfo, subresourceRange}

        {-# INLINE readVkSubresourceRange #-}
        readVkSubresourceRange p
          = peekByteOff p
              #{offset VkImageViewCreateInfo, subresourceRange}

        {-# INLINE writeVkSubresourceRange #-}
        writeVkSubresourceRange p
          = pokeByteOff p
              #{offset VkImageViewCreateInfo, subresourceRange}

instance Show VkImageViewCreateInfo where
        showsPrec d x
          = showString "VkImageViewCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkImage = " .
                                  showsPrec d (vkImage x) .
                                    showString ", " .
                                      showString "vkViewType = " .
                                        showsPrec d (vkViewType x) .
                                          showString ", " .
                                            showString "vkFormat = " .
                                              showsPrec d (vkFormat x) .
                                                showString ", " .
                                                  showString "vkComponents = " .
                                                    showsPrec d (vkComponents x) .
                                                      showString ", " .
                                                        showString "vkSubresourceRange = " .
                                                          showsPrec d (vkSubresourceRange x) .
                                                            showChar '}'

data VkBufferCopy = VkBufferCopy## ByteArray##

instance Eq VkBufferCopy where
        (VkBufferCopy## a) == (VkBufferCopy## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkBufferCopy where
        (VkBufferCopy## a) `compare` (VkBufferCopy## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkBufferCopy where
        sizeOf ~_ = #{size VkBufferCopy}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkBufferCopy}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkBufferCopy),
            I## a <- alignment (undefined :: VkBufferCopy) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkBufferCopy## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkBufferCopy## ba)
          | I## n <- sizeOf (undefined :: VkBufferCopy) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkBufferCopy where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkBufferCopy),
            I## a <- alignment (undefined :: VkBufferCopy) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkBufferCopy##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkBufferCopy## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkBufferCopy##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkBufferCopy## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkBufferCopy## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkBufferCopy## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkSrcOffset a where
        type VkSrcOffsetMType a :: *

        vkSrcOffset :: a -> VkSrcOffsetMType a

        vkSrcOffsetByteOffset :: a -> Int

        readVkSrcOffset :: Ptr a -> IO (VkSrcOffsetMType a)

        writeVkSrcOffset :: Ptr a -> VkSrcOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcOffset a

instance {-# OVERLAPPING #-} HasVkSrcOffset VkBufferCopy where
        type VkSrcOffsetMType VkBufferCopy = VkDeviceSize

        {-# NOINLINE vkSrcOffset #-}
        vkSrcOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferCopy, srcOffset})

        {-# INLINE vkSrcOffsetByteOffset #-}
        vkSrcOffsetByteOffset ~_
          = #{offset VkBufferCopy, srcOffset}

        {-# INLINE readVkSrcOffset #-}
        readVkSrcOffset p
          = peekByteOff p #{offset VkBufferCopy, srcOffset}

        {-# INLINE writeVkSrcOffset #-}
        writeVkSrcOffset p
          = pokeByteOff p #{offset VkBufferCopy, srcOffset}

class HasVkDstOffset a where
        type VkDstOffsetMType a :: *

        vkDstOffset :: a -> VkDstOffsetMType a

        vkDstOffsetByteOffset :: a -> Int

        readVkDstOffset :: Ptr a -> IO (VkDstOffsetMType a)

        writeVkDstOffset :: Ptr a -> VkDstOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstOffset a

instance {-# OVERLAPPING #-} HasVkDstOffset VkBufferCopy where
        type VkDstOffsetMType VkBufferCopy = VkDeviceSize

        {-# NOINLINE vkDstOffset #-}
        vkDstOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferCopy, dstOffset})

        {-# INLINE vkDstOffsetByteOffset #-}
        vkDstOffsetByteOffset ~_
          = #{offset VkBufferCopy, dstOffset}

        {-# INLINE readVkDstOffset #-}
        readVkDstOffset p
          = peekByteOff p #{offset VkBufferCopy, dstOffset}

        {-# INLINE writeVkDstOffset #-}
        writeVkDstOffset p
          = pokeByteOff p #{offset VkBufferCopy, dstOffset}

instance {-# OVERLAPPING #-} HasVkSize VkBufferCopy where
        type VkSizeMType VkBufferCopy = VkDeviceSize

        {-# NOINLINE vkSize #-}
        vkSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkBufferCopy, size})

        {-# INLINE vkSizeByteOffset #-}
        vkSizeByteOffset ~_ = #{offset VkBufferCopy, size}

        {-# INLINE readVkSize #-}
        readVkSize p = peekByteOff p #{offset VkBufferCopy, size}

        {-# INLINE writeVkSize #-}
        writeVkSize p = pokeByteOff p #{offset VkBufferCopy, size}

instance Show VkBufferCopy where
        showsPrec d x
          = showString "VkBufferCopy {" .
              showString "vkSrcOffset = " .
                showsPrec d (vkSrcOffset x) .
                  showString ", " .
                    showString "vkDstOffset = " .
                      showsPrec d (vkDstOffset x) .
                        showString ", " .
                          showString "vkSize = " . showsPrec d (vkSize x) . showChar '}'

data VkSparseMemoryBind = VkSparseMemoryBind## ByteArray##

instance Eq VkSparseMemoryBind where
        (VkSparseMemoryBind## a) == (VkSparseMemoryBind## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSparseMemoryBind where
        (VkSparseMemoryBind## a) `compare` (VkSparseMemoryBind## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSparseMemoryBind where
        sizeOf ~_ = #{size VkSparseMemoryBind}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSparseMemoryBind}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSparseMemoryBind),
            I## a <- alignment (undefined :: VkSparseMemoryBind) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSparseMemoryBind## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSparseMemoryBind## ba)
          | I## n <- sizeOf (undefined :: VkSparseMemoryBind) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSparseMemoryBind where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSparseMemoryBind),
            I## a <- alignment (undefined :: VkSparseMemoryBind) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSparseMemoryBind##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSparseMemoryBind## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSparseMemoryBind##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSparseMemoryBind## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSparseMemoryBind## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSparseMemoryBind## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkResourceOffset a where
        type VkResourceOffsetMType a :: *

        vkResourceOffset :: a -> VkResourceOffsetMType a

        vkResourceOffsetByteOffset :: a -> Int

        readVkResourceOffset :: Ptr a -> IO (VkResourceOffsetMType a)

        writeVkResourceOffset :: Ptr a -> VkResourceOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'resourceOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkResourceOffset a

instance {-# OVERLAPPING #-} HasVkResourceOffset VkSparseMemoryBind
         where
        type VkResourceOffsetMType VkSparseMemoryBind = VkDeviceSize

        {-# NOINLINE vkResourceOffset #-}
        vkResourceOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseMemoryBind, resourceOffset})

        {-# INLINE vkResourceOffsetByteOffset #-}
        vkResourceOffsetByteOffset ~_
          = #{offset VkSparseMemoryBind, resourceOffset}

        {-# INLINE readVkResourceOffset #-}
        readVkResourceOffset p
          = peekByteOff p
              #{offset VkSparseMemoryBind, resourceOffset}

        {-# INLINE writeVkResourceOffset #-}
        writeVkResourceOffset p
          = pokeByteOff p
              #{offset VkSparseMemoryBind, resourceOffset}

instance {-# OVERLAPPING #-} HasVkSize VkSparseMemoryBind where
        type VkSizeMType VkSparseMemoryBind = VkDeviceSize

        {-# NOINLINE vkSize #-}
        vkSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseMemoryBind, size})

        {-# INLINE vkSizeByteOffset #-}
        vkSizeByteOffset ~_ = #{offset VkSparseMemoryBind, size}

        {-# INLINE readVkSize #-}
        readVkSize p
          = peekByteOff p #{offset VkSparseMemoryBind, size}

        {-# INLINE writeVkSize #-}
        writeVkSize p
          = pokeByteOff p #{offset VkSparseMemoryBind, size}

instance {-# OVERLAPPING #-} HasVkMemory VkSparseMemoryBind where
        type VkMemoryMType VkSparseMemoryBind = VkDeviceMemory

        {-# NOINLINE vkMemory #-}
        vkMemory x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseMemoryBind, memory})

        {-# INLINE vkMemoryByteOffset #-}
        vkMemoryByteOffset ~_
          = #{offset VkSparseMemoryBind, memory}

        {-# INLINE readVkMemory #-}
        readVkMemory p
          = peekByteOff p #{offset VkSparseMemoryBind, memory}

        {-# INLINE writeVkMemory #-}
        writeVkMemory p
          = pokeByteOff p #{offset VkSparseMemoryBind, memory}

class HasVkMemoryOffset a where
        type VkMemoryOffsetMType a :: *

        vkMemoryOffset :: a -> VkMemoryOffsetMType a

        vkMemoryOffsetByteOffset :: a -> Int

        readVkMemoryOffset :: Ptr a -> IO (VkMemoryOffsetMType a)

        writeVkMemoryOffset :: Ptr a -> VkMemoryOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memoryOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemoryOffset a

instance {-# OVERLAPPING #-} HasVkMemoryOffset VkSparseMemoryBind
         where
        type VkMemoryOffsetMType VkSparseMemoryBind = VkDeviceSize

        {-# NOINLINE vkMemoryOffset #-}
        vkMemoryOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseMemoryBind, memoryOffset})

        {-# INLINE vkMemoryOffsetByteOffset #-}
        vkMemoryOffsetByteOffset ~_
          = #{offset VkSparseMemoryBind, memoryOffset}

        {-# INLINE readVkMemoryOffset #-}
        readVkMemoryOffset p
          = peekByteOff p #{offset VkSparseMemoryBind, memoryOffset}

        {-# INLINE writeVkMemoryOffset #-}
        writeVkMemoryOffset p
          = pokeByteOff p #{offset VkSparseMemoryBind, memoryOffset}

instance {-# OVERLAPPING #-} HasVkFlags VkSparseMemoryBind where
        type VkFlagsMType VkSparseMemoryBind = VkSparseMemoryBindFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseMemoryBind, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_ = #{offset VkSparseMemoryBind, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkSparseMemoryBind, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkSparseMemoryBind, flags}

instance Show VkSparseMemoryBind where
        showsPrec d x
          = showString "VkSparseMemoryBind {" .
              showString "vkResourceOffset = " .
                showsPrec d (vkResourceOffset x) .
                  showString ", " .
                    showString "vkSize = " .
                      showsPrec d (vkSize x) .
                        showString ", " .
                          showString "vkMemory = " .
                            showsPrec d (vkMemory x) .
                              showString ", " .
                                showString "vkMemoryOffset = " .
                                  showsPrec d (vkMemoryOffset x) .
                                    showString ", " .
                                      showString "vkFlags = " .
                                        showsPrec d (vkFlags x) . showChar '}'

data VkSparseImageMemoryBind = VkSparseImageMemoryBind## ByteArray##

instance Eq VkSparseImageMemoryBind where
        (VkSparseImageMemoryBind## a) == (VkSparseImageMemoryBind## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSparseImageMemoryBind where
        (VkSparseImageMemoryBind## a) `compare` (VkSparseImageMemoryBind## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSparseImageMemoryBind where
        sizeOf ~_ = #{size VkSparseImageMemoryBind}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSparseImageMemoryBind}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryBind),
            I## a <- alignment (undefined :: VkSparseImageMemoryBind) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSparseImageMemoryBind##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSparseImageMemoryBind## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryBind) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSparseImageMemoryBind where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryBind),
            I## a <- alignment (undefined :: VkSparseImageMemoryBind) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSparseImageMemoryBind##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSparseImageMemoryBind## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSparseImageMemoryBind##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSparseImageMemoryBind## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSparseImageMemoryBind## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSparseImageMemoryBind## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkSubresource a where
        type VkSubresourceMType a :: *

        vkSubresource :: a -> VkSubresourceMType a

        vkSubresourceByteOffset :: a -> Int

        readVkSubresource :: Ptr a -> IO (VkSubresourceMType a)

        writeVkSubresource :: Ptr a -> VkSubresourceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'subresource'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSubresource a

instance {-# OVERLAPPING #-}
         HasVkSubresource VkSparseImageMemoryBind where
        type VkSubresourceMType VkSparseImageMemoryBind =
             VkImageSubresource

        {-# NOINLINE vkSubresource #-}
        vkSubresource x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageMemoryBind, subresource})

        {-# INLINE vkSubresourceByteOffset #-}
        vkSubresourceByteOffset ~_
          = #{offset VkSparseImageMemoryBind, subresource}

        {-# INLINE readVkSubresource #-}
        readVkSubresource p
          = peekByteOff p
              #{offset VkSparseImageMemoryBind, subresource}

        {-# INLINE writeVkSubresource #-}
        writeVkSubresource p
          = pokeByteOff p
              #{offset VkSparseImageMemoryBind, subresource}

instance {-# OVERLAPPING #-} HasVkOffset VkSparseImageMemoryBind
         where
        type VkOffsetMType VkSparseImageMemoryBind = VkOffset3D

        {-# NOINLINE vkOffset #-}
        vkOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageMemoryBind, offset})

        {-# INLINE vkOffsetByteOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkSparseImageMemoryBind, offset}

        {-# INLINE readVkOffset #-}
        readVkOffset p
          = peekByteOff p #{offset VkSparseImageMemoryBind, offset}

        {-# INLINE writeVkOffset #-}
        writeVkOffset p
          = pokeByteOff p #{offset VkSparseImageMemoryBind, offset}

instance {-# OVERLAPPING #-} HasVkExtent VkSparseImageMemoryBind
         where
        type VkExtentMType VkSparseImageMemoryBind = VkExtent3D

        {-# NOINLINE vkExtent #-}
        vkExtent x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageMemoryBind, extent})

        {-# INLINE vkExtentByteOffset #-}
        vkExtentByteOffset ~_
          = #{offset VkSparseImageMemoryBind, extent}

        {-# INLINE readVkExtent #-}
        readVkExtent p
          = peekByteOff p #{offset VkSparseImageMemoryBind, extent}

        {-# INLINE writeVkExtent #-}
        writeVkExtent p
          = pokeByteOff p #{offset VkSparseImageMemoryBind, extent}

instance {-# OVERLAPPING #-} HasVkMemory VkSparseImageMemoryBind
         where
        type VkMemoryMType VkSparseImageMemoryBind = VkDeviceMemory

        {-# NOINLINE vkMemory #-}
        vkMemory x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageMemoryBind, memory})

        {-# INLINE vkMemoryByteOffset #-}
        vkMemoryByteOffset ~_
          = #{offset VkSparseImageMemoryBind, memory}

        {-# INLINE readVkMemory #-}
        readVkMemory p
          = peekByteOff p #{offset VkSparseImageMemoryBind, memory}

        {-# INLINE writeVkMemory #-}
        writeVkMemory p
          = pokeByteOff p #{offset VkSparseImageMemoryBind, memory}

instance {-# OVERLAPPING #-}
         HasVkMemoryOffset VkSparseImageMemoryBind where
        type VkMemoryOffsetMType VkSparseImageMemoryBind = VkDeviceSize

        {-# NOINLINE vkMemoryOffset #-}
        vkMemoryOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageMemoryBind, memoryOffset})

        {-# INLINE vkMemoryOffsetByteOffset #-}
        vkMemoryOffsetByteOffset ~_
          = #{offset VkSparseImageMemoryBind, memoryOffset}

        {-# INLINE readVkMemoryOffset #-}
        readVkMemoryOffset p
          = peekByteOff p
              #{offset VkSparseImageMemoryBind, memoryOffset}

        {-# INLINE writeVkMemoryOffset #-}
        writeVkMemoryOffset p
          = pokeByteOff p
              #{offset VkSparseImageMemoryBind, memoryOffset}

instance {-# OVERLAPPING #-} HasVkFlags VkSparseImageMemoryBind
         where
        type VkFlagsMType VkSparseImageMemoryBind = VkSparseMemoryBindFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageMemoryBind, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkSparseImageMemoryBind, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkSparseImageMemoryBind, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkSparseImageMemoryBind, flags}

instance Show VkSparseImageMemoryBind where
        showsPrec d x
          = showString "VkSparseImageMemoryBind {" .
              showString "vkSubresource = " .
                showsPrec d (vkSubresource x) .
                  showString ", " .
                    showString "vkOffset = " .
                      showsPrec d (vkOffset x) .
                        showString ", " .
                          showString "vkExtent = " .
                            showsPrec d (vkExtent x) .
                              showString ", " .
                                showString "vkMemory = " .
                                  showsPrec d (vkMemory x) .
                                    showString ", " .
                                      showString "vkMemoryOffset = " .
                                        showsPrec d (vkMemoryOffset x) .
                                          showString ", " .
                                            showString "vkFlags = " .
                                              showsPrec d (vkFlags x) . showChar '}'

data VkSparseBufferMemoryBindInfo = VkSparseBufferMemoryBindInfo## ByteArray##

instance Eq VkSparseBufferMemoryBindInfo where
        (VkSparseBufferMemoryBindInfo## a) ==
          (VkSparseBufferMemoryBindInfo## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSparseBufferMemoryBindInfo where
        (VkSparseBufferMemoryBindInfo## a) `compare`
          (VkSparseBufferMemoryBindInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSparseBufferMemoryBindInfo where
        sizeOf ~_ = #{size VkSparseBufferMemoryBindInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSparseBufferMemoryBindInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSparseBufferMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseBufferMemoryBindInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSparseBufferMemoryBindInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSparseBufferMemoryBindInfo## ba)
          | I## n <- sizeOf (undefined :: VkSparseBufferMemoryBindInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSparseBufferMemoryBindInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSparseBufferMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseBufferMemoryBindInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSparseBufferMemoryBindInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSparseBufferMemoryBindInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSparseBufferMemoryBindInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSparseBufferMemoryBindInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSparseBufferMemoryBindInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSparseBufferMemoryBindInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkBuffer VkSparseBufferMemoryBindInfo where
        type VkBufferMType VkSparseBufferMemoryBindInfo = VkBuffer

        {-# NOINLINE vkBuffer #-}
        vkBuffer x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseBufferMemoryBindInfo, buffer})

        {-# INLINE vkBufferByteOffset #-}
        vkBufferByteOffset ~_
          = #{offset VkSparseBufferMemoryBindInfo, buffer}

        {-# INLINE readVkBuffer #-}
        readVkBuffer p
          = peekByteOff p
              #{offset VkSparseBufferMemoryBindInfo, buffer}

        {-# INLINE writeVkBuffer #-}
        writeVkBuffer p
          = pokeByteOff p
              #{offset VkSparseBufferMemoryBindInfo, buffer}

class HasVkBindCount a where
        type VkBindCountMType a :: *

        vkBindCount :: a -> VkBindCountMType a

        vkBindCountByteOffset :: a -> Int

        readVkBindCount :: Ptr a -> IO (VkBindCountMType a)

        writeVkBindCount :: Ptr a -> VkBindCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bindCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBindCount a

instance {-# OVERLAPPING #-}
         HasVkBindCount VkSparseBufferMemoryBindInfo where
        type VkBindCountMType VkSparseBufferMemoryBindInfo =
             Data.Word.Word32

        {-# NOINLINE vkBindCount #-}
        vkBindCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseBufferMemoryBindInfo, bindCount})

        {-# INLINE vkBindCountByteOffset #-}
        vkBindCountByteOffset ~_
          = #{offset VkSparseBufferMemoryBindInfo, bindCount}

        {-# INLINE readVkBindCount #-}
        readVkBindCount p
          = peekByteOff p
              #{offset VkSparseBufferMemoryBindInfo, bindCount}

        {-# INLINE writeVkBindCount #-}
        writeVkBindCount p
          = pokeByteOff p
              #{offset VkSparseBufferMemoryBindInfo, bindCount}

class HasVkPBinds a where
        type VkPBindsMType a :: *

        vkPBinds :: a -> VkPBindsMType a

        vkPBindsByteOffset :: a -> Int

        readVkPBinds :: Ptr a -> IO (VkPBindsMType a)

        writeVkPBinds :: Ptr a -> VkPBindsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pBinds'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPBinds a

instance {-# OVERLAPPING #-}
         HasVkPBinds VkSparseBufferMemoryBindInfo where
        type VkPBindsMType VkSparseBufferMemoryBindInfo =
             Foreign.Ptr.Ptr VkSparseMemoryBind

        {-# NOINLINE vkPBinds #-}
        vkPBinds x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseBufferMemoryBindInfo, pBinds})

        {-# INLINE vkPBindsByteOffset #-}
        vkPBindsByteOffset ~_
          = #{offset VkSparseBufferMemoryBindInfo, pBinds}

        {-# INLINE readVkPBinds #-}
        readVkPBinds p
          = peekByteOff p
              #{offset VkSparseBufferMemoryBindInfo, pBinds}

        {-# INLINE writeVkPBinds #-}
        writeVkPBinds p
          = pokeByteOff p
              #{offset VkSparseBufferMemoryBindInfo, pBinds}

instance Show VkSparseBufferMemoryBindInfo where
        showsPrec d x
          = showString "VkSparseBufferMemoryBindInfo {" .
              showString "vkBuffer = " .
                showsPrec d (vkBuffer x) .
                  showString ", " .
                    showString "vkBindCount = " .
                      showsPrec d (vkBindCount x) .
                        showString ", " .
                          showString "vkPBinds = " . showsPrec d (vkPBinds x) . showChar '}'

data VkSparseImageOpaqueMemoryBindInfo = VkSparseImageOpaqueMemoryBindInfo## ByteArray##

instance Eq VkSparseImageOpaqueMemoryBindInfo where
        (VkSparseImageOpaqueMemoryBindInfo## a) ==
          (VkSparseImageOpaqueMemoryBindInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSparseImageOpaqueMemoryBindInfo where
        (VkSparseImageOpaqueMemoryBindInfo## a) `compare`
          (VkSparseImageOpaqueMemoryBindInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSparseImageOpaqueMemoryBindInfo where
        sizeOf ~_ = #{size VkSparseImageOpaqueMemoryBindInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkSparseImageOpaqueMemoryBindInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSparseImageOpaqueMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseImageOpaqueMemoryBindInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSparseImageOpaqueMemoryBindInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSparseImageOpaqueMemoryBindInfo## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageOpaqueMemoryBindInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSparseImageOpaqueMemoryBindInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSparseImageOpaqueMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseImageOpaqueMemoryBindInfo)
            =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSparseImageOpaqueMemoryBindInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSparseImageOpaqueMemoryBindInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSparseImageOpaqueMemoryBindInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSparseImageOpaqueMemoryBindInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSparseImageOpaqueMemoryBindInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSparseImageOpaqueMemoryBindInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkImage VkSparseImageOpaqueMemoryBindInfo where
        type VkImageMType VkSparseImageOpaqueMemoryBindInfo = VkImage

        {-# NOINLINE vkImage #-}
        vkImage x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageOpaqueMemoryBindInfo, image})

        {-# INLINE vkImageByteOffset #-}
        vkImageByteOffset ~_
          = #{offset VkSparseImageOpaqueMemoryBindInfo, image}

        {-# INLINE readVkImage #-}
        readVkImage p
          = peekByteOff p
              #{offset VkSparseImageOpaqueMemoryBindInfo, image}

        {-# INLINE writeVkImage #-}
        writeVkImage p
          = pokeByteOff p
              #{offset VkSparseImageOpaqueMemoryBindInfo, image}

instance {-# OVERLAPPING #-}
         HasVkBindCount VkSparseImageOpaqueMemoryBindInfo where
        type VkBindCountMType VkSparseImageOpaqueMemoryBindInfo =
             Data.Word.Word32

        {-# NOINLINE vkBindCount #-}
        vkBindCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageOpaqueMemoryBindInfo, bindCount})

        {-# INLINE vkBindCountByteOffset #-}
        vkBindCountByteOffset ~_
          = #{offset VkSparseImageOpaqueMemoryBindInfo, bindCount}

        {-# INLINE readVkBindCount #-}
        readVkBindCount p
          = peekByteOff p
              #{offset VkSparseImageOpaqueMemoryBindInfo, bindCount}

        {-# INLINE writeVkBindCount #-}
        writeVkBindCount p
          = pokeByteOff p
              #{offset VkSparseImageOpaqueMemoryBindInfo, bindCount}

instance {-# OVERLAPPING #-}
         HasVkPBinds VkSparseImageOpaqueMemoryBindInfo where
        type VkPBindsMType VkSparseImageOpaqueMemoryBindInfo =
             Foreign.Ptr.Ptr VkSparseMemoryBind

        {-# NOINLINE vkPBinds #-}
        vkPBinds x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageOpaqueMemoryBindInfo, pBinds})

        {-# INLINE vkPBindsByteOffset #-}
        vkPBindsByteOffset ~_
          = #{offset VkSparseImageOpaqueMemoryBindInfo, pBinds}

        {-# INLINE readVkPBinds #-}
        readVkPBinds p
          = peekByteOff p
              #{offset VkSparseImageOpaqueMemoryBindInfo, pBinds}

        {-# INLINE writeVkPBinds #-}
        writeVkPBinds p
          = pokeByteOff p
              #{offset VkSparseImageOpaqueMemoryBindInfo, pBinds}

instance Show VkSparseImageOpaqueMemoryBindInfo where
        showsPrec d x
          = showString "VkSparseImageOpaqueMemoryBindInfo {" .
              showString "vkImage = " .
                showsPrec d (vkImage x) .
                  showString ", " .
                    showString "vkBindCount = " .
                      showsPrec d (vkBindCount x) .
                        showString ", " .
                          showString "vkPBinds = " . showsPrec d (vkPBinds x) . showChar '}'

data VkSparseImageMemoryBindInfo = VkSparseImageMemoryBindInfo## ByteArray##

instance Eq VkSparseImageMemoryBindInfo where
        (VkSparseImageMemoryBindInfo## a) ==
          (VkSparseImageMemoryBindInfo## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSparseImageMemoryBindInfo where
        (VkSparseImageMemoryBindInfo## a) `compare`
          (VkSparseImageMemoryBindInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSparseImageMemoryBindInfo where
        sizeOf ~_ = #{size VkSparseImageMemoryBindInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSparseImageMemoryBindInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseImageMemoryBindInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSparseImageMemoryBindInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSparseImageMemoryBindInfo## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryBindInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSparseImageMemoryBindInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseImageMemoryBindInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSparseImageMemoryBindInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSparseImageMemoryBindInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSparseImageMemoryBindInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSparseImageMemoryBindInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSparseImageMemoryBindInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSparseImageMemoryBindInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkImage VkSparseImageMemoryBindInfo
         where
        type VkImageMType VkSparseImageMemoryBindInfo = VkImage

        {-# NOINLINE vkImage #-}
        vkImage x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageMemoryBindInfo, image})

        {-# INLINE vkImageByteOffset #-}
        vkImageByteOffset ~_
          = #{offset VkSparseImageMemoryBindInfo, image}

        {-# INLINE readVkImage #-}
        readVkImage p
          = peekByteOff p
              #{offset VkSparseImageMemoryBindInfo, image}

        {-# INLINE writeVkImage #-}
        writeVkImage p
          = pokeByteOff p
              #{offset VkSparseImageMemoryBindInfo, image}

instance {-# OVERLAPPING #-}
         HasVkBindCount VkSparseImageMemoryBindInfo where
        type VkBindCountMType VkSparseImageMemoryBindInfo =
             Data.Word.Word32

        {-# NOINLINE vkBindCount #-}
        vkBindCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageMemoryBindInfo, bindCount})

        {-# INLINE vkBindCountByteOffset #-}
        vkBindCountByteOffset ~_
          = #{offset VkSparseImageMemoryBindInfo, bindCount}

        {-# INLINE readVkBindCount #-}
        readVkBindCount p
          = peekByteOff p
              #{offset VkSparseImageMemoryBindInfo, bindCount}

        {-# INLINE writeVkBindCount #-}
        writeVkBindCount p
          = pokeByteOff p
              #{offset VkSparseImageMemoryBindInfo, bindCount}

instance {-# OVERLAPPING #-}
         HasVkPBinds VkSparseImageMemoryBindInfo where
        type VkPBindsMType VkSparseImageMemoryBindInfo =
             Foreign.Ptr.Ptr VkSparseImageMemoryBind

        {-# NOINLINE vkPBinds #-}
        vkPBinds x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSparseImageMemoryBindInfo, pBinds})

        {-# INLINE vkPBindsByteOffset #-}
        vkPBindsByteOffset ~_
          = #{offset VkSparseImageMemoryBindInfo, pBinds}

        {-# INLINE readVkPBinds #-}
        readVkPBinds p
          = peekByteOff p
              #{offset VkSparseImageMemoryBindInfo, pBinds}

        {-# INLINE writeVkPBinds #-}
        writeVkPBinds p
          = pokeByteOff p
              #{offset VkSparseImageMemoryBindInfo, pBinds}

instance Show VkSparseImageMemoryBindInfo where
        showsPrec d x
          = showString "VkSparseImageMemoryBindInfo {" .
              showString "vkImage = " .
                showsPrec d (vkImage x) .
                  showString ", " .
                    showString "vkBindCount = " .
                      showsPrec d (vkBindCount x) .
                        showString ", " .
                          showString "vkPBinds = " . showsPrec d (vkPBinds x) . showChar '}'

data VkBindSparseInfo = VkBindSparseInfo## ByteArray##

instance Eq VkBindSparseInfo where
        (VkBindSparseInfo## a) == (VkBindSparseInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkBindSparseInfo where
        (VkBindSparseInfo## a) `compare` (VkBindSparseInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkBindSparseInfo where
        sizeOf ~_ = #{size VkBindSparseInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkBindSparseInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkBindSparseInfo),
            I## a <- alignment (undefined :: VkBindSparseInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkBindSparseInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkBindSparseInfo## ba)
          | I## n <- sizeOf (undefined :: VkBindSparseInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkBindSparseInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkBindSparseInfo),
            I## a <- alignment (undefined :: VkBindSparseInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkBindSparseInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkBindSparseInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkBindSparseInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkBindSparseInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkBindSparseInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkBindSparseInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkBindSparseInfo where
        type VkSTypeMType VkBindSparseInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBindSparseInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_ = #{offset VkBindSparseInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkBindSparseInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkBindSparseInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkBindSparseInfo where
        type VkPNextMType VkBindSparseInfo = Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBindSparseInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_ = #{offset VkBindSparseInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkBindSparseInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkBindSparseInfo, pNext}

class HasVkWaitSemaphoreCount a where
        type VkWaitSemaphoreCountMType a :: *

        vkWaitSemaphoreCount :: a -> VkWaitSemaphoreCountMType a

        vkWaitSemaphoreCountByteOffset :: a -> Int

        readVkWaitSemaphoreCount ::
                                 Ptr a -> IO (VkWaitSemaphoreCountMType a)

        writeVkWaitSemaphoreCount ::
                                  Ptr a -> VkWaitSemaphoreCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'waitSemaphoreCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkWaitSemaphoreCount a

instance {-# OVERLAPPING #-}
         HasVkWaitSemaphoreCount VkBindSparseInfo where
        type VkWaitSemaphoreCountMType VkBindSparseInfo = Data.Word.Word32

        {-# NOINLINE vkWaitSemaphoreCount #-}
        vkWaitSemaphoreCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBindSparseInfo, waitSemaphoreCount})

        {-# INLINE vkWaitSemaphoreCountByteOffset #-}
        vkWaitSemaphoreCountByteOffset ~_
          = #{offset VkBindSparseInfo, waitSemaphoreCount}

        {-# INLINE readVkWaitSemaphoreCount #-}
        readVkWaitSemaphoreCount p
          = peekByteOff p
              #{offset VkBindSparseInfo, waitSemaphoreCount}

        {-# INLINE writeVkWaitSemaphoreCount #-}
        writeVkWaitSemaphoreCount p
          = pokeByteOff p
              #{offset VkBindSparseInfo, waitSemaphoreCount}

class HasVkPWaitSemaphores a where
        type VkPWaitSemaphoresMType a :: *

        vkPWaitSemaphores :: a -> VkPWaitSemaphoresMType a

        vkPWaitSemaphoresByteOffset :: a -> Int

        readVkPWaitSemaphores :: Ptr a -> IO (VkPWaitSemaphoresMType a)

        writeVkPWaitSemaphores ::
                               Ptr a -> VkPWaitSemaphoresMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pWaitSemaphores'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPWaitSemaphores a

instance {-# OVERLAPPING #-} HasVkPWaitSemaphores VkBindSparseInfo
         where
        type VkPWaitSemaphoresMType VkBindSparseInfo =
             Foreign.Ptr.Ptr VkSemaphore

        {-# NOINLINE vkPWaitSemaphores #-}
        vkPWaitSemaphores x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBindSparseInfo, pWaitSemaphores})

        {-# INLINE vkPWaitSemaphoresByteOffset #-}
        vkPWaitSemaphoresByteOffset ~_
          = #{offset VkBindSparseInfo, pWaitSemaphores}

        {-# INLINE readVkPWaitSemaphores #-}
        readVkPWaitSemaphores p
          = peekByteOff p
              #{offset VkBindSparseInfo, pWaitSemaphores}

        {-# INLINE writeVkPWaitSemaphores #-}
        writeVkPWaitSemaphores p
          = pokeByteOff p
              #{offset VkBindSparseInfo, pWaitSemaphores}

class HasVkBufferBindCount a where
        type VkBufferBindCountMType a :: *

        vkBufferBindCount :: a -> VkBufferBindCountMType a

        vkBufferBindCountByteOffset :: a -> Int

        readVkBufferBindCount :: Ptr a -> IO (VkBufferBindCountMType a)

        writeVkBufferBindCount ::
                               Ptr a -> VkBufferBindCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bufferBindCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBufferBindCount a

instance {-# OVERLAPPING #-} HasVkBufferBindCount VkBindSparseInfo
         where
        type VkBufferBindCountMType VkBindSparseInfo = Data.Word.Word32

        {-# NOINLINE vkBufferBindCount #-}
        vkBufferBindCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBindSparseInfo, bufferBindCount})

        {-# INLINE vkBufferBindCountByteOffset #-}
        vkBufferBindCountByteOffset ~_
          = #{offset VkBindSparseInfo, bufferBindCount}

        {-# INLINE readVkBufferBindCount #-}
        readVkBufferBindCount p
          = peekByteOff p
              #{offset VkBindSparseInfo, bufferBindCount}

        {-# INLINE writeVkBufferBindCount #-}
        writeVkBufferBindCount p
          = pokeByteOff p
              #{offset VkBindSparseInfo, bufferBindCount}

class HasVkPBufferBinds a where
        type VkPBufferBindsMType a :: *

        vkPBufferBinds :: a -> VkPBufferBindsMType a

        vkPBufferBindsByteOffset :: a -> Int

        readVkPBufferBinds :: Ptr a -> IO (VkPBufferBindsMType a)

        writeVkPBufferBinds :: Ptr a -> VkPBufferBindsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pBufferBinds'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPBufferBinds a

instance {-# OVERLAPPING #-} HasVkPBufferBinds VkBindSparseInfo
         where
        type VkPBufferBindsMType VkBindSparseInfo =
             Foreign.Ptr.Ptr VkSparseBufferMemoryBindInfo

        {-# NOINLINE vkPBufferBinds #-}
        vkPBufferBinds x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBindSparseInfo, pBufferBinds})

        {-# INLINE vkPBufferBindsByteOffset #-}
        vkPBufferBindsByteOffset ~_
          = #{offset VkBindSparseInfo, pBufferBinds}

        {-# INLINE readVkPBufferBinds #-}
        readVkPBufferBinds p
          = peekByteOff p #{offset VkBindSparseInfo, pBufferBinds}

        {-# INLINE writeVkPBufferBinds #-}
        writeVkPBufferBinds p
          = pokeByteOff p #{offset VkBindSparseInfo, pBufferBinds}

class HasVkImageOpaqueBindCount a where
        type VkImageOpaqueBindCountMType a :: *

        vkImageOpaqueBindCount :: a -> VkImageOpaqueBindCountMType a

        vkImageOpaqueBindCountByteOffset :: a -> Int

        readVkImageOpaqueBindCount ::
                                   Ptr a -> IO (VkImageOpaqueBindCountMType a)

        writeVkImageOpaqueBindCount ::
                                    Ptr a -> VkImageOpaqueBindCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageOpaqueBindCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageOpaqueBindCount a

instance {-# OVERLAPPING #-}
         HasVkImageOpaqueBindCount VkBindSparseInfo where
        type VkImageOpaqueBindCountMType VkBindSparseInfo =
             Data.Word.Word32

        {-# NOINLINE vkImageOpaqueBindCount #-}
        vkImageOpaqueBindCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBindSparseInfo, imageOpaqueBindCount})

        {-# INLINE vkImageOpaqueBindCountByteOffset #-}
        vkImageOpaqueBindCountByteOffset ~_
          = #{offset VkBindSparseInfo, imageOpaqueBindCount}

        {-# INLINE readVkImageOpaqueBindCount #-}
        readVkImageOpaqueBindCount p
          = peekByteOff p
              #{offset VkBindSparseInfo, imageOpaqueBindCount}

        {-# INLINE writeVkImageOpaqueBindCount #-}
        writeVkImageOpaqueBindCount p
          = pokeByteOff p
              #{offset VkBindSparseInfo, imageOpaqueBindCount}

class HasVkPImageOpaqueBinds a where
        type VkPImageOpaqueBindsMType a :: *

        vkPImageOpaqueBinds :: a -> VkPImageOpaqueBindsMType a

        vkPImageOpaqueBindsByteOffset :: a -> Int

        readVkPImageOpaqueBinds :: Ptr a -> IO (VkPImageOpaqueBindsMType a)

        writeVkPImageOpaqueBinds ::
                                 Ptr a -> VkPImageOpaqueBindsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pImageOpaqueBinds'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPImageOpaqueBinds a

instance {-# OVERLAPPING #-}
         HasVkPImageOpaqueBinds VkBindSparseInfo where
        type VkPImageOpaqueBindsMType VkBindSparseInfo =
             Foreign.Ptr.Ptr VkSparseImageOpaqueMemoryBindInfo

        {-# NOINLINE vkPImageOpaqueBinds #-}
        vkPImageOpaqueBinds x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBindSparseInfo, pImageOpaqueBinds})

        {-# INLINE vkPImageOpaqueBindsByteOffset #-}
        vkPImageOpaqueBindsByteOffset ~_
          = #{offset VkBindSparseInfo, pImageOpaqueBinds}

        {-# INLINE readVkPImageOpaqueBinds #-}
        readVkPImageOpaqueBinds p
          = peekByteOff p
              #{offset VkBindSparseInfo, pImageOpaqueBinds}

        {-# INLINE writeVkPImageOpaqueBinds #-}
        writeVkPImageOpaqueBinds p
          = pokeByteOff p
              #{offset VkBindSparseInfo, pImageOpaqueBinds}

class HasVkImageBindCount a where
        type VkImageBindCountMType a :: *

        vkImageBindCount :: a -> VkImageBindCountMType a

        vkImageBindCountByteOffset :: a -> Int

        readVkImageBindCount :: Ptr a -> IO (VkImageBindCountMType a)

        writeVkImageBindCount :: Ptr a -> VkImageBindCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageBindCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageBindCount a

instance {-# OVERLAPPING #-} HasVkImageBindCount VkBindSparseInfo
         where
        type VkImageBindCountMType VkBindSparseInfo = Data.Word.Word32

        {-# NOINLINE vkImageBindCount #-}
        vkImageBindCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBindSparseInfo, imageBindCount})

        {-# INLINE vkImageBindCountByteOffset #-}
        vkImageBindCountByteOffset ~_
          = #{offset VkBindSparseInfo, imageBindCount}

        {-# INLINE readVkImageBindCount #-}
        readVkImageBindCount p
          = peekByteOff p #{offset VkBindSparseInfo, imageBindCount}

        {-# INLINE writeVkImageBindCount #-}
        writeVkImageBindCount p
          = pokeByteOff p #{offset VkBindSparseInfo, imageBindCount}

class HasVkPImageBinds a where
        type VkPImageBindsMType a :: *

        vkPImageBinds :: a -> VkPImageBindsMType a

        vkPImageBindsByteOffset :: a -> Int

        readVkPImageBinds :: Ptr a -> IO (VkPImageBindsMType a)

        writeVkPImageBinds :: Ptr a -> VkPImageBindsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pImageBinds'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPImageBinds a

instance {-# OVERLAPPING #-} HasVkPImageBinds VkBindSparseInfo
         where
        type VkPImageBindsMType VkBindSparseInfo =
             Foreign.Ptr.Ptr VkSparseImageMemoryBindInfo

        {-# NOINLINE vkPImageBinds #-}
        vkPImageBinds x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBindSparseInfo, pImageBinds})

        {-# INLINE vkPImageBindsByteOffset #-}
        vkPImageBindsByteOffset ~_
          = #{offset VkBindSparseInfo, pImageBinds}

        {-# INLINE readVkPImageBinds #-}
        readVkPImageBinds p
          = peekByteOff p #{offset VkBindSparseInfo, pImageBinds}

        {-# INLINE writeVkPImageBinds #-}
        writeVkPImageBinds p
          = pokeByteOff p #{offset VkBindSparseInfo, pImageBinds}

class HasVkSignalSemaphoreCount a where
        type VkSignalSemaphoreCountMType a :: *

        vkSignalSemaphoreCount :: a -> VkSignalSemaphoreCountMType a

        vkSignalSemaphoreCountByteOffset :: a -> Int

        readVkSignalSemaphoreCount ::
                                   Ptr a -> IO (VkSignalSemaphoreCountMType a)

        writeVkSignalSemaphoreCount ::
                                    Ptr a -> VkSignalSemaphoreCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'signalSemaphoreCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSignalSemaphoreCount a

instance {-# OVERLAPPING #-}
         HasVkSignalSemaphoreCount VkBindSparseInfo where
        type VkSignalSemaphoreCountMType VkBindSparseInfo =
             Data.Word.Word32

        {-# NOINLINE vkSignalSemaphoreCount #-}
        vkSignalSemaphoreCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBindSparseInfo, signalSemaphoreCount})

        {-# INLINE vkSignalSemaphoreCountByteOffset #-}
        vkSignalSemaphoreCountByteOffset ~_
          = #{offset VkBindSparseInfo, signalSemaphoreCount}

        {-# INLINE readVkSignalSemaphoreCount #-}
        readVkSignalSemaphoreCount p
          = peekByteOff p
              #{offset VkBindSparseInfo, signalSemaphoreCount}

        {-# INLINE writeVkSignalSemaphoreCount #-}
        writeVkSignalSemaphoreCount p
          = pokeByteOff p
              #{offset VkBindSparseInfo, signalSemaphoreCount}

class HasVkPSignalSemaphores a where
        type VkPSignalSemaphoresMType a :: *

        vkPSignalSemaphores :: a -> VkPSignalSemaphoresMType a

        vkPSignalSemaphoresByteOffset :: a -> Int

        readVkPSignalSemaphores :: Ptr a -> IO (VkPSignalSemaphoresMType a)

        writeVkPSignalSemaphores ::
                                 Ptr a -> VkPSignalSemaphoresMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pSignalSemaphores'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPSignalSemaphores a

instance {-# OVERLAPPING #-}
         HasVkPSignalSemaphores VkBindSparseInfo where
        type VkPSignalSemaphoresMType VkBindSparseInfo =
             Foreign.Ptr.Ptr VkSemaphore

        {-# NOINLINE vkPSignalSemaphores #-}
        vkPSignalSemaphores x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBindSparseInfo, pSignalSemaphores})

        {-# INLINE vkPSignalSemaphoresByteOffset #-}
        vkPSignalSemaphoresByteOffset ~_
          = #{offset VkBindSparseInfo, pSignalSemaphores}

        {-# INLINE readVkPSignalSemaphores #-}
        readVkPSignalSemaphores p
          = peekByteOff p
              #{offset VkBindSparseInfo, pSignalSemaphores}

        {-# INLINE writeVkPSignalSemaphores #-}
        writeVkPSignalSemaphores p
          = pokeByteOff p
              #{offset VkBindSparseInfo, pSignalSemaphores}

instance Show VkBindSparseInfo where
        showsPrec d x
          = showString "VkBindSparseInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkWaitSemaphoreCount = " .
                            showsPrec d (vkWaitSemaphoreCount x) .
                              showString ", " .
                                showString "vkPWaitSemaphores = " .
                                  showsPrec d (vkPWaitSemaphores x) .
                                    showString ", " .
                                      showString "vkBufferBindCount = " .
                                        showsPrec d (vkBufferBindCount x) .
                                          showString ", " .
                                            showString "vkPBufferBinds = " .
                                              showsPrec d (vkPBufferBinds x) .
                                                showString ", " .
                                                  showString "vkImageOpaqueBindCount = " .
                                                    showsPrec d (vkImageOpaqueBindCount x) .
                                                      showString ", " .
                                                        showString "vkPImageOpaqueBinds = " .
                                                          showsPrec d (vkPImageOpaqueBinds x) .
                                                            showString ", " .
                                                              showString "vkImageBindCount = " .
                                                                showsPrec d (vkImageBindCount x) .
                                                                  showString ", " .
                                                                    showString "vkPImageBinds = " .
                                                                      showsPrec d (vkPImageBinds x)
                                                                        .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkSignalSemaphoreCount = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkSignalSemaphoreCount
                                                                                 x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkPSignalSemaphores = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkPSignalSemaphores
                                                                                       x)
                                                                                    . showChar '}'

data VkImageCopy = VkImageCopy## ByteArray##

instance Eq VkImageCopy where
        (VkImageCopy## a) == (VkImageCopy## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageCopy where
        (VkImageCopy## a) `compare` (VkImageCopy## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageCopy where
        sizeOf ~_ = #{size VkImageCopy}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageCopy}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageCopy),
            I## a <- alignment (undefined :: VkImageCopy) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkImageCopy## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageCopy## ba)
          | I## n <- sizeOf (undefined :: VkImageCopy) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageCopy where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkImageCopy),
            I## a <- alignment (undefined :: VkImageCopy) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkImageCopy##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkImageCopy## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkImageCopy##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkImageCopy## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkImageCopy## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkImageCopy## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkSrcSubresource a where
        type VkSrcSubresourceMType a :: *

        vkSrcSubresource :: a -> VkSrcSubresourceMType a

        vkSrcSubresourceByteOffset :: a -> Int

        readVkSrcSubresource :: Ptr a -> IO (VkSrcSubresourceMType a)

        writeVkSrcSubresource :: Ptr a -> VkSrcSubresourceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcSubresource'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcSubresource a

instance {-# OVERLAPPING #-} HasVkSrcSubresource VkImageCopy where
        type VkSrcSubresourceMType VkImageCopy = VkImageSubresourceLayers

        {-# NOINLINE vkSrcSubresource #-}
        vkSrcSubresource x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCopy, srcSubresource})

        {-# INLINE vkSrcSubresourceByteOffset #-}
        vkSrcSubresourceByteOffset ~_
          = #{offset VkImageCopy, srcSubresource}

        {-# INLINE readVkSrcSubresource #-}
        readVkSrcSubresource p
          = peekByteOff p #{offset VkImageCopy, srcSubresource}

        {-# INLINE writeVkSrcSubresource #-}
        writeVkSrcSubresource p
          = pokeByteOff p #{offset VkImageCopy, srcSubresource}

instance {-# OVERLAPPING #-} HasVkSrcOffset VkImageCopy where
        type VkSrcOffsetMType VkImageCopy = VkOffset3D

        {-# NOINLINE vkSrcOffset #-}
        vkSrcOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCopy, srcOffset})

        {-# INLINE vkSrcOffsetByteOffset #-}
        vkSrcOffsetByteOffset ~_
          = #{offset VkImageCopy, srcOffset}

        {-# INLINE readVkSrcOffset #-}
        readVkSrcOffset p
          = peekByteOff p #{offset VkImageCopy, srcOffset}

        {-# INLINE writeVkSrcOffset #-}
        writeVkSrcOffset p
          = pokeByteOff p #{offset VkImageCopy, srcOffset}

class HasVkDstSubresource a where
        type VkDstSubresourceMType a :: *

        vkDstSubresource :: a -> VkDstSubresourceMType a

        vkDstSubresourceByteOffset :: a -> Int

        readVkDstSubresource :: Ptr a -> IO (VkDstSubresourceMType a)

        writeVkDstSubresource :: Ptr a -> VkDstSubresourceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstSubresource'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstSubresource a

instance {-# OVERLAPPING #-} HasVkDstSubresource VkImageCopy where
        type VkDstSubresourceMType VkImageCopy = VkImageSubresourceLayers

        {-# NOINLINE vkDstSubresource #-}
        vkDstSubresource x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCopy, dstSubresource})

        {-# INLINE vkDstSubresourceByteOffset #-}
        vkDstSubresourceByteOffset ~_
          = #{offset VkImageCopy, dstSubresource}

        {-# INLINE readVkDstSubresource #-}
        readVkDstSubresource p
          = peekByteOff p #{offset VkImageCopy, dstSubresource}

        {-# INLINE writeVkDstSubresource #-}
        writeVkDstSubresource p
          = pokeByteOff p #{offset VkImageCopy, dstSubresource}

instance {-# OVERLAPPING #-} HasVkDstOffset VkImageCopy where
        type VkDstOffsetMType VkImageCopy = VkOffset3D

        {-# NOINLINE vkDstOffset #-}
        vkDstOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageCopy, dstOffset})

        {-# INLINE vkDstOffsetByteOffset #-}
        vkDstOffsetByteOffset ~_
          = #{offset VkImageCopy, dstOffset}

        {-# INLINE readVkDstOffset #-}
        readVkDstOffset p
          = peekByteOff p #{offset VkImageCopy, dstOffset}

        {-# INLINE writeVkDstOffset #-}
        writeVkDstOffset p
          = pokeByteOff p #{offset VkImageCopy, dstOffset}

instance {-# OVERLAPPING #-} HasVkExtent VkImageCopy where
        type VkExtentMType VkImageCopy = VkExtent3D

        {-# NOINLINE vkExtent #-}
        vkExtent x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkImageCopy, extent})

        {-# INLINE vkExtentByteOffset #-}
        vkExtentByteOffset ~_ = #{offset VkImageCopy, extent}

        {-# INLINE readVkExtent #-}
        readVkExtent p
          = peekByteOff p #{offset VkImageCopy, extent}

        {-# INLINE writeVkExtent #-}
        writeVkExtent p
          = pokeByteOff p #{offset VkImageCopy, extent}

instance Show VkImageCopy where
        showsPrec d x
          = showString "VkImageCopy {" .
              showString "vkSrcSubresource = " .
                showsPrec d (vkSrcSubresource x) .
                  showString ", " .
                    showString "vkSrcOffset = " .
                      showsPrec d (vkSrcOffset x) .
                        showString ", " .
                          showString "vkDstSubresource = " .
                            showsPrec d (vkDstSubresource x) .
                              showString ", " .
                                showString "vkDstOffset = " .
                                  showsPrec d (vkDstOffset x) .
                                    showString ", " .
                                      showString "vkExtent = " .
                                        showsPrec d (vkExtent x) . showChar '}'

data VkImageBlit = VkImageBlit## ByteArray##

instance Eq VkImageBlit where
        (VkImageBlit## a) == (VkImageBlit## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageBlit where
        (VkImageBlit## a) `compare` (VkImageBlit## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageBlit where
        sizeOf ~_ = #{size VkImageBlit}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageBlit}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageBlit),
            I## a <- alignment (undefined :: VkImageBlit) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkImageBlit## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageBlit## ba)
          | I## n <- sizeOf (undefined :: VkImageBlit) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageBlit where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkImageBlit),
            I## a <- alignment (undefined :: VkImageBlit) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkImageBlit##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkImageBlit## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkImageBlit##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkImageBlit## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkImageBlit## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkImageBlit## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSrcSubresource VkImageBlit where
        type VkSrcSubresourceMType VkImageBlit = VkImageSubresourceLayers

        {-# NOINLINE vkSrcSubresource #-}
        vkSrcSubresource x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageBlit, srcSubresource})

        {-# INLINE vkSrcSubresourceByteOffset #-}
        vkSrcSubresourceByteOffset ~_
          = #{offset VkImageBlit, srcSubresource}

        {-# INLINE readVkSrcSubresource #-}
        readVkSrcSubresource p
          = peekByteOff p #{offset VkImageBlit, srcSubresource}

        {-# INLINE writeVkSrcSubresource #-}
        writeVkSrcSubresource p
          = pokeByteOff p #{offset VkImageBlit, srcSubresource}

class HasVkSrcOffsetsArray a where
        type VkSrcOffsetsArrayMType a :: *

        vkSrcOffsetsArray :: a -> Int -> VkSrcOffsetsArrayMType a

        vkSrcOffsetsArrayByteOffset :: a -> Int

        readVkSrcOffsetsArray ::
                              Ptr a -> Int -> IO (VkSrcOffsetsArrayMType a)

        writeVkSrcOffsetsArray ::
                               Ptr a -> Int -> VkSrcOffsetsArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcOffsets'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcOffsetsArray a

instance {-# OVERLAPPING #-} HasVkSrcOffsetsArray VkImageBlit where
        type VkSrcOffsetsArrayMType VkImageBlit = VkOffset3D

        {-# NOINLINE vkSrcOffsetsArray #-}
        vkSrcOffsetsArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: VkOffset3D) +
                    #{offset VkImageBlit, srcOffsets}))

        {-# INLINE vkSrcOffsetsArrayByteOffset #-}
        vkSrcOffsetsArrayByteOffset ~_
          = #{offset VkImageBlit, srcOffsets}

        {-# INLINE readVkSrcOffsetsArray #-}
        readVkSrcOffsetsArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: VkOffset3D) +
                 #{offset VkImageBlit, srcOffsets})

        {-# INLINE writeVkSrcOffsetsArray #-}
        writeVkSrcOffsetsArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: VkOffset3D) +
                 #{offset VkImageBlit, srcOffsets})

instance {-# OVERLAPPING #-} HasVkDstSubresource VkImageBlit where
        type VkDstSubresourceMType VkImageBlit = VkImageSubresourceLayers

        {-# NOINLINE vkDstSubresource #-}
        vkDstSubresource x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageBlit, dstSubresource})

        {-# INLINE vkDstSubresourceByteOffset #-}
        vkDstSubresourceByteOffset ~_
          = #{offset VkImageBlit, dstSubresource}

        {-# INLINE readVkDstSubresource #-}
        readVkDstSubresource p
          = peekByteOff p #{offset VkImageBlit, dstSubresource}

        {-# INLINE writeVkDstSubresource #-}
        writeVkDstSubresource p
          = pokeByteOff p #{offset VkImageBlit, dstSubresource}

class HasVkDstOffsetsArray a where
        type VkDstOffsetsArrayMType a :: *

        vkDstOffsetsArray :: a -> Int -> VkDstOffsetsArrayMType a

        vkDstOffsetsArrayByteOffset :: a -> Int

        readVkDstOffsetsArray ::
                              Ptr a -> Int -> IO (VkDstOffsetsArrayMType a)

        writeVkDstOffsetsArray ::
                               Ptr a -> Int -> VkDstOffsetsArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstOffsets'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstOffsetsArray a

instance {-# OVERLAPPING #-} HasVkDstOffsetsArray VkImageBlit where
        type VkDstOffsetsArrayMType VkImageBlit = VkOffset3D

        {-# NOINLINE vkDstOffsetsArray #-}
        vkDstOffsetsArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: VkOffset3D) +
                    #{offset VkImageBlit, dstOffsets}))

        {-# INLINE vkDstOffsetsArrayByteOffset #-}
        vkDstOffsetsArrayByteOffset ~_
          = #{offset VkImageBlit, dstOffsets}

        {-# INLINE readVkDstOffsetsArray #-}
        readVkDstOffsetsArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: VkOffset3D) +
                 #{offset VkImageBlit, dstOffsets})

        {-# INLINE writeVkDstOffsetsArray #-}
        writeVkDstOffsetsArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: VkOffset3D) +
                 #{offset VkImageBlit, dstOffsets})

instance Show VkImageBlit where
        showsPrec d x
          = showString "VkImageBlit {" .
              showString "vkSrcSubresource = " .
                showsPrec d (vkSrcSubresource x) .
                  showString ", " .
                    showString "vkSrcOffsetsArray = [" .
                      showsPrec d (map (vkSrcOffsetsArray x) [1 .. 2]) .
                        showChar ']' .
                          showString ", " .
                            showString "vkDstSubresource = " .
                              showsPrec d (vkDstSubresource x) .
                                showString ", " .
                                  showString "vkDstOffsetsArray = [" .
                                    showsPrec d (map (vkDstOffsetsArray x) [1 .. 2]) .
                                      showChar ']' . showChar '}'

data VkBufferImageCopy = VkBufferImageCopy## ByteArray##

instance Eq VkBufferImageCopy where
        (VkBufferImageCopy## a) == (VkBufferImageCopy## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkBufferImageCopy where
        (VkBufferImageCopy## a) `compare` (VkBufferImageCopy## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkBufferImageCopy where
        sizeOf ~_ = #{size VkBufferImageCopy}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkBufferImageCopy}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkBufferImageCopy),
            I## a <- alignment (undefined :: VkBufferImageCopy) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkBufferImageCopy## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkBufferImageCopy## ba)
          | I## n <- sizeOf (undefined :: VkBufferImageCopy) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkBufferImageCopy where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkBufferImageCopy),
            I## a <- alignment (undefined :: VkBufferImageCopy) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkBufferImageCopy##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkBufferImageCopy## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkBufferImageCopy##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkBufferImageCopy## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkBufferImageCopy## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkBufferImageCopy## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkBufferOffset a where
        type VkBufferOffsetMType a :: *

        vkBufferOffset :: a -> VkBufferOffsetMType a

        vkBufferOffsetByteOffset :: a -> Int

        readVkBufferOffset :: Ptr a -> IO (VkBufferOffsetMType a)

        writeVkBufferOffset :: Ptr a -> VkBufferOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bufferOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBufferOffset a

instance {-# OVERLAPPING #-} HasVkBufferOffset VkBufferImageCopy
         where
        type VkBufferOffsetMType VkBufferImageCopy = VkDeviceSize

        {-# NOINLINE vkBufferOffset #-}
        vkBufferOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferImageCopy, bufferOffset})

        {-# INLINE vkBufferOffsetByteOffset #-}
        vkBufferOffsetByteOffset ~_
          = #{offset VkBufferImageCopy, bufferOffset}

        {-# INLINE readVkBufferOffset #-}
        readVkBufferOffset p
          = peekByteOff p #{offset VkBufferImageCopy, bufferOffset}

        {-# INLINE writeVkBufferOffset #-}
        writeVkBufferOffset p
          = pokeByteOff p #{offset VkBufferImageCopy, bufferOffset}

class HasVkBufferRowLength a where
        type VkBufferRowLengthMType a :: *

        vkBufferRowLength :: a -> VkBufferRowLengthMType a

        vkBufferRowLengthByteOffset :: a -> Int

        readVkBufferRowLength :: Ptr a -> IO (VkBufferRowLengthMType a)

        writeVkBufferRowLength ::
                               Ptr a -> VkBufferRowLengthMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bufferRowLength'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBufferRowLength a

instance {-# OVERLAPPING #-} HasVkBufferRowLength VkBufferImageCopy
         where
        type VkBufferRowLengthMType VkBufferImageCopy = Data.Word.Word32

        {-# NOINLINE vkBufferRowLength #-}
        vkBufferRowLength x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferImageCopy, bufferRowLength})

        {-# INLINE vkBufferRowLengthByteOffset #-}
        vkBufferRowLengthByteOffset ~_
          = #{offset VkBufferImageCopy, bufferRowLength}

        {-# INLINE readVkBufferRowLength #-}
        readVkBufferRowLength p
          = peekByteOff p
              #{offset VkBufferImageCopy, bufferRowLength}

        {-# INLINE writeVkBufferRowLength #-}
        writeVkBufferRowLength p
          = pokeByteOff p
              #{offset VkBufferImageCopy, bufferRowLength}

class HasVkBufferImageHeight a where
        type VkBufferImageHeightMType a :: *

        vkBufferImageHeight :: a -> VkBufferImageHeightMType a

        vkBufferImageHeightByteOffset :: a -> Int

        readVkBufferImageHeight :: Ptr a -> IO (VkBufferImageHeightMType a)

        writeVkBufferImageHeight ::
                                 Ptr a -> VkBufferImageHeightMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bufferImageHeight'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBufferImageHeight a

instance {-# OVERLAPPING #-}
         HasVkBufferImageHeight VkBufferImageCopy where
        type VkBufferImageHeightMType VkBufferImageCopy = Data.Word.Word32

        {-# NOINLINE vkBufferImageHeight #-}
        vkBufferImageHeight x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferImageCopy, bufferImageHeight})

        {-# INLINE vkBufferImageHeightByteOffset #-}
        vkBufferImageHeightByteOffset ~_
          = #{offset VkBufferImageCopy, bufferImageHeight}

        {-# INLINE readVkBufferImageHeight #-}
        readVkBufferImageHeight p
          = peekByteOff p
              #{offset VkBufferImageCopy, bufferImageHeight}

        {-# INLINE writeVkBufferImageHeight #-}
        writeVkBufferImageHeight p
          = pokeByteOff p
              #{offset VkBufferImageCopy, bufferImageHeight}

class HasVkImageSubresource a where
        type VkImageSubresourceMType a :: *

        vkImageSubresource :: a -> VkImageSubresourceMType a

        vkImageSubresourceByteOffset :: a -> Int

        readVkImageSubresource :: Ptr a -> IO (VkImageSubresourceMType a)

        writeVkImageSubresource ::
                                Ptr a -> VkImageSubresourceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageSubresource'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageSubresource a

instance {-# OVERLAPPING #-}
         HasVkImageSubresource VkBufferImageCopy where
        type VkImageSubresourceMType VkBufferImageCopy =
             VkImageSubresourceLayers

        {-# NOINLINE vkImageSubresource #-}
        vkImageSubresource x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferImageCopy, imageSubresource})

        {-# INLINE vkImageSubresourceByteOffset #-}
        vkImageSubresourceByteOffset ~_
          = #{offset VkBufferImageCopy, imageSubresource}

        {-# INLINE readVkImageSubresource #-}
        readVkImageSubresource p
          = peekByteOff p
              #{offset VkBufferImageCopy, imageSubresource}

        {-# INLINE writeVkImageSubresource #-}
        writeVkImageSubresource p
          = pokeByteOff p
              #{offset VkBufferImageCopy, imageSubresource}

class HasVkImageOffset a where
        type VkImageOffsetMType a :: *

        vkImageOffset :: a -> VkImageOffsetMType a

        vkImageOffsetByteOffset :: a -> Int

        readVkImageOffset :: Ptr a -> IO (VkImageOffsetMType a)

        writeVkImageOffset :: Ptr a -> VkImageOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageOffset a

instance {-# OVERLAPPING #-} HasVkImageOffset VkBufferImageCopy
         where
        type VkImageOffsetMType VkBufferImageCopy = VkOffset3D

        {-# NOINLINE vkImageOffset #-}
        vkImageOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferImageCopy, imageOffset})

        {-# INLINE vkImageOffsetByteOffset #-}
        vkImageOffsetByteOffset ~_
          = #{offset VkBufferImageCopy, imageOffset}

        {-# INLINE readVkImageOffset #-}
        readVkImageOffset p
          = peekByteOff p #{offset VkBufferImageCopy, imageOffset}

        {-# INLINE writeVkImageOffset #-}
        writeVkImageOffset p
          = pokeByteOff p #{offset VkBufferImageCopy, imageOffset}

class HasVkImageExtent a where
        type VkImageExtentMType a :: *

        vkImageExtent :: a -> VkImageExtentMType a

        vkImageExtentByteOffset :: a -> Int

        readVkImageExtent :: Ptr a -> IO (VkImageExtentMType a)

        writeVkImageExtent :: Ptr a -> VkImageExtentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageExtent'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageExtent a

instance {-# OVERLAPPING #-} HasVkImageExtent VkBufferImageCopy
         where
        type VkImageExtentMType VkBufferImageCopy = VkExtent3D

        {-# NOINLINE vkImageExtent #-}
        vkImageExtent x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkBufferImageCopy, imageExtent})

        {-# INLINE vkImageExtentByteOffset #-}
        vkImageExtentByteOffset ~_
          = #{offset VkBufferImageCopy, imageExtent}

        {-# INLINE readVkImageExtent #-}
        readVkImageExtent p
          = peekByteOff p #{offset VkBufferImageCopy, imageExtent}

        {-# INLINE writeVkImageExtent #-}
        writeVkImageExtent p
          = pokeByteOff p #{offset VkBufferImageCopy, imageExtent}

instance Show VkBufferImageCopy where
        showsPrec d x
          = showString "VkBufferImageCopy {" .
              showString "vkBufferOffset = " .
                showsPrec d (vkBufferOffset x) .
                  showString ", " .
                    showString "vkBufferRowLength = " .
                      showsPrec d (vkBufferRowLength x) .
                        showString ", " .
                          showString "vkBufferImageHeight = " .
                            showsPrec d (vkBufferImageHeight x) .
                              showString ", " .
                                showString "vkImageSubresource = " .
                                  showsPrec d (vkImageSubresource x) .
                                    showString ", " .
                                      showString "vkImageOffset = " .
                                        showsPrec d (vkImageOffset x) .
                                          showString ", " .
                                            showString "vkImageExtent = " .
                                              showsPrec d (vkImageExtent x) . showChar '}'

data VkImageResolve = VkImageResolve## ByteArray##

instance Eq VkImageResolve where
        (VkImageResolve## a) == (VkImageResolve## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageResolve where
        (VkImageResolve## a) `compare` (VkImageResolve## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageResolve where
        sizeOf ~_ = #{size VkImageResolve}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageResolve}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageResolve),
            I## a <- alignment (undefined :: VkImageResolve) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkImageResolve## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageResolve## ba)
          | I## n <- sizeOf (undefined :: VkImageResolve) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageResolve where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkImageResolve),
            I## a <- alignment (undefined :: VkImageResolve) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkImageResolve##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkImageResolve## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkImageResolve##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkImageResolve## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkImageResolve## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkImageResolve## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSrcSubresource VkImageResolve
         where
        type VkSrcSubresourceMType VkImageResolve =
             VkImageSubresourceLayers

        {-# NOINLINE vkSrcSubresource #-}
        vkSrcSubresource x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageResolve, srcSubresource})

        {-# INLINE vkSrcSubresourceByteOffset #-}
        vkSrcSubresourceByteOffset ~_
          = #{offset VkImageResolve, srcSubresource}

        {-# INLINE readVkSrcSubresource #-}
        readVkSrcSubresource p
          = peekByteOff p #{offset VkImageResolve, srcSubresource}

        {-# INLINE writeVkSrcSubresource #-}
        writeVkSrcSubresource p
          = pokeByteOff p #{offset VkImageResolve, srcSubresource}

instance {-# OVERLAPPING #-} HasVkSrcOffset VkImageResolve where
        type VkSrcOffsetMType VkImageResolve = VkOffset3D

        {-# NOINLINE vkSrcOffset #-}
        vkSrcOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageResolve, srcOffset})

        {-# INLINE vkSrcOffsetByteOffset #-}
        vkSrcOffsetByteOffset ~_
          = #{offset VkImageResolve, srcOffset}

        {-# INLINE readVkSrcOffset #-}
        readVkSrcOffset p
          = peekByteOff p #{offset VkImageResolve, srcOffset}

        {-# INLINE writeVkSrcOffset #-}
        writeVkSrcOffset p
          = pokeByteOff p #{offset VkImageResolve, srcOffset}

instance {-# OVERLAPPING #-} HasVkDstSubresource VkImageResolve
         where
        type VkDstSubresourceMType VkImageResolve =
             VkImageSubresourceLayers

        {-# NOINLINE vkDstSubresource #-}
        vkDstSubresource x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageResolve, dstSubresource})

        {-# INLINE vkDstSubresourceByteOffset #-}
        vkDstSubresourceByteOffset ~_
          = #{offset VkImageResolve, dstSubresource}

        {-# INLINE readVkDstSubresource #-}
        readVkDstSubresource p
          = peekByteOff p #{offset VkImageResolve, dstSubresource}

        {-# INLINE writeVkDstSubresource #-}
        writeVkDstSubresource p
          = pokeByteOff p #{offset VkImageResolve, dstSubresource}

instance {-# OVERLAPPING #-} HasVkDstOffset VkImageResolve where
        type VkDstOffsetMType VkImageResolve = VkOffset3D

        {-# NOINLINE vkDstOffset #-}
        vkDstOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageResolve, dstOffset})

        {-# INLINE vkDstOffsetByteOffset #-}
        vkDstOffsetByteOffset ~_
          = #{offset VkImageResolve, dstOffset}

        {-# INLINE readVkDstOffset #-}
        readVkDstOffset p
          = peekByteOff p #{offset VkImageResolve, dstOffset}

        {-# INLINE writeVkDstOffset #-}
        writeVkDstOffset p
          = pokeByteOff p #{offset VkImageResolve, dstOffset}

instance {-# OVERLAPPING #-} HasVkExtent VkImageResolve where
        type VkExtentMType VkImageResolve = VkExtent3D

        {-# NOINLINE vkExtent #-}
        vkExtent x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkImageResolve, extent})

        {-# INLINE vkExtentByteOffset #-}
        vkExtentByteOffset ~_ = #{offset VkImageResolve, extent}

        {-# INLINE readVkExtent #-}
        readVkExtent p
          = peekByteOff p #{offset VkImageResolve, extent}

        {-# INLINE writeVkExtent #-}
        writeVkExtent p
          = pokeByteOff p #{offset VkImageResolve, extent}

instance Show VkImageResolve where
        showsPrec d x
          = showString "VkImageResolve {" .
              showString "vkSrcSubresource = " .
                showsPrec d (vkSrcSubresource x) .
                  showString ", " .
                    showString "vkSrcOffset = " .
                      showsPrec d (vkSrcOffset x) .
                        showString ", " .
                          showString "vkDstSubresource = " .
                            showsPrec d (vkDstSubresource x) .
                              showString ", " .
                                showString "vkDstOffset = " .
                                  showsPrec d (vkDstOffset x) .
                                    showString ", " .
                                      showString "vkExtent = " .
                                        showsPrec d (vkExtent x) . showChar '}'

data VkShaderModuleCreateInfo = VkShaderModuleCreateInfo## ByteArray##

instance Eq VkShaderModuleCreateInfo where
        (VkShaderModuleCreateInfo## a) == (VkShaderModuleCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkShaderModuleCreateInfo where
        (VkShaderModuleCreateInfo## a) `compare`
          (VkShaderModuleCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkShaderModuleCreateInfo where
        sizeOf ~_ = #{size VkShaderModuleCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkShaderModuleCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkShaderModuleCreateInfo),
            I## a <- alignment (undefined :: VkShaderModuleCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkShaderModuleCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkShaderModuleCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkShaderModuleCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkShaderModuleCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkShaderModuleCreateInfo),
            I## a <- alignment (undefined :: VkShaderModuleCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkShaderModuleCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkShaderModuleCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkShaderModuleCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkShaderModuleCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkShaderModuleCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkShaderModuleCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkShaderModuleCreateInfo
         where
        type VkSTypeMType VkShaderModuleCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkShaderModuleCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkShaderModuleCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkShaderModuleCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkShaderModuleCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkShaderModuleCreateInfo
         where
        type VkPNextMType VkShaderModuleCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkShaderModuleCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkShaderModuleCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkShaderModuleCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkShaderModuleCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkShaderModuleCreateInfo
         where
        type VkFlagsMType VkShaderModuleCreateInfo =
             VkShaderModuleCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkShaderModuleCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkShaderModuleCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkShaderModuleCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkShaderModuleCreateInfo, flags}

class HasVkCodeSize a where
        type VkCodeSizeMType a :: *

        vkCodeSize :: a -> VkCodeSizeMType a

        vkCodeSizeByteOffset :: a -> Int

        readVkCodeSize :: Ptr a -> IO (VkCodeSizeMType a)

        writeVkCodeSize :: Ptr a -> VkCodeSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'codeSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCodeSize a

instance {-# OVERLAPPING #-} HasVkCodeSize VkShaderModuleCreateInfo
         where
        type VkCodeSizeMType VkShaderModuleCreateInfo =
             Foreign.C.Types.CSize

        {-# NOINLINE vkCodeSize #-}
        vkCodeSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkShaderModuleCreateInfo, codeSize})

        {-# INLINE vkCodeSizeByteOffset #-}
        vkCodeSizeByteOffset ~_
          = #{offset VkShaderModuleCreateInfo, codeSize}

        {-# INLINE readVkCodeSize #-}
        readVkCodeSize p
          = peekByteOff p
              #{offset VkShaderModuleCreateInfo, codeSize}

        {-# INLINE writeVkCodeSize #-}
        writeVkCodeSize p
          = pokeByteOff p
              #{offset VkShaderModuleCreateInfo, codeSize}

class HasVkPCode a where
        type VkPCodeMType a :: *

        vkPCode :: a -> VkPCodeMType a

        vkPCodeByteOffset :: a -> Int

        readVkPCode :: Ptr a -> IO (VkPCodeMType a)

        writeVkPCode :: Ptr a -> VkPCodeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pCode'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPCode a

instance {-# OVERLAPPING #-} HasVkPCode VkShaderModuleCreateInfo
         where
        type VkPCodeMType VkShaderModuleCreateInfo =
             Foreign.Ptr.Ptr Data.Word.Word32

        {-# NOINLINE vkPCode #-}
        vkPCode x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkShaderModuleCreateInfo, pCode})

        {-# INLINE vkPCodeByteOffset #-}
        vkPCodeByteOffset ~_
          = #{offset VkShaderModuleCreateInfo, pCode}

        {-# INLINE readVkPCode #-}
        readVkPCode p
          = peekByteOff p #{offset VkShaderModuleCreateInfo, pCode}

        {-# INLINE writeVkPCode #-}
        writeVkPCode p
          = pokeByteOff p #{offset VkShaderModuleCreateInfo, pCode}

instance Show VkShaderModuleCreateInfo where
        showsPrec d x
          = showString "VkShaderModuleCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkCodeSize = " .
                                  showsPrec d (vkCodeSize x) .
                                    showString ", " .
                                      showString "vkPCode = " .
                                        showsPrec d (vkPCode x) . showChar '}'

data VkDescriptorSetLayoutBinding = VkDescriptorSetLayoutBinding## ByteArray##

instance Eq VkDescriptorSetLayoutBinding where
        (VkDescriptorSetLayoutBinding## a) ==
          (VkDescriptorSetLayoutBinding## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDescriptorSetLayoutBinding where
        (VkDescriptorSetLayoutBinding## a) `compare`
          (VkDescriptorSetLayoutBinding## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDescriptorSetLayoutBinding where
        sizeOf ~_ = #{size VkDescriptorSetLayoutBinding}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDescriptorSetLayoutBinding}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDescriptorSetLayoutBinding),
            I## a <- alignment (undefined :: VkDescriptorSetLayoutBinding) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDescriptorSetLayoutBinding##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDescriptorSetLayoutBinding## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorSetLayoutBinding) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDescriptorSetLayoutBinding where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkDescriptorSetLayoutBinding),
            I## a <- alignment (undefined :: VkDescriptorSetLayoutBinding) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkDescriptorSetLayoutBinding##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkDescriptorSetLayoutBinding## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkDescriptorSetLayoutBinding##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkDescriptorSetLayoutBinding## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkDescriptorSetLayoutBinding## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkDescriptorSetLayoutBinding## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkBinding a where
        type VkBindingMType a :: *

        vkBinding :: a -> VkBindingMType a

        vkBindingByteOffset :: a -> Int

        readVkBinding :: Ptr a -> IO (VkBindingMType a)

        writeVkBinding :: Ptr a -> VkBindingMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'binding'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBinding a

instance {-# OVERLAPPING #-}
         HasVkBinding VkDescriptorSetLayoutBinding where
        type VkBindingMType VkDescriptorSetLayoutBinding = Data.Word.Word32

        {-# NOINLINE vkBinding #-}
        vkBinding x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetLayoutBinding, binding})

        {-# INLINE vkBindingByteOffset #-}
        vkBindingByteOffset ~_
          = #{offset VkDescriptorSetLayoutBinding, binding}

        {-# INLINE readVkBinding #-}
        readVkBinding p
          = peekByteOff p
              #{offset VkDescriptorSetLayoutBinding, binding}

        {-# INLINE writeVkBinding #-}
        writeVkBinding p
          = pokeByteOff p
              #{offset VkDescriptorSetLayoutBinding, binding}

instance {-# OVERLAPPING #-}
         HasVkDescriptorType VkDescriptorSetLayoutBinding where
        type VkDescriptorTypeMType VkDescriptorSetLayoutBinding =
             VkDescriptorType

        {-# NOINLINE vkDescriptorType #-}
        vkDescriptorType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetLayoutBinding, descriptorType})

        {-# INLINE vkDescriptorTypeByteOffset #-}
        vkDescriptorTypeByteOffset ~_
          = #{offset VkDescriptorSetLayoutBinding, descriptorType}

        {-# INLINE readVkDescriptorType #-}
        readVkDescriptorType p
          = peekByteOff p
              #{offset VkDescriptorSetLayoutBinding, descriptorType}

        {-# INLINE writeVkDescriptorType #-}
        writeVkDescriptorType p
          = pokeByteOff p
              #{offset VkDescriptorSetLayoutBinding, descriptorType}

instance {-# OVERLAPPING #-}
         HasVkDescriptorCount VkDescriptorSetLayoutBinding where
        type VkDescriptorCountMType VkDescriptorSetLayoutBinding =
             Data.Word.Word32

        {-# NOINLINE vkDescriptorCount #-}
        vkDescriptorCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetLayoutBinding, descriptorCount})

        {-# INLINE vkDescriptorCountByteOffset #-}
        vkDescriptorCountByteOffset ~_
          = #{offset VkDescriptorSetLayoutBinding, descriptorCount}

        {-# INLINE readVkDescriptorCount #-}
        readVkDescriptorCount p
          = peekByteOff p
              #{offset VkDescriptorSetLayoutBinding, descriptorCount}

        {-# INLINE writeVkDescriptorCount #-}
        writeVkDescriptorCount p
          = pokeByteOff p
              #{offset VkDescriptorSetLayoutBinding, descriptorCount}

class HasVkStageFlags a where
        type VkStageFlagsMType a :: *

        vkStageFlags :: a -> VkStageFlagsMType a

        vkStageFlagsByteOffset :: a -> Int

        readVkStageFlags :: Ptr a -> IO (VkStageFlagsMType a)

        writeVkStageFlags :: Ptr a -> VkStageFlagsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stageFlags'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStageFlags a

instance {-# OVERLAPPING #-}
         HasVkStageFlags VkDescriptorSetLayoutBinding where
        type VkStageFlagsMType VkDescriptorSetLayoutBinding =
             VkShaderStageFlags

        {-# NOINLINE vkStageFlags #-}
        vkStageFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetLayoutBinding, stageFlags})

        {-# INLINE vkStageFlagsByteOffset #-}
        vkStageFlagsByteOffset ~_
          = #{offset VkDescriptorSetLayoutBinding, stageFlags}

        {-# INLINE readVkStageFlags #-}
        readVkStageFlags p
          = peekByteOff p
              #{offset VkDescriptorSetLayoutBinding, stageFlags}

        {-# INLINE writeVkStageFlags #-}
        writeVkStageFlags p
          = pokeByteOff p
              #{offset VkDescriptorSetLayoutBinding, stageFlags}

class HasVkPImmutableSamplers a where
        type VkPImmutableSamplersMType a :: *

        vkPImmutableSamplers :: a -> VkPImmutableSamplersMType a

        vkPImmutableSamplersByteOffset :: a -> Int

        readVkPImmutableSamplers ::
                                 Ptr a -> IO (VkPImmutableSamplersMType a)

        writeVkPImmutableSamplers ::
                                  Ptr a -> VkPImmutableSamplersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pImmutableSamplers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPImmutableSamplers a

instance {-# OVERLAPPING #-}
         HasVkPImmutableSamplers VkDescriptorSetLayoutBinding where
        type VkPImmutableSamplersMType VkDescriptorSetLayoutBinding =
             Foreign.Ptr.Ptr VkSampler

        {-# NOINLINE vkPImmutableSamplers #-}
        vkPImmutableSamplers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetLayoutBinding, pImmutableSamplers})

        {-# INLINE vkPImmutableSamplersByteOffset #-}
        vkPImmutableSamplersByteOffset ~_
          = #{offset VkDescriptorSetLayoutBinding, pImmutableSamplers}

        {-# INLINE readVkPImmutableSamplers #-}
        readVkPImmutableSamplers p
          = peekByteOff p
              #{offset VkDescriptorSetLayoutBinding, pImmutableSamplers}

        {-# INLINE writeVkPImmutableSamplers #-}
        writeVkPImmutableSamplers p
          = pokeByteOff p
              #{offset VkDescriptorSetLayoutBinding, pImmutableSamplers}

instance Show VkDescriptorSetLayoutBinding where
        showsPrec d x
          = showString "VkDescriptorSetLayoutBinding {" .
              showString "vkBinding = " .
                showsPrec d (vkBinding x) .
                  showString ", " .
                    showString "vkDescriptorType = " .
                      showsPrec d (vkDescriptorType x) .
                        showString ", " .
                          showString "vkDescriptorCount = " .
                            showsPrec d (vkDescriptorCount x) .
                              showString ", " .
                                showString "vkStageFlags = " .
                                  showsPrec d (vkStageFlags x) .
                                    showString ", " .
                                      showString "vkPImmutableSamplers = " .
                                        showsPrec d (vkPImmutableSamplers x) . showChar '}'

data VkDescriptorSetLayoutCreateInfo = VkDescriptorSetLayoutCreateInfo## ByteArray##

instance Eq VkDescriptorSetLayoutCreateInfo where
        (VkDescriptorSetLayoutCreateInfo## a) ==
          (VkDescriptorSetLayoutCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDescriptorSetLayoutCreateInfo where
        (VkDescriptorSetLayoutCreateInfo## a) `compare`
          (VkDescriptorSetLayoutCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDescriptorSetLayoutCreateInfo where
        sizeOf ~_ = #{size VkDescriptorSetLayoutCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDescriptorSetLayoutCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDescriptorSetLayoutCreateInfo),
            I## a <- alignment (undefined :: VkDescriptorSetLayoutCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDescriptorSetLayoutCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDescriptorSetLayoutCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorSetLayoutCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDescriptorSetLayoutCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkDescriptorSetLayoutCreateInfo),
            I## a <- alignment (undefined :: VkDescriptorSetLayoutCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkDescriptorSetLayoutCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkDescriptorSetLayoutCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkDescriptorSetLayoutCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkDescriptorSetLayoutCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkDescriptorSetLayoutCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkDescriptorSetLayoutCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkSType VkDescriptorSetLayoutCreateInfo where
        type VkSTypeMType VkDescriptorSetLayoutCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetLayoutCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkDescriptorSetLayoutCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkDescriptorSetLayoutCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkDescriptorSetLayoutCreateInfo, sType}

instance {-# OVERLAPPING #-}
         HasVkPNext VkDescriptorSetLayoutCreateInfo where
        type VkPNextMType VkDescriptorSetLayoutCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetLayoutCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkDescriptorSetLayoutCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkDescriptorSetLayoutCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkDescriptorSetLayoutCreateInfo, pNext}

instance {-# OVERLAPPING #-}
         HasVkFlags VkDescriptorSetLayoutCreateInfo where
        type VkFlagsMType VkDescriptorSetLayoutCreateInfo =
             VkDescriptorSetLayoutCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetLayoutCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkDescriptorSetLayoutCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkDescriptorSetLayoutCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkDescriptorSetLayoutCreateInfo, flags}

class HasVkBindingCount a where
        type VkBindingCountMType a :: *

        vkBindingCount :: a -> VkBindingCountMType a

        vkBindingCountByteOffset :: a -> Int

        readVkBindingCount :: Ptr a -> IO (VkBindingCountMType a)

        writeVkBindingCount :: Ptr a -> VkBindingCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bindingCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBindingCount a

instance {-# OVERLAPPING #-}
         HasVkBindingCount VkDescriptorSetLayoutCreateInfo where
        type VkBindingCountMType VkDescriptorSetLayoutCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkBindingCount #-}
        vkBindingCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetLayoutCreateInfo, bindingCount})

        {-# INLINE vkBindingCountByteOffset #-}
        vkBindingCountByteOffset ~_
          = #{offset VkDescriptorSetLayoutCreateInfo, bindingCount}

        {-# INLINE readVkBindingCount #-}
        readVkBindingCount p
          = peekByteOff p
              #{offset VkDescriptorSetLayoutCreateInfo, bindingCount}

        {-# INLINE writeVkBindingCount #-}
        writeVkBindingCount p
          = pokeByteOff p
              #{offset VkDescriptorSetLayoutCreateInfo, bindingCount}

class HasVkPBindings a where
        type VkPBindingsMType a :: *

        vkPBindings :: a -> VkPBindingsMType a

        vkPBindingsByteOffset :: a -> Int

        readVkPBindings :: Ptr a -> IO (VkPBindingsMType a)

        writeVkPBindings :: Ptr a -> VkPBindingsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pBindings'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPBindings a

instance {-# OVERLAPPING #-}
         HasVkPBindings VkDescriptorSetLayoutCreateInfo where
        type VkPBindingsMType VkDescriptorSetLayoutCreateInfo =
             Foreign.Ptr.Ptr VkDescriptorSetLayoutBinding

        {-# NOINLINE vkPBindings #-}
        vkPBindings x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetLayoutCreateInfo, pBindings})

        {-# INLINE vkPBindingsByteOffset #-}
        vkPBindingsByteOffset ~_
          = #{offset VkDescriptorSetLayoutCreateInfo, pBindings}

        {-# INLINE readVkPBindings #-}
        readVkPBindings p
          = peekByteOff p
              #{offset VkDescriptorSetLayoutCreateInfo, pBindings}

        {-# INLINE writeVkPBindings #-}
        writeVkPBindings p
          = pokeByteOff p
              #{offset VkDescriptorSetLayoutCreateInfo, pBindings}

instance Show VkDescriptorSetLayoutCreateInfo where
        showsPrec d x
          = showString "VkDescriptorSetLayoutCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkBindingCount = " .
                                  showsPrec d (vkBindingCount x) .
                                    showString ", " .
                                      showString "vkPBindings = " .
                                        showsPrec d (vkPBindings x) . showChar '}'

data VkDescriptorPoolSize = VkDescriptorPoolSize## ByteArray##

instance Eq VkDescriptorPoolSize where
        (VkDescriptorPoolSize## a) == (VkDescriptorPoolSize## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDescriptorPoolSize where
        (VkDescriptorPoolSize## a) `compare` (VkDescriptorPoolSize## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDescriptorPoolSize where
        sizeOf ~_ = #{size VkDescriptorPoolSize}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDescriptorPoolSize}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDescriptorPoolSize),
            I## a <- alignment (undefined :: VkDescriptorPoolSize) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDescriptorPoolSize## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDescriptorPoolSize## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorPoolSize) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDescriptorPoolSize where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkDescriptorPoolSize),
            I## a <- alignment (undefined :: VkDescriptorPoolSize) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkDescriptorPoolSize##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkDescriptorPoolSize## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkDescriptorPoolSize##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkDescriptorPoolSize## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkDescriptorPoolSize## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkDescriptorPoolSize## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkType a where
        type VkTypeMType a :: *

        vkType :: a -> VkTypeMType a

        vkTypeByteOffset :: a -> Int

        readVkType :: Ptr a -> IO (VkTypeMType a)

        writeVkType :: Ptr a -> VkTypeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'type'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkType a

instance {-# OVERLAPPING #-} HasVkType VkDescriptorPoolSize where
        type VkTypeMType VkDescriptorPoolSize = VkDescriptorType

        {-# NOINLINE vkType #-}
        vkType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorPoolSize, type})

        {-# INLINE vkTypeByteOffset #-}
        vkTypeByteOffset ~_ = #{offset VkDescriptorPoolSize, type}

        {-# INLINE readVkType #-}
        readVkType p
          = peekByteOff p #{offset VkDescriptorPoolSize, type}

        {-# INLINE writeVkType #-}
        writeVkType p
          = pokeByteOff p #{offset VkDescriptorPoolSize, type}

instance {-# OVERLAPPING #-}
         HasVkDescriptorCount VkDescriptorPoolSize where
        type VkDescriptorCountMType VkDescriptorPoolSize = Data.Word.Word32

        {-# NOINLINE vkDescriptorCount #-}
        vkDescriptorCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorPoolSize, descriptorCount})

        {-# INLINE vkDescriptorCountByteOffset #-}
        vkDescriptorCountByteOffset ~_
          = #{offset VkDescriptorPoolSize, descriptorCount}

        {-# INLINE readVkDescriptorCount #-}
        readVkDescriptorCount p
          = peekByteOff p
              #{offset VkDescriptorPoolSize, descriptorCount}

        {-# INLINE writeVkDescriptorCount #-}
        writeVkDescriptorCount p
          = pokeByteOff p
              #{offset VkDescriptorPoolSize, descriptorCount}

instance Show VkDescriptorPoolSize where
        showsPrec d x
          = showString "VkDescriptorPoolSize {" .
              showString "vkType = " .
                showsPrec d (vkType x) .
                  showString ", " .
                    showString "vkDescriptorCount = " .
                      showsPrec d (vkDescriptorCount x) . showChar '}'

data VkDescriptorPoolCreateInfo = VkDescriptorPoolCreateInfo## ByteArray##

instance Eq VkDescriptorPoolCreateInfo where
        (VkDescriptorPoolCreateInfo## a) == (VkDescriptorPoolCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDescriptorPoolCreateInfo where
        (VkDescriptorPoolCreateInfo## a) `compare`
          (VkDescriptorPoolCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDescriptorPoolCreateInfo where
        sizeOf ~_ = #{size VkDescriptorPoolCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDescriptorPoolCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDescriptorPoolCreateInfo),
            I## a <- alignment (undefined :: VkDescriptorPoolCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDescriptorPoolCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDescriptorPoolCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorPoolCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDescriptorPoolCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkDescriptorPoolCreateInfo),
            I## a <- alignment (undefined :: VkDescriptorPoolCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkDescriptorPoolCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkDescriptorPoolCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkDescriptorPoolCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkDescriptorPoolCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkDescriptorPoolCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkDescriptorPoolCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkDescriptorPoolCreateInfo
         where
        type VkSTypeMType VkDescriptorPoolCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorPoolCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkDescriptorPoolCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkDescriptorPoolCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkDescriptorPoolCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkDescriptorPoolCreateInfo
         where
        type VkPNextMType VkDescriptorPoolCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorPoolCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkDescriptorPoolCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkDescriptorPoolCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkDescriptorPoolCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkDescriptorPoolCreateInfo
         where
        type VkFlagsMType VkDescriptorPoolCreateInfo =
             VkDescriptorPoolCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorPoolCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkDescriptorPoolCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkDescriptorPoolCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkDescriptorPoolCreateInfo, flags}

class HasVkMaxSets a where
        type VkMaxSetsMType a :: *

        vkMaxSets :: a -> VkMaxSetsMType a

        vkMaxSetsByteOffset :: a -> Int

        readVkMaxSets :: Ptr a -> IO (VkMaxSetsMType a)

        writeVkMaxSets :: Ptr a -> VkMaxSetsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxSets'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxSets a

instance {-# OVERLAPPING #-}
         HasVkMaxSets VkDescriptorPoolCreateInfo where
        type VkMaxSetsMType VkDescriptorPoolCreateInfo = Data.Word.Word32

        {-# NOINLINE vkMaxSets #-}
        vkMaxSets x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorPoolCreateInfo, maxSets})

        {-# INLINE vkMaxSetsByteOffset #-}
        vkMaxSetsByteOffset ~_
          = #{offset VkDescriptorPoolCreateInfo, maxSets}

        {-# INLINE readVkMaxSets #-}
        readVkMaxSets p
          = peekByteOff p
              #{offset VkDescriptorPoolCreateInfo, maxSets}

        {-# INLINE writeVkMaxSets #-}
        writeVkMaxSets p
          = pokeByteOff p
              #{offset VkDescriptorPoolCreateInfo, maxSets}

class HasVkPoolSizeCount a where
        type VkPoolSizeCountMType a :: *

        vkPoolSizeCount :: a -> VkPoolSizeCountMType a

        vkPoolSizeCountByteOffset :: a -> Int

        readVkPoolSizeCount :: Ptr a -> IO (VkPoolSizeCountMType a)

        writeVkPoolSizeCount :: Ptr a -> VkPoolSizeCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'poolSizeCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPoolSizeCount a

instance {-# OVERLAPPING #-}
         HasVkPoolSizeCount VkDescriptorPoolCreateInfo where
        type VkPoolSizeCountMType VkDescriptorPoolCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkPoolSizeCount #-}
        vkPoolSizeCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorPoolCreateInfo, poolSizeCount})

        {-# INLINE vkPoolSizeCountByteOffset #-}
        vkPoolSizeCountByteOffset ~_
          = #{offset VkDescriptorPoolCreateInfo, poolSizeCount}

        {-# INLINE readVkPoolSizeCount #-}
        readVkPoolSizeCount p
          = peekByteOff p
              #{offset VkDescriptorPoolCreateInfo, poolSizeCount}

        {-# INLINE writeVkPoolSizeCount #-}
        writeVkPoolSizeCount p
          = pokeByteOff p
              #{offset VkDescriptorPoolCreateInfo, poolSizeCount}

class HasVkPPoolSizes a where
        type VkPPoolSizesMType a :: *

        vkPPoolSizes :: a -> VkPPoolSizesMType a

        vkPPoolSizesByteOffset :: a -> Int

        readVkPPoolSizes :: Ptr a -> IO (VkPPoolSizesMType a)

        writeVkPPoolSizes :: Ptr a -> VkPPoolSizesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pPoolSizes'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPPoolSizes a

instance {-# OVERLAPPING #-}
         HasVkPPoolSizes VkDescriptorPoolCreateInfo where
        type VkPPoolSizesMType VkDescriptorPoolCreateInfo =
             Foreign.Ptr.Ptr VkDescriptorPoolSize

        {-# NOINLINE vkPPoolSizes #-}
        vkPPoolSizes x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorPoolCreateInfo, pPoolSizes})

        {-# INLINE vkPPoolSizesByteOffset #-}
        vkPPoolSizesByteOffset ~_
          = #{offset VkDescriptorPoolCreateInfo, pPoolSizes}

        {-# INLINE readVkPPoolSizes #-}
        readVkPPoolSizes p
          = peekByteOff p
              #{offset VkDescriptorPoolCreateInfo, pPoolSizes}

        {-# INLINE writeVkPPoolSizes #-}
        writeVkPPoolSizes p
          = pokeByteOff p
              #{offset VkDescriptorPoolCreateInfo, pPoolSizes}

instance Show VkDescriptorPoolCreateInfo where
        showsPrec d x
          = showString "VkDescriptorPoolCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkMaxSets = " .
                                  showsPrec d (vkMaxSets x) .
                                    showString ", " .
                                      showString "vkPoolSizeCount = " .
                                        showsPrec d (vkPoolSizeCount x) .
                                          showString ", " .
                                            showString "vkPPoolSizes = " .
                                              showsPrec d (vkPPoolSizes x) . showChar '}'

data VkDescriptorSetAllocateInfo = VkDescriptorSetAllocateInfo## ByteArray##

instance Eq VkDescriptorSetAllocateInfo where
        (VkDescriptorSetAllocateInfo## a) ==
          (VkDescriptorSetAllocateInfo## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDescriptorSetAllocateInfo where
        (VkDescriptorSetAllocateInfo## a) `compare`
          (VkDescriptorSetAllocateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDescriptorSetAllocateInfo where
        sizeOf ~_ = #{size VkDescriptorSetAllocateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDescriptorSetAllocateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDescriptorSetAllocateInfo),
            I## a <- alignment (undefined :: VkDescriptorSetAllocateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDescriptorSetAllocateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDescriptorSetAllocateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorSetAllocateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDescriptorSetAllocateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkDescriptorSetAllocateInfo),
            I## a <- alignment (undefined :: VkDescriptorSetAllocateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkDescriptorSetAllocateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkDescriptorSetAllocateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkDescriptorSetAllocateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkDescriptorSetAllocateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkDescriptorSetAllocateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkDescriptorSetAllocateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkDescriptorSetAllocateInfo
         where
        type VkSTypeMType VkDescriptorSetAllocateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetAllocateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkDescriptorSetAllocateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkDescriptorSetAllocateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkDescriptorSetAllocateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkDescriptorSetAllocateInfo
         where
        type VkPNextMType VkDescriptorSetAllocateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetAllocateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkDescriptorSetAllocateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkDescriptorSetAllocateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkDescriptorSetAllocateInfo, pNext}

class HasVkDescriptorPool a where
        type VkDescriptorPoolMType a :: *

        vkDescriptorPool :: a -> VkDescriptorPoolMType a

        vkDescriptorPoolByteOffset :: a -> Int

        readVkDescriptorPool :: Ptr a -> IO (VkDescriptorPoolMType a)

        writeVkDescriptorPool :: Ptr a -> VkDescriptorPoolMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'descriptorPool'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDescriptorPool a

instance {-# OVERLAPPING #-}
         HasVkDescriptorPool VkDescriptorSetAllocateInfo where
        type VkDescriptorPoolMType VkDescriptorSetAllocateInfo =
             VkDescriptorPool

        {-# NOINLINE vkDescriptorPool #-}
        vkDescriptorPool x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetAllocateInfo, descriptorPool})

        {-# INLINE vkDescriptorPoolByteOffset #-}
        vkDescriptorPoolByteOffset ~_
          = #{offset VkDescriptorSetAllocateInfo, descriptorPool}

        {-# INLINE readVkDescriptorPool #-}
        readVkDescriptorPool p
          = peekByteOff p
              #{offset VkDescriptorSetAllocateInfo, descriptorPool}

        {-# INLINE writeVkDescriptorPool #-}
        writeVkDescriptorPool p
          = pokeByteOff p
              #{offset VkDescriptorSetAllocateInfo, descriptorPool}

class HasVkDescriptorSetCount a where
        type VkDescriptorSetCountMType a :: *

        vkDescriptorSetCount :: a -> VkDescriptorSetCountMType a

        vkDescriptorSetCountByteOffset :: a -> Int

        readVkDescriptorSetCount ::
                                 Ptr a -> IO (VkDescriptorSetCountMType a)

        writeVkDescriptorSetCount ::
                                  Ptr a -> VkDescriptorSetCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'descriptorSetCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDescriptorSetCount a

instance {-# OVERLAPPING #-}
         HasVkDescriptorSetCount VkDescriptorSetAllocateInfo where
        type VkDescriptorSetCountMType VkDescriptorSetAllocateInfo =
             Data.Word.Word32

        {-# NOINLINE vkDescriptorSetCount #-}
        vkDescriptorSetCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetAllocateInfo, descriptorSetCount})

        {-# INLINE vkDescriptorSetCountByteOffset #-}
        vkDescriptorSetCountByteOffset ~_
          = #{offset VkDescriptorSetAllocateInfo, descriptorSetCount}

        {-# INLINE readVkDescriptorSetCount #-}
        readVkDescriptorSetCount p
          = peekByteOff p
              #{offset VkDescriptorSetAllocateInfo, descriptorSetCount}

        {-# INLINE writeVkDescriptorSetCount #-}
        writeVkDescriptorSetCount p
          = pokeByteOff p
              #{offset VkDescriptorSetAllocateInfo, descriptorSetCount}

class HasVkPSetLayouts a where
        type VkPSetLayoutsMType a :: *

        vkPSetLayouts :: a -> VkPSetLayoutsMType a

        vkPSetLayoutsByteOffset :: a -> Int

        readVkPSetLayouts :: Ptr a -> IO (VkPSetLayoutsMType a)

        writeVkPSetLayouts :: Ptr a -> VkPSetLayoutsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pSetLayouts'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPSetLayouts a

instance {-# OVERLAPPING #-}
         HasVkPSetLayouts VkDescriptorSetAllocateInfo where
        type VkPSetLayoutsMType VkDescriptorSetAllocateInfo =
             Foreign.Ptr.Ptr VkDescriptorSetLayout

        {-# NOINLINE vkPSetLayouts #-}
        vkPSetLayouts x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkDescriptorSetAllocateInfo, pSetLayouts})

        {-# INLINE vkPSetLayoutsByteOffset #-}
        vkPSetLayoutsByteOffset ~_
          = #{offset VkDescriptorSetAllocateInfo, pSetLayouts}

        {-# INLINE readVkPSetLayouts #-}
        readVkPSetLayouts p
          = peekByteOff p
              #{offset VkDescriptorSetAllocateInfo, pSetLayouts}

        {-# INLINE writeVkPSetLayouts #-}
        writeVkPSetLayouts p
          = pokeByteOff p
              #{offset VkDescriptorSetAllocateInfo, pSetLayouts}

instance Show VkDescriptorSetAllocateInfo where
        showsPrec d x
          = showString "VkDescriptorSetAllocateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkDescriptorPool = " .
                            showsPrec d (vkDescriptorPool x) .
                              showString ", " .
                                showString "vkDescriptorSetCount = " .
                                  showsPrec d (vkDescriptorSetCount x) .
                                    showString ", " .
                                      showString "vkPSetLayouts = " .
                                        showsPrec d (vkPSetLayouts x) . showChar '}'

data VkSpecializationMapEntry = VkSpecializationMapEntry## ByteArray##

instance Eq VkSpecializationMapEntry where
        (VkSpecializationMapEntry## a) == (VkSpecializationMapEntry## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSpecializationMapEntry where
        (VkSpecializationMapEntry## a) `compare`
          (VkSpecializationMapEntry## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSpecializationMapEntry where
        sizeOf ~_ = #{size VkSpecializationMapEntry}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSpecializationMapEntry}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSpecializationMapEntry),
            I## a <- alignment (undefined :: VkSpecializationMapEntry) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSpecializationMapEntry##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSpecializationMapEntry## ba)
          | I## n <- sizeOf (undefined :: VkSpecializationMapEntry) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSpecializationMapEntry where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSpecializationMapEntry),
            I## a <- alignment (undefined :: VkSpecializationMapEntry) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSpecializationMapEntry##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSpecializationMapEntry## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSpecializationMapEntry##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSpecializationMapEntry## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSpecializationMapEntry## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSpecializationMapEntry## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkConstantID a where
        type VkConstantIDMType a :: *

        vkConstantID :: a -> VkConstantIDMType a

        vkConstantIDByteOffset :: a -> Int

        readVkConstantID :: Ptr a -> IO (VkConstantIDMType a)

        writeVkConstantID :: Ptr a -> VkConstantIDMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'constantID'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkConstantID a

instance {-# OVERLAPPING #-}
         HasVkConstantID VkSpecializationMapEntry where
        type VkConstantIDMType VkSpecializationMapEntry = Data.Word.Word32

        {-# NOINLINE vkConstantID #-}
        vkConstantID x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSpecializationMapEntry, constantID})

        {-# INLINE vkConstantIDByteOffset #-}
        vkConstantIDByteOffset ~_
          = #{offset VkSpecializationMapEntry, constantID}

        {-# INLINE readVkConstantID #-}
        readVkConstantID p
          = peekByteOff p
              #{offset VkSpecializationMapEntry, constantID}

        {-# INLINE writeVkConstantID #-}
        writeVkConstantID p
          = pokeByteOff p
              #{offset VkSpecializationMapEntry, constantID}

instance {-# OVERLAPPING #-} HasVkOffset VkSpecializationMapEntry
         where
        type VkOffsetMType VkSpecializationMapEntry = Data.Word.Word32

        {-# NOINLINE vkOffset #-}
        vkOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSpecializationMapEntry, offset})

        {-# INLINE vkOffsetByteOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkSpecializationMapEntry, offset}

        {-# INLINE readVkOffset #-}
        readVkOffset p
          = peekByteOff p #{offset VkSpecializationMapEntry, offset}

        {-# INLINE writeVkOffset #-}
        writeVkOffset p
          = pokeByteOff p #{offset VkSpecializationMapEntry, offset}

instance {-# OVERLAPPING #-} HasVkSize VkSpecializationMapEntry
         where
        type VkSizeMType VkSpecializationMapEntry = Foreign.C.Types.CSize

        {-# NOINLINE vkSize #-}
        vkSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSpecializationMapEntry, size})

        {-# INLINE vkSizeByteOffset #-}
        vkSizeByteOffset ~_
          = #{offset VkSpecializationMapEntry, size}

        {-# INLINE readVkSize #-}
        readVkSize p
          = peekByteOff p #{offset VkSpecializationMapEntry, size}

        {-# INLINE writeVkSize #-}
        writeVkSize p
          = pokeByteOff p #{offset VkSpecializationMapEntry, size}

instance Show VkSpecializationMapEntry where
        showsPrec d x
          = showString "VkSpecializationMapEntry {" .
              showString "vkConstantID = " .
                showsPrec d (vkConstantID x) .
                  showString ", " .
                    showString "vkOffset = " .
                      showsPrec d (vkOffset x) .
                        showString ", " .
                          showString "vkSize = " . showsPrec d (vkSize x) . showChar '}'

data VkSpecializationInfo = VkSpecializationInfo## ByteArray##

instance Eq VkSpecializationInfo where
        (VkSpecializationInfo## a) == (VkSpecializationInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSpecializationInfo where
        (VkSpecializationInfo## a) `compare` (VkSpecializationInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSpecializationInfo where
        sizeOf ~_ = #{size VkSpecializationInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSpecializationInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSpecializationInfo),
            I## a <- alignment (undefined :: VkSpecializationInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSpecializationInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSpecializationInfo## ba)
          | I## n <- sizeOf (undefined :: VkSpecializationInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSpecializationInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSpecializationInfo),
            I## a <- alignment (undefined :: VkSpecializationInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSpecializationInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSpecializationInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSpecializationInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSpecializationInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSpecializationInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSpecializationInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkMapEntryCount a where
        type VkMapEntryCountMType a :: *

        vkMapEntryCount :: a -> VkMapEntryCountMType a

        vkMapEntryCountByteOffset :: a -> Int

        readVkMapEntryCount :: Ptr a -> IO (VkMapEntryCountMType a)

        writeVkMapEntryCount :: Ptr a -> VkMapEntryCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'mapEntryCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMapEntryCount a

instance {-# OVERLAPPING #-}
         HasVkMapEntryCount VkSpecializationInfo where
        type VkMapEntryCountMType VkSpecializationInfo = Data.Word.Word32

        {-# NOINLINE vkMapEntryCount #-}
        vkMapEntryCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSpecializationInfo, mapEntryCount})

        {-# INLINE vkMapEntryCountByteOffset #-}
        vkMapEntryCountByteOffset ~_
          = #{offset VkSpecializationInfo, mapEntryCount}

        {-# INLINE readVkMapEntryCount #-}
        readVkMapEntryCount p
          = peekByteOff p
              #{offset VkSpecializationInfo, mapEntryCount}

        {-# INLINE writeVkMapEntryCount #-}
        writeVkMapEntryCount p
          = pokeByteOff p
              #{offset VkSpecializationInfo, mapEntryCount}

class HasVkPMapEntries a where
        type VkPMapEntriesMType a :: *

        vkPMapEntries :: a -> VkPMapEntriesMType a

        vkPMapEntriesByteOffset :: a -> Int

        readVkPMapEntries :: Ptr a -> IO (VkPMapEntriesMType a)

        writeVkPMapEntries :: Ptr a -> VkPMapEntriesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pMapEntries'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPMapEntries a

instance {-# OVERLAPPING #-} HasVkPMapEntries VkSpecializationInfo
         where
        type VkPMapEntriesMType VkSpecializationInfo =
             Foreign.Ptr.Ptr VkSpecializationMapEntry

        {-# NOINLINE vkPMapEntries #-}
        vkPMapEntries x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSpecializationInfo, pMapEntries})

        {-# INLINE vkPMapEntriesByteOffset #-}
        vkPMapEntriesByteOffset ~_
          = #{offset VkSpecializationInfo, pMapEntries}

        {-# INLINE readVkPMapEntries #-}
        readVkPMapEntries p
          = peekByteOff p
              #{offset VkSpecializationInfo, pMapEntries}

        {-# INLINE writeVkPMapEntries #-}
        writeVkPMapEntries p
          = pokeByteOff p
              #{offset VkSpecializationInfo, pMapEntries}

class HasVkDataSize a where
        type VkDataSizeMType a :: *

        vkDataSize :: a -> VkDataSizeMType a

        vkDataSizeByteOffset :: a -> Int

        readVkDataSize :: Ptr a -> IO (VkDataSizeMType a)

        writeVkDataSize :: Ptr a -> VkDataSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dataSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDataSize a

instance {-# OVERLAPPING #-} HasVkDataSize VkSpecializationInfo
         where
        type VkDataSizeMType VkSpecializationInfo = Foreign.C.Types.CSize

        {-# NOINLINE vkDataSize #-}
        vkDataSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSpecializationInfo, dataSize})

        {-# INLINE vkDataSizeByteOffset #-}
        vkDataSizeByteOffset ~_
          = #{offset VkSpecializationInfo, dataSize}

        {-# INLINE readVkDataSize #-}
        readVkDataSize p
          = peekByteOff p #{offset VkSpecializationInfo, dataSize}

        {-# INLINE writeVkDataSize #-}
        writeVkDataSize p
          = pokeByteOff p #{offset VkSpecializationInfo, dataSize}

class HasVkPData a where
        type VkPDataMType a :: *

        vkPData :: a -> VkPDataMType a

        vkPDataByteOffset :: a -> Int

        readVkPData :: Ptr a -> IO (VkPDataMType a)

        writeVkPData :: Ptr a -> VkPDataMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pData'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPData a

instance {-# OVERLAPPING #-} HasVkPData VkSpecializationInfo where
        type VkPDataMType VkSpecializationInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPData #-}
        vkPData x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSpecializationInfo, pData})

        {-# INLINE vkPDataByteOffset #-}
        vkPDataByteOffset ~_
          = #{offset VkSpecializationInfo, pData}

        {-# INLINE readVkPData #-}
        readVkPData p
          = peekByteOff p #{offset VkSpecializationInfo, pData}

        {-# INLINE writeVkPData #-}
        writeVkPData p
          = pokeByteOff p #{offset VkSpecializationInfo, pData}

instance Show VkSpecializationInfo where
        showsPrec d x
          = showString "VkSpecializationInfo {" .
              showString "vkMapEntryCount = " .
                showsPrec d (vkMapEntryCount x) .
                  showString ", " .
                    showString "vkPMapEntries = " .
                      showsPrec d (vkPMapEntries x) .
                        showString ", " .
                          showString "vkDataSize = " .
                            showsPrec d (vkDataSize x) .
                              showString ", " .
                                showString "vkPData = " . showsPrec d (vkPData x) . showChar '}'

data VkPipelineShaderStageCreateInfo = VkPipelineShaderStageCreateInfo## ByteArray##

instance Eq VkPipelineShaderStageCreateInfo where
        (VkPipelineShaderStageCreateInfo## a) ==
          (VkPipelineShaderStageCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineShaderStageCreateInfo where
        (VkPipelineShaderStageCreateInfo## a) `compare`
          (VkPipelineShaderStageCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineShaderStageCreateInfo where
        sizeOf ~_ = #{size VkPipelineShaderStageCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPipelineShaderStageCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPipelineShaderStageCreateInfo),
            I## a <- alignment (undefined :: VkPipelineShaderStageCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineShaderStageCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineShaderStageCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineShaderStageCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineShaderStageCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkPipelineShaderStageCreateInfo),
            I## a <- alignment (undefined :: VkPipelineShaderStageCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPipelineShaderStageCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPipelineShaderStageCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkPipelineShaderStageCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPipelineShaderStageCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPipelineShaderStageCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPipelineShaderStageCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineShaderStageCreateInfo where
        type VkSTypeMType VkPipelineShaderStageCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineShaderStageCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineShaderStageCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkPipelineShaderStageCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkPipelineShaderStageCreateInfo, sType}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineShaderStageCreateInfo where
        type VkPNextMType VkPipelineShaderStageCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineShaderStageCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineShaderStageCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkPipelineShaderStageCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkPipelineShaderStageCreateInfo, pNext}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineShaderStageCreateInfo where
        type VkFlagsMType VkPipelineShaderStageCreateInfo =
             VkPipelineShaderStageCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineShaderStageCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineShaderStageCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkPipelineShaderStageCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkPipelineShaderStageCreateInfo, flags}

class HasVkStage a where
        type VkStageMType a :: *

        vkStage :: a -> VkStageMType a

        vkStageByteOffset :: a -> Int

        readVkStage :: Ptr a -> IO (VkStageMType a)

        writeVkStage :: Ptr a -> VkStageMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stage'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStage a

instance {-# OVERLAPPING #-}
         HasVkStage VkPipelineShaderStageCreateInfo where
        type VkStageMType VkPipelineShaderStageCreateInfo =
             VkShaderStageFlagBits

        {-# NOINLINE vkStage #-}
        vkStage x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineShaderStageCreateInfo, stage})

        {-# INLINE vkStageByteOffset #-}
        vkStageByteOffset ~_
          = #{offset VkPipelineShaderStageCreateInfo, stage}

        {-# INLINE readVkStage #-}
        readVkStage p
          = peekByteOff p
              #{offset VkPipelineShaderStageCreateInfo, stage}

        {-# INLINE writeVkStage #-}
        writeVkStage p
          = pokeByteOff p
              #{offset VkPipelineShaderStageCreateInfo, stage}

class HasVkModule a where
        type VkModuleMType a :: *

        vkModule :: a -> VkModuleMType a

        vkModuleByteOffset :: a -> Int

        readVkModule :: Ptr a -> IO (VkModuleMType a)

        writeVkModule :: Ptr a -> VkModuleMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'module'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkModule a

instance {-# OVERLAPPING #-}
         HasVkModule VkPipelineShaderStageCreateInfo where
        type VkModuleMType VkPipelineShaderStageCreateInfo = VkShaderModule

        {-# NOINLINE vkModule #-}
        vkModule x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineShaderStageCreateInfo, module})

        {-# INLINE vkModuleByteOffset #-}
        vkModuleByteOffset ~_
          = #{offset VkPipelineShaderStageCreateInfo, module}

        {-# INLINE readVkModule #-}
        readVkModule p
          = peekByteOff p
              #{offset VkPipelineShaderStageCreateInfo, module}

        {-# INLINE writeVkModule #-}
        writeVkModule p
          = pokeByteOff p
              #{offset VkPipelineShaderStageCreateInfo, module}

class HasVkPName a where
        type VkPNameMType a :: *

        vkPName :: a -> VkPNameMType a

        vkPNameByteOffset :: a -> Int

        readVkPName :: Ptr a -> IO (VkPNameMType a)

        writeVkPName :: Ptr a -> VkPNameMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pName'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPName a

instance {-# OVERLAPPING #-}
         HasVkPName VkPipelineShaderStageCreateInfo where
        type VkPNameMType VkPipelineShaderStageCreateInfo =
             Foreign.Ptr.Ptr Foreign.C.Types.CChar

        {-# NOINLINE vkPName #-}
        vkPName x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineShaderStageCreateInfo, pName})

        {-# INLINE vkPNameByteOffset #-}
        vkPNameByteOffset ~_
          = #{offset VkPipelineShaderStageCreateInfo, pName}

        {-# INLINE readVkPName #-}
        readVkPName p
          = peekByteOff p
              #{offset VkPipelineShaderStageCreateInfo, pName}

        {-# INLINE writeVkPName #-}
        writeVkPName p
          = pokeByteOff p
              #{offset VkPipelineShaderStageCreateInfo, pName}

class HasVkPSpecializationInfo a where
        type VkPSpecializationInfoMType a :: *

        vkPSpecializationInfo :: a -> VkPSpecializationInfoMType a

        vkPSpecializationInfoByteOffset :: a -> Int

        readVkPSpecializationInfo ::
                                  Ptr a -> IO (VkPSpecializationInfoMType a)

        writeVkPSpecializationInfo ::
                                   Ptr a -> VkPSpecializationInfoMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pSpecializationInfo'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPSpecializationInfo a

instance {-# OVERLAPPING #-}
         HasVkPSpecializationInfo VkPipelineShaderStageCreateInfo where
        type VkPSpecializationInfoMType VkPipelineShaderStageCreateInfo =
             Foreign.Ptr.Ptr VkSpecializationInfo

        {-# NOINLINE vkPSpecializationInfo #-}
        vkPSpecializationInfo x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineShaderStageCreateInfo, pSpecializationInfo})

        {-# INLINE vkPSpecializationInfoByteOffset #-}
        vkPSpecializationInfoByteOffset ~_
          = #{offset VkPipelineShaderStageCreateInfo, pSpecializationInfo}

        {-# INLINE readVkPSpecializationInfo #-}
        readVkPSpecializationInfo p
          = peekByteOff p
              #{offset VkPipelineShaderStageCreateInfo, pSpecializationInfo}

        {-# INLINE writeVkPSpecializationInfo #-}
        writeVkPSpecializationInfo p
          = pokeByteOff p
              #{offset VkPipelineShaderStageCreateInfo, pSpecializationInfo}

instance Show VkPipelineShaderStageCreateInfo where
        showsPrec d x
          = showString "VkPipelineShaderStageCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkStage = " .
                                  showsPrec d (vkStage x) .
                                    showString ", " .
                                      showString "vkModule = " .
                                        showsPrec d (vkModule x) .
                                          showString ", " .
                                            showString "vkPName = " .
                                              showsPrec d (vkPName x) .
                                                showString ", " .
                                                  showString "vkPSpecializationInfo = " .
                                                    showsPrec d (vkPSpecializationInfo x) .
                                                      showChar '}'

data VkComputePipelineCreateInfo = VkComputePipelineCreateInfo## ByteArray##

instance Eq VkComputePipelineCreateInfo where
        (VkComputePipelineCreateInfo## a) ==
          (VkComputePipelineCreateInfo## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkComputePipelineCreateInfo where
        (VkComputePipelineCreateInfo## a) `compare`
          (VkComputePipelineCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkComputePipelineCreateInfo where
        sizeOf ~_ = #{size VkComputePipelineCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkComputePipelineCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkComputePipelineCreateInfo),
            I## a <- alignment (undefined :: VkComputePipelineCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkComputePipelineCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkComputePipelineCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkComputePipelineCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkComputePipelineCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkComputePipelineCreateInfo),
            I## a <- alignment (undefined :: VkComputePipelineCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkComputePipelineCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkComputePipelineCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkComputePipelineCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkComputePipelineCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkComputePipelineCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkComputePipelineCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkComputePipelineCreateInfo
         where
        type VkSTypeMType VkComputePipelineCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkComputePipelineCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkComputePipelineCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkComputePipelineCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkComputePipelineCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkComputePipelineCreateInfo
         where
        type VkPNextMType VkComputePipelineCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkComputePipelineCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkComputePipelineCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkComputePipelineCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkComputePipelineCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkComputePipelineCreateInfo
         where
        type VkFlagsMType VkComputePipelineCreateInfo =
             VkPipelineCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkComputePipelineCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkComputePipelineCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkComputePipelineCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkComputePipelineCreateInfo, flags}

instance {-# OVERLAPPING #-} HasVkStage VkComputePipelineCreateInfo
         where
        type VkStageMType VkComputePipelineCreateInfo =
             VkPipelineShaderStageCreateInfo

        {-# NOINLINE vkStage #-}
        vkStage x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkComputePipelineCreateInfo, stage})

        {-# INLINE vkStageByteOffset #-}
        vkStageByteOffset ~_
          = #{offset VkComputePipelineCreateInfo, stage}

        {-# INLINE readVkStage #-}
        readVkStage p
          = peekByteOff p
              #{offset VkComputePipelineCreateInfo, stage}

        {-# INLINE writeVkStage #-}
        writeVkStage p
          = pokeByteOff p
              #{offset VkComputePipelineCreateInfo, stage}

class HasVkLayout a where
        type VkLayoutMType a :: *

        vkLayout :: a -> VkLayoutMType a

        vkLayoutByteOffset :: a -> Int

        readVkLayout :: Ptr a -> IO (VkLayoutMType a)

        writeVkLayout :: Ptr a -> VkLayoutMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'layout'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLayout a

instance {-# OVERLAPPING #-}
         HasVkLayout VkComputePipelineCreateInfo where
        type VkLayoutMType VkComputePipelineCreateInfo = VkPipelineLayout

        {-# NOINLINE vkLayout #-}
        vkLayout x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkComputePipelineCreateInfo, layout})

        {-# INLINE vkLayoutByteOffset #-}
        vkLayoutByteOffset ~_
          = #{offset VkComputePipelineCreateInfo, layout}

        {-# INLINE readVkLayout #-}
        readVkLayout p
          = peekByteOff p
              #{offset VkComputePipelineCreateInfo, layout}

        {-# INLINE writeVkLayout #-}
        writeVkLayout p
          = pokeByteOff p
              #{offset VkComputePipelineCreateInfo, layout}

class HasVkBasePipelineHandle a where
        type VkBasePipelineHandleMType a :: *

        vkBasePipelineHandle :: a -> VkBasePipelineHandleMType a

        vkBasePipelineHandleByteOffset :: a -> Int

        readVkBasePipelineHandle ::
                                 Ptr a -> IO (VkBasePipelineHandleMType a)

        writeVkBasePipelineHandle ::
                                  Ptr a -> VkBasePipelineHandleMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'basePipelineHandle'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBasePipelineHandle a

instance {-# OVERLAPPING #-}
         HasVkBasePipelineHandle VkComputePipelineCreateInfo where
        type VkBasePipelineHandleMType VkComputePipelineCreateInfo =
             VkPipeline

        {-# NOINLINE vkBasePipelineHandle #-}
        vkBasePipelineHandle x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkComputePipelineCreateInfo, basePipelineHandle})

        {-# INLINE vkBasePipelineHandleByteOffset #-}
        vkBasePipelineHandleByteOffset ~_
          = #{offset VkComputePipelineCreateInfo, basePipelineHandle}

        {-# INLINE readVkBasePipelineHandle #-}
        readVkBasePipelineHandle p
          = peekByteOff p
              #{offset VkComputePipelineCreateInfo, basePipelineHandle}

        {-# INLINE writeVkBasePipelineHandle #-}
        writeVkBasePipelineHandle p
          = pokeByteOff p
              #{offset VkComputePipelineCreateInfo, basePipelineHandle}

class HasVkBasePipelineIndex a where
        type VkBasePipelineIndexMType a :: *

        vkBasePipelineIndex :: a -> VkBasePipelineIndexMType a

        vkBasePipelineIndexByteOffset :: a -> Int

        readVkBasePipelineIndex :: Ptr a -> IO (VkBasePipelineIndexMType a)

        writeVkBasePipelineIndex ::
                                 Ptr a -> VkBasePipelineIndexMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'basePipelineIndex'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBasePipelineIndex a

instance {-# OVERLAPPING #-}
         HasVkBasePipelineIndex VkComputePipelineCreateInfo where
        type VkBasePipelineIndexMType VkComputePipelineCreateInfo =
             Data.Int.Int32

        {-# NOINLINE vkBasePipelineIndex #-}
        vkBasePipelineIndex x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkComputePipelineCreateInfo, basePipelineIndex})

        {-# INLINE vkBasePipelineIndexByteOffset #-}
        vkBasePipelineIndexByteOffset ~_
          = #{offset VkComputePipelineCreateInfo, basePipelineIndex}

        {-# INLINE readVkBasePipelineIndex #-}
        readVkBasePipelineIndex p
          = peekByteOff p
              #{offset VkComputePipelineCreateInfo, basePipelineIndex}

        {-# INLINE writeVkBasePipelineIndex #-}
        writeVkBasePipelineIndex p
          = pokeByteOff p
              #{offset VkComputePipelineCreateInfo, basePipelineIndex}

instance Show VkComputePipelineCreateInfo where
        showsPrec d x
          = showString "VkComputePipelineCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkStage = " .
                                  showsPrec d (vkStage x) .
                                    showString ", " .
                                      showString "vkLayout = " .
                                        showsPrec d (vkLayout x) .
                                          showString ", " .
                                            showString "vkBasePipelineHandle = " .
                                              showsPrec d (vkBasePipelineHandle x) .
                                                showString ", " .
                                                  showString "vkBasePipelineIndex = " .
                                                    showsPrec d (vkBasePipelineIndex x) .
                                                      showChar '}'

data VkVertexInputBindingDescription = VkVertexInputBindingDescription## ByteArray##

instance Eq VkVertexInputBindingDescription where
        (VkVertexInputBindingDescription## a) ==
          (VkVertexInputBindingDescription## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkVertexInputBindingDescription where
        (VkVertexInputBindingDescription## a) `compare`
          (VkVertexInputBindingDescription## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkVertexInputBindingDescription where
        sizeOf ~_ = #{size VkVertexInputBindingDescription}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkVertexInputBindingDescription}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkVertexInputBindingDescription),
            I## a <- alignment (undefined :: VkVertexInputBindingDescription) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkVertexInputBindingDescription##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkVertexInputBindingDescription## ba)
          | I## n <- sizeOf (undefined :: VkVertexInputBindingDescription) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkVertexInputBindingDescription where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkVertexInputBindingDescription),
            I## a <- alignment (undefined :: VkVertexInputBindingDescription) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkVertexInputBindingDescription##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkVertexInputBindingDescription## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkVertexInputBindingDescription##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkVertexInputBindingDescription## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkVertexInputBindingDescription## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkVertexInputBindingDescription## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkBinding VkVertexInputBindingDescription where
        type VkBindingMType VkVertexInputBindingDescription =
             Data.Word.Word32

        {-# NOINLINE vkBinding #-}
        vkBinding x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkVertexInputBindingDescription, binding})

        {-# INLINE vkBindingByteOffset #-}
        vkBindingByteOffset ~_
          = #{offset VkVertexInputBindingDescription, binding}

        {-# INLINE readVkBinding #-}
        readVkBinding p
          = peekByteOff p
              #{offset VkVertexInputBindingDescription, binding}

        {-# INLINE writeVkBinding #-}
        writeVkBinding p
          = pokeByteOff p
              #{offset VkVertexInputBindingDescription, binding}

class HasVkStride a where
        type VkStrideMType a :: *

        vkStride :: a -> VkStrideMType a

        vkStrideByteOffset :: a -> Int

        readVkStride :: Ptr a -> IO (VkStrideMType a)

        writeVkStride :: Ptr a -> VkStrideMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stride'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStride a

instance {-# OVERLAPPING #-}
         HasVkStride VkVertexInputBindingDescription where
        type VkStrideMType VkVertexInputBindingDescription =
             Data.Word.Word32

        {-# NOINLINE vkStride #-}
        vkStride x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkVertexInputBindingDescription, stride})

        {-# INLINE vkStrideByteOffset #-}
        vkStrideByteOffset ~_
          = #{offset VkVertexInputBindingDescription, stride}

        {-# INLINE readVkStride #-}
        readVkStride p
          = peekByteOff p
              #{offset VkVertexInputBindingDescription, stride}

        {-# INLINE writeVkStride #-}
        writeVkStride p
          = pokeByteOff p
              #{offset VkVertexInputBindingDescription, stride}

class HasVkInputRate a where
        type VkInputRateMType a :: *

        vkInputRate :: a -> VkInputRateMType a

        vkInputRateByteOffset :: a -> Int

        readVkInputRate :: Ptr a -> IO (VkInputRateMType a)

        writeVkInputRate :: Ptr a -> VkInputRateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'inputRate'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkInputRate a

instance {-# OVERLAPPING #-}
         HasVkInputRate VkVertexInputBindingDescription where
        type VkInputRateMType VkVertexInputBindingDescription =
             VkVertexInputRate

        {-# NOINLINE vkInputRate #-}
        vkInputRate x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkVertexInputBindingDescription, inputRate})

        {-# INLINE vkInputRateByteOffset #-}
        vkInputRateByteOffset ~_
          = #{offset VkVertexInputBindingDescription, inputRate}

        {-# INLINE readVkInputRate #-}
        readVkInputRate p
          = peekByteOff p
              #{offset VkVertexInputBindingDescription, inputRate}

        {-# INLINE writeVkInputRate #-}
        writeVkInputRate p
          = pokeByteOff p
              #{offset VkVertexInputBindingDescription, inputRate}

instance Show VkVertexInputBindingDescription where
        showsPrec d x
          = showString "VkVertexInputBindingDescription {" .
              showString "vkBinding = " .
                showsPrec d (vkBinding x) .
                  showString ", " .
                    showString "vkStride = " .
                      showsPrec d (vkStride x) .
                        showString ", " .
                          showString "vkInputRate = " .
                            showsPrec d (vkInputRate x) . showChar '}'

data VkVertexInputAttributeDescription = VkVertexInputAttributeDescription## ByteArray##

instance Eq VkVertexInputAttributeDescription where
        (VkVertexInputAttributeDescription## a) ==
          (VkVertexInputAttributeDescription## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkVertexInputAttributeDescription where
        (VkVertexInputAttributeDescription## a) `compare`
          (VkVertexInputAttributeDescription## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkVertexInputAttributeDescription where
        sizeOf ~_ = #{size VkVertexInputAttributeDescription}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkVertexInputAttributeDescription}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkVertexInputAttributeDescription),
            I## a <- alignment (undefined :: VkVertexInputAttributeDescription)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkVertexInputAttributeDescription##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkVertexInputAttributeDescription## ba)
          | I## n <- sizeOf (undefined :: VkVertexInputAttributeDescription) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkVertexInputAttributeDescription where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkVertexInputAttributeDescription),
            I## a <- alignment (undefined :: VkVertexInputAttributeDescription)
            =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkVertexInputAttributeDescription##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkVertexInputAttributeDescription## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkVertexInputAttributeDescription##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkVertexInputAttributeDescription## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkVertexInputAttributeDescription## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkVertexInputAttributeDescription## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkLocation a where
        type VkLocationMType a :: *

        vkLocation :: a -> VkLocationMType a

        vkLocationByteOffset :: a -> Int

        readVkLocation :: Ptr a -> IO (VkLocationMType a)

        writeVkLocation :: Ptr a -> VkLocationMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'location'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLocation a

instance {-# OVERLAPPING #-}
         HasVkLocation VkVertexInputAttributeDescription where
        type VkLocationMType VkVertexInputAttributeDescription =
             Data.Word.Word32

        {-# NOINLINE vkLocation #-}
        vkLocation x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkVertexInputAttributeDescription, location})

        {-# INLINE vkLocationByteOffset #-}
        vkLocationByteOffset ~_
          = #{offset VkVertexInputAttributeDescription, location}

        {-# INLINE readVkLocation #-}
        readVkLocation p
          = peekByteOff p
              #{offset VkVertexInputAttributeDescription, location}

        {-# INLINE writeVkLocation #-}
        writeVkLocation p
          = pokeByteOff p
              #{offset VkVertexInputAttributeDescription, location}

instance {-# OVERLAPPING #-}
         HasVkBinding VkVertexInputAttributeDescription where
        type VkBindingMType VkVertexInputAttributeDescription =
             Data.Word.Word32

        {-# NOINLINE vkBinding #-}
        vkBinding x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkVertexInputAttributeDescription, binding})

        {-# INLINE vkBindingByteOffset #-}
        vkBindingByteOffset ~_
          = #{offset VkVertexInputAttributeDescription, binding}

        {-# INLINE readVkBinding #-}
        readVkBinding p
          = peekByteOff p
              #{offset VkVertexInputAttributeDescription, binding}

        {-# INLINE writeVkBinding #-}
        writeVkBinding p
          = pokeByteOff p
              #{offset VkVertexInputAttributeDescription, binding}

instance {-# OVERLAPPING #-}
         HasVkFormat VkVertexInputAttributeDescription where
        type VkFormatMType VkVertexInputAttributeDescription = VkFormat

        {-# NOINLINE vkFormat #-}
        vkFormat x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkVertexInputAttributeDescription, format})

        {-# INLINE vkFormatByteOffset #-}
        vkFormatByteOffset ~_
          = #{offset VkVertexInputAttributeDescription, format}

        {-# INLINE readVkFormat #-}
        readVkFormat p
          = peekByteOff p
              #{offset VkVertexInputAttributeDescription, format}

        {-# INLINE writeVkFormat #-}
        writeVkFormat p
          = pokeByteOff p
              #{offset VkVertexInputAttributeDescription, format}

instance {-# OVERLAPPING #-}
         HasVkOffset VkVertexInputAttributeDescription where
        type VkOffsetMType VkVertexInputAttributeDescription =
             Data.Word.Word32

        {-# NOINLINE vkOffset #-}
        vkOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkVertexInputAttributeDescription, offset})

        {-# INLINE vkOffsetByteOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkVertexInputAttributeDescription, offset}

        {-# INLINE readVkOffset #-}
        readVkOffset p
          = peekByteOff p
              #{offset VkVertexInputAttributeDescription, offset}

        {-# INLINE writeVkOffset #-}
        writeVkOffset p
          = pokeByteOff p
              #{offset VkVertexInputAttributeDescription, offset}

instance Show VkVertexInputAttributeDescription where
        showsPrec d x
          = showString "VkVertexInputAttributeDescription {" .
              showString "vkLocation = " .
                showsPrec d (vkLocation x) .
                  showString ", " .
                    showString "vkBinding = " .
                      showsPrec d (vkBinding x) .
                        showString ", " .
                          showString "vkFormat = " .
                            showsPrec d (vkFormat x) .
                              showString ", " .
                                showString "vkOffset = " . showsPrec d (vkOffset x) . showChar '}'

data VkPipelineVertexInputStateCreateInfo = VkPipelineVertexInputStateCreateInfo## ByteArray##

instance Eq VkPipelineVertexInputStateCreateInfo where
        (VkPipelineVertexInputStateCreateInfo## a) ==
          (VkPipelineVertexInputStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineVertexInputStateCreateInfo where
        (VkPipelineVertexInputStateCreateInfo## a) `compare`
          (VkPipelineVertexInputStateCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineVertexInputStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineVertexInputStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineVertexInputStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineVertexInputStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineVertexInputStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineVertexInputStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineVertexInputStateCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf
                      (undefined :: VkPipelineVertexInputStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPipelineVertexInputStateCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPipelineVertexInputStateCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr
          = fromForeignPtr## VkPipelineVertexInputStateCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPipelineVertexInputStateCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPipelineVertexInputStateCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPipelineVertexInputStateCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineVertexInputStateCreateInfo where
        type VkSTypeMType VkPipelineVertexInputStateCreateInfo =
             VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineVertexInputStateCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineVertexInputStateCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkPipelineVertexInputStateCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkPipelineVertexInputStateCreateInfo, sType}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineVertexInputStateCreateInfo where
        type VkPNextMType VkPipelineVertexInputStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineVertexInputStateCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineVertexInputStateCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkPipelineVertexInputStateCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkPipelineVertexInputStateCreateInfo, pNext}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineVertexInputStateCreateInfo where
        type VkFlagsMType VkPipelineVertexInputStateCreateInfo =
             VkPipelineVertexInputStateCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineVertexInputStateCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineVertexInputStateCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkPipelineVertexInputStateCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkPipelineVertexInputStateCreateInfo, flags}

class HasVkVertexBindingDescriptionCount a where
        type VkVertexBindingDescriptionCountMType a :: *

        vkVertexBindingDescriptionCount ::
                                        a -> VkVertexBindingDescriptionCountMType a

        vkVertexBindingDescriptionCountByteOffset :: a -> Int

        readVkVertexBindingDescriptionCount ::
                                            Ptr a -> IO (VkVertexBindingDescriptionCountMType a)

        writeVkVertexBindingDescriptionCount ::
                                             Ptr a ->
                                               VkVertexBindingDescriptionCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'vertexBindingDescriptionCount'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkVertexBindingDescriptionCount a

instance {-# OVERLAPPING #-}
         HasVkVertexBindingDescriptionCount
           VkPipelineVertexInputStateCreateInfo
         where
        type VkVertexBindingDescriptionCountMType
               VkPipelineVertexInputStateCreateInfo
             = Data.Word.Word32

        {-# NOINLINE vkVertexBindingDescriptionCount #-}
        vkVertexBindingDescriptionCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineVertexInputStateCreateInfo, vertexBindingDescriptionCount})

        {-# INLINE vkVertexBindingDescriptionCountByteOffset #-}
        vkVertexBindingDescriptionCountByteOffset ~_
          = #{offset VkPipelineVertexInputStateCreateInfo, vertexBindingDescriptionCount}

        {-# INLINE readVkVertexBindingDescriptionCount #-}
        readVkVertexBindingDescriptionCount p
          = peekByteOff p
              #{offset VkPipelineVertexInputStateCreateInfo, vertexBindingDescriptionCount}

        {-# INLINE writeVkVertexBindingDescriptionCount #-}
        writeVkVertexBindingDescriptionCount p
          = pokeByteOff p
              #{offset VkPipelineVertexInputStateCreateInfo, vertexBindingDescriptionCount}

class HasVkPVertexBindingDescriptions a where
        type VkPVertexBindingDescriptionsMType a :: *

        vkPVertexBindingDescriptions ::
                                     a -> VkPVertexBindingDescriptionsMType a

        vkPVertexBindingDescriptionsByteOffset :: a -> Int

        readVkPVertexBindingDescriptions ::
                                         Ptr a -> IO (VkPVertexBindingDescriptionsMType a)

        writeVkPVertexBindingDescriptions ::
                                          Ptr a -> VkPVertexBindingDescriptionsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pVertexBindingDescriptions'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPVertexBindingDescriptions a

instance {-# OVERLAPPING #-}
         HasVkPVertexBindingDescriptions
           VkPipelineVertexInputStateCreateInfo
         where
        type VkPVertexBindingDescriptionsMType
               VkPipelineVertexInputStateCreateInfo
             = Foreign.Ptr.Ptr VkVertexInputBindingDescription

        {-# NOINLINE vkPVertexBindingDescriptions #-}
        vkPVertexBindingDescriptions x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineVertexInputStateCreateInfo, pVertexBindingDescriptions})

        {-# INLINE vkPVertexBindingDescriptionsByteOffset #-}
        vkPVertexBindingDescriptionsByteOffset ~_
          = #{offset VkPipelineVertexInputStateCreateInfo, pVertexBindingDescriptions}

        {-# INLINE readVkPVertexBindingDescriptions #-}
        readVkPVertexBindingDescriptions p
          = peekByteOff p
              #{offset VkPipelineVertexInputStateCreateInfo, pVertexBindingDescriptions}

        {-# INLINE writeVkPVertexBindingDescriptions #-}
        writeVkPVertexBindingDescriptions p
          = pokeByteOff p
              #{offset VkPipelineVertexInputStateCreateInfo, pVertexBindingDescriptions}

class HasVkVertexAttributeDescriptionCount a where
        type VkVertexAttributeDescriptionCountMType a :: *

        vkVertexAttributeDescriptionCount ::
                                          a -> VkVertexAttributeDescriptionCountMType a

        vkVertexAttributeDescriptionCountByteOffset :: a -> Int

        readVkVertexAttributeDescriptionCount ::
                                              Ptr a -> IO (VkVertexAttributeDescriptionCountMType a)

        writeVkVertexAttributeDescriptionCount ::
                                               Ptr a ->
                                                 VkVertexAttributeDescriptionCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'vertexAttributeDescriptionCount'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkVertexAttributeDescriptionCount a

instance {-# OVERLAPPING #-}
         HasVkVertexAttributeDescriptionCount
           VkPipelineVertexInputStateCreateInfo
         where
        type VkVertexAttributeDescriptionCountMType
               VkPipelineVertexInputStateCreateInfo
             = Data.Word.Word32

        {-# NOINLINE vkVertexAttributeDescriptionCount #-}
        vkVertexAttributeDescriptionCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineVertexInputStateCreateInfo, vertexAttributeDescriptionCount})

        {-# INLINE vkVertexAttributeDescriptionCountByteOffset #-}
        vkVertexAttributeDescriptionCountByteOffset ~_
          = #{offset VkPipelineVertexInputStateCreateInfo, vertexAttributeDescriptionCount}

        {-# INLINE readVkVertexAttributeDescriptionCount #-}
        readVkVertexAttributeDescriptionCount p
          = peekByteOff p
              #{offset VkPipelineVertexInputStateCreateInfo, vertexAttributeDescriptionCount}

        {-# INLINE writeVkVertexAttributeDescriptionCount #-}
        writeVkVertexAttributeDescriptionCount p
          = pokeByteOff p
              #{offset VkPipelineVertexInputStateCreateInfo, vertexAttributeDescriptionCount}

class HasVkPVertexAttributeDescriptions a where
        type VkPVertexAttributeDescriptionsMType a :: *

        vkPVertexAttributeDescriptions ::
                                       a -> VkPVertexAttributeDescriptionsMType a

        vkPVertexAttributeDescriptionsByteOffset :: a -> Int

        readVkPVertexAttributeDescriptions ::
                                           Ptr a -> IO (VkPVertexAttributeDescriptionsMType a)

        writeVkPVertexAttributeDescriptions ::
                                            Ptr a -> VkPVertexAttributeDescriptionsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pVertexAttributeDescriptions'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPVertexAttributeDescriptions a

instance {-# OVERLAPPING #-}
         HasVkPVertexAttributeDescriptions
           VkPipelineVertexInputStateCreateInfo
         where
        type VkPVertexAttributeDescriptionsMType
               VkPipelineVertexInputStateCreateInfo
             = Foreign.Ptr.Ptr VkVertexInputAttributeDescription

        {-# NOINLINE vkPVertexAttributeDescriptions #-}
        vkPVertexAttributeDescriptions x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineVertexInputStateCreateInfo, pVertexAttributeDescriptions})

        {-# INLINE vkPVertexAttributeDescriptionsByteOffset #-}
        vkPVertexAttributeDescriptionsByteOffset ~_
          = #{offset VkPipelineVertexInputStateCreateInfo, pVertexAttributeDescriptions}

        {-# INLINE readVkPVertexAttributeDescriptions #-}
        readVkPVertexAttributeDescriptions p
          = peekByteOff p
              #{offset VkPipelineVertexInputStateCreateInfo, pVertexAttributeDescriptions}

        {-# INLINE writeVkPVertexAttributeDescriptions #-}
        writeVkPVertexAttributeDescriptions p
          = pokeByteOff p
              #{offset VkPipelineVertexInputStateCreateInfo, pVertexAttributeDescriptions}

instance Show VkPipelineVertexInputStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineVertexInputStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkVertexBindingDescriptionCount = " .
                                  showsPrec d (vkVertexBindingDescriptionCount x) .
                                    showString ", " .
                                      showString "vkPVertexBindingDescriptions = " .
                                        showsPrec d (vkPVertexBindingDescriptions x) .
                                          showString ", " .
                                            showString "vkVertexAttributeDescriptionCount = " .
                                              showsPrec d (vkVertexAttributeDescriptionCount x) .
                                                showString ", " .
                                                  showString "vkPVertexAttributeDescriptions = " .
                                                    showsPrec d (vkPVertexAttributeDescriptions x) .
                                                      showChar '}'

data VkPipelineInputAssemblyStateCreateInfo = VkPipelineInputAssemblyStateCreateInfo## ByteArray##

instance Eq VkPipelineInputAssemblyStateCreateInfo where
        (VkPipelineInputAssemblyStateCreateInfo## a) ==
          (VkPipelineInputAssemblyStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineInputAssemblyStateCreateInfo where
        (VkPipelineInputAssemblyStateCreateInfo## a) `compare`
          (VkPipelineInputAssemblyStateCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineInputAssemblyStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineInputAssemblyStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineInputAssemblyStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineInputAssemblyStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineInputAssemblyStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineInputAssemblyStateCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPipelineInputAssemblyStateCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPipelineInputAssemblyStateCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr
          = fromForeignPtr## VkPipelineInputAssemblyStateCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPipelineInputAssemblyStateCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPipelineInputAssemblyStateCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPipelineInputAssemblyStateCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineInputAssemblyStateCreateInfo where
        type VkSTypeMType VkPipelineInputAssemblyStateCreateInfo =
             VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineInputAssemblyStateCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineInputAssemblyStateCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkPipelineInputAssemblyStateCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkPipelineInputAssemblyStateCreateInfo, sType}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineInputAssemblyStateCreateInfo where
        type VkPNextMType VkPipelineInputAssemblyStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineInputAssemblyStateCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineInputAssemblyStateCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkPipelineInputAssemblyStateCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkPipelineInputAssemblyStateCreateInfo, pNext}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineInputAssemblyStateCreateInfo where
        type VkFlagsMType VkPipelineInputAssemblyStateCreateInfo =
             VkPipelineInputAssemblyStateCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineInputAssemblyStateCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineInputAssemblyStateCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkPipelineInputAssemblyStateCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkPipelineInputAssemblyStateCreateInfo, flags}

class HasVkTopology a where
        type VkTopologyMType a :: *

        vkTopology :: a -> VkTopologyMType a

        vkTopologyByteOffset :: a -> Int

        readVkTopology :: Ptr a -> IO (VkTopologyMType a)

        writeVkTopology :: Ptr a -> VkTopologyMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'topology'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTopology a

instance {-# OVERLAPPING #-}
         HasVkTopology VkPipelineInputAssemblyStateCreateInfo where
        type VkTopologyMType VkPipelineInputAssemblyStateCreateInfo =
             VkPrimitiveTopology

        {-# NOINLINE vkTopology #-}
        vkTopology x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineInputAssemblyStateCreateInfo, topology})

        {-# INLINE vkTopologyByteOffset #-}
        vkTopologyByteOffset ~_
          = #{offset VkPipelineInputAssemblyStateCreateInfo, topology}

        {-# INLINE readVkTopology #-}
        readVkTopology p
          = peekByteOff p
              #{offset VkPipelineInputAssemblyStateCreateInfo, topology}

        {-# INLINE writeVkTopology #-}
        writeVkTopology p
          = pokeByteOff p
              #{offset VkPipelineInputAssemblyStateCreateInfo, topology}

class HasVkPrimitiveRestartEnable a where
        type VkPrimitiveRestartEnableMType a :: *

        vkPrimitiveRestartEnable :: a -> VkPrimitiveRestartEnableMType a

        vkPrimitiveRestartEnableByteOffset :: a -> Int

        readVkPrimitiveRestartEnable ::
                                     Ptr a -> IO (VkPrimitiveRestartEnableMType a)

        writeVkPrimitiveRestartEnable ::
                                      Ptr a -> VkPrimitiveRestartEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'primitiveRestartEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPrimitiveRestartEnable a

instance {-# OVERLAPPING #-}
         HasVkPrimitiveRestartEnable VkPipelineInputAssemblyStateCreateInfo
         where
        type VkPrimitiveRestartEnableMType
               VkPipelineInputAssemblyStateCreateInfo
             = VkBool32

        {-# NOINLINE vkPrimitiveRestartEnable #-}
        vkPrimitiveRestartEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineInputAssemblyStateCreateInfo, primitiveRestartEnable})

        {-# INLINE vkPrimitiveRestartEnableByteOffset #-}
        vkPrimitiveRestartEnableByteOffset ~_
          = #{offset VkPipelineInputAssemblyStateCreateInfo, primitiveRestartEnable}

        {-# INLINE readVkPrimitiveRestartEnable #-}
        readVkPrimitiveRestartEnable p
          = peekByteOff p
              #{offset VkPipelineInputAssemblyStateCreateInfo, primitiveRestartEnable}

        {-# INLINE writeVkPrimitiveRestartEnable #-}
        writeVkPrimitiveRestartEnable p
          = pokeByteOff p
              #{offset VkPipelineInputAssemblyStateCreateInfo, primitiveRestartEnable}

instance Show VkPipelineInputAssemblyStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineInputAssemblyStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkTopology = " .
                                  showsPrec d (vkTopology x) .
                                    showString ", " .
                                      showString "vkPrimitiveRestartEnable = " .
                                        showsPrec d (vkPrimitiveRestartEnable x) . showChar '}'

data VkPipelineTessellationStateCreateInfo = VkPipelineTessellationStateCreateInfo## ByteArray##

instance Eq VkPipelineTessellationStateCreateInfo where
        (VkPipelineTessellationStateCreateInfo## a) ==
          (VkPipelineTessellationStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineTessellationStateCreateInfo where
        (VkPipelineTessellationStateCreateInfo## a) `compare`
          (VkPipelineTessellationStateCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineTessellationStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineTessellationStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineTessellationStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineTessellationStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineTessellationStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineTessellationStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineTessellationStateCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf
                      (undefined :: VkPipelineTessellationStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPipelineTessellationStateCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPipelineTessellationStateCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr
          = fromForeignPtr## VkPipelineTessellationStateCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPipelineTessellationStateCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPipelineTessellationStateCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPipelineTessellationStateCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineTessellationStateCreateInfo where
        type VkSTypeMType VkPipelineTessellationStateCreateInfo =
             VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineTessellationStateCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineTessellationStateCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkPipelineTessellationStateCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkPipelineTessellationStateCreateInfo, sType}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineTessellationStateCreateInfo where
        type VkPNextMType VkPipelineTessellationStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineTessellationStateCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineTessellationStateCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkPipelineTessellationStateCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkPipelineTessellationStateCreateInfo, pNext}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineTessellationStateCreateInfo where
        type VkFlagsMType VkPipelineTessellationStateCreateInfo =
             VkPipelineTessellationStateCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineTessellationStateCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineTessellationStateCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkPipelineTessellationStateCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkPipelineTessellationStateCreateInfo, flags}

class HasVkPatchControlPoints a where
        type VkPatchControlPointsMType a :: *

        vkPatchControlPoints :: a -> VkPatchControlPointsMType a

        vkPatchControlPointsByteOffset :: a -> Int

        readVkPatchControlPoints ::
                                 Ptr a -> IO (VkPatchControlPointsMType a)

        writeVkPatchControlPoints ::
                                  Ptr a -> VkPatchControlPointsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'patchControlPoints'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPatchControlPoints a

instance {-# OVERLAPPING #-}
         HasVkPatchControlPoints VkPipelineTessellationStateCreateInfo where
        type VkPatchControlPointsMType
               VkPipelineTessellationStateCreateInfo
             = Data.Word.Word32

        {-# NOINLINE vkPatchControlPoints #-}
        vkPatchControlPoints x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineTessellationStateCreateInfo, patchControlPoints})

        {-# INLINE vkPatchControlPointsByteOffset #-}
        vkPatchControlPointsByteOffset ~_
          = #{offset VkPipelineTessellationStateCreateInfo, patchControlPoints}

        {-# INLINE readVkPatchControlPoints #-}
        readVkPatchControlPoints p
          = peekByteOff p
              #{offset VkPipelineTessellationStateCreateInfo, patchControlPoints}

        {-# INLINE writeVkPatchControlPoints #-}
        writeVkPatchControlPoints p
          = pokeByteOff p
              #{offset VkPipelineTessellationStateCreateInfo, patchControlPoints}

instance Show VkPipelineTessellationStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineTessellationStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkPatchControlPoints = " .
                                  showsPrec d (vkPatchControlPoints x) . showChar '}'

data VkPipelineViewportStateCreateInfo = VkPipelineViewportStateCreateInfo## ByteArray##

instance Eq VkPipelineViewportStateCreateInfo where
        (VkPipelineViewportStateCreateInfo## a) ==
          (VkPipelineViewportStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineViewportStateCreateInfo where
        (VkPipelineViewportStateCreateInfo## a) `compare`
          (VkPipelineViewportStateCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineViewportStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineViewportStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineViewportStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPipelineViewportStateCreateInfo),
            I## a <- alignment (undefined :: VkPipelineViewportStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineViewportStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineViewportStateCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineViewportStateCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineViewportStateCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkPipelineViewportStateCreateInfo),
            I## a <- alignment (undefined :: VkPipelineViewportStateCreateInfo)
            =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPipelineViewportStateCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPipelineViewportStateCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkPipelineViewportStateCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPipelineViewportStateCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPipelineViewportStateCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPipelineViewportStateCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineViewportStateCreateInfo where
        type VkSTypeMType VkPipelineViewportStateCreateInfo =
             VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineViewportStateCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineViewportStateCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkPipelineViewportStateCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkPipelineViewportStateCreateInfo, sType}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineViewportStateCreateInfo where
        type VkPNextMType VkPipelineViewportStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineViewportStateCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineViewportStateCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkPipelineViewportStateCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkPipelineViewportStateCreateInfo, pNext}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineViewportStateCreateInfo where
        type VkFlagsMType VkPipelineViewportStateCreateInfo =
             VkPipelineViewportStateCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineViewportStateCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineViewportStateCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkPipelineViewportStateCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkPipelineViewportStateCreateInfo, flags}

class HasVkViewportCount a where
        type VkViewportCountMType a :: *

        vkViewportCount :: a -> VkViewportCountMType a

        vkViewportCountByteOffset :: a -> Int

        readVkViewportCount :: Ptr a -> IO (VkViewportCountMType a)

        writeVkViewportCount :: Ptr a -> VkViewportCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'viewportCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkViewportCount a

instance {-# OVERLAPPING #-}
         HasVkViewportCount VkPipelineViewportStateCreateInfo where
        type VkViewportCountMType VkPipelineViewportStateCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkViewportCount #-}
        vkViewportCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineViewportStateCreateInfo, viewportCount})

        {-# INLINE vkViewportCountByteOffset #-}
        vkViewportCountByteOffset ~_
          = #{offset VkPipelineViewportStateCreateInfo, viewportCount}

        {-# INLINE readVkViewportCount #-}
        readVkViewportCount p
          = peekByteOff p
              #{offset VkPipelineViewportStateCreateInfo, viewportCount}

        {-# INLINE writeVkViewportCount #-}
        writeVkViewportCount p
          = pokeByteOff p
              #{offset VkPipelineViewportStateCreateInfo, viewportCount}

class HasVkPViewports a where
        type VkPViewportsMType a :: *

        vkPViewports :: a -> VkPViewportsMType a

        vkPViewportsByteOffset :: a -> Int

        readVkPViewports :: Ptr a -> IO (VkPViewportsMType a)

        writeVkPViewports :: Ptr a -> VkPViewportsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pViewports'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPViewports a

instance {-# OVERLAPPING #-}
         HasVkPViewports VkPipelineViewportStateCreateInfo where
        type VkPViewportsMType VkPipelineViewportStateCreateInfo =
             Foreign.Ptr.Ptr VkViewport

        {-# NOINLINE vkPViewports #-}
        vkPViewports x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineViewportStateCreateInfo, pViewports})

        {-# INLINE vkPViewportsByteOffset #-}
        vkPViewportsByteOffset ~_
          = #{offset VkPipelineViewportStateCreateInfo, pViewports}

        {-# INLINE readVkPViewports #-}
        readVkPViewports p
          = peekByteOff p
              #{offset VkPipelineViewportStateCreateInfo, pViewports}

        {-# INLINE writeVkPViewports #-}
        writeVkPViewports p
          = pokeByteOff p
              #{offset VkPipelineViewportStateCreateInfo, pViewports}

class HasVkScissorCount a where
        type VkScissorCountMType a :: *

        vkScissorCount :: a -> VkScissorCountMType a

        vkScissorCountByteOffset :: a -> Int

        readVkScissorCount :: Ptr a -> IO (VkScissorCountMType a)

        writeVkScissorCount :: Ptr a -> VkScissorCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'scissorCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkScissorCount a

instance {-# OVERLAPPING #-}
         HasVkScissorCount VkPipelineViewportStateCreateInfo where
        type VkScissorCountMType VkPipelineViewportStateCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkScissorCount #-}
        vkScissorCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineViewportStateCreateInfo, scissorCount})

        {-# INLINE vkScissorCountByteOffset #-}
        vkScissorCountByteOffset ~_
          = #{offset VkPipelineViewportStateCreateInfo, scissorCount}

        {-# INLINE readVkScissorCount #-}
        readVkScissorCount p
          = peekByteOff p
              #{offset VkPipelineViewportStateCreateInfo, scissorCount}

        {-# INLINE writeVkScissorCount #-}
        writeVkScissorCount p
          = pokeByteOff p
              #{offset VkPipelineViewportStateCreateInfo, scissorCount}

class HasVkPScissors a where
        type VkPScissorsMType a :: *

        vkPScissors :: a -> VkPScissorsMType a

        vkPScissorsByteOffset :: a -> Int

        readVkPScissors :: Ptr a -> IO (VkPScissorsMType a)

        writeVkPScissors :: Ptr a -> VkPScissorsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pScissors'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPScissors a

instance {-# OVERLAPPING #-}
         HasVkPScissors VkPipelineViewportStateCreateInfo where
        type VkPScissorsMType VkPipelineViewportStateCreateInfo =
             Foreign.Ptr.Ptr VkRect2D

        {-# NOINLINE vkPScissors #-}
        vkPScissors x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineViewportStateCreateInfo, pScissors})

        {-# INLINE vkPScissorsByteOffset #-}
        vkPScissorsByteOffset ~_
          = #{offset VkPipelineViewportStateCreateInfo, pScissors}

        {-# INLINE readVkPScissors #-}
        readVkPScissors p
          = peekByteOff p
              #{offset VkPipelineViewportStateCreateInfo, pScissors}

        {-# INLINE writeVkPScissors #-}
        writeVkPScissors p
          = pokeByteOff p
              #{offset VkPipelineViewportStateCreateInfo, pScissors}

instance Show VkPipelineViewportStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineViewportStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkViewportCount = " .
                                  showsPrec d (vkViewportCount x) .
                                    showString ", " .
                                      showString "vkPViewports = " .
                                        showsPrec d (vkPViewports x) .
                                          showString ", " .
                                            showString "vkScissorCount = " .
                                              showsPrec d (vkScissorCount x) .
                                                showString ", " .
                                                  showString "vkPScissors = " .
                                                    showsPrec d (vkPScissors x) . showChar '}'

data VkPipelineRasterizationStateCreateInfo = VkPipelineRasterizationStateCreateInfo## ByteArray##

instance Eq VkPipelineRasterizationStateCreateInfo where
        (VkPipelineRasterizationStateCreateInfo## a) ==
          (VkPipelineRasterizationStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineRasterizationStateCreateInfo where
        (VkPipelineRasterizationStateCreateInfo## a) `compare`
          (VkPipelineRasterizationStateCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineRasterizationStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineRasterizationStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineRasterizationStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineRasterizationStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineRasterizationStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineRasterizationStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineRasterizationStateCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf
                      (undefined :: VkPipelineRasterizationStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPipelineRasterizationStateCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPipelineRasterizationStateCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr
          = fromForeignPtr## VkPipelineRasterizationStateCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPipelineRasterizationStateCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPipelineRasterizationStateCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPipelineRasterizationStateCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineRasterizationStateCreateInfo where
        type VkSTypeMType VkPipelineRasterizationStateCreateInfo =
             VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineRasterizationStateCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, sType}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineRasterizationStateCreateInfo where
        type VkPNextMType VkPipelineRasterizationStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineRasterizationStateCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, pNext}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineRasterizationStateCreateInfo where
        type VkFlagsMType VkPipelineRasterizationStateCreateInfo =
             VkPipelineRasterizationStateCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineRasterizationStateCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, flags}

class HasVkDepthClampEnable a where
        type VkDepthClampEnableMType a :: *

        vkDepthClampEnable :: a -> VkDepthClampEnableMType a

        vkDepthClampEnableByteOffset :: a -> Int

        readVkDepthClampEnable :: Ptr a -> IO (VkDepthClampEnableMType a)

        writeVkDepthClampEnable ::
                                Ptr a -> VkDepthClampEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthClampEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthClampEnable a

instance {-# OVERLAPPING #-}
         HasVkDepthClampEnable VkPipelineRasterizationStateCreateInfo where
        type VkDepthClampEnableMType VkPipelineRasterizationStateCreateInfo
             = VkBool32

        {-# NOINLINE vkDepthClampEnable #-}
        vkDepthClampEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineRasterizationStateCreateInfo, depthClampEnable})

        {-# INLINE vkDepthClampEnableByteOffset #-}
        vkDepthClampEnableByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, depthClampEnable}

        {-# INLINE readVkDepthClampEnable #-}
        readVkDepthClampEnable p
          = peekByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, depthClampEnable}

        {-# INLINE writeVkDepthClampEnable #-}
        writeVkDepthClampEnable p
          = pokeByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, depthClampEnable}

class HasVkRasterizerDiscardEnable a where
        type VkRasterizerDiscardEnableMType a :: *

        vkRasterizerDiscardEnable :: a -> VkRasterizerDiscardEnableMType a

        vkRasterizerDiscardEnableByteOffset :: a -> Int

        readVkRasterizerDiscardEnable ::
                                      Ptr a -> IO (VkRasterizerDiscardEnableMType a)

        writeVkRasterizerDiscardEnable ::
                                       Ptr a -> VkRasterizerDiscardEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'rasterizerDiscardEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRasterizerDiscardEnable a

instance {-# OVERLAPPING #-}
         HasVkRasterizerDiscardEnable VkPipelineRasterizationStateCreateInfo
         where
        type VkRasterizerDiscardEnableMType
               VkPipelineRasterizationStateCreateInfo
             = VkBool32

        {-# NOINLINE vkRasterizerDiscardEnable #-}
        vkRasterizerDiscardEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineRasterizationStateCreateInfo, rasterizerDiscardEnable})

        {-# INLINE vkRasterizerDiscardEnableByteOffset #-}
        vkRasterizerDiscardEnableByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, rasterizerDiscardEnable}

        {-# INLINE readVkRasterizerDiscardEnable #-}
        readVkRasterizerDiscardEnable p
          = peekByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, rasterizerDiscardEnable}

        {-# INLINE writeVkRasterizerDiscardEnable #-}
        writeVkRasterizerDiscardEnable p
          = pokeByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, rasterizerDiscardEnable}

class HasVkPolygonMode a where
        type VkPolygonModeMType a :: *

        vkPolygonMode :: a -> VkPolygonModeMType a

        vkPolygonModeByteOffset :: a -> Int

        readVkPolygonMode :: Ptr a -> IO (VkPolygonModeMType a)

        writeVkPolygonMode :: Ptr a -> VkPolygonModeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'polygonMode'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPolygonMode a

instance {-# OVERLAPPING #-}
         HasVkPolygonMode VkPipelineRasterizationStateCreateInfo where
        type VkPolygonModeMType VkPipelineRasterizationStateCreateInfo =
             VkPolygonMode

        {-# NOINLINE vkPolygonMode #-}
        vkPolygonMode x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineRasterizationStateCreateInfo, polygonMode})

        {-# INLINE vkPolygonModeByteOffset #-}
        vkPolygonModeByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, polygonMode}

        {-# INLINE readVkPolygonMode #-}
        readVkPolygonMode p
          = peekByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, polygonMode}

        {-# INLINE writeVkPolygonMode #-}
        writeVkPolygonMode p
          = pokeByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, polygonMode}

class HasVkCullMode a where
        type VkCullModeMType a :: *

        vkCullMode :: a -> VkCullModeMType a

        vkCullModeByteOffset :: a -> Int

        readVkCullMode :: Ptr a -> IO (VkCullModeMType a)

        writeVkCullMode :: Ptr a -> VkCullModeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'cullMode'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCullMode a

instance {-# OVERLAPPING #-}
         HasVkCullMode VkPipelineRasterizationStateCreateInfo where
        type VkCullModeMType VkPipelineRasterizationStateCreateInfo =
             VkCullModeFlags

        {-# NOINLINE vkCullMode #-}
        vkCullMode x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineRasterizationStateCreateInfo, cullMode})

        {-# INLINE vkCullModeByteOffset #-}
        vkCullModeByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, cullMode}

        {-# INLINE readVkCullMode #-}
        readVkCullMode p
          = peekByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, cullMode}

        {-# INLINE writeVkCullMode #-}
        writeVkCullMode p
          = pokeByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, cullMode}

class HasVkFrontFace a where
        type VkFrontFaceMType a :: *

        vkFrontFace :: a -> VkFrontFaceMType a

        vkFrontFaceByteOffset :: a -> Int

        readVkFrontFace :: Ptr a -> IO (VkFrontFaceMType a)

        writeVkFrontFace :: Ptr a -> VkFrontFaceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'frontFace'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFrontFace a

instance {-# OVERLAPPING #-}
         HasVkFrontFace VkPipelineRasterizationStateCreateInfo where
        type VkFrontFaceMType VkPipelineRasterizationStateCreateInfo =
             VkFrontFace

        {-# NOINLINE vkFrontFace #-}
        vkFrontFace x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineRasterizationStateCreateInfo, frontFace})

        {-# INLINE vkFrontFaceByteOffset #-}
        vkFrontFaceByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, frontFace}

        {-# INLINE readVkFrontFace #-}
        readVkFrontFace p
          = peekByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, frontFace}

        {-# INLINE writeVkFrontFace #-}
        writeVkFrontFace p
          = pokeByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, frontFace}

class HasVkDepthBiasEnable a where
        type VkDepthBiasEnableMType a :: *

        vkDepthBiasEnable :: a -> VkDepthBiasEnableMType a

        vkDepthBiasEnableByteOffset :: a -> Int

        readVkDepthBiasEnable :: Ptr a -> IO (VkDepthBiasEnableMType a)

        writeVkDepthBiasEnable ::
                               Ptr a -> VkDepthBiasEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthBiasEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthBiasEnable a

instance {-# OVERLAPPING #-}
         HasVkDepthBiasEnable VkPipelineRasterizationStateCreateInfo where
        type VkDepthBiasEnableMType VkPipelineRasterizationStateCreateInfo
             = VkBool32

        {-# NOINLINE vkDepthBiasEnable #-}
        vkDepthBiasEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineRasterizationStateCreateInfo, depthBiasEnable})

        {-# INLINE vkDepthBiasEnableByteOffset #-}
        vkDepthBiasEnableByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, depthBiasEnable}

        {-# INLINE readVkDepthBiasEnable #-}
        readVkDepthBiasEnable p
          = peekByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, depthBiasEnable}

        {-# INLINE writeVkDepthBiasEnable #-}
        writeVkDepthBiasEnable p
          = pokeByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, depthBiasEnable}

class HasVkDepthBiasConstantFactor a where
        type VkDepthBiasConstantFactorMType a :: *

        vkDepthBiasConstantFactor :: a -> VkDepthBiasConstantFactorMType a

        vkDepthBiasConstantFactorByteOffset :: a -> Int

        readVkDepthBiasConstantFactor ::
                                      Ptr a -> IO (VkDepthBiasConstantFactorMType a)

        writeVkDepthBiasConstantFactor ::
                                       Ptr a -> VkDepthBiasConstantFactorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthBiasConstantFactor'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthBiasConstantFactor a

instance {-# OVERLAPPING #-}
         HasVkDepthBiasConstantFactor VkPipelineRasterizationStateCreateInfo
         where
        type VkDepthBiasConstantFactorMType
               VkPipelineRasterizationStateCreateInfo
             = Foreign.C.Types.CFloat

        {-# NOINLINE vkDepthBiasConstantFactor #-}
        vkDepthBiasConstantFactor x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineRasterizationStateCreateInfo, depthBiasConstantFactor})

        {-# INLINE vkDepthBiasConstantFactorByteOffset #-}
        vkDepthBiasConstantFactorByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, depthBiasConstantFactor}

        {-# INLINE readVkDepthBiasConstantFactor #-}
        readVkDepthBiasConstantFactor p
          = peekByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, depthBiasConstantFactor}

        {-# INLINE writeVkDepthBiasConstantFactor #-}
        writeVkDepthBiasConstantFactor p
          = pokeByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, depthBiasConstantFactor}

class HasVkDepthBiasClamp a where
        type VkDepthBiasClampMType a :: *

        vkDepthBiasClamp :: a -> VkDepthBiasClampMType a

        vkDepthBiasClampByteOffset :: a -> Int

        readVkDepthBiasClamp :: Ptr a -> IO (VkDepthBiasClampMType a)

        writeVkDepthBiasClamp :: Ptr a -> VkDepthBiasClampMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthBiasClamp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthBiasClamp a

instance {-# OVERLAPPING #-}
         HasVkDepthBiasClamp VkPipelineRasterizationStateCreateInfo where
        type VkDepthBiasClampMType VkPipelineRasterizationStateCreateInfo =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkDepthBiasClamp #-}
        vkDepthBiasClamp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineRasterizationStateCreateInfo, depthBiasClamp})

        {-# INLINE vkDepthBiasClampByteOffset #-}
        vkDepthBiasClampByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, depthBiasClamp}

        {-# INLINE readVkDepthBiasClamp #-}
        readVkDepthBiasClamp p
          = peekByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, depthBiasClamp}

        {-# INLINE writeVkDepthBiasClamp #-}
        writeVkDepthBiasClamp p
          = pokeByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, depthBiasClamp}

class HasVkDepthBiasSlopeFactor a where
        type VkDepthBiasSlopeFactorMType a :: *

        vkDepthBiasSlopeFactor :: a -> VkDepthBiasSlopeFactorMType a

        vkDepthBiasSlopeFactorByteOffset :: a -> Int

        readVkDepthBiasSlopeFactor ::
                                   Ptr a -> IO (VkDepthBiasSlopeFactorMType a)

        writeVkDepthBiasSlopeFactor ::
                                    Ptr a -> VkDepthBiasSlopeFactorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthBiasSlopeFactor'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthBiasSlopeFactor a

instance {-# OVERLAPPING #-}
         HasVkDepthBiasSlopeFactor VkPipelineRasterizationStateCreateInfo
         where
        type VkDepthBiasSlopeFactorMType
               VkPipelineRasterizationStateCreateInfo
             = Foreign.C.Types.CFloat

        {-# NOINLINE vkDepthBiasSlopeFactor #-}
        vkDepthBiasSlopeFactor x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineRasterizationStateCreateInfo, depthBiasSlopeFactor})

        {-# INLINE vkDepthBiasSlopeFactorByteOffset #-}
        vkDepthBiasSlopeFactorByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, depthBiasSlopeFactor}

        {-# INLINE readVkDepthBiasSlopeFactor #-}
        readVkDepthBiasSlopeFactor p
          = peekByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, depthBiasSlopeFactor}

        {-# INLINE writeVkDepthBiasSlopeFactor #-}
        writeVkDepthBiasSlopeFactor p
          = pokeByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, depthBiasSlopeFactor}

class HasVkLineWidth a where
        type VkLineWidthMType a :: *

        vkLineWidth :: a -> VkLineWidthMType a

        vkLineWidthByteOffset :: a -> Int

        readVkLineWidth :: Ptr a -> IO (VkLineWidthMType a)

        writeVkLineWidth :: Ptr a -> VkLineWidthMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'lineWidth'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLineWidth a

instance {-# OVERLAPPING #-}
         HasVkLineWidth VkPipelineRasterizationStateCreateInfo where
        type VkLineWidthMType VkPipelineRasterizationStateCreateInfo =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkLineWidth #-}
        vkLineWidth x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineRasterizationStateCreateInfo, lineWidth})

        {-# INLINE vkLineWidthByteOffset #-}
        vkLineWidthByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, lineWidth}

        {-# INLINE readVkLineWidth #-}
        readVkLineWidth p
          = peekByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, lineWidth}

        {-# INLINE writeVkLineWidth #-}
        writeVkLineWidth p
          = pokeByteOff p
              #{offset VkPipelineRasterizationStateCreateInfo, lineWidth}

instance Show VkPipelineRasterizationStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineRasterizationStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkDepthClampEnable = " .
                                  showsPrec d (vkDepthClampEnable x) .
                                    showString ", " .
                                      showString "vkRasterizerDiscardEnable = " .
                                        showsPrec d (vkRasterizerDiscardEnable x) .
                                          showString ", " .
                                            showString "vkPolygonMode = " .
                                              showsPrec d (vkPolygonMode x) .
                                                showString ", " .
                                                  showString "vkCullMode = " .
                                                    showsPrec d (vkCullMode x) .
                                                      showString ", " .
                                                        showString "vkFrontFace = " .
                                                          showsPrec d (vkFrontFace x) .
                                                            showString ", " .
                                                              showString "vkDepthBiasEnable = " .
                                                                showsPrec d (vkDepthBiasEnable x) .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkDepthBiasConstantFactor = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkDepthBiasConstantFactor
                                                                           x)
                                                                        .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkDepthBiasClamp = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkDepthBiasClamp x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkDepthBiasSlopeFactor = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkDepthBiasSlopeFactor
                                                                                       x)
                                                                                    .
                                                                                    showString ", "
                                                                                      .
                                                                                      showString
                                                                                        "vkLineWidth = "
                                                                                        .
                                                                                        showsPrec d
                                                                                          (vkLineWidth
                                                                                             x)
                                                                                          .
                                                                                          showChar
                                                                                            '}'

data VkPipelineMultisampleStateCreateInfo = VkPipelineMultisampleStateCreateInfo## ByteArray##

instance Eq VkPipelineMultisampleStateCreateInfo where
        (VkPipelineMultisampleStateCreateInfo## a) ==
          (VkPipelineMultisampleStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineMultisampleStateCreateInfo where
        (VkPipelineMultisampleStateCreateInfo## a) `compare`
          (VkPipelineMultisampleStateCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineMultisampleStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineMultisampleStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineMultisampleStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineMultisampleStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineMultisampleStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineMultisampleStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineMultisampleStateCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf
                      (undefined :: VkPipelineMultisampleStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPipelineMultisampleStateCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPipelineMultisampleStateCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr
          = fromForeignPtr## VkPipelineMultisampleStateCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPipelineMultisampleStateCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPipelineMultisampleStateCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPipelineMultisampleStateCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineMultisampleStateCreateInfo where
        type VkSTypeMType VkPipelineMultisampleStateCreateInfo =
             VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineMultisampleStateCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, sType}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineMultisampleStateCreateInfo where
        type VkPNextMType VkPipelineMultisampleStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineMultisampleStateCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, pNext}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineMultisampleStateCreateInfo where
        type VkFlagsMType VkPipelineMultisampleStateCreateInfo =
             VkPipelineMultisampleStateCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineMultisampleStateCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, flags}

class HasVkRasterizationSamples a where
        type VkRasterizationSamplesMType a :: *

        vkRasterizationSamples :: a -> VkRasterizationSamplesMType a

        vkRasterizationSamplesByteOffset :: a -> Int

        readVkRasterizationSamples ::
                                   Ptr a -> IO (VkRasterizationSamplesMType a)

        writeVkRasterizationSamples ::
                                    Ptr a -> VkRasterizationSamplesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'rasterizationSamples'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRasterizationSamples a

instance {-# OVERLAPPING #-}
         HasVkRasterizationSamples VkPipelineMultisampleStateCreateInfo
         where
        type VkRasterizationSamplesMType
               VkPipelineMultisampleStateCreateInfo
             = VkSampleCountFlagBits

        {-# NOINLINE vkRasterizationSamples #-}
        vkRasterizationSamples x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineMultisampleStateCreateInfo, rasterizationSamples})

        {-# INLINE vkRasterizationSamplesByteOffset #-}
        vkRasterizationSamplesByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, rasterizationSamples}

        {-# INLINE readVkRasterizationSamples #-}
        readVkRasterizationSamples p
          = peekByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, rasterizationSamples}

        {-# INLINE writeVkRasterizationSamples #-}
        writeVkRasterizationSamples p
          = pokeByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, rasterizationSamples}

class HasVkSampleShadingEnable a where
        type VkSampleShadingEnableMType a :: *

        vkSampleShadingEnable :: a -> VkSampleShadingEnableMType a

        vkSampleShadingEnableByteOffset :: a -> Int

        readVkSampleShadingEnable ::
                                  Ptr a -> IO (VkSampleShadingEnableMType a)

        writeVkSampleShadingEnable ::
                                   Ptr a -> VkSampleShadingEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sampleShadingEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampleShadingEnable a

instance {-# OVERLAPPING #-}
         HasVkSampleShadingEnable VkPipelineMultisampleStateCreateInfo where
        type VkSampleShadingEnableMType
               VkPipelineMultisampleStateCreateInfo
             = VkBool32

        {-# NOINLINE vkSampleShadingEnable #-}
        vkSampleShadingEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineMultisampleStateCreateInfo, sampleShadingEnable})

        {-# INLINE vkSampleShadingEnableByteOffset #-}
        vkSampleShadingEnableByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, sampleShadingEnable}

        {-# INLINE readVkSampleShadingEnable #-}
        readVkSampleShadingEnable p
          = peekByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, sampleShadingEnable}

        {-# INLINE writeVkSampleShadingEnable #-}
        writeVkSampleShadingEnable p
          = pokeByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, sampleShadingEnable}

class HasVkMinSampleShading a where
        type VkMinSampleShadingMType a :: *

        vkMinSampleShading :: a -> VkMinSampleShadingMType a

        vkMinSampleShadingByteOffset :: a -> Int

        readVkMinSampleShading :: Ptr a -> IO (VkMinSampleShadingMType a)

        writeVkMinSampleShading ::
                                Ptr a -> VkMinSampleShadingMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minSampleShading'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinSampleShading a

instance {-# OVERLAPPING #-}
         HasVkMinSampleShading VkPipelineMultisampleStateCreateInfo where
        type VkMinSampleShadingMType VkPipelineMultisampleStateCreateInfo =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkMinSampleShading #-}
        vkMinSampleShading x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineMultisampleStateCreateInfo, minSampleShading})

        {-# INLINE vkMinSampleShadingByteOffset #-}
        vkMinSampleShadingByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, minSampleShading}

        {-# INLINE readVkMinSampleShading #-}
        readVkMinSampleShading p
          = peekByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, minSampleShading}

        {-# INLINE writeVkMinSampleShading #-}
        writeVkMinSampleShading p
          = pokeByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, minSampleShading}

class HasVkPSampleMask a where
        type VkPSampleMaskMType a :: *

        vkPSampleMask :: a -> VkPSampleMaskMType a

        vkPSampleMaskByteOffset :: a -> Int

        readVkPSampleMask :: Ptr a -> IO (VkPSampleMaskMType a)

        writeVkPSampleMask :: Ptr a -> VkPSampleMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pSampleMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPSampleMask a

instance {-# OVERLAPPING #-}
         HasVkPSampleMask VkPipelineMultisampleStateCreateInfo where
        type VkPSampleMaskMType VkPipelineMultisampleStateCreateInfo =
             Foreign.Ptr.Ptr VkSampleMask

        {-# NOINLINE vkPSampleMask #-}
        vkPSampleMask x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineMultisampleStateCreateInfo, pSampleMask})

        {-# INLINE vkPSampleMaskByteOffset #-}
        vkPSampleMaskByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, pSampleMask}

        {-# INLINE readVkPSampleMask #-}
        readVkPSampleMask p
          = peekByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, pSampleMask}

        {-# INLINE writeVkPSampleMask #-}
        writeVkPSampleMask p
          = pokeByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, pSampleMask}

class HasVkAlphaToCoverageEnable a where
        type VkAlphaToCoverageEnableMType a :: *

        vkAlphaToCoverageEnable :: a -> VkAlphaToCoverageEnableMType a

        vkAlphaToCoverageEnableByteOffset :: a -> Int

        readVkAlphaToCoverageEnable ::
                                    Ptr a -> IO (VkAlphaToCoverageEnableMType a)

        writeVkAlphaToCoverageEnable ::
                                     Ptr a -> VkAlphaToCoverageEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'alphaToCoverageEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAlphaToCoverageEnable a

instance {-# OVERLAPPING #-}
         HasVkAlphaToCoverageEnable VkPipelineMultisampleStateCreateInfo
         where
        type VkAlphaToCoverageEnableMType
               VkPipelineMultisampleStateCreateInfo
             = VkBool32

        {-# NOINLINE vkAlphaToCoverageEnable #-}
        vkAlphaToCoverageEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineMultisampleStateCreateInfo, alphaToCoverageEnable})

        {-# INLINE vkAlphaToCoverageEnableByteOffset #-}
        vkAlphaToCoverageEnableByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, alphaToCoverageEnable}

        {-# INLINE readVkAlphaToCoverageEnable #-}
        readVkAlphaToCoverageEnable p
          = peekByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, alphaToCoverageEnable}

        {-# INLINE writeVkAlphaToCoverageEnable #-}
        writeVkAlphaToCoverageEnable p
          = pokeByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, alphaToCoverageEnable}

class HasVkAlphaToOneEnable a where
        type VkAlphaToOneEnableMType a :: *

        vkAlphaToOneEnable :: a -> VkAlphaToOneEnableMType a

        vkAlphaToOneEnableByteOffset :: a -> Int

        readVkAlphaToOneEnable :: Ptr a -> IO (VkAlphaToOneEnableMType a)

        writeVkAlphaToOneEnable ::
                                Ptr a -> VkAlphaToOneEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'alphaToOneEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAlphaToOneEnable a

instance {-# OVERLAPPING #-}
         HasVkAlphaToOneEnable VkPipelineMultisampleStateCreateInfo where
        type VkAlphaToOneEnableMType VkPipelineMultisampleStateCreateInfo =
             VkBool32

        {-# NOINLINE vkAlphaToOneEnable #-}
        vkAlphaToOneEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineMultisampleStateCreateInfo, alphaToOneEnable})

        {-# INLINE vkAlphaToOneEnableByteOffset #-}
        vkAlphaToOneEnableByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, alphaToOneEnable}

        {-# INLINE readVkAlphaToOneEnable #-}
        readVkAlphaToOneEnable p
          = peekByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, alphaToOneEnable}

        {-# INLINE writeVkAlphaToOneEnable #-}
        writeVkAlphaToOneEnable p
          = pokeByteOff p
              #{offset VkPipelineMultisampleStateCreateInfo, alphaToOneEnable}

instance Show VkPipelineMultisampleStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineMultisampleStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkRasterizationSamples = " .
                                  showsPrec d (vkRasterizationSamples x) .
                                    showString ", " .
                                      showString "vkSampleShadingEnable = " .
                                        showsPrec d (vkSampleShadingEnable x) .
                                          showString ", " .
                                            showString "vkMinSampleShading = " .
                                              showsPrec d (vkMinSampleShading x) .
                                                showString ", " .
                                                  showString "vkPSampleMask = " .
                                                    showsPrec d (vkPSampleMask x) .
                                                      showString ", " .
                                                        showString "vkAlphaToCoverageEnable = " .
                                                          showsPrec d (vkAlphaToCoverageEnable x) .
                                                            showString ", " .
                                                              showString "vkAlphaToOneEnable = " .
                                                                showsPrec d (vkAlphaToOneEnable x) .
                                                                  showChar '}'

data VkPipelineColorBlendAttachmentState = VkPipelineColorBlendAttachmentState## ByteArray##

instance Eq VkPipelineColorBlendAttachmentState where
        (VkPipelineColorBlendAttachmentState## a) ==
          (VkPipelineColorBlendAttachmentState## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineColorBlendAttachmentState where
        (VkPipelineColorBlendAttachmentState## a) `compare`
          (VkPipelineColorBlendAttachmentState## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineColorBlendAttachmentState where
        sizeOf ~_ = #{size VkPipelineColorBlendAttachmentState}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineColorBlendAttachmentState}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineColorBlendAttachmentState),
            I## a <- alignment
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineColorBlendAttachmentState##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineColorBlendAttachmentState## ba)
          | I## n <- sizeOf (undefined :: VkPipelineColorBlendAttachmentState)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineColorBlendAttachmentState where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf
                      (undefined :: VkPipelineColorBlendAttachmentState),
            I## a <- alignment
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPipelineColorBlendAttachmentState##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPipelineColorBlendAttachmentState## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr
          = fromForeignPtr## VkPipelineColorBlendAttachmentState##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPipelineColorBlendAttachmentState## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPipelineColorBlendAttachmentState## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPipelineColorBlendAttachmentState## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkBlendEnable a where
        type VkBlendEnableMType a :: *

        vkBlendEnable :: a -> VkBlendEnableMType a

        vkBlendEnableByteOffset :: a -> Int

        readVkBlendEnable :: Ptr a -> IO (VkBlendEnableMType a)

        writeVkBlendEnable :: Ptr a -> VkBlendEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'blendEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBlendEnable a

instance {-# OVERLAPPING #-}
         HasVkBlendEnable VkPipelineColorBlendAttachmentState where
        type VkBlendEnableMType VkPipelineColorBlendAttachmentState =
             VkBool32

        {-# NOINLINE vkBlendEnable #-}
        vkBlendEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendAttachmentState, blendEnable})

        {-# INLINE vkBlendEnableByteOffset #-}
        vkBlendEnableByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, blendEnable}

        {-# INLINE readVkBlendEnable #-}
        readVkBlendEnable p
          = peekByteOff p
              #{offset VkPipelineColorBlendAttachmentState, blendEnable}

        {-# INLINE writeVkBlendEnable #-}
        writeVkBlendEnable p
          = pokeByteOff p
              #{offset VkPipelineColorBlendAttachmentState, blendEnable}

class HasVkSrcColorBlendFactor a where
        type VkSrcColorBlendFactorMType a :: *

        vkSrcColorBlendFactor :: a -> VkSrcColorBlendFactorMType a

        vkSrcColorBlendFactorByteOffset :: a -> Int

        readVkSrcColorBlendFactor ::
                                  Ptr a -> IO (VkSrcColorBlendFactorMType a)

        writeVkSrcColorBlendFactor ::
                                   Ptr a -> VkSrcColorBlendFactorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcColorBlendFactor'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcColorBlendFactor a

instance {-# OVERLAPPING #-}
         HasVkSrcColorBlendFactor VkPipelineColorBlendAttachmentState where
        type VkSrcColorBlendFactorMType VkPipelineColorBlendAttachmentState
             = VkBlendFactor

        {-# NOINLINE vkSrcColorBlendFactor #-}
        vkSrcColorBlendFactor x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendAttachmentState, srcColorBlendFactor})

        {-# INLINE vkSrcColorBlendFactorByteOffset #-}
        vkSrcColorBlendFactorByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, srcColorBlendFactor}

        {-# INLINE readVkSrcColorBlendFactor #-}
        readVkSrcColorBlendFactor p
          = peekByteOff p
              #{offset VkPipelineColorBlendAttachmentState, srcColorBlendFactor}

        {-# INLINE writeVkSrcColorBlendFactor #-}
        writeVkSrcColorBlendFactor p
          = pokeByteOff p
              #{offset VkPipelineColorBlendAttachmentState, srcColorBlendFactor}

class HasVkDstColorBlendFactor a where
        type VkDstColorBlendFactorMType a :: *

        vkDstColorBlendFactor :: a -> VkDstColorBlendFactorMType a

        vkDstColorBlendFactorByteOffset :: a -> Int

        readVkDstColorBlendFactor ::
                                  Ptr a -> IO (VkDstColorBlendFactorMType a)

        writeVkDstColorBlendFactor ::
                                   Ptr a -> VkDstColorBlendFactorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstColorBlendFactor'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstColorBlendFactor a

instance {-# OVERLAPPING #-}
         HasVkDstColorBlendFactor VkPipelineColorBlendAttachmentState where
        type VkDstColorBlendFactorMType VkPipelineColorBlendAttachmentState
             = VkBlendFactor

        {-# NOINLINE vkDstColorBlendFactor #-}
        vkDstColorBlendFactor x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendAttachmentState, dstColorBlendFactor})

        {-# INLINE vkDstColorBlendFactorByteOffset #-}
        vkDstColorBlendFactorByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, dstColorBlendFactor}

        {-# INLINE readVkDstColorBlendFactor #-}
        readVkDstColorBlendFactor p
          = peekByteOff p
              #{offset VkPipelineColorBlendAttachmentState, dstColorBlendFactor}

        {-# INLINE writeVkDstColorBlendFactor #-}
        writeVkDstColorBlendFactor p
          = pokeByteOff p
              #{offset VkPipelineColorBlendAttachmentState, dstColorBlendFactor}

class HasVkColorBlendOp a where
        type VkColorBlendOpMType a :: *

        vkColorBlendOp :: a -> VkColorBlendOpMType a

        vkColorBlendOpByteOffset :: a -> Int

        readVkColorBlendOp :: Ptr a -> IO (VkColorBlendOpMType a)

        writeVkColorBlendOp :: Ptr a -> VkColorBlendOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'colorBlendOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkColorBlendOp a

instance {-# OVERLAPPING #-}
         HasVkColorBlendOp VkPipelineColorBlendAttachmentState where
        type VkColorBlendOpMType VkPipelineColorBlendAttachmentState =
             VkBlendOp

        {-# NOINLINE vkColorBlendOp #-}
        vkColorBlendOp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendAttachmentState, colorBlendOp})

        {-# INLINE vkColorBlendOpByteOffset #-}
        vkColorBlendOpByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, colorBlendOp}

        {-# INLINE readVkColorBlendOp #-}
        readVkColorBlendOp p
          = peekByteOff p
              #{offset VkPipelineColorBlendAttachmentState, colorBlendOp}

        {-# INLINE writeVkColorBlendOp #-}
        writeVkColorBlendOp p
          = pokeByteOff p
              #{offset VkPipelineColorBlendAttachmentState, colorBlendOp}

class HasVkSrcAlphaBlendFactor a where
        type VkSrcAlphaBlendFactorMType a :: *

        vkSrcAlphaBlendFactor :: a -> VkSrcAlphaBlendFactorMType a

        vkSrcAlphaBlendFactorByteOffset :: a -> Int

        readVkSrcAlphaBlendFactor ::
                                  Ptr a -> IO (VkSrcAlphaBlendFactorMType a)

        writeVkSrcAlphaBlendFactor ::
                                   Ptr a -> VkSrcAlphaBlendFactorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcAlphaBlendFactor'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcAlphaBlendFactor a

instance {-# OVERLAPPING #-}
         HasVkSrcAlphaBlendFactor VkPipelineColorBlendAttachmentState where
        type VkSrcAlphaBlendFactorMType VkPipelineColorBlendAttachmentState
             = VkBlendFactor

        {-# NOINLINE vkSrcAlphaBlendFactor #-}
        vkSrcAlphaBlendFactor x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendAttachmentState, srcAlphaBlendFactor})

        {-# INLINE vkSrcAlphaBlendFactorByteOffset #-}
        vkSrcAlphaBlendFactorByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, srcAlphaBlendFactor}

        {-# INLINE readVkSrcAlphaBlendFactor #-}
        readVkSrcAlphaBlendFactor p
          = peekByteOff p
              #{offset VkPipelineColorBlendAttachmentState, srcAlphaBlendFactor}

        {-# INLINE writeVkSrcAlphaBlendFactor #-}
        writeVkSrcAlphaBlendFactor p
          = pokeByteOff p
              #{offset VkPipelineColorBlendAttachmentState, srcAlphaBlendFactor}

class HasVkDstAlphaBlendFactor a where
        type VkDstAlphaBlendFactorMType a :: *

        vkDstAlphaBlendFactor :: a -> VkDstAlphaBlendFactorMType a

        vkDstAlphaBlendFactorByteOffset :: a -> Int

        readVkDstAlphaBlendFactor ::
                                  Ptr a -> IO (VkDstAlphaBlendFactorMType a)

        writeVkDstAlphaBlendFactor ::
                                   Ptr a -> VkDstAlphaBlendFactorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstAlphaBlendFactor'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstAlphaBlendFactor a

instance {-# OVERLAPPING #-}
         HasVkDstAlphaBlendFactor VkPipelineColorBlendAttachmentState where
        type VkDstAlphaBlendFactorMType VkPipelineColorBlendAttachmentState
             = VkBlendFactor

        {-# NOINLINE vkDstAlphaBlendFactor #-}
        vkDstAlphaBlendFactor x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendAttachmentState, dstAlphaBlendFactor})

        {-# INLINE vkDstAlphaBlendFactorByteOffset #-}
        vkDstAlphaBlendFactorByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, dstAlphaBlendFactor}

        {-# INLINE readVkDstAlphaBlendFactor #-}
        readVkDstAlphaBlendFactor p
          = peekByteOff p
              #{offset VkPipelineColorBlendAttachmentState, dstAlphaBlendFactor}

        {-# INLINE writeVkDstAlphaBlendFactor #-}
        writeVkDstAlphaBlendFactor p
          = pokeByteOff p
              #{offset VkPipelineColorBlendAttachmentState, dstAlphaBlendFactor}

class HasVkAlphaBlendOp a where
        type VkAlphaBlendOpMType a :: *

        vkAlphaBlendOp :: a -> VkAlphaBlendOpMType a

        vkAlphaBlendOpByteOffset :: a -> Int

        readVkAlphaBlendOp :: Ptr a -> IO (VkAlphaBlendOpMType a)

        writeVkAlphaBlendOp :: Ptr a -> VkAlphaBlendOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'alphaBlendOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAlphaBlendOp a

instance {-# OVERLAPPING #-}
         HasVkAlphaBlendOp VkPipelineColorBlendAttachmentState where
        type VkAlphaBlendOpMType VkPipelineColorBlendAttachmentState =
             VkBlendOp

        {-# NOINLINE vkAlphaBlendOp #-}
        vkAlphaBlendOp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendAttachmentState, alphaBlendOp})

        {-# INLINE vkAlphaBlendOpByteOffset #-}
        vkAlphaBlendOpByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, alphaBlendOp}

        {-# INLINE readVkAlphaBlendOp #-}
        readVkAlphaBlendOp p
          = peekByteOff p
              #{offset VkPipelineColorBlendAttachmentState, alphaBlendOp}

        {-# INLINE writeVkAlphaBlendOp #-}
        writeVkAlphaBlendOp p
          = pokeByteOff p
              #{offset VkPipelineColorBlendAttachmentState, alphaBlendOp}

class HasVkColorWriteMask a where
        type VkColorWriteMaskMType a :: *

        vkColorWriteMask :: a -> VkColorWriteMaskMType a

        vkColorWriteMaskByteOffset :: a -> Int

        readVkColorWriteMask :: Ptr a -> IO (VkColorWriteMaskMType a)

        writeVkColorWriteMask :: Ptr a -> VkColorWriteMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'colorWriteMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkColorWriteMask a

instance {-# OVERLAPPING #-}
         HasVkColorWriteMask VkPipelineColorBlendAttachmentState where
        type VkColorWriteMaskMType VkPipelineColorBlendAttachmentState =
             VkColorComponentFlags

        {-# NOINLINE vkColorWriteMask #-}
        vkColorWriteMask x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendAttachmentState, colorWriteMask})

        {-# INLINE vkColorWriteMaskByteOffset #-}
        vkColorWriteMaskByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, colorWriteMask}

        {-# INLINE readVkColorWriteMask #-}
        readVkColorWriteMask p
          = peekByteOff p
              #{offset VkPipelineColorBlendAttachmentState, colorWriteMask}

        {-# INLINE writeVkColorWriteMask #-}
        writeVkColorWriteMask p
          = pokeByteOff p
              #{offset VkPipelineColorBlendAttachmentState, colorWriteMask}

instance Show VkPipelineColorBlendAttachmentState where
        showsPrec d x
          = showString "VkPipelineColorBlendAttachmentState {" .
              showString "vkBlendEnable = " .
                showsPrec d (vkBlendEnable x) .
                  showString ", " .
                    showString "vkSrcColorBlendFactor = " .
                      showsPrec d (vkSrcColorBlendFactor x) .
                        showString ", " .
                          showString "vkDstColorBlendFactor = " .
                            showsPrec d (vkDstColorBlendFactor x) .
                              showString ", " .
                                showString "vkColorBlendOp = " .
                                  showsPrec d (vkColorBlendOp x) .
                                    showString ", " .
                                      showString "vkSrcAlphaBlendFactor = " .
                                        showsPrec d (vkSrcAlphaBlendFactor x) .
                                          showString ", " .
                                            showString "vkDstAlphaBlendFactor = " .
                                              showsPrec d (vkDstAlphaBlendFactor x) .
                                                showString ", " .
                                                  showString "vkAlphaBlendOp = " .
                                                    showsPrec d (vkAlphaBlendOp x) .
                                                      showString ", " .
                                                        showString "vkColorWriteMask = " .
                                                          showsPrec d (vkColorWriteMask x) .
                                                            showChar '}'

data VkPipelineColorBlendStateCreateInfo = VkPipelineColorBlendStateCreateInfo## ByteArray##

instance Eq VkPipelineColorBlendStateCreateInfo where
        (VkPipelineColorBlendStateCreateInfo## a) ==
          (VkPipelineColorBlendStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineColorBlendStateCreateInfo where
        (VkPipelineColorBlendStateCreateInfo## a) `compare`
          (VkPipelineColorBlendStateCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineColorBlendStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineColorBlendStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineColorBlendStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineColorBlendStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineColorBlendStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineColorBlendStateCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineColorBlendStateCreateInfo)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineColorBlendStateCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf
                      (undefined :: VkPipelineColorBlendStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPipelineColorBlendStateCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPipelineColorBlendStateCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr
          = fromForeignPtr## VkPipelineColorBlendStateCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPipelineColorBlendStateCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPipelineColorBlendStateCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPipelineColorBlendStateCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineColorBlendStateCreateInfo where
        type VkSTypeMType VkPipelineColorBlendStateCreateInfo =
             VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendStateCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkPipelineColorBlendStateCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkPipelineColorBlendStateCreateInfo, sType}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineColorBlendStateCreateInfo where
        type VkPNextMType VkPipelineColorBlendStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendStateCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkPipelineColorBlendStateCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkPipelineColorBlendStateCreateInfo, pNext}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineColorBlendStateCreateInfo where
        type VkFlagsMType VkPipelineColorBlendStateCreateInfo =
             VkPipelineColorBlendStateCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendStateCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkPipelineColorBlendStateCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkPipelineColorBlendStateCreateInfo, flags}

class HasVkLogicOpEnable a where
        type VkLogicOpEnableMType a :: *

        vkLogicOpEnable :: a -> VkLogicOpEnableMType a

        vkLogicOpEnableByteOffset :: a -> Int

        readVkLogicOpEnable :: Ptr a -> IO (VkLogicOpEnableMType a)

        writeVkLogicOpEnable :: Ptr a -> VkLogicOpEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'logicOpEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLogicOpEnable a

instance {-# OVERLAPPING #-}
         HasVkLogicOpEnable VkPipelineColorBlendStateCreateInfo where
        type VkLogicOpEnableMType VkPipelineColorBlendStateCreateInfo =
             VkBool32

        {-# NOINLINE vkLogicOpEnable #-}
        vkLogicOpEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendStateCreateInfo, logicOpEnable})

        {-# INLINE vkLogicOpEnableByteOffset #-}
        vkLogicOpEnableByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, logicOpEnable}

        {-# INLINE readVkLogicOpEnable #-}
        readVkLogicOpEnable p
          = peekByteOff p
              #{offset VkPipelineColorBlendStateCreateInfo, logicOpEnable}

        {-# INLINE writeVkLogicOpEnable #-}
        writeVkLogicOpEnable p
          = pokeByteOff p
              #{offset VkPipelineColorBlendStateCreateInfo, logicOpEnable}

class HasVkLogicOp a where
        type VkLogicOpMType a :: *

        vkLogicOp :: a -> VkLogicOpMType a

        vkLogicOpByteOffset :: a -> Int

        readVkLogicOp :: Ptr a -> IO (VkLogicOpMType a)

        writeVkLogicOp :: Ptr a -> VkLogicOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'logicOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLogicOp a

instance {-# OVERLAPPING #-}
         HasVkLogicOp VkPipelineColorBlendStateCreateInfo where
        type VkLogicOpMType VkPipelineColorBlendStateCreateInfo = VkLogicOp

        {-# NOINLINE vkLogicOp #-}
        vkLogicOp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendStateCreateInfo, logicOp})

        {-# INLINE vkLogicOpByteOffset #-}
        vkLogicOpByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, logicOp}

        {-# INLINE readVkLogicOp #-}
        readVkLogicOp p
          = peekByteOff p
              #{offset VkPipelineColorBlendStateCreateInfo, logicOp}

        {-# INLINE writeVkLogicOp #-}
        writeVkLogicOp p
          = pokeByteOff p
              #{offset VkPipelineColorBlendStateCreateInfo, logicOp}

class HasVkAttachmentCount a where
        type VkAttachmentCountMType a :: *

        vkAttachmentCount :: a -> VkAttachmentCountMType a

        vkAttachmentCountByteOffset :: a -> Int

        readVkAttachmentCount :: Ptr a -> IO (VkAttachmentCountMType a)

        writeVkAttachmentCount ::
                               Ptr a -> VkAttachmentCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'attachmentCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAttachmentCount a

instance {-# OVERLAPPING #-}
         HasVkAttachmentCount VkPipelineColorBlendStateCreateInfo where
        type VkAttachmentCountMType VkPipelineColorBlendStateCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkAttachmentCount #-}
        vkAttachmentCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendStateCreateInfo, attachmentCount})

        {-# INLINE vkAttachmentCountByteOffset #-}
        vkAttachmentCountByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, attachmentCount}

        {-# INLINE readVkAttachmentCount #-}
        readVkAttachmentCount p
          = peekByteOff p
              #{offset VkPipelineColorBlendStateCreateInfo, attachmentCount}

        {-# INLINE writeVkAttachmentCount #-}
        writeVkAttachmentCount p
          = pokeByteOff p
              #{offset VkPipelineColorBlendStateCreateInfo, attachmentCount}

class HasVkPAttachments a where
        type VkPAttachmentsMType a :: *

        vkPAttachments :: a -> VkPAttachmentsMType a

        vkPAttachmentsByteOffset :: a -> Int

        readVkPAttachments :: Ptr a -> IO (VkPAttachmentsMType a)

        writeVkPAttachments :: Ptr a -> VkPAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pAttachments'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPAttachments a

instance {-# OVERLAPPING #-}
         HasVkPAttachments VkPipelineColorBlendStateCreateInfo where
        type VkPAttachmentsMType VkPipelineColorBlendStateCreateInfo =
             Foreign.Ptr.Ptr VkPipelineColorBlendAttachmentState

        {-# NOINLINE vkPAttachments #-}
        vkPAttachments x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineColorBlendStateCreateInfo, pAttachments})

        {-# INLINE vkPAttachmentsByteOffset #-}
        vkPAttachmentsByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, pAttachments}

        {-# INLINE readVkPAttachments #-}
        readVkPAttachments p
          = peekByteOff p
              #{offset VkPipelineColorBlendStateCreateInfo, pAttachments}

        {-# INLINE writeVkPAttachments #-}
        writeVkPAttachments p
          = pokeByteOff p
              #{offset VkPipelineColorBlendStateCreateInfo, pAttachments}

class HasVkBlendConstantsArray a where
        type VkBlendConstantsArrayMType a :: *

        vkBlendConstantsArray :: a -> Int -> VkBlendConstantsArrayMType a

        vkBlendConstantsArrayByteOffset :: a -> Int

        readVkBlendConstantsArray ::
                                  Ptr a -> Int -> IO (VkBlendConstantsArrayMType a)

        writeVkBlendConstantsArray ::
                                   Ptr a -> Int -> VkBlendConstantsArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'blendConstants'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBlendConstantsArray a

instance {-# OVERLAPPING #-}
         HasVkBlendConstantsArray VkPipelineColorBlendStateCreateInfo where
        type VkBlendConstantsArrayMType VkPipelineColorBlendStateCreateInfo
             = Foreign.C.Types.CFloat

        {-# NOINLINE vkBlendConstantsArray #-}
        vkBlendConstantsArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                    #{offset VkPipelineColorBlendStateCreateInfo, blendConstants}))

        {-# INLINE vkBlendConstantsArrayByteOffset #-}
        vkBlendConstantsArrayByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, blendConstants}

        {-# INLINE readVkBlendConstantsArray #-}
        readVkBlendConstantsArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                 #{offset VkPipelineColorBlendStateCreateInfo, blendConstants})

        {-# INLINE writeVkBlendConstantsArray #-}
        writeVkBlendConstantsArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                 #{offset VkPipelineColorBlendStateCreateInfo, blendConstants})

instance Show VkPipelineColorBlendStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineColorBlendStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkLogicOpEnable = " .
                                  showsPrec d (vkLogicOpEnable x) .
                                    showString ", " .
                                      showString "vkLogicOp = " .
                                        showsPrec d (vkLogicOp x) .
                                          showString ", " .
                                            showString "vkAttachmentCount = " .
                                              showsPrec d (vkAttachmentCount x) .
                                                showString ", " .
                                                  showString "vkPAttachments = " .
                                                    showsPrec d (vkPAttachments x) .
                                                      showString ", " .
                                                        showString "vkBlendConstantsArray = [" .
                                                          showsPrec d
                                                            (map (vkBlendConstantsArray x) [1 .. 4])
                                                            . showChar ']' . showChar '}'

data VkPipelineDynamicStateCreateInfo = VkPipelineDynamicStateCreateInfo## ByteArray##

instance Eq VkPipelineDynamicStateCreateInfo where
        (VkPipelineDynamicStateCreateInfo## a) ==
          (VkPipelineDynamicStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineDynamicStateCreateInfo where
        (VkPipelineDynamicStateCreateInfo## a) `compare`
          (VkPipelineDynamicStateCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineDynamicStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineDynamicStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineDynamicStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPipelineDynamicStateCreateInfo),
            I## a <- alignment (undefined :: VkPipelineDynamicStateCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineDynamicStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineDynamicStateCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineDynamicStateCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineDynamicStateCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkPipelineDynamicStateCreateInfo),
            I## a <- alignment (undefined :: VkPipelineDynamicStateCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPipelineDynamicStateCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPipelineDynamicStateCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkPipelineDynamicStateCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPipelineDynamicStateCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPipelineDynamicStateCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPipelineDynamicStateCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineDynamicStateCreateInfo where
        type VkSTypeMType VkPipelineDynamicStateCreateInfo =
             VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDynamicStateCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineDynamicStateCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkPipelineDynamicStateCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkPipelineDynamicStateCreateInfo, sType}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineDynamicStateCreateInfo where
        type VkPNextMType VkPipelineDynamicStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDynamicStateCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineDynamicStateCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkPipelineDynamicStateCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkPipelineDynamicStateCreateInfo, pNext}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineDynamicStateCreateInfo where
        type VkFlagsMType VkPipelineDynamicStateCreateInfo =
             VkPipelineDynamicStateCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDynamicStateCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineDynamicStateCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkPipelineDynamicStateCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkPipelineDynamicStateCreateInfo, flags}

class HasVkDynamicStateCount a where
        type VkDynamicStateCountMType a :: *

        vkDynamicStateCount :: a -> VkDynamicStateCountMType a

        vkDynamicStateCountByteOffset :: a -> Int

        readVkDynamicStateCount :: Ptr a -> IO (VkDynamicStateCountMType a)

        writeVkDynamicStateCount ::
                                 Ptr a -> VkDynamicStateCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dynamicStateCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDynamicStateCount a

instance {-# OVERLAPPING #-}
         HasVkDynamicStateCount VkPipelineDynamicStateCreateInfo where
        type VkDynamicStateCountMType VkPipelineDynamicStateCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkDynamicStateCount #-}
        vkDynamicStateCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDynamicStateCreateInfo, dynamicStateCount})

        {-# INLINE vkDynamicStateCountByteOffset #-}
        vkDynamicStateCountByteOffset ~_
          = #{offset VkPipelineDynamicStateCreateInfo, dynamicStateCount}

        {-# INLINE readVkDynamicStateCount #-}
        readVkDynamicStateCount p
          = peekByteOff p
              #{offset VkPipelineDynamicStateCreateInfo, dynamicStateCount}

        {-# INLINE writeVkDynamicStateCount #-}
        writeVkDynamicStateCount p
          = pokeByteOff p
              #{offset VkPipelineDynamicStateCreateInfo, dynamicStateCount}

class HasVkPDynamicStates a where
        type VkPDynamicStatesMType a :: *

        vkPDynamicStates :: a -> VkPDynamicStatesMType a

        vkPDynamicStatesByteOffset :: a -> Int

        readVkPDynamicStates :: Ptr a -> IO (VkPDynamicStatesMType a)

        writeVkPDynamicStates :: Ptr a -> VkPDynamicStatesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pDynamicStates'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPDynamicStates a

instance {-# OVERLAPPING #-}
         HasVkPDynamicStates VkPipelineDynamicStateCreateInfo where
        type VkPDynamicStatesMType VkPipelineDynamicStateCreateInfo =
             Foreign.Ptr.Ptr VkDynamicState

        {-# NOINLINE vkPDynamicStates #-}
        vkPDynamicStates x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDynamicStateCreateInfo, pDynamicStates})

        {-# INLINE vkPDynamicStatesByteOffset #-}
        vkPDynamicStatesByteOffset ~_
          = #{offset VkPipelineDynamicStateCreateInfo, pDynamicStates}

        {-# INLINE readVkPDynamicStates #-}
        readVkPDynamicStates p
          = peekByteOff p
              #{offset VkPipelineDynamicStateCreateInfo, pDynamicStates}

        {-# INLINE writeVkPDynamicStates #-}
        writeVkPDynamicStates p
          = pokeByteOff p
              #{offset VkPipelineDynamicStateCreateInfo, pDynamicStates}

instance Show VkPipelineDynamicStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineDynamicStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkDynamicStateCount = " .
                                  showsPrec d (vkDynamicStateCount x) .
                                    showString ", " .
                                      showString "vkPDynamicStates = " .
                                        showsPrec d (vkPDynamicStates x) . showChar '}'

data VkStencilOpState = VkStencilOpState## ByteArray##

instance Eq VkStencilOpState where
        (VkStencilOpState## a) == (VkStencilOpState## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkStencilOpState where
        (VkStencilOpState## a) `compare` (VkStencilOpState## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkStencilOpState where
        sizeOf ~_ = #{size VkStencilOpState}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkStencilOpState}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkStencilOpState),
            I## a <- alignment (undefined :: VkStencilOpState) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkStencilOpState## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkStencilOpState## ba)
          | I## n <- sizeOf (undefined :: VkStencilOpState) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkStencilOpState where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkStencilOpState),
            I## a <- alignment (undefined :: VkStencilOpState) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkStencilOpState##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkStencilOpState## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkStencilOpState##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkStencilOpState## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkStencilOpState## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkStencilOpState## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkFailOp a where
        type VkFailOpMType a :: *

        vkFailOp :: a -> VkFailOpMType a

        vkFailOpByteOffset :: a -> Int

        readVkFailOp :: Ptr a -> IO (VkFailOpMType a)

        writeVkFailOp :: Ptr a -> VkFailOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'failOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFailOp a

instance {-# OVERLAPPING #-} HasVkFailOp VkStencilOpState where
        type VkFailOpMType VkStencilOpState = VkStencilOp

        {-# NOINLINE vkFailOp #-}
        vkFailOp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkStencilOpState, failOp})

        {-# INLINE vkFailOpByteOffset #-}
        vkFailOpByteOffset ~_ = #{offset VkStencilOpState, failOp}

        {-# INLINE readVkFailOp #-}
        readVkFailOp p
          = peekByteOff p #{offset VkStencilOpState, failOp}

        {-# INLINE writeVkFailOp #-}
        writeVkFailOp p
          = pokeByteOff p #{offset VkStencilOpState, failOp}

class HasVkPassOp a where
        type VkPassOpMType a :: *

        vkPassOp :: a -> VkPassOpMType a

        vkPassOpByteOffset :: a -> Int

        readVkPassOp :: Ptr a -> IO (VkPassOpMType a)

        writeVkPassOp :: Ptr a -> VkPassOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'passOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPassOp a

instance {-# OVERLAPPING #-} HasVkPassOp VkStencilOpState where
        type VkPassOpMType VkStencilOpState = VkStencilOp

        {-# NOINLINE vkPassOp #-}
        vkPassOp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkStencilOpState, passOp})

        {-# INLINE vkPassOpByteOffset #-}
        vkPassOpByteOffset ~_ = #{offset VkStencilOpState, passOp}

        {-# INLINE readVkPassOp #-}
        readVkPassOp p
          = peekByteOff p #{offset VkStencilOpState, passOp}

        {-# INLINE writeVkPassOp #-}
        writeVkPassOp p
          = pokeByteOff p #{offset VkStencilOpState, passOp}

class HasVkDepthFailOp a where
        type VkDepthFailOpMType a :: *

        vkDepthFailOp :: a -> VkDepthFailOpMType a

        vkDepthFailOpByteOffset :: a -> Int

        readVkDepthFailOp :: Ptr a -> IO (VkDepthFailOpMType a)

        writeVkDepthFailOp :: Ptr a -> VkDepthFailOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthFailOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthFailOp a

instance {-# OVERLAPPING #-} HasVkDepthFailOp VkStencilOpState
         where
        type VkDepthFailOpMType VkStencilOpState = VkStencilOp

        {-# NOINLINE vkDepthFailOp #-}
        vkDepthFailOp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkStencilOpState, depthFailOp})

        {-# INLINE vkDepthFailOpByteOffset #-}
        vkDepthFailOpByteOffset ~_
          = #{offset VkStencilOpState, depthFailOp}

        {-# INLINE readVkDepthFailOp #-}
        readVkDepthFailOp p
          = peekByteOff p #{offset VkStencilOpState, depthFailOp}

        {-# INLINE writeVkDepthFailOp #-}
        writeVkDepthFailOp p
          = pokeByteOff p #{offset VkStencilOpState, depthFailOp}

class HasVkCompareOp a where
        type VkCompareOpMType a :: *

        vkCompareOp :: a -> VkCompareOpMType a

        vkCompareOpByteOffset :: a -> Int

        readVkCompareOp :: Ptr a -> IO (VkCompareOpMType a)

        writeVkCompareOp :: Ptr a -> VkCompareOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'compareOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCompareOp a

instance {-# OVERLAPPING #-} HasVkCompareOp VkStencilOpState where
        type VkCompareOpMType VkStencilOpState = VkCompareOp

        {-# NOINLINE vkCompareOp #-}
        vkCompareOp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkStencilOpState, compareOp})

        {-# INLINE vkCompareOpByteOffset #-}
        vkCompareOpByteOffset ~_
          = #{offset VkStencilOpState, compareOp}

        {-# INLINE readVkCompareOp #-}
        readVkCompareOp p
          = peekByteOff p #{offset VkStencilOpState, compareOp}

        {-# INLINE writeVkCompareOp #-}
        writeVkCompareOp p
          = pokeByteOff p #{offset VkStencilOpState, compareOp}

class HasVkCompareMask a where
        type VkCompareMaskMType a :: *

        vkCompareMask :: a -> VkCompareMaskMType a

        vkCompareMaskByteOffset :: a -> Int

        readVkCompareMask :: Ptr a -> IO (VkCompareMaskMType a)

        writeVkCompareMask :: Ptr a -> VkCompareMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'compareMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCompareMask a

instance {-# OVERLAPPING #-} HasVkCompareMask VkStencilOpState
         where
        type VkCompareMaskMType VkStencilOpState = Data.Word.Word32

        {-# NOINLINE vkCompareMask #-}
        vkCompareMask x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkStencilOpState, compareMask})

        {-# INLINE vkCompareMaskByteOffset #-}
        vkCompareMaskByteOffset ~_
          = #{offset VkStencilOpState, compareMask}

        {-# INLINE readVkCompareMask #-}
        readVkCompareMask p
          = peekByteOff p #{offset VkStencilOpState, compareMask}

        {-# INLINE writeVkCompareMask #-}
        writeVkCompareMask p
          = pokeByteOff p #{offset VkStencilOpState, compareMask}

class HasVkWriteMask a where
        type VkWriteMaskMType a :: *

        vkWriteMask :: a -> VkWriteMaskMType a

        vkWriteMaskByteOffset :: a -> Int

        readVkWriteMask :: Ptr a -> IO (VkWriteMaskMType a)

        writeVkWriteMask :: Ptr a -> VkWriteMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'writeMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkWriteMask a

instance {-# OVERLAPPING #-} HasVkWriteMask VkStencilOpState where
        type VkWriteMaskMType VkStencilOpState = Data.Word.Word32

        {-# NOINLINE vkWriteMask #-}
        vkWriteMask x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkStencilOpState, writeMask})

        {-# INLINE vkWriteMaskByteOffset #-}
        vkWriteMaskByteOffset ~_
          = #{offset VkStencilOpState, writeMask}

        {-# INLINE readVkWriteMask #-}
        readVkWriteMask p
          = peekByteOff p #{offset VkStencilOpState, writeMask}

        {-# INLINE writeVkWriteMask #-}
        writeVkWriteMask p
          = pokeByteOff p #{offset VkStencilOpState, writeMask}

class HasVkReference a where
        type VkReferenceMType a :: *

        vkReference :: a -> VkReferenceMType a

        vkReferenceByteOffset :: a -> Int

        readVkReference :: Ptr a -> IO (VkReferenceMType a)

        writeVkReference :: Ptr a -> VkReferenceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'reference'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkReference a

instance {-# OVERLAPPING #-} HasVkReference VkStencilOpState where
        type VkReferenceMType VkStencilOpState = Data.Word.Word32

        {-# NOINLINE vkReference #-}
        vkReference x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkStencilOpState, reference})

        {-# INLINE vkReferenceByteOffset #-}
        vkReferenceByteOffset ~_
          = #{offset VkStencilOpState, reference}

        {-# INLINE readVkReference #-}
        readVkReference p
          = peekByteOff p #{offset VkStencilOpState, reference}

        {-# INLINE writeVkReference #-}
        writeVkReference p
          = pokeByteOff p #{offset VkStencilOpState, reference}

instance Show VkStencilOpState where
        showsPrec d x
          = showString "VkStencilOpState {" .
              showString "vkFailOp = " .
                showsPrec d (vkFailOp x) .
                  showString ", " .
                    showString "vkPassOp = " .
                      showsPrec d (vkPassOp x) .
                        showString ", " .
                          showString "vkDepthFailOp = " .
                            showsPrec d (vkDepthFailOp x) .
                              showString ", " .
                                showString "vkCompareOp = " .
                                  showsPrec d (vkCompareOp x) .
                                    showString ", " .
                                      showString "vkCompareMask = " .
                                        showsPrec d (vkCompareMask x) .
                                          showString ", " .
                                            showString "vkWriteMask = " .
                                              showsPrec d (vkWriteMask x) .
                                                showString ", " .
                                                  showString "vkReference = " .
                                                    showsPrec d (vkReference x) . showChar '}'

data VkPipelineDepthStencilStateCreateInfo = VkPipelineDepthStencilStateCreateInfo## ByteArray##

instance Eq VkPipelineDepthStencilStateCreateInfo where
        (VkPipelineDepthStencilStateCreateInfo## a) ==
          (VkPipelineDepthStencilStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineDepthStencilStateCreateInfo where
        (VkPipelineDepthStencilStateCreateInfo## a) `compare`
          (VkPipelineDepthStencilStateCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineDepthStencilStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineDepthStencilStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineDepthStencilStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineDepthStencilStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineDepthStencilStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineDepthStencilStateCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf
                      (undefined :: VkPipelineDepthStencilStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPipelineDepthStencilStateCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPipelineDepthStencilStateCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr
          = fromForeignPtr## VkPipelineDepthStencilStateCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPipelineDepthStencilStateCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPipelineDepthStencilStateCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPipelineDepthStencilStateCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineDepthStencilStateCreateInfo where
        type VkSTypeMType VkPipelineDepthStencilStateCreateInfo =
             VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDepthStencilStateCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, sType}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineDepthStencilStateCreateInfo where
        type VkPNextMType VkPipelineDepthStencilStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDepthStencilStateCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, pNext}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineDepthStencilStateCreateInfo where
        type VkFlagsMType VkPipelineDepthStencilStateCreateInfo =
             VkPipelineDepthStencilStateCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDepthStencilStateCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, flags}

class HasVkDepthTestEnable a where
        type VkDepthTestEnableMType a :: *

        vkDepthTestEnable :: a -> VkDepthTestEnableMType a

        vkDepthTestEnableByteOffset :: a -> Int

        readVkDepthTestEnable :: Ptr a -> IO (VkDepthTestEnableMType a)

        writeVkDepthTestEnable ::
                               Ptr a -> VkDepthTestEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthTestEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthTestEnable a

instance {-# OVERLAPPING #-}
         HasVkDepthTestEnable VkPipelineDepthStencilStateCreateInfo where
        type VkDepthTestEnableMType VkPipelineDepthStencilStateCreateInfo =
             VkBool32

        {-# NOINLINE vkDepthTestEnable #-}
        vkDepthTestEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDepthStencilStateCreateInfo, depthTestEnable})

        {-# INLINE vkDepthTestEnableByteOffset #-}
        vkDepthTestEnableByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, depthTestEnable}

        {-# INLINE readVkDepthTestEnable #-}
        readVkDepthTestEnable p
          = peekByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, depthTestEnable}

        {-# INLINE writeVkDepthTestEnable #-}
        writeVkDepthTestEnable p
          = pokeByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, depthTestEnable}

class HasVkDepthWriteEnable a where
        type VkDepthWriteEnableMType a :: *

        vkDepthWriteEnable :: a -> VkDepthWriteEnableMType a

        vkDepthWriteEnableByteOffset :: a -> Int

        readVkDepthWriteEnable :: Ptr a -> IO (VkDepthWriteEnableMType a)

        writeVkDepthWriteEnable ::
                                Ptr a -> VkDepthWriteEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthWriteEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthWriteEnable a

instance {-# OVERLAPPING #-}
         HasVkDepthWriteEnable VkPipelineDepthStencilStateCreateInfo where
        type VkDepthWriteEnableMType VkPipelineDepthStencilStateCreateInfo
             = VkBool32

        {-# NOINLINE vkDepthWriteEnable #-}
        vkDepthWriteEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDepthStencilStateCreateInfo, depthWriteEnable})

        {-# INLINE vkDepthWriteEnableByteOffset #-}
        vkDepthWriteEnableByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, depthWriteEnable}

        {-# INLINE readVkDepthWriteEnable #-}
        readVkDepthWriteEnable p
          = peekByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, depthWriteEnable}

        {-# INLINE writeVkDepthWriteEnable #-}
        writeVkDepthWriteEnable p
          = pokeByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, depthWriteEnable}

class HasVkDepthCompareOp a where
        type VkDepthCompareOpMType a :: *

        vkDepthCompareOp :: a -> VkDepthCompareOpMType a

        vkDepthCompareOpByteOffset :: a -> Int

        readVkDepthCompareOp :: Ptr a -> IO (VkDepthCompareOpMType a)

        writeVkDepthCompareOp :: Ptr a -> VkDepthCompareOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthCompareOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthCompareOp a

instance {-# OVERLAPPING #-}
         HasVkDepthCompareOp VkPipelineDepthStencilStateCreateInfo where
        type VkDepthCompareOpMType VkPipelineDepthStencilStateCreateInfo =
             VkCompareOp

        {-# NOINLINE vkDepthCompareOp #-}
        vkDepthCompareOp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDepthStencilStateCreateInfo, depthCompareOp})

        {-# INLINE vkDepthCompareOpByteOffset #-}
        vkDepthCompareOpByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, depthCompareOp}

        {-# INLINE readVkDepthCompareOp #-}
        readVkDepthCompareOp p
          = peekByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, depthCompareOp}

        {-# INLINE writeVkDepthCompareOp #-}
        writeVkDepthCompareOp p
          = pokeByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, depthCompareOp}

class HasVkDepthBoundsTestEnable a where
        type VkDepthBoundsTestEnableMType a :: *

        vkDepthBoundsTestEnable :: a -> VkDepthBoundsTestEnableMType a

        vkDepthBoundsTestEnableByteOffset :: a -> Int

        readVkDepthBoundsTestEnable ::
                                    Ptr a -> IO (VkDepthBoundsTestEnableMType a)

        writeVkDepthBoundsTestEnable ::
                                     Ptr a -> VkDepthBoundsTestEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthBoundsTestEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthBoundsTestEnable a

instance {-# OVERLAPPING #-}
         HasVkDepthBoundsTestEnable VkPipelineDepthStencilStateCreateInfo
         where
        type VkDepthBoundsTestEnableMType
               VkPipelineDepthStencilStateCreateInfo
             = VkBool32

        {-# NOINLINE vkDepthBoundsTestEnable #-}
        vkDepthBoundsTestEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDepthStencilStateCreateInfo, depthBoundsTestEnable})

        {-# INLINE vkDepthBoundsTestEnableByteOffset #-}
        vkDepthBoundsTestEnableByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, depthBoundsTestEnable}

        {-# INLINE readVkDepthBoundsTestEnable #-}
        readVkDepthBoundsTestEnable p
          = peekByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, depthBoundsTestEnable}

        {-# INLINE writeVkDepthBoundsTestEnable #-}
        writeVkDepthBoundsTestEnable p
          = pokeByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, depthBoundsTestEnable}

class HasVkStencilTestEnable a where
        type VkStencilTestEnableMType a :: *

        vkStencilTestEnable :: a -> VkStencilTestEnableMType a

        vkStencilTestEnableByteOffset :: a -> Int

        readVkStencilTestEnable :: Ptr a -> IO (VkStencilTestEnableMType a)

        writeVkStencilTestEnable ::
                                 Ptr a -> VkStencilTestEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stencilTestEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStencilTestEnable a

instance {-# OVERLAPPING #-}
         HasVkStencilTestEnable VkPipelineDepthStencilStateCreateInfo where
        type VkStencilTestEnableMType VkPipelineDepthStencilStateCreateInfo
             = VkBool32

        {-# NOINLINE vkStencilTestEnable #-}
        vkStencilTestEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDepthStencilStateCreateInfo, stencilTestEnable})

        {-# INLINE vkStencilTestEnableByteOffset #-}
        vkStencilTestEnableByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, stencilTestEnable}

        {-# INLINE readVkStencilTestEnable #-}
        readVkStencilTestEnable p
          = peekByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, stencilTestEnable}

        {-# INLINE writeVkStencilTestEnable #-}
        writeVkStencilTestEnable p
          = pokeByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, stencilTestEnable}

class HasVkFront a where
        type VkFrontMType a :: *

        vkFront :: a -> VkFrontMType a

        vkFrontByteOffset :: a -> Int

        readVkFront :: Ptr a -> IO (VkFrontMType a)

        writeVkFront :: Ptr a -> VkFrontMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'front'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFront a

instance {-# OVERLAPPING #-}
         HasVkFront VkPipelineDepthStencilStateCreateInfo where
        type VkFrontMType VkPipelineDepthStencilStateCreateInfo =
             VkStencilOpState

        {-# NOINLINE vkFront #-}
        vkFront x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDepthStencilStateCreateInfo, front})

        {-# INLINE vkFrontByteOffset #-}
        vkFrontByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, front}

        {-# INLINE readVkFront #-}
        readVkFront p
          = peekByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, front}

        {-# INLINE writeVkFront #-}
        writeVkFront p
          = pokeByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, front}

class HasVkBack a where
        type VkBackMType a :: *

        vkBack :: a -> VkBackMType a

        vkBackByteOffset :: a -> Int

        readVkBack :: Ptr a -> IO (VkBackMType a)

        writeVkBack :: Ptr a -> VkBackMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'back'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBack a

instance {-# OVERLAPPING #-}
         HasVkBack VkPipelineDepthStencilStateCreateInfo where
        type VkBackMType VkPipelineDepthStencilStateCreateInfo =
             VkStencilOpState

        {-# NOINLINE vkBack #-}
        vkBack x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDepthStencilStateCreateInfo, back})

        {-# INLINE vkBackByteOffset #-}
        vkBackByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, back}

        {-# INLINE readVkBack #-}
        readVkBack p
          = peekByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, back}

        {-# INLINE writeVkBack #-}
        writeVkBack p
          = pokeByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, back}

class HasVkMinDepthBounds a where
        type VkMinDepthBoundsMType a :: *

        vkMinDepthBounds :: a -> VkMinDepthBoundsMType a

        vkMinDepthBoundsByteOffset :: a -> Int

        readVkMinDepthBounds :: Ptr a -> IO (VkMinDepthBoundsMType a)

        writeVkMinDepthBounds :: Ptr a -> VkMinDepthBoundsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minDepthBounds'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinDepthBounds a

instance {-# OVERLAPPING #-}
         HasVkMinDepthBounds VkPipelineDepthStencilStateCreateInfo where
        type VkMinDepthBoundsMType VkPipelineDepthStencilStateCreateInfo =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkMinDepthBounds #-}
        vkMinDepthBounds x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDepthStencilStateCreateInfo, minDepthBounds})

        {-# INLINE vkMinDepthBoundsByteOffset #-}
        vkMinDepthBoundsByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, minDepthBounds}

        {-# INLINE readVkMinDepthBounds #-}
        readVkMinDepthBounds p
          = peekByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, minDepthBounds}

        {-# INLINE writeVkMinDepthBounds #-}
        writeVkMinDepthBounds p
          = pokeByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, minDepthBounds}

class HasVkMaxDepthBounds a where
        type VkMaxDepthBoundsMType a :: *

        vkMaxDepthBounds :: a -> VkMaxDepthBoundsMType a

        vkMaxDepthBoundsByteOffset :: a -> Int

        readVkMaxDepthBounds :: Ptr a -> IO (VkMaxDepthBoundsMType a)

        writeVkMaxDepthBounds :: Ptr a -> VkMaxDepthBoundsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxDepthBounds'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDepthBounds a

instance {-# OVERLAPPING #-}
         HasVkMaxDepthBounds VkPipelineDepthStencilStateCreateInfo where
        type VkMaxDepthBoundsMType VkPipelineDepthStencilStateCreateInfo =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkMaxDepthBounds #-}
        vkMaxDepthBounds x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineDepthStencilStateCreateInfo, maxDepthBounds})

        {-# INLINE vkMaxDepthBoundsByteOffset #-}
        vkMaxDepthBoundsByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, maxDepthBounds}

        {-# INLINE readVkMaxDepthBounds #-}
        readVkMaxDepthBounds p
          = peekByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, maxDepthBounds}

        {-# INLINE writeVkMaxDepthBounds #-}
        writeVkMaxDepthBounds p
          = pokeByteOff p
              #{offset VkPipelineDepthStencilStateCreateInfo, maxDepthBounds}

instance Show VkPipelineDepthStencilStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineDepthStencilStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkDepthTestEnable = " .
                                  showsPrec d (vkDepthTestEnable x) .
                                    showString ", " .
                                      showString "vkDepthWriteEnable = " .
                                        showsPrec d (vkDepthWriteEnable x) .
                                          showString ", " .
                                            showString "vkDepthCompareOp = " .
                                              showsPrec d (vkDepthCompareOp x) .
                                                showString ", " .
                                                  showString "vkDepthBoundsTestEnable = " .
                                                    showsPrec d (vkDepthBoundsTestEnable x) .
                                                      showString ", " .
                                                        showString "vkStencilTestEnable = " .
                                                          showsPrec d (vkStencilTestEnable x) .
                                                            showString ", " .
                                                              showString "vkFront = " .
                                                                showsPrec d (vkFront x) .
                                                                  showString ", " .
                                                                    showString "vkBack = " .
                                                                      showsPrec d (vkBack x) .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkMinDepthBounds = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkMinDepthBounds x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkMaxDepthBounds = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkMaxDepthBounds
                                                                                       x)
                                                                                    . showChar '}'

data VkGraphicsPipelineCreateInfo = VkGraphicsPipelineCreateInfo## ByteArray##

instance Eq VkGraphicsPipelineCreateInfo where
        (VkGraphicsPipelineCreateInfo## a) ==
          (VkGraphicsPipelineCreateInfo## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkGraphicsPipelineCreateInfo where
        (VkGraphicsPipelineCreateInfo## a) `compare`
          (VkGraphicsPipelineCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkGraphicsPipelineCreateInfo where
        sizeOf ~_ = #{size VkGraphicsPipelineCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkGraphicsPipelineCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkGraphicsPipelineCreateInfo),
            I## a <- alignment (undefined :: VkGraphicsPipelineCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkGraphicsPipelineCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkGraphicsPipelineCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkGraphicsPipelineCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkGraphicsPipelineCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkGraphicsPipelineCreateInfo),
            I## a <- alignment (undefined :: VkGraphicsPipelineCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkGraphicsPipelineCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkGraphicsPipelineCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkGraphicsPipelineCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkGraphicsPipelineCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkGraphicsPipelineCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkGraphicsPipelineCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkSType VkGraphicsPipelineCreateInfo where
        type VkSTypeMType VkGraphicsPipelineCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, sType}

instance {-# OVERLAPPING #-}
         HasVkPNext VkGraphicsPipelineCreateInfo where
        type VkPNextMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pNext}

instance {-# OVERLAPPING #-}
         HasVkFlags VkGraphicsPipelineCreateInfo where
        type VkFlagsMType VkGraphicsPipelineCreateInfo =
             VkPipelineCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, flags}

class HasVkStageCount a where
        type VkStageCountMType a :: *

        vkStageCount :: a -> VkStageCountMType a

        vkStageCountByteOffset :: a -> Int

        readVkStageCount :: Ptr a -> IO (VkStageCountMType a)

        writeVkStageCount :: Ptr a -> VkStageCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stageCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStageCount a

instance {-# OVERLAPPING #-}
         HasVkStageCount VkGraphicsPipelineCreateInfo where
        type VkStageCountMType VkGraphicsPipelineCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkStageCount #-}
        vkStageCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, stageCount})

        {-# INLINE vkStageCountByteOffset #-}
        vkStageCountByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, stageCount}

        {-# INLINE readVkStageCount #-}
        readVkStageCount p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, stageCount}

        {-# INLINE writeVkStageCount #-}
        writeVkStageCount p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, stageCount}

class HasVkPStages a where
        type VkPStagesMType a :: *

        vkPStages :: a -> VkPStagesMType a

        vkPStagesByteOffset :: a -> Int

        readVkPStages :: Ptr a -> IO (VkPStagesMType a)

        writeVkPStages :: Ptr a -> VkPStagesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pStages'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPStages a

instance {-# OVERLAPPING #-}
         HasVkPStages VkGraphicsPipelineCreateInfo where
        type VkPStagesMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineShaderStageCreateInfo

        {-# NOINLINE vkPStages #-}
        vkPStages x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, pStages})

        {-# INLINE vkPStagesByteOffset #-}
        vkPStagesByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pStages}

        {-# INLINE readVkPStages #-}
        readVkPStages p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pStages}

        {-# INLINE writeVkPStages #-}
        writeVkPStages p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pStages}

class HasVkPVertexInputState a where
        type VkPVertexInputStateMType a :: *

        vkPVertexInputState :: a -> VkPVertexInputStateMType a

        vkPVertexInputStateByteOffset :: a -> Int

        readVkPVertexInputState :: Ptr a -> IO (VkPVertexInputStateMType a)

        writeVkPVertexInputState ::
                                 Ptr a -> VkPVertexInputStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pVertexInputState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPVertexInputState a

instance {-# OVERLAPPING #-}
         HasVkPVertexInputState VkGraphicsPipelineCreateInfo where
        type VkPVertexInputStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineVertexInputStateCreateInfo

        {-# NOINLINE vkPVertexInputState #-}
        vkPVertexInputState x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, pVertexInputState})

        {-# INLINE vkPVertexInputStateByteOffset #-}
        vkPVertexInputStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pVertexInputState}

        {-# INLINE readVkPVertexInputState #-}
        readVkPVertexInputState p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pVertexInputState}

        {-# INLINE writeVkPVertexInputState #-}
        writeVkPVertexInputState p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pVertexInputState}

class HasVkPInputAssemblyState a where
        type VkPInputAssemblyStateMType a :: *

        vkPInputAssemblyState :: a -> VkPInputAssemblyStateMType a

        vkPInputAssemblyStateByteOffset :: a -> Int

        readVkPInputAssemblyState ::
                                  Ptr a -> IO (VkPInputAssemblyStateMType a)

        writeVkPInputAssemblyState ::
                                   Ptr a -> VkPInputAssemblyStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pInputAssemblyState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPInputAssemblyState a

instance {-# OVERLAPPING #-}
         HasVkPInputAssemblyState VkGraphicsPipelineCreateInfo where
        type VkPInputAssemblyStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineInputAssemblyStateCreateInfo

        {-# NOINLINE vkPInputAssemblyState #-}
        vkPInputAssemblyState x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, pInputAssemblyState})

        {-# INLINE vkPInputAssemblyStateByteOffset #-}
        vkPInputAssemblyStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pInputAssemblyState}

        {-# INLINE readVkPInputAssemblyState #-}
        readVkPInputAssemblyState p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pInputAssemblyState}

        {-# INLINE writeVkPInputAssemblyState #-}
        writeVkPInputAssemblyState p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pInputAssemblyState}

class HasVkPTessellationState a where
        type VkPTessellationStateMType a :: *

        vkPTessellationState :: a -> VkPTessellationStateMType a

        vkPTessellationStateByteOffset :: a -> Int

        readVkPTessellationState ::
                                 Ptr a -> IO (VkPTessellationStateMType a)

        writeVkPTessellationState ::
                                  Ptr a -> VkPTessellationStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pTessellationState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPTessellationState a

instance {-# OVERLAPPING #-}
         HasVkPTessellationState VkGraphicsPipelineCreateInfo where
        type VkPTessellationStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineTessellationStateCreateInfo

        {-# NOINLINE vkPTessellationState #-}
        vkPTessellationState x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, pTessellationState})

        {-# INLINE vkPTessellationStateByteOffset #-}
        vkPTessellationStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pTessellationState}

        {-# INLINE readVkPTessellationState #-}
        readVkPTessellationState p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pTessellationState}

        {-# INLINE writeVkPTessellationState #-}
        writeVkPTessellationState p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pTessellationState}

class HasVkPViewportState a where
        type VkPViewportStateMType a :: *

        vkPViewportState :: a -> VkPViewportStateMType a

        vkPViewportStateByteOffset :: a -> Int

        readVkPViewportState :: Ptr a -> IO (VkPViewportStateMType a)

        writeVkPViewportState :: Ptr a -> VkPViewportStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pViewportState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPViewportState a

instance {-# OVERLAPPING #-}
         HasVkPViewportState VkGraphicsPipelineCreateInfo where
        type VkPViewportStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineViewportStateCreateInfo

        {-# NOINLINE vkPViewportState #-}
        vkPViewportState x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, pViewportState})

        {-# INLINE vkPViewportStateByteOffset #-}
        vkPViewportStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pViewportState}

        {-# INLINE readVkPViewportState #-}
        readVkPViewportState p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pViewportState}

        {-# INLINE writeVkPViewportState #-}
        writeVkPViewportState p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pViewportState}

class HasVkPRasterizationState a where
        type VkPRasterizationStateMType a :: *

        vkPRasterizationState :: a -> VkPRasterizationStateMType a

        vkPRasterizationStateByteOffset :: a -> Int

        readVkPRasterizationState ::
                                  Ptr a -> IO (VkPRasterizationStateMType a)

        writeVkPRasterizationState ::
                                   Ptr a -> VkPRasterizationStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pRasterizationState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPRasterizationState a

instance {-# OVERLAPPING #-}
         HasVkPRasterizationState VkGraphicsPipelineCreateInfo where
        type VkPRasterizationStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineRasterizationStateCreateInfo

        {-# NOINLINE vkPRasterizationState #-}
        vkPRasterizationState x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, pRasterizationState})

        {-# INLINE vkPRasterizationStateByteOffset #-}
        vkPRasterizationStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pRasterizationState}

        {-# INLINE readVkPRasterizationState #-}
        readVkPRasterizationState p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pRasterizationState}

        {-# INLINE writeVkPRasterizationState #-}
        writeVkPRasterizationState p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pRasterizationState}

class HasVkPMultisampleState a where
        type VkPMultisampleStateMType a :: *

        vkPMultisampleState :: a -> VkPMultisampleStateMType a

        vkPMultisampleStateByteOffset :: a -> Int

        readVkPMultisampleState :: Ptr a -> IO (VkPMultisampleStateMType a)

        writeVkPMultisampleState ::
                                 Ptr a -> VkPMultisampleStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pMultisampleState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPMultisampleState a

instance {-# OVERLAPPING #-}
         HasVkPMultisampleState VkGraphicsPipelineCreateInfo where
        type VkPMultisampleStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineMultisampleStateCreateInfo

        {-# NOINLINE vkPMultisampleState #-}
        vkPMultisampleState x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, pMultisampleState})

        {-# INLINE vkPMultisampleStateByteOffset #-}
        vkPMultisampleStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pMultisampleState}

        {-# INLINE readVkPMultisampleState #-}
        readVkPMultisampleState p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pMultisampleState}

        {-# INLINE writeVkPMultisampleState #-}
        writeVkPMultisampleState p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pMultisampleState}

class HasVkPDepthStencilState a where
        type VkPDepthStencilStateMType a :: *

        vkPDepthStencilState :: a -> VkPDepthStencilStateMType a

        vkPDepthStencilStateByteOffset :: a -> Int

        readVkPDepthStencilState ::
                                 Ptr a -> IO (VkPDepthStencilStateMType a)

        writeVkPDepthStencilState ::
                                  Ptr a -> VkPDepthStencilStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pDepthStencilState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPDepthStencilState a

instance {-# OVERLAPPING #-}
         HasVkPDepthStencilState VkGraphicsPipelineCreateInfo where
        type VkPDepthStencilStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineDepthStencilStateCreateInfo

        {-# NOINLINE vkPDepthStencilState #-}
        vkPDepthStencilState x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, pDepthStencilState})

        {-# INLINE vkPDepthStencilStateByteOffset #-}
        vkPDepthStencilStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pDepthStencilState}

        {-# INLINE readVkPDepthStencilState #-}
        readVkPDepthStencilState p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pDepthStencilState}

        {-# INLINE writeVkPDepthStencilState #-}
        writeVkPDepthStencilState p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pDepthStencilState}

class HasVkPColorBlendState a where
        type VkPColorBlendStateMType a :: *

        vkPColorBlendState :: a -> VkPColorBlendStateMType a

        vkPColorBlendStateByteOffset :: a -> Int

        readVkPColorBlendState :: Ptr a -> IO (VkPColorBlendStateMType a)

        writeVkPColorBlendState ::
                                Ptr a -> VkPColorBlendStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pColorBlendState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPColorBlendState a

instance {-# OVERLAPPING #-}
         HasVkPColorBlendState VkGraphicsPipelineCreateInfo where
        type VkPColorBlendStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineColorBlendStateCreateInfo

        {-# NOINLINE vkPColorBlendState #-}
        vkPColorBlendState x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, pColorBlendState})

        {-# INLINE vkPColorBlendStateByteOffset #-}
        vkPColorBlendStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pColorBlendState}

        {-# INLINE readVkPColorBlendState #-}
        readVkPColorBlendState p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pColorBlendState}

        {-# INLINE writeVkPColorBlendState #-}
        writeVkPColorBlendState p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pColorBlendState}

class HasVkPDynamicState a where
        type VkPDynamicStateMType a :: *

        vkPDynamicState :: a -> VkPDynamicStateMType a

        vkPDynamicStateByteOffset :: a -> Int

        readVkPDynamicState :: Ptr a -> IO (VkPDynamicStateMType a)

        writeVkPDynamicState :: Ptr a -> VkPDynamicStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pDynamicState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPDynamicState a

instance {-# OVERLAPPING #-}
         HasVkPDynamicState VkGraphicsPipelineCreateInfo where
        type VkPDynamicStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineDynamicStateCreateInfo

        {-# NOINLINE vkPDynamicState #-}
        vkPDynamicState x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, pDynamicState})

        {-# INLINE vkPDynamicStateByteOffset #-}
        vkPDynamicStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pDynamicState}

        {-# INLINE readVkPDynamicState #-}
        readVkPDynamicState p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pDynamicState}

        {-# INLINE writeVkPDynamicState #-}
        writeVkPDynamicState p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, pDynamicState}

instance {-# OVERLAPPING #-}
         HasVkLayout VkGraphicsPipelineCreateInfo where
        type VkLayoutMType VkGraphicsPipelineCreateInfo = VkPipelineLayout

        {-# NOINLINE vkLayout #-}
        vkLayout x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, layout})

        {-# INLINE vkLayoutByteOffset #-}
        vkLayoutByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, layout}

        {-# INLINE readVkLayout #-}
        readVkLayout p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, layout}

        {-# INLINE writeVkLayout #-}
        writeVkLayout p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, layout}

class HasVkRenderPass a where
        type VkRenderPassMType a :: *

        vkRenderPass :: a -> VkRenderPassMType a

        vkRenderPassByteOffset :: a -> Int

        readVkRenderPass :: Ptr a -> IO (VkRenderPassMType a)

        writeVkRenderPass :: Ptr a -> VkRenderPassMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'renderPass'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRenderPass a

instance {-# OVERLAPPING #-}
         HasVkRenderPass VkGraphicsPipelineCreateInfo where
        type VkRenderPassMType VkGraphicsPipelineCreateInfo = VkRenderPass

        {-# NOINLINE vkRenderPass #-}
        vkRenderPass x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, renderPass})

        {-# INLINE vkRenderPassByteOffset #-}
        vkRenderPassByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, renderPass}

        {-# INLINE readVkRenderPass #-}
        readVkRenderPass p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, renderPass}

        {-# INLINE writeVkRenderPass #-}
        writeVkRenderPass p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, renderPass}

class HasVkSubpass a where
        type VkSubpassMType a :: *

        vkSubpass :: a -> VkSubpassMType a

        vkSubpassByteOffset :: a -> Int

        readVkSubpass :: Ptr a -> IO (VkSubpassMType a)

        writeVkSubpass :: Ptr a -> VkSubpassMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'subpass'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSubpass a

instance {-# OVERLAPPING #-}
         HasVkSubpass VkGraphicsPipelineCreateInfo where
        type VkSubpassMType VkGraphicsPipelineCreateInfo = Data.Word.Word32

        {-# NOINLINE vkSubpass #-}
        vkSubpass x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, subpass})

        {-# INLINE vkSubpassByteOffset #-}
        vkSubpassByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, subpass}

        {-# INLINE readVkSubpass #-}
        readVkSubpass p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, subpass}

        {-# INLINE writeVkSubpass #-}
        writeVkSubpass p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, subpass}

instance {-# OVERLAPPING #-}
         HasVkBasePipelineHandle VkGraphicsPipelineCreateInfo where
        type VkBasePipelineHandleMType VkGraphicsPipelineCreateInfo =
             VkPipeline

        {-# NOINLINE vkBasePipelineHandle #-}
        vkBasePipelineHandle x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, basePipelineHandle})

        {-# INLINE vkBasePipelineHandleByteOffset #-}
        vkBasePipelineHandleByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, basePipelineHandle}

        {-# INLINE readVkBasePipelineHandle #-}
        readVkBasePipelineHandle p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, basePipelineHandle}

        {-# INLINE writeVkBasePipelineHandle #-}
        writeVkBasePipelineHandle p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, basePipelineHandle}

instance {-# OVERLAPPING #-}
         HasVkBasePipelineIndex VkGraphicsPipelineCreateInfo where
        type VkBasePipelineIndexMType VkGraphicsPipelineCreateInfo =
             Data.Int.Int32

        {-# NOINLINE vkBasePipelineIndex #-}
        vkBasePipelineIndex x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkGraphicsPipelineCreateInfo, basePipelineIndex})

        {-# INLINE vkBasePipelineIndexByteOffset #-}
        vkBasePipelineIndexByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, basePipelineIndex}

        {-# INLINE readVkBasePipelineIndex #-}
        readVkBasePipelineIndex p
          = peekByteOff p
              #{offset VkGraphicsPipelineCreateInfo, basePipelineIndex}

        {-# INLINE writeVkBasePipelineIndex #-}
        writeVkBasePipelineIndex p
          = pokeByteOff p
              #{offset VkGraphicsPipelineCreateInfo, basePipelineIndex}

instance Show VkGraphicsPipelineCreateInfo where
        showsPrec d x
          = showString "VkGraphicsPipelineCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkStageCount = " .
                                  showsPrec d (vkStageCount x) .
                                    showString ", " .
                                      showString "vkPStages = " .
                                        showsPrec d (vkPStages x) .
                                          showString ", " .
                                            showString "vkPVertexInputState = " .
                                              showsPrec d (vkPVertexInputState x) .
                                                showString ", " .
                                                  showString "vkPInputAssemblyState = " .
                                                    showsPrec d (vkPInputAssemblyState x) .
                                                      showString ", " .
                                                        showString "vkPTessellationState = " .
                                                          showsPrec d (vkPTessellationState x) .
                                                            showString ", " .
                                                              showString "vkPViewportState = " .
                                                                showsPrec d (vkPViewportState x) .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkPRasterizationState = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkPRasterizationState x)
                                                                        .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkPMultisampleState = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkPMultisampleState
                                                                                 x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkPDepthStencilState = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkPDepthStencilState
                                                                                       x)
                                                                                    .
                                                                                    showString ", "
                                                                                      .
                                                                                      showString
                                                                                        "vkPColorBlendState = "
                                                                                        .
                                                                                        showsPrec d
                                                                                          (vkPColorBlendState
                                                                                             x)
                                                                                          .
                                                                                          showString
                                                                                            ", "
                                                                                            .
                                                                                            showString
                                                                                              "vkPDynamicState = "
                                                                                              .
                                                                                              showsPrec
                                                                                                d
                                                                                                (vkPDynamicState
                                                                                                   x)
                                                                                                .
                                                                                                showString
                                                                                                  ", "
                                                                                                  .
                                                                                                  showString
                                                                                                    "vkLayout = "
                                                                                                    .
                                                                                                    showsPrec
                                                                                                      d
                                                                                                      (vkLayout
                                                                                                         x)
                                                                                                      .
                                                                                                      showString
                                                                                                        ", "
                                                                                                        .
                                                                                                        showString
                                                                                                          "vkRenderPass = "
                                                                                                          .
                                                                                                          showsPrec
                                                                                                            d
                                                                                                            (vkRenderPass
                                                                                                               x)
                                                                                                            .
                                                                                                            showString
                                                                                                              ", "
                                                                                                              .
                                                                                                              showString
                                                                                                                "vkSubpass = "
                                                                                                                .
                                                                                                                showsPrec
                                                                                                                  d
                                                                                                                  (vkSubpass
                                                                                                                     x)
                                                                                                                  .
                                                                                                                  showString
                                                                                                                    ", "
                                                                                                                    .
                                                                                                                    showString
                                                                                                                      "vkBasePipelineHandle = "
                                                                                                                      .
                                                                                                                      showsPrec
                                                                                                                        d
                                                                                                                        (vkBasePipelineHandle
                                                                                                                           x)
                                                                                                                        .
                                                                                                                        showString
                                                                                                                          ", "
                                                                                                                          .
                                                                                                                          showString
                                                                                                                            "vkBasePipelineIndex = "
                                                                                                                            .
                                                                                                                            showsPrec
                                                                                                                              d
                                                                                                                              (vkBasePipelineIndex
                                                                                                                                 x)
                                                                                                                              .
                                                                                                                              showChar
                                                                                                                                '}'

data VkPipelineCacheCreateInfo = VkPipelineCacheCreateInfo## ByteArray##

instance Eq VkPipelineCacheCreateInfo where
        (VkPipelineCacheCreateInfo## a) == (VkPipelineCacheCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineCacheCreateInfo where
        (VkPipelineCacheCreateInfo## a) `compare`
          (VkPipelineCacheCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineCacheCreateInfo where
        sizeOf ~_ = #{size VkPipelineCacheCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPipelineCacheCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPipelineCacheCreateInfo),
            I## a <- alignment (undefined :: VkPipelineCacheCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineCacheCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineCacheCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineCacheCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineCacheCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkPipelineCacheCreateInfo),
            I## a <- alignment (undefined :: VkPipelineCacheCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPipelineCacheCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPipelineCacheCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkPipelineCacheCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPipelineCacheCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPipelineCacheCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPipelineCacheCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkPipelineCacheCreateInfo
         where
        type VkSTypeMType VkPipelineCacheCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineCacheCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineCacheCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkPipelineCacheCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkPipelineCacheCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkPipelineCacheCreateInfo
         where
        type VkPNextMType VkPipelineCacheCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineCacheCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineCacheCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkPipelineCacheCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkPipelineCacheCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkPipelineCacheCreateInfo
         where
        type VkFlagsMType VkPipelineCacheCreateInfo =
             VkPipelineCacheCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineCacheCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineCacheCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkPipelineCacheCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkPipelineCacheCreateInfo, flags}

class HasVkInitialDataSize a where
        type VkInitialDataSizeMType a :: *

        vkInitialDataSize :: a -> VkInitialDataSizeMType a

        vkInitialDataSizeByteOffset :: a -> Int

        readVkInitialDataSize :: Ptr a -> IO (VkInitialDataSizeMType a)

        writeVkInitialDataSize ::
                               Ptr a -> VkInitialDataSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'initialDataSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkInitialDataSize a

instance {-# OVERLAPPING #-}
         HasVkInitialDataSize VkPipelineCacheCreateInfo where
        type VkInitialDataSizeMType VkPipelineCacheCreateInfo =
             Foreign.C.Types.CSize

        {-# NOINLINE vkInitialDataSize #-}
        vkInitialDataSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineCacheCreateInfo, initialDataSize})

        {-# INLINE vkInitialDataSizeByteOffset #-}
        vkInitialDataSizeByteOffset ~_
          = #{offset VkPipelineCacheCreateInfo, initialDataSize}

        {-# INLINE readVkInitialDataSize #-}
        readVkInitialDataSize p
          = peekByteOff p
              #{offset VkPipelineCacheCreateInfo, initialDataSize}

        {-# INLINE writeVkInitialDataSize #-}
        writeVkInitialDataSize p
          = pokeByteOff p
              #{offset VkPipelineCacheCreateInfo, initialDataSize}

class HasVkPInitialData a where
        type VkPInitialDataMType a :: *

        vkPInitialData :: a -> VkPInitialDataMType a

        vkPInitialDataByteOffset :: a -> Int

        readVkPInitialData :: Ptr a -> IO (VkPInitialDataMType a)

        writeVkPInitialData :: Ptr a -> VkPInitialDataMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pInitialData'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPInitialData a

instance {-# OVERLAPPING #-}
         HasVkPInitialData VkPipelineCacheCreateInfo where
        type VkPInitialDataMType VkPipelineCacheCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPInitialData #-}
        vkPInitialData x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineCacheCreateInfo, pInitialData})

        {-# INLINE vkPInitialDataByteOffset #-}
        vkPInitialDataByteOffset ~_
          = #{offset VkPipelineCacheCreateInfo, pInitialData}

        {-# INLINE readVkPInitialData #-}
        readVkPInitialData p
          = peekByteOff p
              #{offset VkPipelineCacheCreateInfo, pInitialData}

        {-# INLINE writeVkPInitialData #-}
        writeVkPInitialData p
          = pokeByteOff p
              #{offset VkPipelineCacheCreateInfo, pInitialData}

instance Show VkPipelineCacheCreateInfo where
        showsPrec d x
          = showString "VkPipelineCacheCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkInitialDataSize = " .
                                  showsPrec d (vkInitialDataSize x) .
                                    showString ", " .
                                      showString "vkPInitialData = " .
                                        showsPrec d (vkPInitialData x) . showChar '}'

data VkPushConstantRange = VkPushConstantRange## ByteArray##

instance Eq VkPushConstantRange where
        (VkPushConstantRange## a) == (VkPushConstantRange## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPushConstantRange where
        (VkPushConstantRange## a) `compare` (VkPushConstantRange## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPushConstantRange where
        sizeOf ~_ = #{size VkPushConstantRange}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPushConstantRange}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPushConstantRange),
            I## a <- alignment (undefined :: VkPushConstantRange) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPushConstantRange## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPushConstantRange## ba)
          | I## n <- sizeOf (undefined :: VkPushConstantRange) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPushConstantRange where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkPushConstantRange),
            I## a <- alignment (undefined :: VkPushConstantRange) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPushConstantRange##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPushConstantRange## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkPushConstantRange##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPushConstantRange## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPushConstantRange## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPushConstantRange## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkStageFlags VkPushConstantRange
         where
        type VkStageFlagsMType VkPushConstantRange = VkShaderStageFlags

        {-# NOINLINE vkStageFlags #-}
        vkStageFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPushConstantRange, stageFlags})

        {-# INLINE vkStageFlagsByteOffset #-}
        vkStageFlagsByteOffset ~_
          = #{offset VkPushConstantRange, stageFlags}

        {-# INLINE readVkStageFlags #-}
        readVkStageFlags p
          = peekByteOff p #{offset VkPushConstantRange, stageFlags}

        {-# INLINE writeVkStageFlags #-}
        writeVkStageFlags p
          = pokeByteOff p #{offset VkPushConstantRange, stageFlags}

instance {-# OVERLAPPING #-} HasVkOffset VkPushConstantRange where
        type VkOffsetMType VkPushConstantRange = Data.Word.Word32

        {-# NOINLINE vkOffset #-}
        vkOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPushConstantRange, offset})

        {-# INLINE vkOffsetByteOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkPushConstantRange, offset}

        {-# INLINE readVkOffset #-}
        readVkOffset p
          = peekByteOff p #{offset VkPushConstantRange, offset}

        {-# INLINE writeVkOffset #-}
        writeVkOffset p
          = pokeByteOff p #{offset VkPushConstantRange, offset}

instance {-# OVERLAPPING #-} HasVkSize VkPushConstantRange where
        type VkSizeMType VkPushConstantRange = Data.Word.Word32

        {-# NOINLINE vkSize #-}
        vkSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPushConstantRange, size})

        {-# INLINE vkSizeByteOffset #-}
        vkSizeByteOffset ~_ = #{offset VkPushConstantRange, size}

        {-# INLINE readVkSize #-}
        readVkSize p
          = peekByteOff p #{offset VkPushConstantRange, size}

        {-# INLINE writeVkSize #-}
        writeVkSize p
          = pokeByteOff p #{offset VkPushConstantRange, size}

instance Show VkPushConstantRange where
        showsPrec d x
          = showString "VkPushConstantRange {" .
              showString "vkStageFlags = " .
                showsPrec d (vkStageFlags x) .
                  showString ", " .
                    showString "vkOffset = " .
                      showsPrec d (vkOffset x) .
                        showString ", " .
                          showString "vkSize = " . showsPrec d (vkSize x) . showChar '}'

data VkPipelineLayoutCreateInfo = VkPipelineLayoutCreateInfo## ByteArray##

instance Eq VkPipelineLayoutCreateInfo where
        (VkPipelineLayoutCreateInfo## a) == (VkPipelineLayoutCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineLayoutCreateInfo where
        (VkPipelineLayoutCreateInfo## a) `compare`
          (VkPipelineLayoutCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineLayoutCreateInfo where
        sizeOf ~_ = #{size VkPipelineLayoutCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPipelineLayoutCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPipelineLayoutCreateInfo),
            I## a <- alignment (undefined :: VkPipelineLayoutCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineLayoutCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineLayoutCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineLayoutCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineLayoutCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkPipelineLayoutCreateInfo),
            I## a <- alignment (undefined :: VkPipelineLayoutCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPipelineLayoutCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPipelineLayoutCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkPipelineLayoutCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPipelineLayoutCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPipelineLayoutCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPipelineLayoutCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkPipelineLayoutCreateInfo
         where
        type VkSTypeMType VkPipelineLayoutCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineLayoutCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineLayoutCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkPipelineLayoutCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkPipelineLayoutCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkPipelineLayoutCreateInfo
         where
        type VkPNextMType VkPipelineLayoutCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineLayoutCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineLayoutCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkPipelineLayoutCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkPipelineLayoutCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkPipelineLayoutCreateInfo
         where
        type VkFlagsMType VkPipelineLayoutCreateInfo =
             VkPipelineLayoutCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineLayoutCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineLayoutCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p
              #{offset VkPipelineLayoutCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p
              #{offset VkPipelineLayoutCreateInfo, flags}

class HasVkSetLayoutCount a where
        type VkSetLayoutCountMType a :: *

        vkSetLayoutCount :: a -> VkSetLayoutCountMType a

        vkSetLayoutCountByteOffset :: a -> Int

        readVkSetLayoutCount :: Ptr a -> IO (VkSetLayoutCountMType a)

        writeVkSetLayoutCount :: Ptr a -> VkSetLayoutCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'setLayoutCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSetLayoutCount a

instance {-# OVERLAPPING #-}
         HasVkSetLayoutCount VkPipelineLayoutCreateInfo where
        type VkSetLayoutCountMType VkPipelineLayoutCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkSetLayoutCount #-}
        vkSetLayoutCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineLayoutCreateInfo, setLayoutCount})

        {-# INLINE vkSetLayoutCountByteOffset #-}
        vkSetLayoutCountByteOffset ~_
          = #{offset VkPipelineLayoutCreateInfo, setLayoutCount}

        {-# INLINE readVkSetLayoutCount #-}
        readVkSetLayoutCount p
          = peekByteOff p
              #{offset VkPipelineLayoutCreateInfo, setLayoutCount}

        {-# INLINE writeVkSetLayoutCount #-}
        writeVkSetLayoutCount p
          = pokeByteOff p
              #{offset VkPipelineLayoutCreateInfo, setLayoutCount}

instance {-# OVERLAPPING #-}
         HasVkPSetLayouts VkPipelineLayoutCreateInfo where
        type VkPSetLayoutsMType VkPipelineLayoutCreateInfo =
             Foreign.Ptr.Ptr VkDescriptorSetLayout

        {-# NOINLINE vkPSetLayouts #-}
        vkPSetLayouts x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineLayoutCreateInfo, pSetLayouts})

        {-# INLINE vkPSetLayoutsByteOffset #-}
        vkPSetLayoutsByteOffset ~_
          = #{offset VkPipelineLayoutCreateInfo, pSetLayouts}

        {-# INLINE readVkPSetLayouts #-}
        readVkPSetLayouts p
          = peekByteOff p
              #{offset VkPipelineLayoutCreateInfo, pSetLayouts}

        {-# INLINE writeVkPSetLayouts #-}
        writeVkPSetLayouts p
          = pokeByteOff p
              #{offset VkPipelineLayoutCreateInfo, pSetLayouts}

class HasVkPushConstantRangeCount a where
        type VkPushConstantRangeCountMType a :: *

        vkPushConstantRangeCount :: a -> VkPushConstantRangeCountMType a

        vkPushConstantRangeCountByteOffset :: a -> Int

        readVkPushConstantRangeCount ::
                                     Ptr a -> IO (VkPushConstantRangeCountMType a)

        writeVkPushConstantRangeCount ::
                                      Ptr a -> VkPushConstantRangeCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pushConstantRangeCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPushConstantRangeCount a

instance {-# OVERLAPPING #-}
         HasVkPushConstantRangeCount VkPipelineLayoutCreateInfo where
        type VkPushConstantRangeCountMType VkPipelineLayoutCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkPushConstantRangeCount #-}
        vkPushConstantRangeCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineLayoutCreateInfo, pushConstantRangeCount})

        {-# INLINE vkPushConstantRangeCountByteOffset #-}
        vkPushConstantRangeCountByteOffset ~_
          = #{offset VkPipelineLayoutCreateInfo, pushConstantRangeCount}

        {-# INLINE readVkPushConstantRangeCount #-}
        readVkPushConstantRangeCount p
          = peekByteOff p
              #{offset VkPipelineLayoutCreateInfo, pushConstantRangeCount}

        {-# INLINE writeVkPushConstantRangeCount #-}
        writeVkPushConstantRangeCount p
          = pokeByteOff p
              #{offset VkPipelineLayoutCreateInfo, pushConstantRangeCount}

class HasVkPPushConstantRanges a where
        type VkPPushConstantRangesMType a :: *

        vkPPushConstantRanges :: a -> VkPPushConstantRangesMType a

        vkPPushConstantRangesByteOffset :: a -> Int

        readVkPPushConstantRanges ::
                                  Ptr a -> IO (VkPPushConstantRangesMType a)

        writeVkPPushConstantRanges ::
                                   Ptr a -> VkPPushConstantRangesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pPushConstantRanges'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPPushConstantRanges a

instance {-# OVERLAPPING #-}
         HasVkPPushConstantRanges VkPipelineLayoutCreateInfo where
        type VkPPushConstantRangesMType VkPipelineLayoutCreateInfo =
             Foreign.Ptr.Ptr VkPushConstantRange

        {-# NOINLINE vkPPushConstantRanges #-}
        vkPPushConstantRanges x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPipelineLayoutCreateInfo, pPushConstantRanges})

        {-# INLINE vkPPushConstantRangesByteOffset #-}
        vkPPushConstantRangesByteOffset ~_
          = #{offset VkPipelineLayoutCreateInfo, pPushConstantRanges}

        {-# INLINE readVkPPushConstantRanges #-}
        readVkPPushConstantRanges p
          = peekByteOff p
              #{offset VkPipelineLayoutCreateInfo, pPushConstantRanges}

        {-# INLINE writeVkPPushConstantRanges #-}
        writeVkPPushConstantRanges p
          = pokeByteOff p
              #{offset VkPipelineLayoutCreateInfo, pPushConstantRanges}

instance Show VkPipelineLayoutCreateInfo where
        showsPrec d x
          = showString "VkPipelineLayoutCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkSetLayoutCount = " .
                                  showsPrec d (vkSetLayoutCount x) .
                                    showString ", " .
                                      showString "vkPSetLayouts = " .
                                        showsPrec d (vkPSetLayouts x) .
                                          showString ", " .
                                            showString "vkPushConstantRangeCount = " .
                                              showsPrec d (vkPushConstantRangeCount x) .
                                                showString ", " .
                                                  showString "vkPPushConstantRanges = " .
                                                    showsPrec d (vkPPushConstantRanges x) .
                                                      showChar '}'

data VkSamplerCreateInfo = VkSamplerCreateInfo## ByteArray##

instance Eq VkSamplerCreateInfo where
        (VkSamplerCreateInfo## a) == (VkSamplerCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSamplerCreateInfo where
        (VkSamplerCreateInfo## a) `compare` (VkSamplerCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSamplerCreateInfo where
        sizeOf ~_ = #{size VkSamplerCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSamplerCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSamplerCreateInfo),
            I## a <- alignment (undefined :: VkSamplerCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSamplerCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSamplerCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkSamplerCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSamplerCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSamplerCreateInfo),
            I## a <- alignment (undefined :: VkSamplerCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSamplerCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSamplerCreateInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSamplerCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSamplerCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSamplerCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSamplerCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkSamplerCreateInfo where
        type VkSTypeMType VkSamplerCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkSamplerCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkSamplerCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkSamplerCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkSamplerCreateInfo where
        type VkPNextMType VkSamplerCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkSamplerCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkSamplerCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkSamplerCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkSamplerCreateInfo where
        type VkFlagsMType VkSamplerCreateInfo = VkSamplerCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkSamplerCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkSamplerCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkSamplerCreateInfo, flags}

class HasVkMagFilter a where
        type VkMagFilterMType a :: *

        vkMagFilter :: a -> VkMagFilterMType a

        vkMagFilterByteOffset :: a -> Int

        readVkMagFilter :: Ptr a -> IO (VkMagFilterMType a)

        writeVkMagFilter :: Ptr a -> VkMagFilterMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'magFilter'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMagFilter a

instance {-# OVERLAPPING #-} HasVkMagFilter VkSamplerCreateInfo
         where
        type VkMagFilterMType VkSamplerCreateInfo = VkFilter

        {-# NOINLINE vkMagFilter #-}
        vkMagFilter x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, magFilter})

        {-# INLINE vkMagFilterByteOffset #-}
        vkMagFilterByteOffset ~_
          = #{offset VkSamplerCreateInfo, magFilter}

        {-# INLINE readVkMagFilter #-}
        readVkMagFilter p
          = peekByteOff p #{offset VkSamplerCreateInfo, magFilter}

        {-# INLINE writeVkMagFilter #-}
        writeVkMagFilter p
          = pokeByteOff p #{offset VkSamplerCreateInfo, magFilter}

class HasVkMinFilter a where
        type VkMinFilterMType a :: *

        vkMinFilter :: a -> VkMinFilterMType a

        vkMinFilterByteOffset :: a -> Int

        readVkMinFilter :: Ptr a -> IO (VkMinFilterMType a)

        writeVkMinFilter :: Ptr a -> VkMinFilterMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minFilter'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinFilter a

instance {-# OVERLAPPING #-} HasVkMinFilter VkSamplerCreateInfo
         where
        type VkMinFilterMType VkSamplerCreateInfo = VkFilter

        {-# NOINLINE vkMinFilter #-}
        vkMinFilter x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, minFilter})

        {-# INLINE vkMinFilterByteOffset #-}
        vkMinFilterByteOffset ~_
          = #{offset VkSamplerCreateInfo, minFilter}

        {-# INLINE readVkMinFilter #-}
        readVkMinFilter p
          = peekByteOff p #{offset VkSamplerCreateInfo, minFilter}

        {-# INLINE writeVkMinFilter #-}
        writeVkMinFilter p
          = pokeByteOff p #{offset VkSamplerCreateInfo, minFilter}

class HasVkMipmapMode a where
        type VkMipmapModeMType a :: *

        vkMipmapMode :: a -> VkMipmapModeMType a

        vkMipmapModeByteOffset :: a -> Int

        readVkMipmapMode :: Ptr a -> IO (VkMipmapModeMType a)

        writeVkMipmapMode :: Ptr a -> VkMipmapModeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'mipmapMode'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMipmapMode a

instance {-# OVERLAPPING #-} HasVkMipmapMode VkSamplerCreateInfo
         where
        type VkMipmapModeMType VkSamplerCreateInfo = VkSamplerMipmapMode

        {-# NOINLINE vkMipmapMode #-}
        vkMipmapMode x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, mipmapMode})

        {-# INLINE vkMipmapModeByteOffset #-}
        vkMipmapModeByteOffset ~_
          = #{offset VkSamplerCreateInfo, mipmapMode}

        {-# INLINE readVkMipmapMode #-}
        readVkMipmapMode p
          = peekByteOff p #{offset VkSamplerCreateInfo, mipmapMode}

        {-# INLINE writeVkMipmapMode #-}
        writeVkMipmapMode p
          = pokeByteOff p #{offset VkSamplerCreateInfo, mipmapMode}

class HasVkAddressModeU a where
        type VkAddressModeUMType a :: *

        vkAddressModeU :: a -> VkAddressModeUMType a

        vkAddressModeUByteOffset :: a -> Int

        readVkAddressModeU :: Ptr a -> IO (VkAddressModeUMType a)

        writeVkAddressModeU :: Ptr a -> VkAddressModeUMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'addressModeU'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAddressModeU a

instance {-# OVERLAPPING #-} HasVkAddressModeU VkSamplerCreateInfo
         where
        type VkAddressModeUMType VkSamplerCreateInfo = VkSamplerAddressMode

        {-# NOINLINE vkAddressModeU #-}
        vkAddressModeU x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, addressModeU})

        {-# INLINE vkAddressModeUByteOffset #-}
        vkAddressModeUByteOffset ~_
          = #{offset VkSamplerCreateInfo, addressModeU}

        {-# INLINE readVkAddressModeU #-}
        readVkAddressModeU p
          = peekByteOff p
              #{offset VkSamplerCreateInfo, addressModeU}

        {-# INLINE writeVkAddressModeU #-}
        writeVkAddressModeU p
          = pokeByteOff p
              #{offset VkSamplerCreateInfo, addressModeU}

class HasVkAddressModeV a where
        type VkAddressModeVMType a :: *

        vkAddressModeV :: a -> VkAddressModeVMType a

        vkAddressModeVByteOffset :: a -> Int

        readVkAddressModeV :: Ptr a -> IO (VkAddressModeVMType a)

        writeVkAddressModeV :: Ptr a -> VkAddressModeVMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'addressModeV'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAddressModeV a

instance {-# OVERLAPPING #-} HasVkAddressModeV VkSamplerCreateInfo
         where
        type VkAddressModeVMType VkSamplerCreateInfo = VkSamplerAddressMode

        {-# NOINLINE vkAddressModeV #-}
        vkAddressModeV x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, addressModeV})

        {-# INLINE vkAddressModeVByteOffset #-}
        vkAddressModeVByteOffset ~_
          = #{offset VkSamplerCreateInfo, addressModeV}

        {-# INLINE readVkAddressModeV #-}
        readVkAddressModeV p
          = peekByteOff p
              #{offset VkSamplerCreateInfo, addressModeV}

        {-# INLINE writeVkAddressModeV #-}
        writeVkAddressModeV p
          = pokeByteOff p
              #{offset VkSamplerCreateInfo, addressModeV}

class HasVkAddressModeW a where
        type VkAddressModeWMType a :: *

        vkAddressModeW :: a -> VkAddressModeWMType a

        vkAddressModeWByteOffset :: a -> Int

        readVkAddressModeW :: Ptr a -> IO (VkAddressModeWMType a)

        writeVkAddressModeW :: Ptr a -> VkAddressModeWMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'addressModeW'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAddressModeW a

instance {-# OVERLAPPING #-} HasVkAddressModeW VkSamplerCreateInfo
         where
        type VkAddressModeWMType VkSamplerCreateInfo = VkSamplerAddressMode

        {-# NOINLINE vkAddressModeW #-}
        vkAddressModeW x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, addressModeW})

        {-# INLINE vkAddressModeWByteOffset #-}
        vkAddressModeWByteOffset ~_
          = #{offset VkSamplerCreateInfo, addressModeW}

        {-# INLINE readVkAddressModeW #-}
        readVkAddressModeW p
          = peekByteOff p
              #{offset VkSamplerCreateInfo, addressModeW}

        {-# INLINE writeVkAddressModeW #-}
        writeVkAddressModeW p
          = pokeByteOff p
              #{offset VkSamplerCreateInfo, addressModeW}

class HasVkMipLodBias a where
        type VkMipLodBiasMType a :: *

        vkMipLodBias :: a -> VkMipLodBiasMType a

        vkMipLodBiasByteOffset :: a -> Int

        readVkMipLodBias :: Ptr a -> IO (VkMipLodBiasMType a)

        writeVkMipLodBias :: Ptr a -> VkMipLodBiasMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'mipLodBias'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMipLodBias a

instance {-# OVERLAPPING #-} HasVkMipLodBias VkSamplerCreateInfo
         where
        type VkMipLodBiasMType VkSamplerCreateInfo = Foreign.C.Types.CFloat

        {-# NOINLINE vkMipLodBias #-}
        vkMipLodBias x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, mipLodBias})

        {-# INLINE vkMipLodBiasByteOffset #-}
        vkMipLodBiasByteOffset ~_
          = #{offset VkSamplerCreateInfo, mipLodBias}

        {-# INLINE readVkMipLodBias #-}
        readVkMipLodBias p
          = peekByteOff p #{offset VkSamplerCreateInfo, mipLodBias}

        {-# INLINE writeVkMipLodBias #-}
        writeVkMipLodBias p
          = pokeByteOff p #{offset VkSamplerCreateInfo, mipLodBias}

class HasVkAnisotropyEnable a where
        type VkAnisotropyEnableMType a :: *

        vkAnisotropyEnable :: a -> VkAnisotropyEnableMType a

        vkAnisotropyEnableByteOffset :: a -> Int

        readVkAnisotropyEnable :: Ptr a -> IO (VkAnisotropyEnableMType a)

        writeVkAnisotropyEnable ::
                                Ptr a -> VkAnisotropyEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'anisotropyEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAnisotropyEnable a

instance {-# OVERLAPPING #-}
         HasVkAnisotropyEnable VkSamplerCreateInfo where
        type VkAnisotropyEnableMType VkSamplerCreateInfo = VkBool32

        {-# NOINLINE vkAnisotropyEnable #-}
        vkAnisotropyEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, anisotropyEnable})

        {-# INLINE vkAnisotropyEnableByteOffset #-}
        vkAnisotropyEnableByteOffset ~_
          = #{offset VkSamplerCreateInfo, anisotropyEnable}

        {-# INLINE readVkAnisotropyEnable #-}
        readVkAnisotropyEnable p
          = peekByteOff p
              #{offset VkSamplerCreateInfo, anisotropyEnable}

        {-# INLINE writeVkAnisotropyEnable #-}
        writeVkAnisotropyEnable p
          = pokeByteOff p
              #{offset VkSamplerCreateInfo, anisotropyEnable}

class HasVkMaxAnisotropy a where
        type VkMaxAnisotropyMType a :: *

        vkMaxAnisotropy :: a -> VkMaxAnisotropyMType a

        vkMaxAnisotropyByteOffset :: a -> Int

        readVkMaxAnisotropy :: Ptr a -> IO (VkMaxAnisotropyMType a)

        writeVkMaxAnisotropy :: Ptr a -> VkMaxAnisotropyMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxAnisotropy'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxAnisotropy a

instance {-# OVERLAPPING #-} HasVkMaxAnisotropy VkSamplerCreateInfo
         where
        type VkMaxAnisotropyMType VkSamplerCreateInfo =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkMaxAnisotropy #-}
        vkMaxAnisotropy x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, maxAnisotropy})

        {-# INLINE vkMaxAnisotropyByteOffset #-}
        vkMaxAnisotropyByteOffset ~_
          = #{offset VkSamplerCreateInfo, maxAnisotropy}

        {-# INLINE readVkMaxAnisotropy #-}
        readVkMaxAnisotropy p
          = peekByteOff p
              #{offset VkSamplerCreateInfo, maxAnisotropy}

        {-# INLINE writeVkMaxAnisotropy #-}
        writeVkMaxAnisotropy p
          = pokeByteOff p
              #{offset VkSamplerCreateInfo, maxAnisotropy}

class HasVkCompareEnable a where
        type VkCompareEnableMType a :: *

        vkCompareEnable :: a -> VkCompareEnableMType a

        vkCompareEnableByteOffset :: a -> Int

        readVkCompareEnable :: Ptr a -> IO (VkCompareEnableMType a)

        writeVkCompareEnable :: Ptr a -> VkCompareEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'compareEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCompareEnable a

instance {-# OVERLAPPING #-} HasVkCompareEnable VkSamplerCreateInfo
         where
        type VkCompareEnableMType VkSamplerCreateInfo = VkBool32

        {-# NOINLINE vkCompareEnable #-}
        vkCompareEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, compareEnable})

        {-# INLINE vkCompareEnableByteOffset #-}
        vkCompareEnableByteOffset ~_
          = #{offset VkSamplerCreateInfo, compareEnable}

        {-# INLINE readVkCompareEnable #-}
        readVkCompareEnable p
          = peekByteOff p
              #{offset VkSamplerCreateInfo, compareEnable}

        {-# INLINE writeVkCompareEnable #-}
        writeVkCompareEnable p
          = pokeByteOff p
              #{offset VkSamplerCreateInfo, compareEnable}

instance {-# OVERLAPPING #-} HasVkCompareOp VkSamplerCreateInfo
         where
        type VkCompareOpMType VkSamplerCreateInfo = VkCompareOp

        {-# NOINLINE vkCompareOp #-}
        vkCompareOp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, compareOp})

        {-# INLINE vkCompareOpByteOffset #-}
        vkCompareOpByteOffset ~_
          = #{offset VkSamplerCreateInfo, compareOp}

        {-# INLINE readVkCompareOp #-}
        readVkCompareOp p
          = peekByteOff p #{offset VkSamplerCreateInfo, compareOp}

        {-# INLINE writeVkCompareOp #-}
        writeVkCompareOp p
          = pokeByteOff p #{offset VkSamplerCreateInfo, compareOp}

class HasVkMinLod a where
        type VkMinLodMType a :: *

        vkMinLod :: a -> VkMinLodMType a

        vkMinLodByteOffset :: a -> Int

        readVkMinLod :: Ptr a -> IO (VkMinLodMType a)

        writeVkMinLod :: Ptr a -> VkMinLodMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minLod'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinLod a

instance {-# OVERLAPPING #-} HasVkMinLod VkSamplerCreateInfo where
        type VkMinLodMType VkSamplerCreateInfo = Foreign.C.Types.CFloat

        {-# NOINLINE vkMinLod #-}
        vkMinLod x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, minLod})

        {-# INLINE vkMinLodByteOffset #-}
        vkMinLodByteOffset ~_
          = #{offset VkSamplerCreateInfo, minLod}

        {-# INLINE readVkMinLod #-}
        readVkMinLod p
          = peekByteOff p #{offset VkSamplerCreateInfo, minLod}

        {-# INLINE writeVkMinLod #-}
        writeVkMinLod p
          = pokeByteOff p #{offset VkSamplerCreateInfo, minLod}

class HasVkMaxLod a where
        type VkMaxLodMType a :: *

        vkMaxLod :: a -> VkMaxLodMType a

        vkMaxLodByteOffset :: a -> Int

        readVkMaxLod :: Ptr a -> IO (VkMaxLodMType a)

        writeVkMaxLod :: Ptr a -> VkMaxLodMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxLod'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxLod a

instance {-# OVERLAPPING #-} HasVkMaxLod VkSamplerCreateInfo where
        type VkMaxLodMType VkSamplerCreateInfo = Foreign.C.Types.CFloat

        {-# NOINLINE vkMaxLod #-}
        vkMaxLod x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, maxLod})

        {-# INLINE vkMaxLodByteOffset #-}
        vkMaxLodByteOffset ~_
          = #{offset VkSamplerCreateInfo, maxLod}

        {-# INLINE readVkMaxLod #-}
        readVkMaxLod p
          = peekByteOff p #{offset VkSamplerCreateInfo, maxLod}

        {-# INLINE writeVkMaxLod #-}
        writeVkMaxLod p
          = pokeByteOff p #{offset VkSamplerCreateInfo, maxLod}

class HasVkBorderColor a where
        type VkBorderColorMType a :: *

        vkBorderColor :: a -> VkBorderColorMType a

        vkBorderColorByteOffset :: a -> Int

        readVkBorderColor :: Ptr a -> IO (VkBorderColorMType a)

        writeVkBorderColor :: Ptr a -> VkBorderColorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'borderColor'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBorderColor a

instance {-# OVERLAPPING #-} HasVkBorderColor VkSamplerCreateInfo
         where
        type VkBorderColorMType VkSamplerCreateInfo = VkBorderColor

        {-# NOINLINE vkBorderColor #-}
        vkBorderColor x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, borderColor})

        {-# INLINE vkBorderColorByteOffset #-}
        vkBorderColorByteOffset ~_
          = #{offset VkSamplerCreateInfo, borderColor}

        {-# INLINE readVkBorderColor #-}
        readVkBorderColor p
          = peekByteOff p #{offset VkSamplerCreateInfo, borderColor}

        {-# INLINE writeVkBorderColor #-}
        writeVkBorderColor p
          = pokeByteOff p #{offset VkSamplerCreateInfo, borderColor}

class HasVkUnnormalizedCoordinates a where
        type VkUnnormalizedCoordinatesMType a :: *

        vkUnnormalizedCoordinates :: a -> VkUnnormalizedCoordinatesMType a

        vkUnnormalizedCoordinatesByteOffset :: a -> Int

        readVkUnnormalizedCoordinates ::
                                      Ptr a -> IO (VkUnnormalizedCoordinatesMType a)

        writeVkUnnormalizedCoordinates ::
                                       Ptr a -> VkUnnormalizedCoordinatesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'unnormalizedCoordinates'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkUnnormalizedCoordinates a

instance {-# OVERLAPPING #-}
         HasVkUnnormalizedCoordinates VkSamplerCreateInfo where
        type VkUnnormalizedCoordinatesMType VkSamplerCreateInfo = VkBool32

        {-# NOINLINE vkUnnormalizedCoordinates #-}
        vkUnnormalizedCoordinates x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSamplerCreateInfo, unnormalizedCoordinates})

        {-# INLINE vkUnnormalizedCoordinatesByteOffset #-}
        vkUnnormalizedCoordinatesByteOffset ~_
          = #{offset VkSamplerCreateInfo, unnormalizedCoordinates}

        {-# INLINE readVkUnnormalizedCoordinates #-}
        readVkUnnormalizedCoordinates p
          = peekByteOff p
              #{offset VkSamplerCreateInfo, unnormalizedCoordinates}

        {-# INLINE writeVkUnnormalizedCoordinates #-}
        writeVkUnnormalizedCoordinates p
          = pokeByteOff p
              #{offset VkSamplerCreateInfo, unnormalizedCoordinates}

instance Show VkSamplerCreateInfo where
        showsPrec d x
          = showString "VkSamplerCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkMagFilter = " .
                                  showsPrec d (vkMagFilter x) .
                                    showString ", " .
                                      showString "vkMinFilter = " .
                                        showsPrec d (vkMinFilter x) .
                                          showString ", " .
                                            showString "vkMipmapMode = " .
                                              showsPrec d (vkMipmapMode x) .
                                                showString ", " .
                                                  showString "vkAddressModeU = " .
                                                    showsPrec d (vkAddressModeU x) .
                                                      showString ", " .
                                                        showString "vkAddressModeV = " .
                                                          showsPrec d (vkAddressModeV x) .
                                                            showString ", " .
                                                              showString "vkAddressModeW = " .
                                                                showsPrec d (vkAddressModeW x) .
                                                                  showString ", " .
                                                                    showString "vkMipLodBias = " .
                                                                      showsPrec d (vkMipLodBias x) .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkAnisotropyEnable = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkAnisotropyEnable x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkMaxAnisotropy = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkMaxAnisotropy
                                                                                       x)
                                                                                    .
                                                                                    showString ", "
                                                                                      .
                                                                                      showString
                                                                                        "vkCompareEnable = "
                                                                                        .
                                                                                        showsPrec d
                                                                                          (vkCompareEnable
                                                                                             x)
                                                                                          .
                                                                                          showString
                                                                                            ", "
                                                                                            .
                                                                                            showString
                                                                                              "vkCompareOp = "
                                                                                              .
                                                                                              showsPrec
                                                                                                d
                                                                                                (vkCompareOp
                                                                                                   x)
                                                                                                .
                                                                                                showString
                                                                                                  ", "
                                                                                                  .
                                                                                                  showString
                                                                                                    "vkMinLod = "
                                                                                                    .
                                                                                                    showsPrec
                                                                                                      d
                                                                                                      (vkMinLod
                                                                                                         x)
                                                                                                      .
                                                                                                      showString
                                                                                                        ", "
                                                                                                        .
                                                                                                        showString
                                                                                                          "vkMaxLod = "
                                                                                                          .
                                                                                                          showsPrec
                                                                                                            d
                                                                                                            (vkMaxLod
                                                                                                               x)
                                                                                                            .
                                                                                                            showString
                                                                                                              ", "
                                                                                                              .
                                                                                                              showString
                                                                                                                "vkBorderColor = "
                                                                                                                .
                                                                                                                showsPrec
                                                                                                                  d
                                                                                                                  (vkBorderColor
                                                                                                                     x)
                                                                                                                  .
                                                                                                                  showString
                                                                                                                    ", "
                                                                                                                    .
                                                                                                                    showString
                                                                                                                      "vkUnnormalizedCoordinates = "
                                                                                                                      .
                                                                                                                      showsPrec
                                                                                                                        d
                                                                                                                        (vkUnnormalizedCoordinates
                                                                                                                           x)
                                                                                                                        .
                                                                                                                        showChar
                                                                                                                          '}'

data VkCommandPoolCreateInfo = VkCommandPoolCreateInfo## ByteArray##

instance Eq VkCommandPoolCreateInfo where
        (VkCommandPoolCreateInfo## a) == (VkCommandPoolCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkCommandPoolCreateInfo where
        (VkCommandPoolCreateInfo## a) `compare` (VkCommandPoolCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkCommandPoolCreateInfo where
        sizeOf ~_ = #{size VkCommandPoolCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkCommandPoolCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkCommandPoolCreateInfo),
            I## a <- alignment (undefined :: VkCommandPoolCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkCommandPoolCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkCommandPoolCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkCommandPoolCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkCommandPoolCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkCommandPoolCreateInfo),
            I## a <- alignment (undefined :: VkCommandPoolCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkCommandPoolCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkCommandPoolCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkCommandPoolCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkCommandPoolCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkCommandPoolCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkCommandPoolCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkCommandPoolCreateInfo
         where
        type VkSTypeMType VkCommandPoolCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandPoolCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkCommandPoolCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkCommandPoolCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkCommandPoolCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkCommandPoolCreateInfo
         where
        type VkPNextMType VkCommandPoolCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandPoolCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkCommandPoolCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkCommandPoolCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkCommandPoolCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkCommandPoolCreateInfo
         where
        type VkFlagsMType VkCommandPoolCreateInfo =
             VkCommandPoolCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandPoolCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkCommandPoolCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkCommandPoolCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkCommandPoolCreateInfo, flags}

instance {-# OVERLAPPING #-}
         HasVkQueueFamilyIndex VkCommandPoolCreateInfo where
        type VkQueueFamilyIndexMType VkCommandPoolCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkQueueFamilyIndex #-}
        vkQueueFamilyIndex x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandPoolCreateInfo, queueFamilyIndex})

        {-# INLINE vkQueueFamilyIndexByteOffset #-}
        vkQueueFamilyIndexByteOffset ~_
          = #{offset VkCommandPoolCreateInfo, queueFamilyIndex}

        {-# INLINE readVkQueueFamilyIndex #-}
        readVkQueueFamilyIndex p
          = peekByteOff p
              #{offset VkCommandPoolCreateInfo, queueFamilyIndex}

        {-# INLINE writeVkQueueFamilyIndex #-}
        writeVkQueueFamilyIndex p
          = pokeByteOff p
              #{offset VkCommandPoolCreateInfo, queueFamilyIndex}

instance Show VkCommandPoolCreateInfo where
        showsPrec d x
          = showString "VkCommandPoolCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkQueueFamilyIndex = " .
                                  showsPrec d (vkQueueFamilyIndex x) . showChar '}'

data VkCommandBufferAllocateInfo = VkCommandBufferAllocateInfo## ByteArray##

instance Eq VkCommandBufferAllocateInfo where
        (VkCommandBufferAllocateInfo## a) ==
          (VkCommandBufferAllocateInfo## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkCommandBufferAllocateInfo where
        (VkCommandBufferAllocateInfo## a) `compare`
          (VkCommandBufferAllocateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkCommandBufferAllocateInfo where
        sizeOf ~_ = #{size VkCommandBufferAllocateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkCommandBufferAllocateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkCommandBufferAllocateInfo),
            I## a <- alignment (undefined :: VkCommandBufferAllocateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkCommandBufferAllocateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkCommandBufferAllocateInfo## ba)
          | I## n <- sizeOf (undefined :: VkCommandBufferAllocateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkCommandBufferAllocateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkCommandBufferAllocateInfo),
            I## a <- alignment (undefined :: VkCommandBufferAllocateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkCommandBufferAllocateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkCommandBufferAllocateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkCommandBufferAllocateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkCommandBufferAllocateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkCommandBufferAllocateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkCommandBufferAllocateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkCommandBufferAllocateInfo
         where
        type VkSTypeMType VkCommandBufferAllocateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferAllocateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkCommandBufferAllocateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkCommandBufferAllocateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkCommandBufferAllocateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkCommandBufferAllocateInfo
         where
        type VkPNextMType VkCommandBufferAllocateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferAllocateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkCommandBufferAllocateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkCommandBufferAllocateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkCommandBufferAllocateInfo, pNext}

class HasVkCommandPool a where
        type VkCommandPoolMType a :: *

        vkCommandPool :: a -> VkCommandPoolMType a

        vkCommandPoolByteOffset :: a -> Int

        readVkCommandPool :: Ptr a -> IO (VkCommandPoolMType a)

        writeVkCommandPool :: Ptr a -> VkCommandPoolMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'commandPool'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCommandPool a

instance {-# OVERLAPPING #-}
         HasVkCommandPool VkCommandBufferAllocateInfo where
        type VkCommandPoolMType VkCommandBufferAllocateInfo = VkCommandPool

        {-# NOINLINE vkCommandPool #-}
        vkCommandPool x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferAllocateInfo, commandPool})

        {-# INLINE vkCommandPoolByteOffset #-}
        vkCommandPoolByteOffset ~_
          = #{offset VkCommandBufferAllocateInfo, commandPool}

        {-# INLINE readVkCommandPool #-}
        readVkCommandPool p
          = peekByteOff p
              #{offset VkCommandBufferAllocateInfo, commandPool}

        {-# INLINE writeVkCommandPool #-}
        writeVkCommandPool p
          = pokeByteOff p
              #{offset VkCommandBufferAllocateInfo, commandPool}

class HasVkLevel a where
        type VkLevelMType a :: *

        vkLevel :: a -> VkLevelMType a

        vkLevelByteOffset :: a -> Int

        readVkLevel :: Ptr a -> IO (VkLevelMType a)

        writeVkLevel :: Ptr a -> VkLevelMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'level'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLevel a

instance {-# OVERLAPPING #-} HasVkLevel VkCommandBufferAllocateInfo
         where
        type VkLevelMType VkCommandBufferAllocateInfo =
             VkCommandBufferLevel

        {-# NOINLINE vkLevel #-}
        vkLevel x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferAllocateInfo, level})

        {-# INLINE vkLevelByteOffset #-}
        vkLevelByteOffset ~_
          = #{offset VkCommandBufferAllocateInfo, level}

        {-# INLINE readVkLevel #-}
        readVkLevel p
          = peekByteOff p
              #{offset VkCommandBufferAllocateInfo, level}

        {-# INLINE writeVkLevel #-}
        writeVkLevel p
          = pokeByteOff p
              #{offset VkCommandBufferAllocateInfo, level}

class HasVkCommandBufferCount a where
        type VkCommandBufferCountMType a :: *

        vkCommandBufferCount :: a -> VkCommandBufferCountMType a

        vkCommandBufferCountByteOffset :: a -> Int

        readVkCommandBufferCount ::
                                 Ptr a -> IO (VkCommandBufferCountMType a)

        writeVkCommandBufferCount ::
                                  Ptr a -> VkCommandBufferCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'commandBufferCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCommandBufferCount a

instance {-# OVERLAPPING #-}
         HasVkCommandBufferCount VkCommandBufferAllocateInfo where
        type VkCommandBufferCountMType VkCommandBufferAllocateInfo =
             Data.Word.Word32

        {-# NOINLINE vkCommandBufferCount #-}
        vkCommandBufferCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferAllocateInfo, commandBufferCount})

        {-# INLINE vkCommandBufferCountByteOffset #-}
        vkCommandBufferCountByteOffset ~_
          = #{offset VkCommandBufferAllocateInfo, commandBufferCount}

        {-# INLINE readVkCommandBufferCount #-}
        readVkCommandBufferCount p
          = peekByteOff p
              #{offset VkCommandBufferAllocateInfo, commandBufferCount}

        {-# INLINE writeVkCommandBufferCount #-}
        writeVkCommandBufferCount p
          = pokeByteOff p
              #{offset VkCommandBufferAllocateInfo, commandBufferCount}

instance Show VkCommandBufferAllocateInfo where
        showsPrec d x
          = showString "VkCommandBufferAllocateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkCommandPool = " .
                            showsPrec d (vkCommandPool x) .
                              showString ", " .
                                showString "vkLevel = " .
                                  showsPrec d (vkLevel x) .
                                    showString ", " .
                                      showString "vkCommandBufferCount = " .
                                        showsPrec d (vkCommandBufferCount x) . showChar '}'

data VkCommandBufferInheritanceInfo = VkCommandBufferInheritanceInfo## ByteArray##

instance Eq VkCommandBufferInheritanceInfo where
        (VkCommandBufferInheritanceInfo## a) ==
          (VkCommandBufferInheritanceInfo## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkCommandBufferInheritanceInfo where
        (VkCommandBufferInheritanceInfo## a) `compare`
          (VkCommandBufferInheritanceInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkCommandBufferInheritanceInfo where
        sizeOf ~_ = #{size VkCommandBufferInheritanceInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkCommandBufferInheritanceInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkCommandBufferInheritanceInfo),
            I## a <- alignment (undefined :: VkCommandBufferInheritanceInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkCommandBufferInheritanceInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkCommandBufferInheritanceInfo## ba)
          | I## n <- sizeOf (undefined :: VkCommandBufferInheritanceInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkCommandBufferInheritanceInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkCommandBufferInheritanceInfo),
            I## a <- alignment (undefined :: VkCommandBufferInheritanceInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkCommandBufferInheritanceInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkCommandBufferInheritanceInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkCommandBufferInheritanceInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkCommandBufferInheritanceInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkCommandBufferInheritanceInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkCommandBufferInheritanceInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-}
         HasVkSType VkCommandBufferInheritanceInfo where
        type VkSTypeMType VkCommandBufferInheritanceInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferInheritanceInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p
              #{offset VkCommandBufferInheritanceInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p
              #{offset VkCommandBufferInheritanceInfo, sType}

instance {-# OVERLAPPING #-}
         HasVkPNext VkCommandBufferInheritanceInfo where
        type VkPNextMType VkCommandBufferInheritanceInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferInheritanceInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p
              #{offset VkCommandBufferInheritanceInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p
              #{offset VkCommandBufferInheritanceInfo, pNext}

instance {-# OVERLAPPING #-}
         HasVkRenderPass VkCommandBufferInheritanceInfo where
        type VkRenderPassMType VkCommandBufferInheritanceInfo =
             VkRenderPass

        {-# NOINLINE vkRenderPass #-}
        vkRenderPass x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferInheritanceInfo, renderPass})

        {-# INLINE vkRenderPassByteOffset #-}
        vkRenderPassByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, renderPass}

        {-# INLINE readVkRenderPass #-}
        readVkRenderPass p
          = peekByteOff p
              #{offset VkCommandBufferInheritanceInfo, renderPass}

        {-# INLINE writeVkRenderPass #-}
        writeVkRenderPass p
          = pokeByteOff p
              #{offset VkCommandBufferInheritanceInfo, renderPass}

instance {-# OVERLAPPING #-}
         HasVkSubpass VkCommandBufferInheritanceInfo where
        type VkSubpassMType VkCommandBufferInheritanceInfo =
             Data.Word.Word32

        {-# NOINLINE vkSubpass #-}
        vkSubpass x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferInheritanceInfo, subpass})

        {-# INLINE vkSubpassByteOffset #-}
        vkSubpassByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, subpass}

        {-# INLINE readVkSubpass #-}
        readVkSubpass p
          = peekByteOff p
              #{offset VkCommandBufferInheritanceInfo, subpass}

        {-# INLINE writeVkSubpass #-}
        writeVkSubpass p
          = pokeByteOff p
              #{offset VkCommandBufferInheritanceInfo, subpass}

class HasVkFramebuffer a where
        type VkFramebufferMType a :: *

        vkFramebuffer :: a -> VkFramebufferMType a

        vkFramebufferByteOffset :: a -> Int

        readVkFramebuffer :: Ptr a -> IO (VkFramebufferMType a)

        writeVkFramebuffer :: Ptr a -> VkFramebufferMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'framebuffer'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFramebuffer a

instance {-# OVERLAPPING #-}
         HasVkFramebuffer VkCommandBufferInheritanceInfo where
        type VkFramebufferMType VkCommandBufferInheritanceInfo =
             VkFramebuffer

        {-# NOINLINE vkFramebuffer #-}
        vkFramebuffer x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferInheritanceInfo, framebuffer})

        {-# INLINE vkFramebufferByteOffset #-}
        vkFramebufferByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, framebuffer}

        {-# INLINE readVkFramebuffer #-}
        readVkFramebuffer p
          = peekByteOff p
              #{offset VkCommandBufferInheritanceInfo, framebuffer}

        {-# INLINE writeVkFramebuffer #-}
        writeVkFramebuffer p
          = pokeByteOff p
              #{offset VkCommandBufferInheritanceInfo, framebuffer}

class HasVkOcclusionQueryEnable a where
        type VkOcclusionQueryEnableMType a :: *

        vkOcclusionQueryEnable :: a -> VkOcclusionQueryEnableMType a

        vkOcclusionQueryEnableByteOffset :: a -> Int

        readVkOcclusionQueryEnable ::
                                   Ptr a -> IO (VkOcclusionQueryEnableMType a)

        writeVkOcclusionQueryEnable ::
                                    Ptr a -> VkOcclusionQueryEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'occlusionQueryEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkOcclusionQueryEnable a

instance {-# OVERLAPPING #-}
         HasVkOcclusionQueryEnable VkCommandBufferInheritanceInfo where
        type VkOcclusionQueryEnableMType VkCommandBufferInheritanceInfo =
             VkBool32

        {-# NOINLINE vkOcclusionQueryEnable #-}
        vkOcclusionQueryEnable x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferInheritanceInfo, occlusionQueryEnable})

        {-# INLINE vkOcclusionQueryEnableByteOffset #-}
        vkOcclusionQueryEnableByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, occlusionQueryEnable}

        {-# INLINE readVkOcclusionQueryEnable #-}
        readVkOcclusionQueryEnable p
          = peekByteOff p
              #{offset VkCommandBufferInheritanceInfo, occlusionQueryEnable}

        {-# INLINE writeVkOcclusionQueryEnable #-}
        writeVkOcclusionQueryEnable p
          = pokeByteOff p
              #{offset VkCommandBufferInheritanceInfo, occlusionQueryEnable}

class HasVkQueryFlags a where
        type VkQueryFlagsMType a :: *

        vkQueryFlags :: a -> VkQueryFlagsMType a

        vkQueryFlagsByteOffset :: a -> Int

        readVkQueryFlags :: Ptr a -> IO (VkQueryFlagsMType a)

        writeVkQueryFlags :: Ptr a -> VkQueryFlagsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queryFlags'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueryFlags a

instance {-# OVERLAPPING #-}
         HasVkQueryFlags VkCommandBufferInheritanceInfo where
        type VkQueryFlagsMType VkCommandBufferInheritanceInfo =
             VkQueryControlFlags

        {-# NOINLINE vkQueryFlags #-}
        vkQueryFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferInheritanceInfo, queryFlags})

        {-# INLINE vkQueryFlagsByteOffset #-}
        vkQueryFlagsByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, queryFlags}

        {-# INLINE readVkQueryFlags #-}
        readVkQueryFlags p
          = peekByteOff p
              #{offset VkCommandBufferInheritanceInfo, queryFlags}

        {-# INLINE writeVkQueryFlags #-}
        writeVkQueryFlags p
          = pokeByteOff p
              #{offset VkCommandBufferInheritanceInfo, queryFlags}

class HasVkPipelineStatistics a where
        type VkPipelineStatisticsMType a :: *

        vkPipelineStatistics :: a -> VkPipelineStatisticsMType a

        vkPipelineStatisticsByteOffset :: a -> Int

        readVkPipelineStatistics ::
                                 Ptr a -> IO (VkPipelineStatisticsMType a)

        writeVkPipelineStatistics ::
                                  Ptr a -> VkPipelineStatisticsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pipelineStatistics'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPipelineStatistics a

instance {-# OVERLAPPING #-}
         HasVkPipelineStatistics VkCommandBufferInheritanceInfo where
        type VkPipelineStatisticsMType VkCommandBufferInheritanceInfo =
             VkQueryPipelineStatisticFlags

        {-# NOINLINE vkPipelineStatistics #-}
        vkPipelineStatistics x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferInheritanceInfo, pipelineStatistics})

        {-# INLINE vkPipelineStatisticsByteOffset #-}
        vkPipelineStatisticsByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, pipelineStatistics}

        {-# INLINE readVkPipelineStatistics #-}
        readVkPipelineStatistics p
          = peekByteOff p
              #{offset VkCommandBufferInheritanceInfo, pipelineStatistics}

        {-# INLINE writeVkPipelineStatistics #-}
        writeVkPipelineStatistics p
          = pokeByteOff p
              #{offset VkCommandBufferInheritanceInfo, pipelineStatistics}

instance Show VkCommandBufferInheritanceInfo where
        showsPrec d x
          = showString "VkCommandBufferInheritanceInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkRenderPass = " .
                            showsPrec d (vkRenderPass x) .
                              showString ", " .
                                showString "vkSubpass = " .
                                  showsPrec d (vkSubpass x) .
                                    showString ", " .
                                      showString "vkFramebuffer = " .
                                        showsPrec d (vkFramebuffer x) .
                                          showString ", " .
                                            showString "vkOcclusionQueryEnable = " .
                                              showsPrec d (vkOcclusionQueryEnable x) .
                                                showString ", " .
                                                  showString "vkQueryFlags = " .
                                                    showsPrec d (vkQueryFlags x) .
                                                      showString ", " .
                                                        showString "vkPipelineStatistics = " .
                                                          showsPrec d (vkPipelineStatistics x) .
                                                            showChar '}'

data VkCommandBufferBeginInfo = VkCommandBufferBeginInfo## ByteArray##

instance Eq VkCommandBufferBeginInfo where
        (VkCommandBufferBeginInfo## a) == (VkCommandBufferBeginInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkCommandBufferBeginInfo where
        (VkCommandBufferBeginInfo## a) `compare`
          (VkCommandBufferBeginInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkCommandBufferBeginInfo where
        sizeOf ~_ = #{size VkCommandBufferBeginInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkCommandBufferBeginInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkCommandBufferBeginInfo),
            I## a <- alignment (undefined :: VkCommandBufferBeginInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkCommandBufferBeginInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkCommandBufferBeginInfo## ba)
          | I## n <- sizeOf (undefined :: VkCommandBufferBeginInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkCommandBufferBeginInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkCommandBufferBeginInfo),
            I## a <- alignment (undefined :: VkCommandBufferBeginInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkCommandBufferBeginInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkCommandBufferBeginInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkCommandBufferBeginInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkCommandBufferBeginInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkCommandBufferBeginInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkCommandBufferBeginInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkCommandBufferBeginInfo
         where
        type VkSTypeMType VkCommandBufferBeginInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferBeginInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkCommandBufferBeginInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkCommandBufferBeginInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkCommandBufferBeginInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkCommandBufferBeginInfo
         where
        type VkPNextMType VkCommandBufferBeginInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferBeginInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkCommandBufferBeginInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkCommandBufferBeginInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkCommandBufferBeginInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkCommandBufferBeginInfo
         where
        type VkFlagsMType VkCommandBufferBeginInfo =
             VkCommandBufferUsageFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferBeginInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkCommandBufferBeginInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkCommandBufferBeginInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkCommandBufferBeginInfo, flags}

class HasVkPInheritanceInfo a where
        type VkPInheritanceInfoMType a :: *

        vkPInheritanceInfo :: a -> VkPInheritanceInfoMType a

        vkPInheritanceInfoByteOffset :: a -> Int

        readVkPInheritanceInfo :: Ptr a -> IO (VkPInheritanceInfoMType a)

        writeVkPInheritanceInfo ::
                                Ptr a -> VkPInheritanceInfoMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pInheritanceInfo'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPInheritanceInfo a

instance {-# OVERLAPPING #-}
         HasVkPInheritanceInfo VkCommandBufferBeginInfo where
        type VkPInheritanceInfoMType VkCommandBufferBeginInfo =
             Foreign.Ptr.Ptr VkCommandBufferInheritanceInfo

        {-# NOINLINE vkPInheritanceInfo #-}
        vkPInheritanceInfo x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkCommandBufferBeginInfo, pInheritanceInfo})

        {-# INLINE vkPInheritanceInfoByteOffset #-}
        vkPInheritanceInfoByteOffset ~_
          = #{offset VkCommandBufferBeginInfo, pInheritanceInfo}

        {-# INLINE readVkPInheritanceInfo #-}
        readVkPInheritanceInfo p
          = peekByteOff p
              #{offset VkCommandBufferBeginInfo, pInheritanceInfo}

        {-# INLINE writeVkPInheritanceInfo #-}
        writeVkPInheritanceInfo p
          = pokeByteOff p
              #{offset VkCommandBufferBeginInfo, pInheritanceInfo}

instance Show VkCommandBufferBeginInfo where
        showsPrec d x
          = showString "VkCommandBufferBeginInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkPInheritanceInfo = " .
                                  showsPrec d (vkPInheritanceInfo x) . showChar '}'

data VkRenderPassBeginInfo = VkRenderPassBeginInfo## ByteArray##

instance Eq VkRenderPassBeginInfo where
        (VkRenderPassBeginInfo## a) == (VkRenderPassBeginInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkRenderPassBeginInfo where
        (VkRenderPassBeginInfo## a) `compare` (VkRenderPassBeginInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkRenderPassBeginInfo where
        sizeOf ~_ = #{size VkRenderPassBeginInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkRenderPassBeginInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkRenderPassBeginInfo),
            I## a <- alignment (undefined :: VkRenderPassBeginInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkRenderPassBeginInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkRenderPassBeginInfo## ba)
          | I## n <- sizeOf (undefined :: VkRenderPassBeginInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkRenderPassBeginInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkRenderPassBeginInfo),
            I## a <- alignment (undefined :: VkRenderPassBeginInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkRenderPassBeginInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkRenderPassBeginInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkRenderPassBeginInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkRenderPassBeginInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkRenderPassBeginInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkRenderPassBeginInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkRenderPassBeginInfo where
        type VkSTypeMType VkRenderPassBeginInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassBeginInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkRenderPassBeginInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkRenderPassBeginInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkRenderPassBeginInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkRenderPassBeginInfo where
        type VkPNextMType VkRenderPassBeginInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassBeginInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkRenderPassBeginInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkRenderPassBeginInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkRenderPassBeginInfo, pNext}

instance {-# OVERLAPPING #-} HasVkRenderPass VkRenderPassBeginInfo
         where
        type VkRenderPassMType VkRenderPassBeginInfo = VkRenderPass

        {-# NOINLINE vkRenderPass #-}
        vkRenderPass x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassBeginInfo, renderPass})

        {-# INLINE vkRenderPassByteOffset #-}
        vkRenderPassByteOffset ~_
          = #{offset VkRenderPassBeginInfo, renderPass}

        {-# INLINE readVkRenderPass #-}
        readVkRenderPass p
          = peekByteOff p
              #{offset VkRenderPassBeginInfo, renderPass}

        {-# INLINE writeVkRenderPass #-}
        writeVkRenderPass p
          = pokeByteOff p
              #{offset VkRenderPassBeginInfo, renderPass}

instance {-# OVERLAPPING #-} HasVkFramebuffer VkRenderPassBeginInfo
         where
        type VkFramebufferMType VkRenderPassBeginInfo = VkFramebuffer

        {-# NOINLINE vkFramebuffer #-}
        vkFramebuffer x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassBeginInfo, framebuffer})

        {-# INLINE vkFramebufferByteOffset #-}
        vkFramebufferByteOffset ~_
          = #{offset VkRenderPassBeginInfo, framebuffer}

        {-# INLINE readVkFramebuffer #-}
        readVkFramebuffer p
          = peekByteOff p
              #{offset VkRenderPassBeginInfo, framebuffer}

        {-# INLINE writeVkFramebuffer #-}
        writeVkFramebuffer p
          = pokeByteOff p
              #{offset VkRenderPassBeginInfo, framebuffer}

class HasVkRenderArea a where
        type VkRenderAreaMType a :: *

        vkRenderArea :: a -> VkRenderAreaMType a

        vkRenderAreaByteOffset :: a -> Int

        readVkRenderArea :: Ptr a -> IO (VkRenderAreaMType a)

        writeVkRenderArea :: Ptr a -> VkRenderAreaMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'renderArea'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRenderArea a

instance {-# OVERLAPPING #-} HasVkRenderArea VkRenderPassBeginInfo
         where
        type VkRenderAreaMType VkRenderPassBeginInfo = VkRect2D

        {-# NOINLINE vkRenderArea #-}
        vkRenderArea x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassBeginInfo, renderArea})

        {-# INLINE vkRenderAreaByteOffset #-}
        vkRenderAreaByteOffset ~_
          = #{offset VkRenderPassBeginInfo, renderArea}

        {-# INLINE readVkRenderArea #-}
        readVkRenderArea p
          = peekByteOff p
              #{offset VkRenderPassBeginInfo, renderArea}

        {-# INLINE writeVkRenderArea #-}
        writeVkRenderArea p
          = pokeByteOff p
              #{offset VkRenderPassBeginInfo, renderArea}

class HasVkClearValueCount a where
        type VkClearValueCountMType a :: *

        vkClearValueCount :: a -> VkClearValueCountMType a

        vkClearValueCountByteOffset :: a -> Int

        readVkClearValueCount :: Ptr a -> IO (VkClearValueCountMType a)

        writeVkClearValueCount ::
                               Ptr a -> VkClearValueCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'clearValueCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkClearValueCount a

instance {-# OVERLAPPING #-}
         HasVkClearValueCount VkRenderPassBeginInfo where
        type VkClearValueCountMType VkRenderPassBeginInfo =
             Data.Word.Word32

        {-# NOINLINE vkClearValueCount #-}
        vkClearValueCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassBeginInfo, clearValueCount})

        {-# INLINE vkClearValueCountByteOffset #-}
        vkClearValueCountByteOffset ~_
          = #{offset VkRenderPassBeginInfo, clearValueCount}

        {-# INLINE readVkClearValueCount #-}
        readVkClearValueCount p
          = peekByteOff p
              #{offset VkRenderPassBeginInfo, clearValueCount}

        {-# INLINE writeVkClearValueCount #-}
        writeVkClearValueCount p
          = pokeByteOff p
              #{offset VkRenderPassBeginInfo, clearValueCount}

class HasVkPClearValues a where
        type VkPClearValuesMType a :: *

        vkPClearValues :: a -> VkPClearValuesMType a

        vkPClearValuesByteOffset :: a -> Int

        readVkPClearValues :: Ptr a -> IO (VkPClearValuesMType a)

        writeVkPClearValues :: Ptr a -> VkPClearValuesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pClearValues'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPClearValues a

instance {-# OVERLAPPING #-}
         HasVkPClearValues VkRenderPassBeginInfo where
        type VkPClearValuesMType VkRenderPassBeginInfo =
             Foreign.Ptr.Ptr VkClearValue

        {-# NOINLINE vkPClearValues #-}
        vkPClearValues x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassBeginInfo, pClearValues})

        {-# INLINE vkPClearValuesByteOffset #-}
        vkPClearValuesByteOffset ~_
          = #{offset VkRenderPassBeginInfo, pClearValues}

        {-# INLINE readVkPClearValues #-}
        readVkPClearValues p
          = peekByteOff p
              #{offset VkRenderPassBeginInfo, pClearValues}

        {-# INLINE writeVkPClearValues #-}
        writeVkPClearValues p
          = pokeByteOff p
              #{offset VkRenderPassBeginInfo, pClearValues}

instance Show VkRenderPassBeginInfo where
        showsPrec d x
          = showString "VkRenderPassBeginInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkRenderPass = " .
                            showsPrec d (vkRenderPass x) .
                              showString ", " .
                                showString "vkFramebuffer = " .
                                  showsPrec d (vkFramebuffer x) .
                                    showString ", " .
                                      showString "vkRenderArea = " .
                                        showsPrec d (vkRenderArea x) .
                                          showString ", " .
                                            showString "vkClearValueCount = " .
                                              showsPrec d (vkClearValueCount x) .
                                                showString ", " .
                                                  showString "vkPClearValues = " .
                                                    showsPrec d (vkPClearValues x) . showChar '}'

-- | // Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.
--
data VkClearColorValue = VkClearColorValue## ByteArray##

instance Eq VkClearColorValue where
        (VkClearColorValue## a) == (VkClearColorValue## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkClearColorValue where
        (VkClearColorValue## a) `compare` (VkClearColorValue## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkClearColorValue where
        sizeOf ~_ = #{size VkClearColorValue}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkClearColorValue}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkClearColorValue),
            I## a <- alignment (undefined :: VkClearColorValue) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkClearColorValue## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkClearColorValue## ba)
          | I## n <- sizeOf (undefined :: VkClearColorValue) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkClearColorValue where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkClearColorValue),
            I## a <- alignment (undefined :: VkClearColorValue) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkClearColorValue##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkClearColorValue## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkClearColorValue##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkClearColorValue## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkClearColorValue## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkClearColorValue## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkFloat32Array a where
        type VkFloat32ArrayMType a :: *

        vkFloat32Array :: a -> Int -> VkFloat32ArrayMType a

        vkFloat32ArrayByteOffset :: a -> Int

        readVkFloat32Array :: Ptr a -> Int -> IO (VkFloat32ArrayMType a)

        writeVkFloat32Array ::
                            Ptr a -> Int -> VkFloat32ArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'float32'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFloat32Array a

instance {-# OVERLAPPING #-} HasVkFloat32Array VkClearColorValue
         where
        type VkFloat32ArrayMType VkClearColorValue = Foreign.C.Types.CFloat

        {-# NOINLINE vkFloat32Array #-}
        vkFloat32Array x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                    #{offset VkClearColorValue, float32}))

        {-# INLINE vkFloat32ArrayByteOffset #-}
        vkFloat32ArrayByteOffset ~_
          = #{offset VkClearColorValue, float32}

        {-# INLINE readVkFloat32Array #-}
        readVkFloat32Array p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                 #{offset VkClearColorValue, float32})

        {-# INLINE writeVkFloat32Array #-}
        writeVkFloat32Array p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                 #{offset VkClearColorValue, float32})

class HasVkInt32Array a where
        type VkInt32ArrayMType a :: *

        vkInt32Array :: a -> Int -> VkInt32ArrayMType a

        vkInt32ArrayByteOffset :: a -> Int

        readVkInt32Array :: Ptr a -> Int -> IO (VkInt32ArrayMType a)

        writeVkInt32Array :: Ptr a -> Int -> VkInt32ArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'int32'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkInt32Array a

instance {-# OVERLAPPING #-} HasVkInt32Array VkClearColorValue
         where
        type VkInt32ArrayMType VkClearColorValue = Data.Int.Int32

        {-# NOINLINE vkInt32Array #-}
        vkInt32Array x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Data.Int.Int32) +
                    #{offset VkClearColorValue, int32}))

        {-# INLINE vkInt32ArrayByteOffset #-}
        vkInt32ArrayByteOffset ~_
          = #{offset VkClearColorValue, int32}

        {-# INLINE readVkInt32Array #-}
        readVkInt32Array p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Data.Int.Int32) +
                 #{offset VkClearColorValue, int32})

        {-# INLINE writeVkInt32Array #-}
        writeVkInt32Array p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Data.Int.Int32) +
                 #{offset VkClearColorValue, int32})

class HasVkUint32Array a where
        type VkUint32ArrayMType a :: *

        vkUint32Array :: a -> Int -> VkUint32ArrayMType a

        vkUint32ArrayByteOffset :: a -> Int

        readVkUint32Array :: Ptr a -> Int -> IO (VkUint32ArrayMType a)

        writeVkUint32Array :: Ptr a -> Int -> VkUint32ArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'uint32'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkUint32Array a

instance {-# OVERLAPPING #-} HasVkUint32Array VkClearColorValue
         where
        type VkUint32ArrayMType VkClearColorValue = Data.Word.Word32

        {-# NOINLINE vkUint32Array #-}
        vkUint32Array x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Data.Word.Word32) +
                    #{offset VkClearColorValue, uint32}))

        {-# INLINE vkUint32ArrayByteOffset #-}
        vkUint32ArrayByteOffset ~_
          = #{offset VkClearColorValue, uint32}

        {-# INLINE readVkUint32Array #-}
        readVkUint32Array p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Data.Word.Word32) +
                 #{offset VkClearColorValue, uint32})

        {-# INLINE writeVkUint32Array #-}
        writeVkUint32Array p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Data.Word.Word32) +
                 #{offset VkClearColorValue, uint32})

instance Show VkClearColorValue where
        showsPrec d x
          = showString "VkClearColorValue {" .
              showString "vkFloat32Array = [" .
                showsPrec d (map (vkFloat32Array x) [1 .. 4]) .
                  showChar ']' .
                    showString ", " .
                      showString "vkInt32Array = [" .
                        showsPrec d (map (vkInt32Array x) [1 .. 4]) .
                          showChar ']' .
                            showString ", " .
                              showString "vkUint32Array = [" .
                                showsPrec d (map (vkUint32Array x) [1 .. 4]) .
                                  showChar ']' . showChar '}'

data VkClearDepthStencilValue = VkClearDepthStencilValue## ByteArray##

instance Eq VkClearDepthStencilValue where
        (VkClearDepthStencilValue## a) == (VkClearDepthStencilValue## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkClearDepthStencilValue where
        (VkClearDepthStencilValue## a) `compare`
          (VkClearDepthStencilValue## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkClearDepthStencilValue where
        sizeOf ~_ = #{size VkClearDepthStencilValue}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkClearDepthStencilValue}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkClearDepthStencilValue),
            I## a <- alignment (undefined :: VkClearDepthStencilValue) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkClearDepthStencilValue##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkClearDepthStencilValue## ba)
          | I## n <- sizeOf (undefined :: VkClearDepthStencilValue) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkClearDepthStencilValue where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkClearDepthStencilValue),
            I## a <- alignment (undefined :: VkClearDepthStencilValue) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkClearDepthStencilValue##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkClearDepthStencilValue## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkClearDepthStencilValue##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkClearDepthStencilValue## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkClearDepthStencilValue## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkClearDepthStencilValue## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkDepth VkClearDepthStencilValue
         where
        type VkDepthMType VkClearDepthStencilValue = Foreign.C.Types.CFloat

        {-# NOINLINE vkDepth #-}
        vkDepth x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkClearDepthStencilValue, depth})

        {-# INLINE vkDepthByteOffset #-}
        vkDepthByteOffset ~_
          = #{offset VkClearDepthStencilValue, depth}

        {-# INLINE readVkDepth #-}
        readVkDepth p
          = peekByteOff p #{offset VkClearDepthStencilValue, depth}

        {-# INLINE writeVkDepth #-}
        writeVkDepth p
          = pokeByteOff p #{offset VkClearDepthStencilValue, depth}

class HasVkStencil a where
        type VkStencilMType a :: *

        vkStencil :: a -> VkStencilMType a

        vkStencilByteOffset :: a -> Int

        readVkStencil :: Ptr a -> IO (VkStencilMType a)

        writeVkStencil :: Ptr a -> VkStencilMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stencil'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStencil a

instance {-# OVERLAPPING #-} HasVkStencil VkClearDepthStencilValue
         where
        type VkStencilMType VkClearDepthStencilValue = Data.Word.Word32

        {-# NOINLINE vkStencil #-}
        vkStencil x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkClearDepthStencilValue, stencil})

        {-# INLINE vkStencilByteOffset #-}
        vkStencilByteOffset ~_
          = #{offset VkClearDepthStencilValue, stencil}

        {-# INLINE readVkStencil #-}
        readVkStencil p
          = peekByteOff p
              #{offset VkClearDepthStencilValue, stencil}

        {-# INLINE writeVkStencil #-}
        writeVkStencil p
          = pokeByteOff p
              #{offset VkClearDepthStencilValue, stencil}

instance Show VkClearDepthStencilValue where
        showsPrec d x
          = showString "VkClearDepthStencilValue {" .
              showString "vkDepth = " .
                showsPrec d (vkDepth x) .
                  showString ", " .
                    showString "vkStencil = " .
                      showsPrec d (vkStencil x) . showChar '}'

-- | // Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared.
--
data VkClearValue = VkClearValue## ByteArray##

instance Eq VkClearValue where
        (VkClearValue## a) == (VkClearValue## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkClearValue where
        (VkClearValue## a) `compare` (VkClearValue## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkClearValue where
        sizeOf ~_ = #{size VkClearValue}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkClearValue}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkClearValue),
            I## a <- alignment (undefined :: VkClearValue) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkClearValue## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkClearValue## ba)
          | I## n <- sizeOf (undefined :: VkClearValue) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkClearValue where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkClearValue),
            I## a <- alignment (undefined :: VkClearValue) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkClearValue##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkClearValue## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkClearValue##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkClearValue## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkClearValue## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkClearValue## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkColor a where
        type VkColorMType a :: *

        vkColor :: a -> VkColorMType a

        vkColorByteOffset :: a -> Int

        readVkColor :: Ptr a -> IO (VkColorMType a)

        writeVkColor :: Ptr a -> VkColorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'color'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkColor a

instance {-# OVERLAPPING #-} HasVkColor VkClearValue where
        type VkColorMType VkClearValue = VkClearColorValue

        {-# NOINLINE vkColor #-}
        vkColor x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkClearValue, color})

        {-# INLINE vkColorByteOffset #-}
        vkColorByteOffset ~_ = #{offset VkClearValue, color}

        {-# INLINE readVkColor #-}
        readVkColor p
          = peekByteOff p #{offset VkClearValue, color}

        {-# INLINE writeVkColor #-}
        writeVkColor p
          = pokeByteOff p #{offset VkClearValue, color}

class HasVkDepthStencil a where
        type VkDepthStencilMType a :: *

        vkDepthStencil :: a -> VkDepthStencilMType a

        vkDepthStencilByteOffset :: a -> Int

        readVkDepthStencil :: Ptr a -> IO (VkDepthStencilMType a)

        writeVkDepthStencil :: Ptr a -> VkDepthStencilMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthStencil'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthStencil a

instance {-# OVERLAPPING #-} HasVkDepthStencil VkClearValue where
        type VkDepthStencilMType VkClearValue = VkClearDepthStencilValue

        {-# NOINLINE vkDepthStencil #-}
        vkDepthStencil x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkClearValue, depthStencil})

        {-# INLINE vkDepthStencilByteOffset #-}
        vkDepthStencilByteOffset ~_
          = #{offset VkClearValue, depthStencil}

        {-# INLINE readVkDepthStencil #-}
        readVkDepthStencil p
          = peekByteOff p #{offset VkClearValue, depthStencil}

        {-# INLINE writeVkDepthStencil #-}
        writeVkDepthStencil p
          = pokeByteOff p #{offset VkClearValue, depthStencil}

instance Show VkClearValue where
        showsPrec d x
          = showString "VkClearValue {" .
              showString "vkColor = " .
                showsPrec d (vkColor x) .
                  showString ", " .
                    showString "vkDepthStencil = " .
                      showsPrec d (vkDepthStencil x) . showChar '}'

data VkClearAttachment = VkClearAttachment## ByteArray##

instance Eq VkClearAttachment where
        (VkClearAttachment## a) == (VkClearAttachment## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkClearAttachment where
        (VkClearAttachment## a) `compare` (VkClearAttachment## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkClearAttachment where
        sizeOf ~_ = #{size VkClearAttachment}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkClearAttachment}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkClearAttachment),
            I## a <- alignment (undefined :: VkClearAttachment) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkClearAttachment## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkClearAttachment## ba)
          | I## n <- sizeOf (undefined :: VkClearAttachment) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkClearAttachment where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkClearAttachment),
            I## a <- alignment (undefined :: VkClearAttachment) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkClearAttachment##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkClearAttachment## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkClearAttachment##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkClearAttachment## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkClearAttachment## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkClearAttachment## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkAspectMask VkClearAttachment
         where
        type VkAspectMaskMType VkClearAttachment = VkImageAspectFlags

        {-# NOINLINE vkAspectMask #-}
        vkAspectMask x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkClearAttachment, aspectMask})

        {-# INLINE vkAspectMaskByteOffset #-}
        vkAspectMaskByteOffset ~_
          = #{offset VkClearAttachment, aspectMask}

        {-# INLINE readVkAspectMask #-}
        readVkAspectMask p
          = peekByteOff p #{offset VkClearAttachment, aspectMask}

        {-# INLINE writeVkAspectMask #-}
        writeVkAspectMask p
          = pokeByteOff p #{offset VkClearAttachment, aspectMask}

class HasVkColorAttachment a where
        type VkColorAttachmentMType a :: *

        vkColorAttachment :: a -> VkColorAttachmentMType a

        vkColorAttachmentByteOffset :: a -> Int

        readVkColorAttachment :: Ptr a -> IO (VkColorAttachmentMType a)

        writeVkColorAttachment ::
                               Ptr a -> VkColorAttachmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'colorAttachment'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkColorAttachment a

instance {-# OVERLAPPING #-} HasVkColorAttachment VkClearAttachment
         where
        type VkColorAttachmentMType VkClearAttachment = Data.Word.Word32

        {-# NOINLINE vkColorAttachment #-}
        vkColorAttachment x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkClearAttachment, colorAttachment})

        {-# INLINE vkColorAttachmentByteOffset #-}
        vkColorAttachmentByteOffset ~_
          = #{offset VkClearAttachment, colorAttachment}

        {-# INLINE readVkColorAttachment #-}
        readVkColorAttachment p
          = peekByteOff p
              #{offset VkClearAttachment, colorAttachment}

        {-# INLINE writeVkColorAttachment #-}
        writeVkColorAttachment p
          = pokeByteOff p
              #{offset VkClearAttachment, colorAttachment}

class HasVkClearValue a where
        type VkClearValueMType a :: *

        vkClearValue :: a -> VkClearValueMType a

        vkClearValueByteOffset :: a -> Int

        readVkClearValue :: Ptr a -> IO (VkClearValueMType a)

        writeVkClearValue :: Ptr a -> VkClearValueMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'clearValue'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkClearValue a

instance {-# OVERLAPPING #-} HasVkClearValue VkClearAttachment
         where
        type VkClearValueMType VkClearAttachment = VkClearValue

        {-# NOINLINE vkClearValue #-}
        vkClearValue x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkClearAttachment, clearValue})

        {-# INLINE vkClearValueByteOffset #-}
        vkClearValueByteOffset ~_
          = #{offset VkClearAttachment, clearValue}

        {-# INLINE readVkClearValue #-}
        readVkClearValue p
          = peekByteOff p #{offset VkClearAttachment, clearValue}

        {-# INLINE writeVkClearValue #-}
        writeVkClearValue p
          = pokeByteOff p #{offset VkClearAttachment, clearValue}

instance Show VkClearAttachment where
        showsPrec d x
          = showString "VkClearAttachment {" .
              showString "vkAspectMask = " .
                showsPrec d (vkAspectMask x) .
                  showString ", " .
                    showString "vkColorAttachment = " .
                      showsPrec d (vkColorAttachment x) .
                        showString ", " .
                          showString "vkClearValue = " .
                            showsPrec d (vkClearValue x) . showChar '}'

data VkAttachmentDescription = VkAttachmentDescription## ByteArray##

instance Eq VkAttachmentDescription where
        (VkAttachmentDescription## a) == (VkAttachmentDescription## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkAttachmentDescription where
        (VkAttachmentDescription## a) `compare` (VkAttachmentDescription## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkAttachmentDescription where
        sizeOf ~_ = #{size VkAttachmentDescription}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkAttachmentDescription}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkAttachmentDescription),
            I## a <- alignment (undefined :: VkAttachmentDescription) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkAttachmentDescription##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkAttachmentDescription## ba)
          | I## n <- sizeOf (undefined :: VkAttachmentDescription) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkAttachmentDescription where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkAttachmentDescription),
            I## a <- alignment (undefined :: VkAttachmentDescription) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkAttachmentDescription##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkAttachmentDescription## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkAttachmentDescription##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkAttachmentDescription## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkAttachmentDescription## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkAttachmentDescription## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkFlags VkAttachmentDescription
         where
        type VkFlagsMType VkAttachmentDescription =
             VkAttachmentDescriptionFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAttachmentDescription, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkAttachmentDescription, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkAttachmentDescription, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkAttachmentDescription, flags}

instance {-# OVERLAPPING #-} HasVkFormat VkAttachmentDescription
         where
        type VkFormatMType VkAttachmentDescription = VkFormat

        {-# NOINLINE vkFormat #-}
        vkFormat x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAttachmentDescription, format})

        {-# INLINE vkFormatByteOffset #-}
        vkFormatByteOffset ~_
          = #{offset VkAttachmentDescription, format}

        {-# INLINE readVkFormat #-}
        readVkFormat p
          = peekByteOff p #{offset VkAttachmentDescription, format}

        {-# INLINE writeVkFormat #-}
        writeVkFormat p
          = pokeByteOff p #{offset VkAttachmentDescription, format}

instance {-# OVERLAPPING #-} HasVkSamples VkAttachmentDescription
         where
        type VkSamplesMType VkAttachmentDescription = VkSampleCountFlagBits

        {-# NOINLINE vkSamples #-}
        vkSamples x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAttachmentDescription, samples})

        {-# INLINE vkSamplesByteOffset #-}
        vkSamplesByteOffset ~_
          = #{offset VkAttachmentDescription, samples}

        {-# INLINE readVkSamples #-}
        readVkSamples p
          = peekByteOff p #{offset VkAttachmentDescription, samples}

        {-# INLINE writeVkSamples #-}
        writeVkSamples p
          = pokeByteOff p #{offset VkAttachmentDescription, samples}

class HasVkLoadOp a where
        type VkLoadOpMType a :: *

        vkLoadOp :: a -> VkLoadOpMType a

        vkLoadOpByteOffset :: a -> Int

        readVkLoadOp :: Ptr a -> IO (VkLoadOpMType a)

        writeVkLoadOp :: Ptr a -> VkLoadOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'loadOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLoadOp a

instance {-# OVERLAPPING #-} HasVkLoadOp VkAttachmentDescription
         where
        type VkLoadOpMType VkAttachmentDescription = VkAttachmentLoadOp

        {-# NOINLINE vkLoadOp #-}
        vkLoadOp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAttachmentDescription, loadOp})

        {-# INLINE vkLoadOpByteOffset #-}
        vkLoadOpByteOffset ~_
          = #{offset VkAttachmentDescription, loadOp}

        {-# INLINE readVkLoadOp #-}
        readVkLoadOp p
          = peekByteOff p #{offset VkAttachmentDescription, loadOp}

        {-# INLINE writeVkLoadOp #-}
        writeVkLoadOp p
          = pokeByteOff p #{offset VkAttachmentDescription, loadOp}

class HasVkStoreOp a where
        type VkStoreOpMType a :: *

        vkStoreOp :: a -> VkStoreOpMType a

        vkStoreOpByteOffset :: a -> Int

        readVkStoreOp :: Ptr a -> IO (VkStoreOpMType a)

        writeVkStoreOp :: Ptr a -> VkStoreOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'storeOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStoreOp a

instance {-# OVERLAPPING #-} HasVkStoreOp VkAttachmentDescription
         where
        type VkStoreOpMType VkAttachmentDescription = VkAttachmentStoreOp

        {-# NOINLINE vkStoreOp #-}
        vkStoreOp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAttachmentDescription, storeOp})

        {-# INLINE vkStoreOpByteOffset #-}
        vkStoreOpByteOffset ~_
          = #{offset VkAttachmentDescription, storeOp}

        {-# INLINE readVkStoreOp #-}
        readVkStoreOp p
          = peekByteOff p #{offset VkAttachmentDescription, storeOp}

        {-# INLINE writeVkStoreOp #-}
        writeVkStoreOp p
          = pokeByteOff p #{offset VkAttachmentDescription, storeOp}

class HasVkStencilLoadOp a where
        type VkStencilLoadOpMType a :: *

        vkStencilLoadOp :: a -> VkStencilLoadOpMType a

        vkStencilLoadOpByteOffset :: a -> Int

        readVkStencilLoadOp :: Ptr a -> IO (VkStencilLoadOpMType a)

        writeVkStencilLoadOp :: Ptr a -> VkStencilLoadOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stencilLoadOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStencilLoadOp a

instance {-# OVERLAPPING #-}
         HasVkStencilLoadOp VkAttachmentDescription where
        type VkStencilLoadOpMType VkAttachmentDescription =
             VkAttachmentLoadOp

        {-# NOINLINE vkStencilLoadOp #-}
        vkStencilLoadOp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAttachmentDescription, stencilLoadOp})

        {-# INLINE vkStencilLoadOpByteOffset #-}
        vkStencilLoadOpByteOffset ~_
          = #{offset VkAttachmentDescription, stencilLoadOp}

        {-# INLINE readVkStencilLoadOp #-}
        readVkStencilLoadOp p
          = peekByteOff p
              #{offset VkAttachmentDescription, stencilLoadOp}

        {-# INLINE writeVkStencilLoadOp #-}
        writeVkStencilLoadOp p
          = pokeByteOff p
              #{offset VkAttachmentDescription, stencilLoadOp}

class HasVkStencilStoreOp a where
        type VkStencilStoreOpMType a :: *

        vkStencilStoreOp :: a -> VkStencilStoreOpMType a

        vkStencilStoreOpByteOffset :: a -> Int

        readVkStencilStoreOp :: Ptr a -> IO (VkStencilStoreOpMType a)

        writeVkStencilStoreOp :: Ptr a -> VkStencilStoreOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stencilStoreOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStencilStoreOp a

instance {-# OVERLAPPING #-}
         HasVkStencilStoreOp VkAttachmentDescription where
        type VkStencilStoreOpMType VkAttachmentDescription =
             VkAttachmentStoreOp

        {-# NOINLINE vkStencilStoreOp #-}
        vkStencilStoreOp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAttachmentDescription, stencilStoreOp})

        {-# INLINE vkStencilStoreOpByteOffset #-}
        vkStencilStoreOpByteOffset ~_
          = #{offset VkAttachmentDescription, stencilStoreOp}

        {-# INLINE readVkStencilStoreOp #-}
        readVkStencilStoreOp p
          = peekByteOff p
              #{offset VkAttachmentDescription, stencilStoreOp}

        {-# INLINE writeVkStencilStoreOp #-}
        writeVkStencilStoreOp p
          = pokeByteOff p
              #{offset VkAttachmentDescription, stencilStoreOp}

instance {-# OVERLAPPING #-}
         HasVkInitialLayout VkAttachmentDescription where
        type VkInitialLayoutMType VkAttachmentDescription = VkImageLayout

        {-# NOINLINE vkInitialLayout #-}
        vkInitialLayout x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAttachmentDescription, initialLayout})

        {-# INLINE vkInitialLayoutByteOffset #-}
        vkInitialLayoutByteOffset ~_
          = #{offset VkAttachmentDescription, initialLayout}

        {-# INLINE readVkInitialLayout #-}
        readVkInitialLayout p
          = peekByteOff p
              #{offset VkAttachmentDescription, initialLayout}

        {-# INLINE writeVkInitialLayout #-}
        writeVkInitialLayout p
          = pokeByteOff p
              #{offset VkAttachmentDescription, initialLayout}

class HasVkFinalLayout a where
        type VkFinalLayoutMType a :: *

        vkFinalLayout :: a -> VkFinalLayoutMType a

        vkFinalLayoutByteOffset :: a -> Int

        readVkFinalLayout :: Ptr a -> IO (VkFinalLayoutMType a)

        writeVkFinalLayout :: Ptr a -> VkFinalLayoutMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'finalLayout'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFinalLayout a

instance {-# OVERLAPPING #-}
         HasVkFinalLayout VkAttachmentDescription where
        type VkFinalLayoutMType VkAttachmentDescription = VkImageLayout

        {-# NOINLINE vkFinalLayout #-}
        vkFinalLayout x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAttachmentDescription, finalLayout})

        {-# INLINE vkFinalLayoutByteOffset #-}
        vkFinalLayoutByteOffset ~_
          = #{offset VkAttachmentDescription, finalLayout}

        {-# INLINE readVkFinalLayout #-}
        readVkFinalLayout p
          = peekByteOff p
              #{offset VkAttachmentDescription, finalLayout}

        {-# INLINE writeVkFinalLayout #-}
        writeVkFinalLayout p
          = pokeByteOff p
              #{offset VkAttachmentDescription, finalLayout}

instance Show VkAttachmentDescription where
        showsPrec d x
          = showString "VkAttachmentDescription {" .
              showString "vkFlags = " .
                showsPrec d (vkFlags x) .
                  showString ", " .
                    showString "vkFormat = " .
                      showsPrec d (vkFormat x) .
                        showString ", " .
                          showString "vkSamples = " .
                            showsPrec d (vkSamples x) .
                              showString ", " .
                                showString "vkLoadOp = " .
                                  showsPrec d (vkLoadOp x) .
                                    showString ", " .
                                      showString "vkStoreOp = " .
                                        showsPrec d (vkStoreOp x) .
                                          showString ", " .
                                            showString "vkStencilLoadOp = " .
                                              showsPrec d (vkStencilLoadOp x) .
                                                showString ", " .
                                                  showString "vkStencilStoreOp = " .
                                                    showsPrec d (vkStencilStoreOp x) .
                                                      showString ", " .
                                                        showString "vkInitialLayout = " .
                                                          showsPrec d (vkInitialLayout x) .
                                                            showString ", " .
                                                              showString "vkFinalLayout = " .
                                                                showsPrec d (vkFinalLayout x) .
                                                                  showChar '}'

data VkAttachmentReference = VkAttachmentReference## ByteArray##

instance Eq VkAttachmentReference where
        (VkAttachmentReference## a) == (VkAttachmentReference## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkAttachmentReference where
        (VkAttachmentReference## a) `compare` (VkAttachmentReference## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkAttachmentReference where
        sizeOf ~_ = #{size VkAttachmentReference}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkAttachmentReference}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkAttachmentReference),
            I## a <- alignment (undefined :: VkAttachmentReference) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkAttachmentReference## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkAttachmentReference## ba)
          | I## n <- sizeOf (undefined :: VkAttachmentReference) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkAttachmentReference where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkAttachmentReference),
            I## a <- alignment (undefined :: VkAttachmentReference) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkAttachmentReference##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkAttachmentReference## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkAttachmentReference##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkAttachmentReference## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkAttachmentReference## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkAttachmentReference## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkAttachment a where
        type VkAttachmentMType a :: *

        vkAttachment :: a -> VkAttachmentMType a

        vkAttachmentByteOffset :: a -> Int

        readVkAttachment :: Ptr a -> IO (VkAttachmentMType a)

        writeVkAttachment :: Ptr a -> VkAttachmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'attachment'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAttachment a

instance {-# OVERLAPPING #-} HasVkAttachment VkAttachmentReference
         where
        type VkAttachmentMType VkAttachmentReference = Data.Word.Word32

        {-# NOINLINE vkAttachment #-}
        vkAttachment x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAttachmentReference, attachment})

        {-# INLINE vkAttachmentByteOffset #-}
        vkAttachmentByteOffset ~_
          = #{offset VkAttachmentReference, attachment}

        {-# INLINE readVkAttachment #-}
        readVkAttachment p
          = peekByteOff p
              #{offset VkAttachmentReference, attachment}

        {-# INLINE writeVkAttachment #-}
        writeVkAttachment p
          = pokeByteOff p
              #{offset VkAttachmentReference, attachment}

instance {-# OVERLAPPING #-} HasVkLayout VkAttachmentReference
         where
        type VkLayoutMType VkAttachmentReference = VkImageLayout

        {-# NOINLINE vkLayout #-}
        vkLayout x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkAttachmentReference, layout})

        {-# INLINE vkLayoutByteOffset #-}
        vkLayoutByteOffset ~_
          = #{offset VkAttachmentReference, layout}

        {-# INLINE readVkLayout #-}
        readVkLayout p
          = peekByteOff p #{offset VkAttachmentReference, layout}

        {-# INLINE writeVkLayout #-}
        writeVkLayout p
          = pokeByteOff p #{offset VkAttachmentReference, layout}

instance Show VkAttachmentReference where
        showsPrec d x
          = showString "VkAttachmentReference {" .
              showString "vkAttachment = " .
                showsPrec d (vkAttachment x) .
                  showString ", " .
                    showString "vkLayout = " . showsPrec d (vkLayout x) . showChar '}'

data VkSubpassDescription = VkSubpassDescription## ByteArray##

instance Eq VkSubpassDescription where
        (VkSubpassDescription## a) == (VkSubpassDescription## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSubpassDescription where
        (VkSubpassDescription## a) `compare` (VkSubpassDescription## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSubpassDescription where
        sizeOf ~_ = #{size VkSubpassDescription}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSubpassDescription}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSubpassDescription),
            I## a <- alignment (undefined :: VkSubpassDescription) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSubpassDescription## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSubpassDescription## ba)
          | I## n <- sizeOf (undefined :: VkSubpassDescription) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSubpassDescription where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSubpassDescription),
            I## a <- alignment (undefined :: VkSubpassDescription) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSubpassDescription##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSubpassDescription## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSubpassDescription##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSubpassDescription## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSubpassDescription## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSubpassDescription## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkFlags VkSubpassDescription where
        type VkFlagsMType VkSubpassDescription = VkSubpassDescriptionFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDescription, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkSubpassDescription, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkSubpassDescription, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkSubpassDescription, flags}

class HasVkPipelineBindPoint a where
        type VkPipelineBindPointMType a :: *

        vkPipelineBindPoint :: a -> VkPipelineBindPointMType a

        vkPipelineBindPointByteOffset :: a -> Int

        readVkPipelineBindPoint :: Ptr a -> IO (VkPipelineBindPointMType a)

        writeVkPipelineBindPoint ::
                                 Ptr a -> VkPipelineBindPointMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pipelineBindPoint'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPipelineBindPoint a

instance {-# OVERLAPPING #-}
         HasVkPipelineBindPoint VkSubpassDescription where
        type VkPipelineBindPointMType VkSubpassDescription =
             VkPipelineBindPoint

        {-# NOINLINE vkPipelineBindPoint #-}
        vkPipelineBindPoint x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDescription, pipelineBindPoint})

        {-# INLINE vkPipelineBindPointByteOffset #-}
        vkPipelineBindPointByteOffset ~_
          = #{offset VkSubpassDescription, pipelineBindPoint}

        {-# INLINE readVkPipelineBindPoint #-}
        readVkPipelineBindPoint p
          = peekByteOff p
              #{offset VkSubpassDescription, pipelineBindPoint}

        {-# INLINE writeVkPipelineBindPoint #-}
        writeVkPipelineBindPoint p
          = pokeByteOff p
              #{offset VkSubpassDescription, pipelineBindPoint}

class HasVkInputAttachmentCount a where
        type VkInputAttachmentCountMType a :: *

        vkInputAttachmentCount :: a -> VkInputAttachmentCountMType a

        vkInputAttachmentCountByteOffset :: a -> Int

        readVkInputAttachmentCount ::
                                   Ptr a -> IO (VkInputAttachmentCountMType a)

        writeVkInputAttachmentCount ::
                                    Ptr a -> VkInputAttachmentCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'inputAttachmentCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkInputAttachmentCount a

instance {-# OVERLAPPING #-}
         HasVkInputAttachmentCount VkSubpassDescription where
        type VkInputAttachmentCountMType VkSubpassDescription =
             Data.Word.Word32

        {-# NOINLINE vkInputAttachmentCount #-}
        vkInputAttachmentCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDescription, inputAttachmentCount})

        {-# INLINE vkInputAttachmentCountByteOffset #-}
        vkInputAttachmentCountByteOffset ~_
          = #{offset VkSubpassDescription, inputAttachmentCount}

        {-# INLINE readVkInputAttachmentCount #-}
        readVkInputAttachmentCount p
          = peekByteOff p
              #{offset VkSubpassDescription, inputAttachmentCount}

        {-# INLINE writeVkInputAttachmentCount #-}
        writeVkInputAttachmentCount p
          = pokeByteOff p
              #{offset VkSubpassDescription, inputAttachmentCount}

class HasVkPInputAttachments a where
        type VkPInputAttachmentsMType a :: *

        vkPInputAttachments :: a -> VkPInputAttachmentsMType a

        vkPInputAttachmentsByteOffset :: a -> Int

        readVkPInputAttachments :: Ptr a -> IO (VkPInputAttachmentsMType a)

        writeVkPInputAttachments ::
                                 Ptr a -> VkPInputAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pInputAttachments'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPInputAttachments a

instance {-# OVERLAPPING #-}
         HasVkPInputAttachments VkSubpassDescription where
        type VkPInputAttachmentsMType VkSubpassDescription =
             Foreign.Ptr.Ptr VkAttachmentReference

        {-# NOINLINE vkPInputAttachments #-}
        vkPInputAttachments x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDescription, pInputAttachments})

        {-# INLINE vkPInputAttachmentsByteOffset #-}
        vkPInputAttachmentsByteOffset ~_
          = #{offset VkSubpassDescription, pInputAttachments}

        {-# INLINE readVkPInputAttachments #-}
        readVkPInputAttachments p
          = peekByteOff p
              #{offset VkSubpassDescription, pInputAttachments}

        {-# INLINE writeVkPInputAttachments #-}
        writeVkPInputAttachments p
          = pokeByteOff p
              #{offset VkSubpassDescription, pInputAttachments}

class HasVkColorAttachmentCount a where
        type VkColorAttachmentCountMType a :: *

        vkColorAttachmentCount :: a -> VkColorAttachmentCountMType a

        vkColorAttachmentCountByteOffset :: a -> Int

        readVkColorAttachmentCount ::
                                   Ptr a -> IO (VkColorAttachmentCountMType a)

        writeVkColorAttachmentCount ::
                                    Ptr a -> VkColorAttachmentCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'colorAttachmentCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkColorAttachmentCount a

instance {-# OVERLAPPING #-}
         HasVkColorAttachmentCount VkSubpassDescription where
        type VkColorAttachmentCountMType VkSubpassDescription =
             Data.Word.Word32

        {-# NOINLINE vkColorAttachmentCount #-}
        vkColorAttachmentCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDescription, colorAttachmentCount})

        {-# INLINE vkColorAttachmentCountByteOffset #-}
        vkColorAttachmentCountByteOffset ~_
          = #{offset VkSubpassDescription, colorAttachmentCount}

        {-# INLINE readVkColorAttachmentCount #-}
        readVkColorAttachmentCount p
          = peekByteOff p
              #{offset VkSubpassDescription, colorAttachmentCount}

        {-# INLINE writeVkColorAttachmentCount #-}
        writeVkColorAttachmentCount p
          = pokeByteOff p
              #{offset VkSubpassDescription, colorAttachmentCount}

class HasVkPColorAttachments a where
        type VkPColorAttachmentsMType a :: *

        vkPColorAttachments :: a -> VkPColorAttachmentsMType a

        vkPColorAttachmentsByteOffset :: a -> Int

        readVkPColorAttachments :: Ptr a -> IO (VkPColorAttachmentsMType a)

        writeVkPColorAttachments ::
                                 Ptr a -> VkPColorAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pColorAttachments'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPColorAttachments a

instance {-# OVERLAPPING #-}
         HasVkPColorAttachments VkSubpassDescription where
        type VkPColorAttachmentsMType VkSubpassDescription =
             Foreign.Ptr.Ptr VkAttachmentReference

        {-# NOINLINE vkPColorAttachments #-}
        vkPColorAttachments x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDescription, pColorAttachments})

        {-# INLINE vkPColorAttachmentsByteOffset #-}
        vkPColorAttachmentsByteOffset ~_
          = #{offset VkSubpassDescription, pColorAttachments}

        {-# INLINE readVkPColorAttachments #-}
        readVkPColorAttachments p
          = peekByteOff p
              #{offset VkSubpassDescription, pColorAttachments}

        {-# INLINE writeVkPColorAttachments #-}
        writeVkPColorAttachments p
          = pokeByteOff p
              #{offset VkSubpassDescription, pColorAttachments}

class HasVkPResolveAttachments a where
        type VkPResolveAttachmentsMType a :: *

        vkPResolveAttachments :: a -> VkPResolveAttachmentsMType a

        vkPResolveAttachmentsByteOffset :: a -> Int

        readVkPResolveAttachments ::
                                  Ptr a -> IO (VkPResolveAttachmentsMType a)

        writeVkPResolveAttachments ::
                                   Ptr a -> VkPResolveAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pResolveAttachments'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPResolveAttachments a

instance {-# OVERLAPPING #-}
         HasVkPResolveAttachments VkSubpassDescription where
        type VkPResolveAttachmentsMType VkSubpassDescription =
             Foreign.Ptr.Ptr VkAttachmentReference

        {-# NOINLINE vkPResolveAttachments #-}
        vkPResolveAttachments x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDescription, pResolveAttachments})

        {-# INLINE vkPResolveAttachmentsByteOffset #-}
        vkPResolveAttachmentsByteOffset ~_
          = #{offset VkSubpassDescription, pResolveAttachments}

        {-# INLINE readVkPResolveAttachments #-}
        readVkPResolveAttachments p
          = peekByteOff p
              #{offset VkSubpassDescription, pResolveAttachments}

        {-# INLINE writeVkPResolveAttachments #-}
        writeVkPResolveAttachments p
          = pokeByteOff p
              #{offset VkSubpassDescription, pResolveAttachments}

class HasVkPDepthStencilAttachment a where
        type VkPDepthStencilAttachmentMType a :: *

        vkPDepthStencilAttachment :: a -> VkPDepthStencilAttachmentMType a

        vkPDepthStencilAttachmentByteOffset :: a -> Int

        readVkPDepthStencilAttachment ::
                                      Ptr a -> IO (VkPDepthStencilAttachmentMType a)

        writeVkPDepthStencilAttachment ::
                                       Ptr a -> VkPDepthStencilAttachmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pDepthStencilAttachment'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPDepthStencilAttachment a

instance {-# OVERLAPPING #-}
         HasVkPDepthStencilAttachment VkSubpassDescription where
        type VkPDepthStencilAttachmentMType VkSubpassDescription =
             Foreign.Ptr.Ptr VkAttachmentReference

        {-# NOINLINE vkPDepthStencilAttachment #-}
        vkPDepthStencilAttachment x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDescription, pDepthStencilAttachment})

        {-# INLINE vkPDepthStencilAttachmentByteOffset #-}
        vkPDepthStencilAttachmentByteOffset ~_
          = #{offset VkSubpassDescription, pDepthStencilAttachment}

        {-# INLINE readVkPDepthStencilAttachment #-}
        readVkPDepthStencilAttachment p
          = peekByteOff p
              #{offset VkSubpassDescription, pDepthStencilAttachment}

        {-# INLINE writeVkPDepthStencilAttachment #-}
        writeVkPDepthStencilAttachment p
          = pokeByteOff p
              #{offset VkSubpassDescription, pDepthStencilAttachment}

class HasVkPreserveAttachmentCount a where
        type VkPreserveAttachmentCountMType a :: *

        vkPreserveAttachmentCount :: a -> VkPreserveAttachmentCountMType a

        vkPreserveAttachmentCountByteOffset :: a -> Int

        readVkPreserveAttachmentCount ::
                                      Ptr a -> IO (VkPreserveAttachmentCountMType a)

        writeVkPreserveAttachmentCount ::
                                       Ptr a -> VkPreserveAttachmentCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'preserveAttachmentCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPreserveAttachmentCount a

instance {-# OVERLAPPING #-}
         HasVkPreserveAttachmentCount VkSubpassDescription where
        type VkPreserveAttachmentCountMType VkSubpassDescription =
             Data.Word.Word32

        {-# NOINLINE vkPreserveAttachmentCount #-}
        vkPreserveAttachmentCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDescription, preserveAttachmentCount})

        {-# INLINE vkPreserveAttachmentCountByteOffset #-}
        vkPreserveAttachmentCountByteOffset ~_
          = #{offset VkSubpassDescription, preserveAttachmentCount}

        {-# INLINE readVkPreserveAttachmentCount #-}
        readVkPreserveAttachmentCount p
          = peekByteOff p
              #{offset VkSubpassDescription, preserveAttachmentCount}

        {-# INLINE writeVkPreserveAttachmentCount #-}
        writeVkPreserveAttachmentCount p
          = pokeByteOff p
              #{offset VkSubpassDescription, preserveAttachmentCount}

class HasVkPPreserveAttachments a where
        type VkPPreserveAttachmentsMType a :: *

        vkPPreserveAttachments :: a -> VkPPreserveAttachmentsMType a

        vkPPreserveAttachmentsByteOffset :: a -> Int

        readVkPPreserveAttachments ::
                                   Ptr a -> IO (VkPPreserveAttachmentsMType a)

        writeVkPPreserveAttachments ::
                                    Ptr a -> VkPPreserveAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pPreserveAttachments'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPPreserveAttachments a

instance {-# OVERLAPPING #-}
         HasVkPPreserveAttachments VkSubpassDescription where
        type VkPPreserveAttachmentsMType VkSubpassDescription =
             Foreign.Ptr.Ptr Data.Word.Word32

        {-# NOINLINE vkPPreserveAttachments #-}
        vkPPreserveAttachments x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDescription, pPreserveAttachments})

        {-# INLINE vkPPreserveAttachmentsByteOffset #-}
        vkPPreserveAttachmentsByteOffset ~_
          = #{offset VkSubpassDescription, pPreserveAttachments}

        {-# INLINE readVkPPreserveAttachments #-}
        readVkPPreserveAttachments p
          = peekByteOff p
              #{offset VkSubpassDescription, pPreserveAttachments}

        {-# INLINE writeVkPPreserveAttachments #-}
        writeVkPPreserveAttachments p
          = pokeByteOff p
              #{offset VkSubpassDescription, pPreserveAttachments}

instance Show VkSubpassDescription where
        showsPrec d x
          = showString "VkSubpassDescription {" .
              showString "vkFlags = " .
                showsPrec d (vkFlags x) .
                  showString ", " .
                    showString "vkPipelineBindPoint = " .
                      showsPrec d (vkPipelineBindPoint x) .
                        showString ", " .
                          showString "vkInputAttachmentCount = " .
                            showsPrec d (vkInputAttachmentCount x) .
                              showString ", " .
                                showString "vkPInputAttachments = " .
                                  showsPrec d (vkPInputAttachments x) .
                                    showString ", " .
                                      showString "vkColorAttachmentCount = " .
                                        showsPrec d (vkColorAttachmentCount x) .
                                          showString ", " .
                                            showString "vkPColorAttachments = " .
                                              showsPrec d (vkPColorAttachments x) .
                                                showString ", " .
                                                  showString "vkPResolveAttachments = " .
                                                    showsPrec d (vkPResolveAttachments x) .
                                                      showString ", " .
                                                        showString "vkPDepthStencilAttachment = " .
                                                          showsPrec d (vkPDepthStencilAttachment x)
                                                            .
                                                            showString ", " .
                                                              showString
                                                                "vkPreserveAttachmentCount = "
                                                                .
                                                                showsPrec d
                                                                  (vkPreserveAttachmentCount x)
                                                                  .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkPPreserveAttachments = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkPPreserveAttachments x)
                                                                        . showChar '}'

data VkSubpassDependency = VkSubpassDependency## ByteArray##

instance Eq VkSubpassDependency where
        (VkSubpassDependency## a) == (VkSubpassDependency## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSubpassDependency where
        (VkSubpassDependency## a) `compare` (VkSubpassDependency## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSubpassDependency where
        sizeOf ~_ = #{size VkSubpassDependency}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSubpassDependency}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSubpassDependency),
            I## a <- alignment (undefined :: VkSubpassDependency) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSubpassDependency## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSubpassDependency## ba)
          | I## n <- sizeOf (undefined :: VkSubpassDependency) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSubpassDependency where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSubpassDependency),
            I## a <- alignment (undefined :: VkSubpassDependency) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSubpassDependency##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSubpassDependency## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSubpassDependency##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSubpassDependency## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSubpassDependency## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSubpassDependency## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkSrcSubpass a where
        type VkSrcSubpassMType a :: *

        vkSrcSubpass :: a -> VkSrcSubpassMType a

        vkSrcSubpassByteOffset :: a -> Int

        readVkSrcSubpass :: Ptr a -> IO (VkSrcSubpassMType a)

        writeVkSrcSubpass :: Ptr a -> VkSrcSubpassMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcSubpass'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcSubpass a

instance {-# OVERLAPPING #-} HasVkSrcSubpass VkSubpassDependency
         where
        type VkSrcSubpassMType VkSubpassDependency = Data.Word.Word32

        {-# NOINLINE vkSrcSubpass #-}
        vkSrcSubpass x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDependency, srcSubpass})

        {-# INLINE vkSrcSubpassByteOffset #-}
        vkSrcSubpassByteOffset ~_
          = #{offset VkSubpassDependency, srcSubpass}

        {-# INLINE readVkSrcSubpass #-}
        readVkSrcSubpass p
          = peekByteOff p #{offset VkSubpassDependency, srcSubpass}

        {-# INLINE writeVkSrcSubpass #-}
        writeVkSrcSubpass p
          = pokeByteOff p #{offset VkSubpassDependency, srcSubpass}

class HasVkDstSubpass a where
        type VkDstSubpassMType a :: *

        vkDstSubpass :: a -> VkDstSubpassMType a

        vkDstSubpassByteOffset :: a -> Int

        readVkDstSubpass :: Ptr a -> IO (VkDstSubpassMType a)

        writeVkDstSubpass :: Ptr a -> VkDstSubpassMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstSubpass'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstSubpass a

instance {-# OVERLAPPING #-} HasVkDstSubpass VkSubpassDependency
         where
        type VkDstSubpassMType VkSubpassDependency = Data.Word.Word32

        {-# NOINLINE vkDstSubpass #-}
        vkDstSubpass x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDependency, dstSubpass})

        {-# INLINE vkDstSubpassByteOffset #-}
        vkDstSubpassByteOffset ~_
          = #{offset VkSubpassDependency, dstSubpass}

        {-# INLINE readVkDstSubpass #-}
        readVkDstSubpass p
          = peekByteOff p #{offset VkSubpassDependency, dstSubpass}

        {-# INLINE writeVkDstSubpass #-}
        writeVkDstSubpass p
          = pokeByteOff p #{offset VkSubpassDependency, dstSubpass}

class HasVkSrcStageMask a where
        type VkSrcStageMaskMType a :: *

        vkSrcStageMask :: a -> VkSrcStageMaskMType a

        vkSrcStageMaskByteOffset :: a -> Int

        readVkSrcStageMask :: Ptr a -> IO (VkSrcStageMaskMType a)

        writeVkSrcStageMask :: Ptr a -> VkSrcStageMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcStageMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcStageMask a

instance {-# OVERLAPPING #-} HasVkSrcStageMask VkSubpassDependency
         where
        type VkSrcStageMaskMType VkSubpassDependency = VkPipelineStageFlags

        {-# NOINLINE vkSrcStageMask #-}
        vkSrcStageMask x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDependency, srcStageMask})

        {-# INLINE vkSrcStageMaskByteOffset #-}
        vkSrcStageMaskByteOffset ~_
          = #{offset VkSubpassDependency, srcStageMask}

        {-# INLINE readVkSrcStageMask #-}
        readVkSrcStageMask p
          = peekByteOff p
              #{offset VkSubpassDependency, srcStageMask}

        {-# INLINE writeVkSrcStageMask #-}
        writeVkSrcStageMask p
          = pokeByteOff p
              #{offset VkSubpassDependency, srcStageMask}

class HasVkDstStageMask a where
        type VkDstStageMaskMType a :: *

        vkDstStageMask :: a -> VkDstStageMaskMType a

        vkDstStageMaskByteOffset :: a -> Int

        readVkDstStageMask :: Ptr a -> IO (VkDstStageMaskMType a)

        writeVkDstStageMask :: Ptr a -> VkDstStageMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstStageMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstStageMask a

instance {-# OVERLAPPING #-} HasVkDstStageMask VkSubpassDependency
         where
        type VkDstStageMaskMType VkSubpassDependency = VkPipelineStageFlags

        {-# NOINLINE vkDstStageMask #-}
        vkDstStageMask x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDependency, dstStageMask})

        {-# INLINE vkDstStageMaskByteOffset #-}
        vkDstStageMaskByteOffset ~_
          = #{offset VkSubpassDependency, dstStageMask}

        {-# INLINE readVkDstStageMask #-}
        readVkDstStageMask p
          = peekByteOff p
              #{offset VkSubpassDependency, dstStageMask}

        {-# INLINE writeVkDstStageMask #-}
        writeVkDstStageMask p
          = pokeByteOff p
              #{offset VkSubpassDependency, dstStageMask}

class HasVkSrcAccessMask a where
        type VkSrcAccessMaskMType a :: *

        vkSrcAccessMask :: a -> VkSrcAccessMaskMType a

        vkSrcAccessMaskByteOffset :: a -> Int

        readVkSrcAccessMask :: Ptr a -> IO (VkSrcAccessMaskMType a)

        writeVkSrcAccessMask :: Ptr a -> VkSrcAccessMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcAccessMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcAccessMask a

instance {-# OVERLAPPING #-} HasVkSrcAccessMask VkSubpassDependency
         where
        type VkSrcAccessMaskMType VkSubpassDependency = VkAccessFlags

        {-# NOINLINE vkSrcAccessMask #-}
        vkSrcAccessMask x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDependency, srcAccessMask})

        {-# INLINE vkSrcAccessMaskByteOffset #-}
        vkSrcAccessMaskByteOffset ~_
          = #{offset VkSubpassDependency, srcAccessMask}

        {-# INLINE readVkSrcAccessMask #-}
        readVkSrcAccessMask p
          = peekByteOff p
              #{offset VkSubpassDependency, srcAccessMask}

        {-# INLINE writeVkSrcAccessMask #-}
        writeVkSrcAccessMask p
          = pokeByteOff p
              #{offset VkSubpassDependency, srcAccessMask}

class HasVkDstAccessMask a where
        type VkDstAccessMaskMType a :: *

        vkDstAccessMask :: a -> VkDstAccessMaskMType a

        vkDstAccessMaskByteOffset :: a -> Int

        readVkDstAccessMask :: Ptr a -> IO (VkDstAccessMaskMType a)

        writeVkDstAccessMask :: Ptr a -> VkDstAccessMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstAccessMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstAccessMask a

instance {-# OVERLAPPING #-} HasVkDstAccessMask VkSubpassDependency
         where
        type VkDstAccessMaskMType VkSubpassDependency = VkAccessFlags

        {-# NOINLINE vkDstAccessMask #-}
        vkDstAccessMask x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDependency, dstAccessMask})

        {-# INLINE vkDstAccessMaskByteOffset #-}
        vkDstAccessMaskByteOffset ~_
          = #{offset VkSubpassDependency, dstAccessMask}

        {-# INLINE readVkDstAccessMask #-}
        readVkDstAccessMask p
          = peekByteOff p
              #{offset VkSubpassDependency, dstAccessMask}

        {-# INLINE writeVkDstAccessMask #-}
        writeVkDstAccessMask p
          = pokeByteOff p
              #{offset VkSubpassDependency, dstAccessMask}

class HasVkDependencyFlags a where
        type VkDependencyFlagsMType a :: *

        vkDependencyFlags :: a -> VkDependencyFlagsMType a

        vkDependencyFlagsByteOffset :: a -> Int

        readVkDependencyFlags :: Ptr a -> IO (VkDependencyFlagsMType a)

        writeVkDependencyFlags ::
                               Ptr a -> VkDependencyFlagsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dependencyFlags'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDependencyFlags a

instance {-# OVERLAPPING #-}
         HasVkDependencyFlags VkSubpassDependency where
        type VkDependencyFlagsMType VkSubpassDependency = VkDependencyFlags

        {-# NOINLINE vkDependencyFlags #-}
        vkDependencyFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubpassDependency, dependencyFlags})

        {-# INLINE vkDependencyFlagsByteOffset #-}
        vkDependencyFlagsByteOffset ~_
          = #{offset VkSubpassDependency, dependencyFlags}

        {-# INLINE readVkDependencyFlags #-}
        readVkDependencyFlags p
          = peekByteOff p
              #{offset VkSubpassDependency, dependencyFlags}

        {-# INLINE writeVkDependencyFlags #-}
        writeVkDependencyFlags p
          = pokeByteOff p
              #{offset VkSubpassDependency, dependencyFlags}

instance Show VkSubpassDependency where
        showsPrec d x
          = showString "VkSubpassDependency {" .
              showString "vkSrcSubpass = " .
                showsPrec d (vkSrcSubpass x) .
                  showString ", " .
                    showString "vkDstSubpass = " .
                      showsPrec d (vkDstSubpass x) .
                        showString ", " .
                          showString "vkSrcStageMask = " .
                            showsPrec d (vkSrcStageMask x) .
                              showString ", " .
                                showString "vkDstStageMask = " .
                                  showsPrec d (vkDstStageMask x) .
                                    showString ", " .
                                      showString "vkSrcAccessMask = " .
                                        showsPrec d (vkSrcAccessMask x) .
                                          showString ", " .
                                            showString "vkDstAccessMask = " .
                                              showsPrec d (vkDstAccessMask x) .
                                                showString ", " .
                                                  showString "vkDependencyFlags = " .
                                                    showsPrec d (vkDependencyFlags x) . showChar '}'

data VkRenderPassCreateInfo = VkRenderPassCreateInfo## ByteArray##

instance Eq VkRenderPassCreateInfo where
        (VkRenderPassCreateInfo## a) == (VkRenderPassCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkRenderPassCreateInfo where
        (VkRenderPassCreateInfo## a) `compare` (VkRenderPassCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkRenderPassCreateInfo where
        sizeOf ~_ = #{size VkRenderPassCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkRenderPassCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkRenderPassCreateInfo),
            I## a <- alignment (undefined :: VkRenderPassCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkRenderPassCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkRenderPassCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkRenderPassCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkRenderPassCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkRenderPassCreateInfo),
            I## a <- alignment (undefined :: VkRenderPassCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkRenderPassCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkRenderPassCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkRenderPassCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkRenderPassCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkRenderPassCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkRenderPassCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkRenderPassCreateInfo
         where
        type VkSTypeMType VkRenderPassCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkRenderPassCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkRenderPassCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkRenderPassCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkRenderPassCreateInfo
         where
        type VkPNextMType VkRenderPassCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkRenderPassCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkRenderPassCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkRenderPassCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkRenderPassCreateInfo
         where
        type VkFlagsMType VkRenderPassCreateInfo = VkRenderPassCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkRenderPassCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkRenderPassCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkRenderPassCreateInfo, flags}

instance {-# OVERLAPPING #-}
         HasVkAttachmentCount VkRenderPassCreateInfo where
        type VkAttachmentCountMType VkRenderPassCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkAttachmentCount #-}
        vkAttachmentCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassCreateInfo, attachmentCount})

        {-# INLINE vkAttachmentCountByteOffset #-}
        vkAttachmentCountByteOffset ~_
          = #{offset VkRenderPassCreateInfo, attachmentCount}

        {-# INLINE readVkAttachmentCount #-}
        readVkAttachmentCount p
          = peekByteOff p
              #{offset VkRenderPassCreateInfo, attachmentCount}

        {-# INLINE writeVkAttachmentCount #-}
        writeVkAttachmentCount p
          = pokeByteOff p
              #{offset VkRenderPassCreateInfo, attachmentCount}

instance {-# OVERLAPPING #-}
         HasVkPAttachments VkRenderPassCreateInfo where
        type VkPAttachmentsMType VkRenderPassCreateInfo =
             Foreign.Ptr.Ptr VkAttachmentDescription

        {-# NOINLINE vkPAttachments #-}
        vkPAttachments x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassCreateInfo, pAttachments})

        {-# INLINE vkPAttachmentsByteOffset #-}
        vkPAttachmentsByteOffset ~_
          = #{offset VkRenderPassCreateInfo, pAttachments}

        {-# INLINE readVkPAttachments #-}
        readVkPAttachments p
          = peekByteOff p
              #{offset VkRenderPassCreateInfo, pAttachments}

        {-# INLINE writeVkPAttachments #-}
        writeVkPAttachments p
          = pokeByteOff p
              #{offset VkRenderPassCreateInfo, pAttachments}

class HasVkSubpassCount a where
        type VkSubpassCountMType a :: *

        vkSubpassCount :: a -> VkSubpassCountMType a

        vkSubpassCountByteOffset :: a -> Int

        readVkSubpassCount :: Ptr a -> IO (VkSubpassCountMType a)

        writeVkSubpassCount :: Ptr a -> VkSubpassCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'subpassCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSubpassCount a

instance {-# OVERLAPPING #-}
         HasVkSubpassCount VkRenderPassCreateInfo where
        type VkSubpassCountMType VkRenderPassCreateInfo = Data.Word.Word32

        {-# NOINLINE vkSubpassCount #-}
        vkSubpassCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassCreateInfo, subpassCount})

        {-# INLINE vkSubpassCountByteOffset #-}
        vkSubpassCountByteOffset ~_
          = #{offset VkRenderPassCreateInfo, subpassCount}

        {-# INLINE readVkSubpassCount #-}
        readVkSubpassCount p
          = peekByteOff p
              #{offset VkRenderPassCreateInfo, subpassCount}

        {-# INLINE writeVkSubpassCount #-}
        writeVkSubpassCount p
          = pokeByteOff p
              #{offset VkRenderPassCreateInfo, subpassCount}

class HasVkPSubpasses a where
        type VkPSubpassesMType a :: *

        vkPSubpasses :: a -> VkPSubpassesMType a

        vkPSubpassesByteOffset :: a -> Int

        readVkPSubpasses :: Ptr a -> IO (VkPSubpassesMType a)

        writeVkPSubpasses :: Ptr a -> VkPSubpassesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pSubpasses'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPSubpasses a

instance {-# OVERLAPPING #-} HasVkPSubpasses VkRenderPassCreateInfo
         where
        type VkPSubpassesMType VkRenderPassCreateInfo =
             Foreign.Ptr.Ptr VkSubpassDescription

        {-# NOINLINE vkPSubpasses #-}
        vkPSubpasses x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassCreateInfo, pSubpasses})

        {-# INLINE vkPSubpassesByteOffset #-}
        vkPSubpassesByteOffset ~_
          = #{offset VkRenderPassCreateInfo, pSubpasses}

        {-# INLINE readVkPSubpasses #-}
        readVkPSubpasses p
          = peekByteOff p
              #{offset VkRenderPassCreateInfo, pSubpasses}

        {-# INLINE writeVkPSubpasses #-}
        writeVkPSubpasses p
          = pokeByteOff p
              #{offset VkRenderPassCreateInfo, pSubpasses}

class HasVkDependencyCount a where
        type VkDependencyCountMType a :: *

        vkDependencyCount :: a -> VkDependencyCountMType a

        vkDependencyCountByteOffset :: a -> Int

        readVkDependencyCount :: Ptr a -> IO (VkDependencyCountMType a)

        writeVkDependencyCount ::
                               Ptr a -> VkDependencyCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dependencyCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDependencyCount a

instance {-# OVERLAPPING #-}
         HasVkDependencyCount VkRenderPassCreateInfo where
        type VkDependencyCountMType VkRenderPassCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkDependencyCount #-}
        vkDependencyCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassCreateInfo, dependencyCount})

        {-# INLINE vkDependencyCountByteOffset #-}
        vkDependencyCountByteOffset ~_
          = #{offset VkRenderPassCreateInfo, dependencyCount}

        {-# INLINE readVkDependencyCount #-}
        readVkDependencyCount p
          = peekByteOff p
              #{offset VkRenderPassCreateInfo, dependencyCount}

        {-# INLINE writeVkDependencyCount #-}
        writeVkDependencyCount p
          = pokeByteOff p
              #{offset VkRenderPassCreateInfo, dependencyCount}

class HasVkPDependencies a where
        type VkPDependenciesMType a :: *

        vkPDependencies :: a -> VkPDependenciesMType a

        vkPDependenciesByteOffset :: a -> Int

        readVkPDependencies :: Ptr a -> IO (VkPDependenciesMType a)

        writeVkPDependencies :: Ptr a -> VkPDependenciesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pDependencies'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPDependencies a

instance {-# OVERLAPPING #-}
         HasVkPDependencies VkRenderPassCreateInfo where
        type VkPDependenciesMType VkRenderPassCreateInfo =
             Foreign.Ptr.Ptr VkSubpassDependency

        {-# NOINLINE vkPDependencies #-}
        vkPDependencies x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkRenderPassCreateInfo, pDependencies})

        {-# INLINE vkPDependenciesByteOffset #-}
        vkPDependenciesByteOffset ~_
          = #{offset VkRenderPassCreateInfo, pDependencies}

        {-# INLINE readVkPDependencies #-}
        readVkPDependencies p
          = peekByteOff p
              #{offset VkRenderPassCreateInfo, pDependencies}

        {-# INLINE writeVkPDependencies #-}
        writeVkPDependencies p
          = pokeByteOff p
              #{offset VkRenderPassCreateInfo, pDependencies}

instance Show VkRenderPassCreateInfo where
        showsPrec d x
          = showString "VkRenderPassCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkAttachmentCount = " .
                                  showsPrec d (vkAttachmentCount x) .
                                    showString ", " .
                                      showString "vkPAttachments = " .
                                        showsPrec d (vkPAttachments x) .
                                          showString ", " .
                                            showString "vkSubpassCount = " .
                                              showsPrec d (vkSubpassCount x) .
                                                showString ", " .
                                                  showString "vkPSubpasses = " .
                                                    showsPrec d (vkPSubpasses x) .
                                                      showString ", " .
                                                        showString "vkDependencyCount = " .
                                                          showsPrec d (vkDependencyCount x) .
                                                            showString ", " .
                                                              showString "vkPDependencies = " .
                                                                showsPrec d (vkPDependencies x) .
                                                                  showChar '}'

data VkEventCreateInfo = VkEventCreateInfo## ByteArray##

instance Eq VkEventCreateInfo where
        (VkEventCreateInfo## a) == (VkEventCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkEventCreateInfo where
        (VkEventCreateInfo## a) `compare` (VkEventCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkEventCreateInfo where
        sizeOf ~_ = #{size VkEventCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkEventCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkEventCreateInfo),
            I## a <- alignment (undefined :: VkEventCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkEventCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkEventCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkEventCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkEventCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkEventCreateInfo),
            I## a <- alignment (undefined :: VkEventCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkEventCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkEventCreateInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkEventCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkEventCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkEventCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkEventCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkEventCreateInfo where
        type VkSTypeMType VkEventCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkEventCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_ = #{offset VkEventCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkEventCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkEventCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkEventCreateInfo where
        type VkPNextMType VkEventCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkEventCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_ = #{offset VkEventCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkEventCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkEventCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkEventCreateInfo where
        type VkFlagsMType VkEventCreateInfo = VkEventCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkEventCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_ = #{offset VkEventCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkEventCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkEventCreateInfo, flags}

instance Show VkEventCreateInfo where
        showsPrec d x
          = showString "VkEventCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " . showsPrec d (vkFlags x) . showChar '}'

data VkFenceCreateInfo = VkFenceCreateInfo## ByteArray##

instance Eq VkFenceCreateInfo where
        (VkFenceCreateInfo## a) == (VkFenceCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkFenceCreateInfo where
        (VkFenceCreateInfo## a) `compare` (VkFenceCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkFenceCreateInfo where
        sizeOf ~_ = #{size VkFenceCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkFenceCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkFenceCreateInfo),
            I## a <- alignment (undefined :: VkFenceCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkFenceCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkFenceCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkFenceCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkFenceCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkFenceCreateInfo),
            I## a <- alignment (undefined :: VkFenceCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkFenceCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkFenceCreateInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkFenceCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkFenceCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkFenceCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkFenceCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkFenceCreateInfo where
        type VkSTypeMType VkFenceCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFenceCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_ = #{offset VkFenceCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkFenceCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkFenceCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkFenceCreateInfo where
        type VkPNextMType VkFenceCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFenceCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_ = #{offset VkFenceCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkFenceCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkFenceCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkFenceCreateInfo where
        type VkFlagsMType VkFenceCreateInfo = VkFenceCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFenceCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_ = #{offset VkFenceCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkFenceCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkFenceCreateInfo, flags}

instance Show VkFenceCreateInfo where
        showsPrec d x
          = showString "VkFenceCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " . showsPrec d (vkFlags x) . showChar '}'

data VkPhysicalDeviceFeatures = VkPhysicalDeviceFeatures## ByteArray##

instance Eq VkPhysicalDeviceFeatures where
        (VkPhysicalDeviceFeatures## a) == (VkPhysicalDeviceFeatures## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPhysicalDeviceFeatures where
        (VkPhysicalDeviceFeatures## a) `compare`
          (VkPhysicalDeviceFeatures## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPhysicalDeviceFeatures where
        sizeOf ~_ = #{size VkPhysicalDeviceFeatures}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPhysicalDeviceFeatures}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceFeatures),
            I## a <- alignment (undefined :: VkPhysicalDeviceFeatures) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPhysicalDeviceFeatures##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPhysicalDeviceFeatures## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceFeatures) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPhysicalDeviceFeatures where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceFeatures),
            I## a <- alignment (undefined :: VkPhysicalDeviceFeatures) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPhysicalDeviceFeatures##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPhysicalDeviceFeatures## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkPhysicalDeviceFeatures##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPhysicalDeviceFeatures## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPhysicalDeviceFeatures## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPhysicalDeviceFeatures## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkRobustBufferAccess a where
        type VkRobustBufferAccessMType a :: *

        vkRobustBufferAccess :: a -> VkRobustBufferAccessMType a

        vkRobustBufferAccessByteOffset :: a -> Int

        readVkRobustBufferAccess ::
                                 Ptr a -> IO (VkRobustBufferAccessMType a)

        writeVkRobustBufferAccess ::
                                  Ptr a -> VkRobustBufferAccessMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'robustBufferAccess'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRobustBufferAccess a

instance {-# OVERLAPPING #-}
         HasVkRobustBufferAccess VkPhysicalDeviceFeatures where
        type VkRobustBufferAccessMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkRobustBufferAccess #-}
        vkRobustBufferAccess x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, robustBufferAccess})

        {-# INLINE vkRobustBufferAccessByteOffset #-}
        vkRobustBufferAccessByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, robustBufferAccess}

        {-# INLINE readVkRobustBufferAccess #-}
        readVkRobustBufferAccess p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, robustBufferAccess}

        {-# INLINE writeVkRobustBufferAccess #-}
        writeVkRobustBufferAccess p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, robustBufferAccess}

class HasVkFullDrawIndexUint32 a where
        type VkFullDrawIndexUint32MType a :: *

        vkFullDrawIndexUint32 :: a -> VkFullDrawIndexUint32MType a

        vkFullDrawIndexUint32ByteOffset :: a -> Int

        readVkFullDrawIndexUint32 ::
                                  Ptr a -> IO (VkFullDrawIndexUint32MType a)

        writeVkFullDrawIndexUint32 ::
                                   Ptr a -> VkFullDrawIndexUint32MType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'fullDrawIndexUint32'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFullDrawIndexUint32 a

instance {-# OVERLAPPING #-}
         HasVkFullDrawIndexUint32 VkPhysicalDeviceFeatures where
        type VkFullDrawIndexUint32MType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkFullDrawIndexUint32 #-}
        vkFullDrawIndexUint32 x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, fullDrawIndexUint32})

        {-# INLINE vkFullDrawIndexUint32ByteOffset #-}
        vkFullDrawIndexUint32ByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, fullDrawIndexUint32}

        {-# INLINE readVkFullDrawIndexUint32 #-}
        readVkFullDrawIndexUint32 p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, fullDrawIndexUint32}

        {-# INLINE writeVkFullDrawIndexUint32 #-}
        writeVkFullDrawIndexUint32 p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, fullDrawIndexUint32}

class HasVkImageCubeArray a where
        type VkImageCubeArrayMType a :: *

        vkImageCubeArray :: a -> VkImageCubeArrayMType a

        vkImageCubeArrayByteOffset :: a -> Int

        readVkImageCubeArray :: Ptr a -> IO (VkImageCubeArrayMType a)

        writeVkImageCubeArray :: Ptr a -> VkImageCubeArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageCubeArray'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageCubeArray a

instance {-# OVERLAPPING #-}
         HasVkImageCubeArray VkPhysicalDeviceFeatures where
        type VkImageCubeArrayMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkImageCubeArray #-}
        vkImageCubeArray x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, imageCubeArray})

        {-# INLINE vkImageCubeArrayByteOffset #-}
        vkImageCubeArrayByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, imageCubeArray}

        {-# INLINE readVkImageCubeArray #-}
        readVkImageCubeArray p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, imageCubeArray}

        {-# INLINE writeVkImageCubeArray #-}
        writeVkImageCubeArray p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, imageCubeArray}

class HasVkIndependentBlend a where
        type VkIndependentBlendMType a :: *

        vkIndependentBlend :: a -> VkIndependentBlendMType a

        vkIndependentBlendByteOffset :: a -> Int

        readVkIndependentBlend :: Ptr a -> IO (VkIndependentBlendMType a)

        writeVkIndependentBlend ::
                                Ptr a -> VkIndependentBlendMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'independentBlend'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkIndependentBlend a

instance {-# OVERLAPPING #-}
         HasVkIndependentBlend VkPhysicalDeviceFeatures where
        type VkIndependentBlendMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkIndependentBlend #-}
        vkIndependentBlend x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, independentBlend})

        {-# INLINE vkIndependentBlendByteOffset #-}
        vkIndependentBlendByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, independentBlend}

        {-# INLINE readVkIndependentBlend #-}
        readVkIndependentBlend p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, independentBlend}

        {-# INLINE writeVkIndependentBlend #-}
        writeVkIndependentBlend p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, independentBlend}

class HasVkGeometryShader a where
        type VkGeometryShaderMType a :: *

        vkGeometryShader :: a -> VkGeometryShaderMType a

        vkGeometryShaderByteOffset :: a -> Int

        readVkGeometryShader :: Ptr a -> IO (VkGeometryShaderMType a)

        writeVkGeometryShader :: Ptr a -> VkGeometryShaderMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'geometryShader'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkGeometryShader a

instance {-# OVERLAPPING #-}
         HasVkGeometryShader VkPhysicalDeviceFeatures where
        type VkGeometryShaderMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkGeometryShader #-}
        vkGeometryShader x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, geometryShader})

        {-# INLINE vkGeometryShaderByteOffset #-}
        vkGeometryShaderByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, geometryShader}

        {-# INLINE readVkGeometryShader #-}
        readVkGeometryShader p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, geometryShader}

        {-# INLINE writeVkGeometryShader #-}
        writeVkGeometryShader p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, geometryShader}

class HasVkTessellationShader a where
        type VkTessellationShaderMType a :: *

        vkTessellationShader :: a -> VkTessellationShaderMType a

        vkTessellationShaderByteOffset :: a -> Int

        readVkTessellationShader ::
                                 Ptr a -> IO (VkTessellationShaderMType a)

        writeVkTessellationShader ::
                                  Ptr a -> VkTessellationShaderMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'tessellationShader'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTessellationShader a

instance {-# OVERLAPPING #-}
         HasVkTessellationShader VkPhysicalDeviceFeatures where
        type VkTessellationShaderMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkTessellationShader #-}
        vkTessellationShader x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, tessellationShader})

        {-# INLINE vkTessellationShaderByteOffset #-}
        vkTessellationShaderByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, tessellationShader}

        {-# INLINE readVkTessellationShader #-}
        readVkTessellationShader p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, tessellationShader}

        {-# INLINE writeVkTessellationShader #-}
        writeVkTessellationShader p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, tessellationShader}

class HasVkSampleRateShading a where
        type VkSampleRateShadingMType a :: *

        vkSampleRateShading :: a -> VkSampleRateShadingMType a

        vkSampleRateShadingByteOffset :: a -> Int

        readVkSampleRateShading :: Ptr a -> IO (VkSampleRateShadingMType a)

        writeVkSampleRateShading ::
                                 Ptr a -> VkSampleRateShadingMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sampleRateShading'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampleRateShading a

instance {-# OVERLAPPING #-}
         HasVkSampleRateShading VkPhysicalDeviceFeatures where
        type VkSampleRateShadingMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkSampleRateShading #-}
        vkSampleRateShading x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, sampleRateShading})

        {-# INLINE vkSampleRateShadingByteOffset #-}
        vkSampleRateShadingByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sampleRateShading}

        {-# INLINE readVkSampleRateShading #-}
        readVkSampleRateShading p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, sampleRateShading}

        {-# INLINE writeVkSampleRateShading #-}
        writeVkSampleRateShading p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, sampleRateShading}

class HasVkDualSrcBlend a where
        type VkDualSrcBlendMType a :: *

        vkDualSrcBlend :: a -> VkDualSrcBlendMType a

        vkDualSrcBlendByteOffset :: a -> Int

        readVkDualSrcBlend :: Ptr a -> IO (VkDualSrcBlendMType a)

        writeVkDualSrcBlend :: Ptr a -> VkDualSrcBlendMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dualSrcBlend'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDualSrcBlend a

instance {-# OVERLAPPING #-}
         HasVkDualSrcBlend VkPhysicalDeviceFeatures where
        type VkDualSrcBlendMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkDualSrcBlend #-}
        vkDualSrcBlend x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, dualSrcBlend})

        {-# INLINE vkDualSrcBlendByteOffset #-}
        vkDualSrcBlendByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, dualSrcBlend}

        {-# INLINE readVkDualSrcBlend #-}
        readVkDualSrcBlend p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, dualSrcBlend}

        {-# INLINE writeVkDualSrcBlend #-}
        writeVkDualSrcBlend p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, dualSrcBlend}

instance {-# OVERLAPPING #-} HasVkLogicOp VkPhysicalDeviceFeatures
         where
        type VkLogicOpMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkLogicOp #-}
        vkLogicOp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, logicOp})

        {-# INLINE vkLogicOpByteOffset #-}
        vkLogicOpByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, logicOp}

        {-# INLINE readVkLogicOp #-}
        readVkLogicOp p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, logicOp}

        {-# INLINE writeVkLogicOp #-}
        writeVkLogicOp p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, logicOp}

class HasVkMultiDrawIndirect a where
        type VkMultiDrawIndirectMType a :: *

        vkMultiDrawIndirect :: a -> VkMultiDrawIndirectMType a

        vkMultiDrawIndirectByteOffset :: a -> Int

        readVkMultiDrawIndirect :: Ptr a -> IO (VkMultiDrawIndirectMType a)

        writeVkMultiDrawIndirect ::
                                 Ptr a -> VkMultiDrawIndirectMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'multiDrawIndirect'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMultiDrawIndirect a

instance {-# OVERLAPPING #-}
         HasVkMultiDrawIndirect VkPhysicalDeviceFeatures where
        type VkMultiDrawIndirectMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkMultiDrawIndirect #-}
        vkMultiDrawIndirect x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, multiDrawIndirect})

        {-# INLINE vkMultiDrawIndirectByteOffset #-}
        vkMultiDrawIndirectByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, multiDrawIndirect}

        {-# INLINE readVkMultiDrawIndirect #-}
        readVkMultiDrawIndirect p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, multiDrawIndirect}

        {-# INLINE writeVkMultiDrawIndirect #-}
        writeVkMultiDrawIndirect p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, multiDrawIndirect}

class HasVkDrawIndirectFirstInstance a where
        type VkDrawIndirectFirstInstanceMType a :: *

        vkDrawIndirectFirstInstance ::
                                    a -> VkDrawIndirectFirstInstanceMType a

        vkDrawIndirectFirstInstanceByteOffset :: a -> Int

        readVkDrawIndirectFirstInstance ::
                                        Ptr a -> IO (VkDrawIndirectFirstInstanceMType a)

        writeVkDrawIndirectFirstInstance ::
                                         Ptr a -> VkDrawIndirectFirstInstanceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'drawIndirectFirstInstance'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDrawIndirectFirstInstance a

instance {-# OVERLAPPING #-}
         HasVkDrawIndirectFirstInstance VkPhysicalDeviceFeatures where
        type VkDrawIndirectFirstInstanceMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkDrawIndirectFirstInstance #-}
        vkDrawIndirectFirstInstance x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, drawIndirectFirstInstance})

        {-# INLINE vkDrawIndirectFirstInstanceByteOffset #-}
        vkDrawIndirectFirstInstanceByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, drawIndirectFirstInstance}

        {-# INLINE readVkDrawIndirectFirstInstance #-}
        readVkDrawIndirectFirstInstance p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, drawIndirectFirstInstance}

        {-# INLINE writeVkDrawIndirectFirstInstance #-}
        writeVkDrawIndirectFirstInstance p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, drawIndirectFirstInstance}

class HasVkDepthClamp a where
        type VkDepthClampMType a :: *

        vkDepthClamp :: a -> VkDepthClampMType a

        vkDepthClampByteOffset :: a -> Int

        readVkDepthClamp :: Ptr a -> IO (VkDepthClampMType a)

        writeVkDepthClamp :: Ptr a -> VkDepthClampMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthClamp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthClamp a

instance {-# OVERLAPPING #-}
         HasVkDepthClamp VkPhysicalDeviceFeatures where
        type VkDepthClampMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkDepthClamp #-}
        vkDepthClamp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, depthClamp})

        {-# INLINE vkDepthClampByteOffset #-}
        vkDepthClampByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, depthClamp}

        {-# INLINE readVkDepthClamp #-}
        readVkDepthClamp p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, depthClamp}

        {-# INLINE writeVkDepthClamp #-}
        writeVkDepthClamp p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, depthClamp}

instance {-# OVERLAPPING #-}
         HasVkDepthBiasClamp VkPhysicalDeviceFeatures where
        type VkDepthBiasClampMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkDepthBiasClamp #-}
        vkDepthBiasClamp x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, depthBiasClamp})

        {-# INLINE vkDepthBiasClampByteOffset #-}
        vkDepthBiasClampByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, depthBiasClamp}

        {-# INLINE readVkDepthBiasClamp #-}
        readVkDepthBiasClamp p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, depthBiasClamp}

        {-# INLINE writeVkDepthBiasClamp #-}
        writeVkDepthBiasClamp p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, depthBiasClamp}

class HasVkFillModeNonSolid a where
        type VkFillModeNonSolidMType a :: *

        vkFillModeNonSolid :: a -> VkFillModeNonSolidMType a

        vkFillModeNonSolidByteOffset :: a -> Int

        readVkFillModeNonSolid :: Ptr a -> IO (VkFillModeNonSolidMType a)

        writeVkFillModeNonSolid ::
                                Ptr a -> VkFillModeNonSolidMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'fillModeNonSolid'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFillModeNonSolid a

instance {-# OVERLAPPING #-}
         HasVkFillModeNonSolid VkPhysicalDeviceFeatures where
        type VkFillModeNonSolidMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkFillModeNonSolid #-}
        vkFillModeNonSolid x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, fillModeNonSolid})

        {-# INLINE vkFillModeNonSolidByteOffset #-}
        vkFillModeNonSolidByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, fillModeNonSolid}

        {-# INLINE readVkFillModeNonSolid #-}
        readVkFillModeNonSolid p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, fillModeNonSolid}

        {-# INLINE writeVkFillModeNonSolid #-}
        writeVkFillModeNonSolid p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, fillModeNonSolid}

class HasVkDepthBounds a where
        type VkDepthBoundsMType a :: *

        vkDepthBounds :: a -> VkDepthBoundsMType a

        vkDepthBoundsByteOffset :: a -> Int

        readVkDepthBounds :: Ptr a -> IO (VkDepthBoundsMType a)

        writeVkDepthBounds :: Ptr a -> VkDepthBoundsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthBounds'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthBounds a

instance {-# OVERLAPPING #-}
         HasVkDepthBounds VkPhysicalDeviceFeatures where
        type VkDepthBoundsMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkDepthBounds #-}
        vkDepthBounds x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, depthBounds})

        {-# INLINE vkDepthBoundsByteOffset #-}
        vkDepthBoundsByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, depthBounds}

        {-# INLINE readVkDepthBounds #-}
        readVkDepthBounds p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, depthBounds}

        {-# INLINE writeVkDepthBounds #-}
        writeVkDepthBounds p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, depthBounds}

class HasVkWideLines a where
        type VkWideLinesMType a :: *

        vkWideLines :: a -> VkWideLinesMType a

        vkWideLinesByteOffset :: a -> Int

        readVkWideLines :: Ptr a -> IO (VkWideLinesMType a)

        writeVkWideLines :: Ptr a -> VkWideLinesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'wideLines'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkWideLines a

instance {-# OVERLAPPING #-}
         HasVkWideLines VkPhysicalDeviceFeatures where
        type VkWideLinesMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkWideLines #-}
        vkWideLines x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, wideLines})

        {-# INLINE vkWideLinesByteOffset #-}
        vkWideLinesByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, wideLines}

        {-# INLINE readVkWideLines #-}
        readVkWideLines p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, wideLines}

        {-# INLINE writeVkWideLines #-}
        writeVkWideLines p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, wideLines}

class HasVkLargePoints a where
        type VkLargePointsMType a :: *

        vkLargePoints :: a -> VkLargePointsMType a

        vkLargePointsByteOffset :: a -> Int

        readVkLargePoints :: Ptr a -> IO (VkLargePointsMType a)

        writeVkLargePoints :: Ptr a -> VkLargePointsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'largePoints'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLargePoints a

instance {-# OVERLAPPING #-}
         HasVkLargePoints VkPhysicalDeviceFeatures where
        type VkLargePointsMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkLargePoints #-}
        vkLargePoints x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, largePoints})

        {-# INLINE vkLargePointsByteOffset #-}
        vkLargePointsByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, largePoints}

        {-# INLINE readVkLargePoints #-}
        readVkLargePoints p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, largePoints}

        {-# INLINE writeVkLargePoints #-}
        writeVkLargePoints p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, largePoints}

class HasVkAlphaToOne a where
        type VkAlphaToOneMType a :: *

        vkAlphaToOne :: a -> VkAlphaToOneMType a

        vkAlphaToOneByteOffset :: a -> Int

        readVkAlphaToOne :: Ptr a -> IO (VkAlphaToOneMType a)

        writeVkAlphaToOne :: Ptr a -> VkAlphaToOneMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'alphaToOne'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAlphaToOne a

instance {-# OVERLAPPING #-}
         HasVkAlphaToOne VkPhysicalDeviceFeatures where
        type VkAlphaToOneMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkAlphaToOne #-}
        vkAlphaToOne x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, alphaToOne})

        {-# INLINE vkAlphaToOneByteOffset #-}
        vkAlphaToOneByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, alphaToOne}

        {-# INLINE readVkAlphaToOne #-}
        readVkAlphaToOne p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, alphaToOne}

        {-# INLINE writeVkAlphaToOne #-}
        writeVkAlphaToOne p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, alphaToOne}

class HasVkMultiViewport a where
        type VkMultiViewportMType a :: *

        vkMultiViewport :: a -> VkMultiViewportMType a

        vkMultiViewportByteOffset :: a -> Int

        readVkMultiViewport :: Ptr a -> IO (VkMultiViewportMType a)

        writeVkMultiViewport :: Ptr a -> VkMultiViewportMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'multiViewport'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMultiViewport a

instance {-# OVERLAPPING #-}
         HasVkMultiViewport VkPhysicalDeviceFeatures where
        type VkMultiViewportMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkMultiViewport #-}
        vkMultiViewport x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, multiViewport})

        {-# INLINE vkMultiViewportByteOffset #-}
        vkMultiViewportByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, multiViewport}

        {-# INLINE readVkMultiViewport #-}
        readVkMultiViewport p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, multiViewport}

        {-# INLINE writeVkMultiViewport #-}
        writeVkMultiViewport p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, multiViewport}

class HasVkSamplerAnisotropy a where
        type VkSamplerAnisotropyMType a :: *

        vkSamplerAnisotropy :: a -> VkSamplerAnisotropyMType a

        vkSamplerAnisotropyByteOffset :: a -> Int

        readVkSamplerAnisotropy :: Ptr a -> IO (VkSamplerAnisotropyMType a)

        writeVkSamplerAnisotropy ::
                                 Ptr a -> VkSamplerAnisotropyMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'samplerAnisotropy'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSamplerAnisotropy a

instance {-# OVERLAPPING #-}
         HasVkSamplerAnisotropy VkPhysicalDeviceFeatures where
        type VkSamplerAnisotropyMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkSamplerAnisotropy #-}
        vkSamplerAnisotropy x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, samplerAnisotropy})

        {-# INLINE vkSamplerAnisotropyByteOffset #-}
        vkSamplerAnisotropyByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, samplerAnisotropy}

        {-# INLINE readVkSamplerAnisotropy #-}
        readVkSamplerAnisotropy p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, samplerAnisotropy}

        {-# INLINE writeVkSamplerAnisotropy #-}
        writeVkSamplerAnisotropy p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, samplerAnisotropy}

class HasVkTextureCompressionETC2 a where
        type VkTextureCompressionETC2MType a :: *

        vkTextureCompressionETC2 :: a -> VkTextureCompressionETC2MType a

        vkTextureCompressionETC2ByteOffset :: a -> Int

        readVkTextureCompressionETC2 ::
                                     Ptr a -> IO (VkTextureCompressionETC2MType a)

        writeVkTextureCompressionETC2 ::
                                      Ptr a -> VkTextureCompressionETC2MType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'textureCompressionETC2'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTextureCompressionETC2 a

instance {-# OVERLAPPING #-}
         HasVkTextureCompressionETC2 VkPhysicalDeviceFeatures where
        type VkTextureCompressionETC2MType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkTextureCompressionETC2 #-}
        vkTextureCompressionETC2 x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, textureCompressionETC2})

        {-# INLINE vkTextureCompressionETC2ByteOffset #-}
        vkTextureCompressionETC2ByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, textureCompressionETC2}

        {-# INLINE readVkTextureCompressionETC2 #-}
        readVkTextureCompressionETC2 p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, textureCompressionETC2}

        {-# INLINE writeVkTextureCompressionETC2 #-}
        writeVkTextureCompressionETC2 p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, textureCompressionETC2}

class HasVkTextureCompressionASTC_LDR a where
        type VkTextureCompressionASTC_LDRMType a :: *

        vkTextureCompressionASTC_LDR ::
                                     a -> VkTextureCompressionASTC_LDRMType a

        vkTextureCompressionASTC_LDRByteOffset :: a -> Int

        readVkTextureCompressionASTC_LDR ::
                                         Ptr a -> IO (VkTextureCompressionASTC_LDRMType a)

        writeVkTextureCompressionASTC_LDR ::
                                          Ptr a -> VkTextureCompressionASTC_LDRMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'textureCompressionASTC_LDR'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTextureCompressionASTC_LDR a

instance {-# OVERLAPPING #-}
         HasVkTextureCompressionASTC_LDR VkPhysicalDeviceFeatures where
        type VkTextureCompressionASTC_LDRMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkTextureCompressionASTC_LDR #-}
        vkTextureCompressionASTC_LDR x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, textureCompressionASTC_LDR})

        {-# INLINE vkTextureCompressionASTC_LDRByteOffset #-}
        vkTextureCompressionASTC_LDRByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, textureCompressionASTC_LDR}

        {-# INLINE readVkTextureCompressionASTC_LDR #-}
        readVkTextureCompressionASTC_LDR p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, textureCompressionASTC_LDR}

        {-# INLINE writeVkTextureCompressionASTC_LDR #-}
        writeVkTextureCompressionASTC_LDR p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, textureCompressionASTC_LDR}

class HasVkTextureCompressionBC a where
        type VkTextureCompressionBCMType a :: *

        vkTextureCompressionBC :: a -> VkTextureCompressionBCMType a

        vkTextureCompressionBCByteOffset :: a -> Int

        readVkTextureCompressionBC ::
                                   Ptr a -> IO (VkTextureCompressionBCMType a)

        writeVkTextureCompressionBC ::
                                    Ptr a -> VkTextureCompressionBCMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'textureCompressionBC'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTextureCompressionBC a

instance {-# OVERLAPPING #-}
         HasVkTextureCompressionBC VkPhysicalDeviceFeatures where
        type VkTextureCompressionBCMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkTextureCompressionBC #-}
        vkTextureCompressionBC x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, textureCompressionBC})

        {-# INLINE vkTextureCompressionBCByteOffset #-}
        vkTextureCompressionBCByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, textureCompressionBC}

        {-# INLINE readVkTextureCompressionBC #-}
        readVkTextureCompressionBC p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, textureCompressionBC}

        {-# INLINE writeVkTextureCompressionBC #-}
        writeVkTextureCompressionBC p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, textureCompressionBC}

class HasVkOcclusionQueryPrecise a where
        type VkOcclusionQueryPreciseMType a :: *

        vkOcclusionQueryPrecise :: a -> VkOcclusionQueryPreciseMType a

        vkOcclusionQueryPreciseByteOffset :: a -> Int

        readVkOcclusionQueryPrecise ::
                                    Ptr a -> IO (VkOcclusionQueryPreciseMType a)

        writeVkOcclusionQueryPrecise ::
                                     Ptr a -> VkOcclusionQueryPreciseMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'occlusionQueryPrecise'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkOcclusionQueryPrecise a

instance {-# OVERLAPPING #-}
         HasVkOcclusionQueryPrecise VkPhysicalDeviceFeatures where
        type VkOcclusionQueryPreciseMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkOcclusionQueryPrecise #-}
        vkOcclusionQueryPrecise x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, occlusionQueryPrecise})

        {-# INLINE vkOcclusionQueryPreciseByteOffset #-}
        vkOcclusionQueryPreciseByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, occlusionQueryPrecise}

        {-# INLINE readVkOcclusionQueryPrecise #-}
        readVkOcclusionQueryPrecise p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, occlusionQueryPrecise}

        {-# INLINE writeVkOcclusionQueryPrecise #-}
        writeVkOcclusionQueryPrecise p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, occlusionQueryPrecise}

class HasVkPipelineStatisticsQuery a where
        type VkPipelineStatisticsQueryMType a :: *

        vkPipelineStatisticsQuery :: a -> VkPipelineStatisticsQueryMType a

        vkPipelineStatisticsQueryByteOffset :: a -> Int

        readVkPipelineStatisticsQuery ::
                                      Ptr a -> IO (VkPipelineStatisticsQueryMType a)

        writeVkPipelineStatisticsQuery ::
                                       Ptr a -> VkPipelineStatisticsQueryMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pipelineStatisticsQuery'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPipelineStatisticsQuery a

instance {-# OVERLAPPING #-}
         HasVkPipelineStatisticsQuery VkPhysicalDeviceFeatures where
        type VkPipelineStatisticsQueryMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkPipelineStatisticsQuery #-}
        vkPipelineStatisticsQuery x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, pipelineStatisticsQuery})

        {-# INLINE vkPipelineStatisticsQueryByteOffset #-}
        vkPipelineStatisticsQueryByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, pipelineStatisticsQuery}

        {-# INLINE readVkPipelineStatisticsQuery #-}
        readVkPipelineStatisticsQuery p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, pipelineStatisticsQuery}

        {-# INLINE writeVkPipelineStatisticsQuery #-}
        writeVkPipelineStatisticsQuery p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, pipelineStatisticsQuery}

class HasVkVertexPipelineStoresAndAtomics a where
        type VkVertexPipelineStoresAndAtomicsMType a :: *

        vkVertexPipelineStoresAndAtomics ::
                                         a -> VkVertexPipelineStoresAndAtomicsMType a

        vkVertexPipelineStoresAndAtomicsByteOffset :: a -> Int

        readVkVertexPipelineStoresAndAtomics ::
                                             Ptr a -> IO (VkVertexPipelineStoresAndAtomicsMType a)

        writeVkVertexPipelineStoresAndAtomics ::
                                              Ptr a ->
                                                VkVertexPipelineStoresAndAtomicsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'vertexPipelineStoresAndAtomics'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkVertexPipelineStoresAndAtomics a

instance {-# OVERLAPPING #-}
         HasVkVertexPipelineStoresAndAtomics VkPhysicalDeviceFeatures where
        type VkVertexPipelineStoresAndAtomicsMType VkPhysicalDeviceFeatures
             = VkBool32

        {-# NOINLINE vkVertexPipelineStoresAndAtomics #-}
        vkVertexPipelineStoresAndAtomics x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, vertexPipelineStoresAndAtomics})

        {-# INLINE vkVertexPipelineStoresAndAtomicsByteOffset #-}
        vkVertexPipelineStoresAndAtomicsByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, vertexPipelineStoresAndAtomics}

        {-# INLINE readVkVertexPipelineStoresAndAtomics #-}
        readVkVertexPipelineStoresAndAtomics p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, vertexPipelineStoresAndAtomics}

        {-# INLINE writeVkVertexPipelineStoresAndAtomics #-}
        writeVkVertexPipelineStoresAndAtomics p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, vertexPipelineStoresAndAtomics}

class HasVkFragmentStoresAndAtomics a where
        type VkFragmentStoresAndAtomicsMType a :: *

        vkFragmentStoresAndAtomics ::
                                   a -> VkFragmentStoresAndAtomicsMType a

        vkFragmentStoresAndAtomicsByteOffset :: a -> Int

        readVkFragmentStoresAndAtomics ::
                                       Ptr a -> IO (VkFragmentStoresAndAtomicsMType a)

        writeVkFragmentStoresAndAtomics ::
                                        Ptr a -> VkFragmentStoresAndAtomicsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'fragmentStoresAndAtomics'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFragmentStoresAndAtomics a

instance {-# OVERLAPPING #-}
         HasVkFragmentStoresAndAtomics VkPhysicalDeviceFeatures where
        type VkFragmentStoresAndAtomicsMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkFragmentStoresAndAtomics #-}
        vkFragmentStoresAndAtomics x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, fragmentStoresAndAtomics})

        {-# INLINE vkFragmentStoresAndAtomicsByteOffset #-}
        vkFragmentStoresAndAtomicsByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, fragmentStoresAndAtomics}

        {-# INLINE readVkFragmentStoresAndAtomics #-}
        readVkFragmentStoresAndAtomics p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, fragmentStoresAndAtomics}

        {-# INLINE writeVkFragmentStoresAndAtomics #-}
        writeVkFragmentStoresAndAtomics p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, fragmentStoresAndAtomics}

class HasVkShaderTessellationAndGeometryPointSize a where
        type VkShaderTessellationAndGeometryPointSizeMType a :: *

        vkShaderTessellationAndGeometryPointSize ::
                                                 a ->
                                                   VkShaderTessellationAndGeometryPointSizeMType a

        vkShaderTessellationAndGeometryPointSizeByteOffset :: a -> Int

        readVkShaderTessellationAndGeometryPointSize ::
                                                     Ptr a ->
                                                       IO
                                                         (VkShaderTessellationAndGeometryPointSizeMType
                                                            a)

        writeVkShaderTessellationAndGeometryPointSize ::
                                                      Ptr a ->
                                                        VkShaderTessellationAndGeometryPointSizeMType
                                                          a
                                                          -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderTessellationAndGeometryPointSize'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderTessellationAndGeometryPointSize a

instance {-# OVERLAPPING #-}
         HasVkShaderTessellationAndGeometryPointSize
           VkPhysicalDeviceFeatures
         where
        type VkShaderTessellationAndGeometryPointSizeMType
               VkPhysicalDeviceFeatures
             = VkBool32

        {-# NOINLINE vkShaderTessellationAndGeometryPointSize #-}
        vkShaderTessellationAndGeometryPointSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderTessellationAndGeometryPointSize})

        {-# INLINE vkShaderTessellationAndGeometryPointSizeByteOffset #-}
        vkShaderTessellationAndGeometryPointSizeByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderTessellationAndGeometryPointSize}

        {-# INLINE readVkShaderTessellationAndGeometryPointSize #-}
        readVkShaderTessellationAndGeometryPointSize p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderTessellationAndGeometryPointSize}

        {-# INLINE writeVkShaderTessellationAndGeometryPointSize #-}
        writeVkShaderTessellationAndGeometryPointSize p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderTessellationAndGeometryPointSize}

class HasVkShaderImageGatherExtended a where
        type VkShaderImageGatherExtendedMType a :: *

        vkShaderImageGatherExtended ::
                                    a -> VkShaderImageGatherExtendedMType a

        vkShaderImageGatherExtendedByteOffset :: a -> Int

        readVkShaderImageGatherExtended ::
                                        Ptr a -> IO (VkShaderImageGatherExtendedMType a)

        writeVkShaderImageGatherExtended ::
                                         Ptr a -> VkShaderImageGatherExtendedMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderImageGatherExtended'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderImageGatherExtended a

instance {-# OVERLAPPING #-}
         HasVkShaderImageGatherExtended VkPhysicalDeviceFeatures where
        type VkShaderImageGatherExtendedMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkShaderImageGatherExtended #-}
        vkShaderImageGatherExtended x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderImageGatherExtended})

        {-# INLINE vkShaderImageGatherExtendedByteOffset #-}
        vkShaderImageGatherExtendedByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderImageGatherExtended}

        {-# INLINE readVkShaderImageGatherExtended #-}
        readVkShaderImageGatherExtended p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderImageGatherExtended}

        {-# INLINE writeVkShaderImageGatherExtended #-}
        writeVkShaderImageGatherExtended p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderImageGatherExtended}

class HasVkShaderStorageImageExtendedFormats a where
        type VkShaderStorageImageExtendedFormatsMType a :: *

        vkShaderStorageImageExtendedFormats ::
                                            a -> VkShaderStorageImageExtendedFormatsMType a

        vkShaderStorageImageExtendedFormatsByteOffset :: a -> Int

        readVkShaderStorageImageExtendedFormats ::
                                                Ptr a ->
                                                  IO (VkShaderStorageImageExtendedFormatsMType a)

        writeVkShaderStorageImageExtendedFormats ::
                                                 Ptr a ->
                                                   VkShaderStorageImageExtendedFormatsMType a ->
                                                     IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderStorageImageExtendedFormats'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderStorageImageExtendedFormats a

instance {-# OVERLAPPING #-}
         HasVkShaderStorageImageExtendedFormats VkPhysicalDeviceFeatures
         where
        type VkShaderStorageImageExtendedFormatsMType
               VkPhysicalDeviceFeatures
             = VkBool32

        {-# NOINLINE vkShaderStorageImageExtendedFormats #-}
        vkShaderStorageImageExtendedFormats x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderStorageImageExtendedFormats})

        {-# INLINE vkShaderStorageImageExtendedFormatsByteOffset #-}
        vkShaderStorageImageExtendedFormatsByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderStorageImageExtendedFormats}

        {-# INLINE readVkShaderStorageImageExtendedFormats #-}
        readVkShaderStorageImageExtendedFormats p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderStorageImageExtendedFormats}

        {-# INLINE writeVkShaderStorageImageExtendedFormats #-}
        writeVkShaderStorageImageExtendedFormats p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderStorageImageExtendedFormats}

class HasVkShaderStorageImageMultisample a where
        type VkShaderStorageImageMultisampleMType a :: *

        vkShaderStorageImageMultisample ::
                                        a -> VkShaderStorageImageMultisampleMType a

        vkShaderStorageImageMultisampleByteOffset :: a -> Int

        readVkShaderStorageImageMultisample ::
                                            Ptr a -> IO (VkShaderStorageImageMultisampleMType a)

        writeVkShaderStorageImageMultisample ::
                                             Ptr a ->
                                               VkShaderStorageImageMultisampleMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderStorageImageMultisample'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderStorageImageMultisample a

instance {-# OVERLAPPING #-}
         HasVkShaderStorageImageMultisample VkPhysicalDeviceFeatures where
        type VkShaderStorageImageMultisampleMType VkPhysicalDeviceFeatures
             = VkBool32

        {-# NOINLINE vkShaderStorageImageMultisample #-}
        vkShaderStorageImageMultisample x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderStorageImageMultisample})

        {-# INLINE vkShaderStorageImageMultisampleByteOffset #-}
        vkShaderStorageImageMultisampleByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderStorageImageMultisample}

        {-# INLINE readVkShaderStorageImageMultisample #-}
        readVkShaderStorageImageMultisample p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderStorageImageMultisample}

        {-# INLINE writeVkShaderStorageImageMultisample #-}
        writeVkShaderStorageImageMultisample p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderStorageImageMultisample}

class HasVkShaderStorageImageReadWithoutFormat a where
        type VkShaderStorageImageReadWithoutFormatMType a :: *

        vkShaderStorageImageReadWithoutFormat ::
                                              a -> VkShaderStorageImageReadWithoutFormatMType a

        vkShaderStorageImageReadWithoutFormatByteOffset :: a -> Int

        readVkShaderStorageImageReadWithoutFormat ::
                                                  Ptr a ->
                                                    IO
                                                      (VkShaderStorageImageReadWithoutFormatMType a)

        writeVkShaderStorageImageReadWithoutFormat ::
                                                   Ptr a ->
                                                     VkShaderStorageImageReadWithoutFormatMType a ->
                                                       IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderStorageImageReadWithoutFormat'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderStorageImageReadWithoutFormat a

instance {-# OVERLAPPING #-}
         HasVkShaderStorageImageReadWithoutFormat VkPhysicalDeviceFeatures
         where
        type VkShaderStorageImageReadWithoutFormatMType
               VkPhysicalDeviceFeatures
             = VkBool32

        {-# NOINLINE vkShaderStorageImageReadWithoutFormat #-}
        vkShaderStorageImageReadWithoutFormat x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderStorageImageReadWithoutFormat})

        {-# INLINE vkShaderStorageImageReadWithoutFormatByteOffset #-}
        vkShaderStorageImageReadWithoutFormatByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderStorageImageReadWithoutFormat}

        {-# INLINE readVkShaderStorageImageReadWithoutFormat #-}
        readVkShaderStorageImageReadWithoutFormat p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderStorageImageReadWithoutFormat}

        {-# INLINE writeVkShaderStorageImageReadWithoutFormat #-}
        writeVkShaderStorageImageReadWithoutFormat p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderStorageImageReadWithoutFormat}

class HasVkShaderStorageImageWriteWithoutFormat a where
        type VkShaderStorageImageWriteWithoutFormatMType a :: *

        vkShaderStorageImageWriteWithoutFormat ::
                                               a -> VkShaderStorageImageWriteWithoutFormatMType a

        vkShaderStorageImageWriteWithoutFormatByteOffset :: a -> Int

        readVkShaderStorageImageWriteWithoutFormat ::
                                                   Ptr a ->
                                                     IO
                                                       (VkShaderStorageImageWriteWithoutFormatMType
                                                          a)

        writeVkShaderStorageImageWriteWithoutFormat ::
                                                    Ptr a ->
                                                      VkShaderStorageImageWriteWithoutFormatMType a
                                                        -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderStorageImageWriteWithoutFormat'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderStorageImageWriteWithoutFormat a

instance {-# OVERLAPPING #-}
         HasVkShaderStorageImageWriteWithoutFormat VkPhysicalDeviceFeatures
         where
        type VkShaderStorageImageWriteWithoutFormatMType
               VkPhysicalDeviceFeatures
             = VkBool32

        {-# NOINLINE vkShaderStorageImageWriteWithoutFormat #-}
        vkShaderStorageImageWriteWithoutFormat x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderStorageImageWriteWithoutFormat})

        {-# INLINE vkShaderStorageImageWriteWithoutFormatByteOffset #-}
        vkShaderStorageImageWriteWithoutFormatByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderStorageImageWriteWithoutFormat}

        {-# INLINE readVkShaderStorageImageWriteWithoutFormat #-}
        readVkShaderStorageImageWriteWithoutFormat p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderStorageImageWriteWithoutFormat}

        {-# INLINE writeVkShaderStorageImageWriteWithoutFormat #-}
        writeVkShaderStorageImageWriteWithoutFormat p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderStorageImageWriteWithoutFormat}

class HasVkShaderUniformBufferArrayDynamicIndexing a where
        type VkShaderUniformBufferArrayDynamicIndexingMType a :: *

        vkShaderUniformBufferArrayDynamicIndexing ::
                                                  a ->
                                                    VkShaderUniformBufferArrayDynamicIndexingMType a

        vkShaderUniformBufferArrayDynamicIndexingByteOffset :: a -> Int

        readVkShaderUniformBufferArrayDynamicIndexing ::
                                                      Ptr a ->
                                                        IO
                                                          (VkShaderUniformBufferArrayDynamicIndexingMType
                                                             a)

        writeVkShaderUniformBufferArrayDynamicIndexing ::
                                                       Ptr a ->
                                                         VkShaderUniformBufferArrayDynamicIndexingMType
                                                           a
                                                           -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderUniformBufferArrayDynamicIndexing'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderUniformBufferArrayDynamicIndexing a

instance {-# OVERLAPPING #-}
         HasVkShaderUniformBufferArrayDynamicIndexing
           VkPhysicalDeviceFeatures
         where
        type VkShaderUniformBufferArrayDynamicIndexingMType
               VkPhysicalDeviceFeatures
             = VkBool32

        {-# NOINLINE vkShaderUniformBufferArrayDynamicIndexing #-}
        vkShaderUniformBufferArrayDynamicIndexing x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderUniformBufferArrayDynamicIndexing})

        {-# INLINE vkShaderUniformBufferArrayDynamicIndexingByteOffset #-}
        vkShaderUniformBufferArrayDynamicIndexingByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderUniformBufferArrayDynamicIndexing}

        {-# INLINE readVkShaderUniformBufferArrayDynamicIndexing #-}
        readVkShaderUniformBufferArrayDynamicIndexing p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderUniformBufferArrayDynamicIndexing}

        {-# INLINE writeVkShaderUniformBufferArrayDynamicIndexing #-}
        writeVkShaderUniformBufferArrayDynamicIndexing p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderUniformBufferArrayDynamicIndexing}

class HasVkShaderSampledImageArrayDynamicIndexing a where
        type VkShaderSampledImageArrayDynamicIndexingMType a :: *

        vkShaderSampledImageArrayDynamicIndexing ::
                                                 a ->
                                                   VkShaderSampledImageArrayDynamicIndexingMType a

        vkShaderSampledImageArrayDynamicIndexingByteOffset :: a -> Int

        readVkShaderSampledImageArrayDynamicIndexing ::
                                                     Ptr a ->
                                                       IO
                                                         (VkShaderSampledImageArrayDynamicIndexingMType
                                                            a)

        writeVkShaderSampledImageArrayDynamicIndexing ::
                                                      Ptr a ->
                                                        VkShaderSampledImageArrayDynamicIndexingMType
                                                          a
                                                          -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderSampledImageArrayDynamicIndexing'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderSampledImageArrayDynamicIndexing a

instance {-# OVERLAPPING #-}
         HasVkShaderSampledImageArrayDynamicIndexing
           VkPhysicalDeviceFeatures
         where
        type VkShaderSampledImageArrayDynamicIndexingMType
               VkPhysicalDeviceFeatures
             = VkBool32

        {-# NOINLINE vkShaderSampledImageArrayDynamicIndexing #-}
        vkShaderSampledImageArrayDynamicIndexing x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderSampledImageArrayDynamicIndexing})

        {-# INLINE vkShaderSampledImageArrayDynamicIndexingByteOffset #-}
        vkShaderSampledImageArrayDynamicIndexingByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderSampledImageArrayDynamicIndexing}

        {-# INLINE readVkShaderSampledImageArrayDynamicIndexing #-}
        readVkShaderSampledImageArrayDynamicIndexing p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderSampledImageArrayDynamicIndexing}

        {-# INLINE writeVkShaderSampledImageArrayDynamicIndexing #-}
        writeVkShaderSampledImageArrayDynamicIndexing p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderSampledImageArrayDynamicIndexing}

class HasVkShaderStorageBufferArrayDynamicIndexing a where
        type VkShaderStorageBufferArrayDynamicIndexingMType a :: *

        vkShaderStorageBufferArrayDynamicIndexing ::
                                                  a ->
                                                    VkShaderStorageBufferArrayDynamicIndexingMType a

        vkShaderStorageBufferArrayDynamicIndexingByteOffset :: a -> Int

        readVkShaderStorageBufferArrayDynamicIndexing ::
                                                      Ptr a ->
                                                        IO
                                                          (VkShaderStorageBufferArrayDynamicIndexingMType
                                                             a)

        writeVkShaderStorageBufferArrayDynamicIndexing ::
                                                       Ptr a ->
                                                         VkShaderStorageBufferArrayDynamicIndexingMType
                                                           a
                                                           -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderStorageBufferArrayDynamicIndexing'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderStorageBufferArrayDynamicIndexing a

instance {-# OVERLAPPING #-}
         HasVkShaderStorageBufferArrayDynamicIndexing
           VkPhysicalDeviceFeatures
         where
        type VkShaderStorageBufferArrayDynamicIndexingMType
               VkPhysicalDeviceFeatures
             = VkBool32

        {-# NOINLINE vkShaderStorageBufferArrayDynamicIndexing #-}
        vkShaderStorageBufferArrayDynamicIndexing x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderStorageBufferArrayDynamicIndexing})

        {-# INLINE vkShaderStorageBufferArrayDynamicIndexingByteOffset #-}
        vkShaderStorageBufferArrayDynamicIndexingByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderStorageBufferArrayDynamicIndexing}

        {-# INLINE readVkShaderStorageBufferArrayDynamicIndexing #-}
        readVkShaderStorageBufferArrayDynamicIndexing p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderStorageBufferArrayDynamicIndexing}

        {-# INLINE writeVkShaderStorageBufferArrayDynamicIndexing #-}
        writeVkShaderStorageBufferArrayDynamicIndexing p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderStorageBufferArrayDynamicIndexing}

class HasVkShaderStorageImageArrayDynamicIndexing a where
        type VkShaderStorageImageArrayDynamicIndexingMType a :: *

        vkShaderStorageImageArrayDynamicIndexing ::
                                                 a ->
                                                   VkShaderStorageImageArrayDynamicIndexingMType a

        vkShaderStorageImageArrayDynamicIndexingByteOffset :: a -> Int

        readVkShaderStorageImageArrayDynamicIndexing ::
                                                     Ptr a ->
                                                       IO
                                                         (VkShaderStorageImageArrayDynamicIndexingMType
                                                            a)

        writeVkShaderStorageImageArrayDynamicIndexing ::
                                                      Ptr a ->
                                                        VkShaderStorageImageArrayDynamicIndexingMType
                                                          a
                                                          -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderStorageImageArrayDynamicIndexing'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderStorageImageArrayDynamicIndexing a

instance {-# OVERLAPPING #-}
         HasVkShaderStorageImageArrayDynamicIndexing
           VkPhysicalDeviceFeatures
         where
        type VkShaderStorageImageArrayDynamicIndexingMType
               VkPhysicalDeviceFeatures
             = VkBool32

        {-# NOINLINE vkShaderStorageImageArrayDynamicIndexing #-}
        vkShaderStorageImageArrayDynamicIndexing x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderStorageImageArrayDynamicIndexing})

        {-# INLINE vkShaderStorageImageArrayDynamicIndexingByteOffset #-}
        vkShaderStorageImageArrayDynamicIndexingByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderStorageImageArrayDynamicIndexing}

        {-# INLINE readVkShaderStorageImageArrayDynamicIndexing #-}
        readVkShaderStorageImageArrayDynamicIndexing p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderStorageImageArrayDynamicIndexing}

        {-# INLINE writeVkShaderStorageImageArrayDynamicIndexing #-}
        writeVkShaderStorageImageArrayDynamicIndexing p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderStorageImageArrayDynamicIndexing}

class HasVkShaderClipDistance a where
        type VkShaderClipDistanceMType a :: *

        vkShaderClipDistance :: a -> VkShaderClipDistanceMType a

        vkShaderClipDistanceByteOffset :: a -> Int

        readVkShaderClipDistance ::
                                 Ptr a -> IO (VkShaderClipDistanceMType a)

        writeVkShaderClipDistance ::
                                  Ptr a -> VkShaderClipDistanceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderClipDistance'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderClipDistance a

instance {-# OVERLAPPING #-}
         HasVkShaderClipDistance VkPhysicalDeviceFeatures where
        type VkShaderClipDistanceMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkShaderClipDistance #-}
        vkShaderClipDistance x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderClipDistance})

        {-# INLINE vkShaderClipDistanceByteOffset #-}
        vkShaderClipDistanceByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderClipDistance}

        {-# INLINE readVkShaderClipDistance #-}
        readVkShaderClipDistance p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderClipDistance}

        {-# INLINE writeVkShaderClipDistance #-}
        writeVkShaderClipDistance p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderClipDistance}

class HasVkShaderCullDistance a where
        type VkShaderCullDistanceMType a :: *

        vkShaderCullDistance :: a -> VkShaderCullDistanceMType a

        vkShaderCullDistanceByteOffset :: a -> Int

        readVkShaderCullDistance ::
                                 Ptr a -> IO (VkShaderCullDistanceMType a)

        writeVkShaderCullDistance ::
                                  Ptr a -> VkShaderCullDistanceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderCullDistance'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderCullDistance a

instance {-# OVERLAPPING #-}
         HasVkShaderCullDistance VkPhysicalDeviceFeatures where
        type VkShaderCullDistanceMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkShaderCullDistance #-}
        vkShaderCullDistance x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderCullDistance})

        {-# INLINE vkShaderCullDistanceByteOffset #-}
        vkShaderCullDistanceByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderCullDistance}

        {-# INLINE readVkShaderCullDistance #-}
        readVkShaderCullDistance p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderCullDistance}

        {-# INLINE writeVkShaderCullDistance #-}
        writeVkShaderCullDistance p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderCullDistance}

class HasVkShaderFloat64 a where
        type VkShaderFloat64MType a :: *

        vkShaderFloat64 :: a -> VkShaderFloat64MType a

        vkShaderFloat64ByteOffset :: a -> Int

        readVkShaderFloat64 :: Ptr a -> IO (VkShaderFloat64MType a)

        writeVkShaderFloat64 :: Ptr a -> VkShaderFloat64MType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderFloat64'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderFloat64 a

instance {-# OVERLAPPING #-}
         HasVkShaderFloat64 VkPhysicalDeviceFeatures where
        type VkShaderFloat64MType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkShaderFloat64 #-}
        vkShaderFloat64 x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderFloat64})

        {-# INLINE vkShaderFloat64ByteOffset #-}
        vkShaderFloat64ByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderFloat64}

        {-# INLINE readVkShaderFloat64 #-}
        readVkShaderFloat64 p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderFloat64}

        {-# INLINE writeVkShaderFloat64 #-}
        writeVkShaderFloat64 p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderFloat64}

class HasVkShaderInt64 a where
        type VkShaderInt64MType a :: *

        vkShaderInt64 :: a -> VkShaderInt64MType a

        vkShaderInt64ByteOffset :: a -> Int

        readVkShaderInt64 :: Ptr a -> IO (VkShaderInt64MType a)

        writeVkShaderInt64 :: Ptr a -> VkShaderInt64MType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderInt64'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderInt64 a

instance {-# OVERLAPPING #-}
         HasVkShaderInt64 VkPhysicalDeviceFeatures where
        type VkShaderInt64MType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkShaderInt64 #-}
        vkShaderInt64 x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderInt64})

        {-# INLINE vkShaderInt64ByteOffset #-}
        vkShaderInt64ByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderInt64}

        {-# INLINE readVkShaderInt64 #-}
        readVkShaderInt64 p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderInt64}

        {-# INLINE writeVkShaderInt64 #-}
        writeVkShaderInt64 p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderInt64}

class HasVkShaderInt16 a where
        type VkShaderInt16MType a :: *

        vkShaderInt16 :: a -> VkShaderInt16MType a

        vkShaderInt16ByteOffset :: a -> Int

        readVkShaderInt16 :: Ptr a -> IO (VkShaderInt16MType a)

        writeVkShaderInt16 :: Ptr a -> VkShaderInt16MType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderInt16'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderInt16 a

instance {-# OVERLAPPING #-}
         HasVkShaderInt16 VkPhysicalDeviceFeatures where
        type VkShaderInt16MType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkShaderInt16 #-}
        vkShaderInt16 x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderInt16})

        {-# INLINE vkShaderInt16ByteOffset #-}
        vkShaderInt16ByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderInt16}

        {-# INLINE readVkShaderInt16 #-}
        readVkShaderInt16 p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderInt16}

        {-# INLINE writeVkShaderInt16 #-}
        writeVkShaderInt16 p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderInt16}

class HasVkShaderResourceResidency a where
        type VkShaderResourceResidencyMType a :: *

        vkShaderResourceResidency :: a -> VkShaderResourceResidencyMType a

        vkShaderResourceResidencyByteOffset :: a -> Int

        readVkShaderResourceResidency ::
                                      Ptr a -> IO (VkShaderResourceResidencyMType a)

        writeVkShaderResourceResidency ::
                                       Ptr a -> VkShaderResourceResidencyMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderResourceResidency'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderResourceResidency a

instance {-# OVERLAPPING #-}
         HasVkShaderResourceResidency VkPhysicalDeviceFeatures where
        type VkShaderResourceResidencyMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkShaderResourceResidency #-}
        vkShaderResourceResidency x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderResourceResidency})

        {-# INLINE vkShaderResourceResidencyByteOffset #-}
        vkShaderResourceResidencyByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderResourceResidency}

        {-# INLINE readVkShaderResourceResidency #-}
        readVkShaderResourceResidency p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderResourceResidency}

        {-# INLINE writeVkShaderResourceResidency #-}
        writeVkShaderResourceResidency p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderResourceResidency}

class HasVkShaderResourceMinLod a where
        type VkShaderResourceMinLodMType a :: *

        vkShaderResourceMinLod :: a -> VkShaderResourceMinLodMType a

        vkShaderResourceMinLodByteOffset :: a -> Int

        readVkShaderResourceMinLod ::
                                   Ptr a -> IO (VkShaderResourceMinLodMType a)

        writeVkShaderResourceMinLod ::
                                    Ptr a -> VkShaderResourceMinLodMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderResourceMinLod'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderResourceMinLod a

instance {-# OVERLAPPING #-}
         HasVkShaderResourceMinLod VkPhysicalDeviceFeatures where
        type VkShaderResourceMinLodMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkShaderResourceMinLod #-}
        vkShaderResourceMinLod x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, shaderResourceMinLod})

        {-# INLINE vkShaderResourceMinLodByteOffset #-}
        vkShaderResourceMinLodByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderResourceMinLod}

        {-# INLINE readVkShaderResourceMinLod #-}
        readVkShaderResourceMinLod p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderResourceMinLod}

        {-# INLINE writeVkShaderResourceMinLod #-}
        writeVkShaderResourceMinLod p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, shaderResourceMinLod}

class HasVkSparseBinding a where
        type VkSparseBindingMType a :: *

        vkSparseBinding :: a -> VkSparseBindingMType a

        vkSparseBindingByteOffset :: a -> Int

        readVkSparseBinding :: Ptr a -> IO (VkSparseBindingMType a)

        writeVkSparseBinding :: Ptr a -> VkSparseBindingMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseBinding'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseBinding a

instance {-# OVERLAPPING #-}
         HasVkSparseBinding VkPhysicalDeviceFeatures where
        type VkSparseBindingMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkSparseBinding #-}
        vkSparseBinding x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, sparseBinding})

        {-# INLINE vkSparseBindingByteOffset #-}
        vkSparseBindingByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseBinding}

        {-# INLINE readVkSparseBinding #-}
        readVkSparseBinding p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseBinding}

        {-# INLINE writeVkSparseBinding #-}
        writeVkSparseBinding p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseBinding}

class HasVkSparseResidencyBuffer a where
        type VkSparseResidencyBufferMType a :: *

        vkSparseResidencyBuffer :: a -> VkSparseResidencyBufferMType a

        vkSparseResidencyBufferByteOffset :: a -> Int

        readVkSparseResidencyBuffer ::
                                    Ptr a -> IO (VkSparseResidencyBufferMType a)

        writeVkSparseResidencyBuffer ::
                                     Ptr a -> VkSparseResidencyBufferMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidencyBuffer'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidencyBuffer a

instance {-# OVERLAPPING #-}
         HasVkSparseResidencyBuffer VkPhysicalDeviceFeatures where
        type VkSparseResidencyBufferMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkSparseResidencyBuffer #-}
        vkSparseResidencyBuffer x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, sparseResidencyBuffer})

        {-# INLINE vkSparseResidencyBufferByteOffset #-}
        vkSparseResidencyBufferByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidencyBuffer}

        {-# INLINE readVkSparseResidencyBuffer #-}
        readVkSparseResidencyBuffer p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidencyBuffer}

        {-# INLINE writeVkSparseResidencyBuffer #-}
        writeVkSparseResidencyBuffer p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidencyBuffer}

class HasVkSparseResidencyImage2D a where
        type VkSparseResidencyImage2DMType a :: *

        vkSparseResidencyImage2D :: a -> VkSparseResidencyImage2DMType a

        vkSparseResidencyImage2DByteOffset :: a -> Int

        readVkSparseResidencyImage2D ::
                                     Ptr a -> IO (VkSparseResidencyImage2DMType a)

        writeVkSparseResidencyImage2D ::
                                      Ptr a -> VkSparseResidencyImage2DMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidencyImage2D'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidencyImage2D a

instance {-# OVERLAPPING #-}
         HasVkSparseResidencyImage2D VkPhysicalDeviceFeatures where
        type VkSparseResidencyImage2DMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkSparseResidencyImage2D #-}
        vkSparseResidencyImage2D x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, sparseResidencyImage2D})

        {-# INLINE vkSparseResidencyImage2DByteOffset #-}
        vkSparseResidencyImage2DByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidencyImage2D}

        {-# INLINE readVkSparseResidencyImage2D #-}
        readVkSparseResidencyImage2D p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidencyImage2D}

        {-# INLINE writeVkSparseResidencyImage2D #-}
        writeVkSparseResidencyImage2D p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidencyImage2D}

class HasVkSparseResidencyImage3D a where
        type VkSparseResidencyImage3DMType a :: *

        vkSparseResidencyImage3D :: a -> VkSparseResidencyImage3DMType a

        vkSparseResidencyImage3DByteOffset :: a -> Int

        readVkSparseResidencyImage3D ::
                                     Ptr a -> IO (VkSparseResidencyImage3DMType a)

        writeVkSparseResidencyImage3D ::
                                      Ptr a -> VkSparseResidencyImage3DMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidencyImage3D'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidencyImage3D a

instance {-# OVERLAPPING #-}
         HasVkSparseResidencyImage3D VkPhysicalDeviceFeatures where
        type VkSparseResidencyImage3DMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkSparseResidencyImage3D #-}
        vkSparseResidencyImage3D x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, sparseResidencyImage3D})

        {-# INLINE vkSparseResidencyImage3DByteOffset #-}
        vkSparseResidencyImage3DByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidencyImage3D}

        {-# INLINE readVkSparseResidencyImage3D #-}
        readVkSparseResidencyImage3D p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidencyImage3D}

        {-# INLINE writeVkSparseResidencyImage3D #-}
        writeVkSparseResidencyImage3D p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidencyImage3D}

class HasVkSparseResidency2Samples a where
        type VkSparseResidency2SamplesMType a :: *

        vkSparseResidency2Samples :: a -> VkSparseResidency2SamplesMType a

        vkSparseResidency2SamplesByteOffset :: a -> Int

        readVkSparseResidency2Samples ::
                                      Ptr a -> IO (VkSparseResidency2SamplesMType a)

        writeVkSparseResidency2Samples ::
                                       Ptr a -> VkSparseResidency2SamplesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidency2Samples'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidency2Samples a

instance {-# OVERLAPPING #-}
         HasVkSparseResidency2Samples VkPhysicalDeviceFeatures where
        type VkSparseResidency2SamplesMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkSparseResidency2Samples #-}
        vkSparseResidency2Samples x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, sparseResidency2Samples})

        {-# INLINE vkSparseResidency2SamplesByteOffset #-}
        vkSparseResidency2SamplesByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidency2Samples}

        {-# INLINE readVkSparseResidency2Samples #-}
        readVkSparseResidency2Samples p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidency2Samples}

        {-# INLINE writeVkSparseResidency2Samples #-}
        writeVkSparseResidency2Samples p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidency2Samples}

class HasVkSparseResidency4Samples a where
        type VkSparseResidency4SamplesMType a :: *

        vkSparseResidency4Samples :: a -> VkSparseResidency4SamplesMType a

        vkSparseResidency4SamplesByteOffset :: a -> Int

        readVkSparseResidency4Samples ::
                                      Ptr a -> IO (VkSparseResidency4SamplesMType a)

        writeVkSparseResidency4Samples ::
                                       Ptr a -> VkSparseResidency4SamplesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidency4Samples'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidency4Samples a

instance {-# OVERLAPPING #-}
         HasVkSparseResidency4Samples VkPhysicalDeviceFeatures where
        type VkSparseResidency4SamplesMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkSparseResidency4Samples #-}
        vkSparseResidency4Samples x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, sparseResidency4Samples})

        {-# INLINE vkSparseResidency4SamplesByteOffset #-}
        vkSparseResidency4SamplesByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidency4Samples}

        {-# INLINE readVkSparseResidency4Samples #-}
        readVkSparseResidency4Samples p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidency4Samples}

        {-# INLINE writeVkSparseResidency4Samples #-}
        writeVkSparseResidency4Samples p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidency4Samples}

class HasVkSparseResidency8Samples a where
        type VkSparseResidency8SamplesMType a :: *

        vkSparseResidency8Samples :: a -> VkSparseResidency8SamplesMType a

        vkSparseResidency8SamplesByteOffset :: a -> Int

        readVkSparseResidency8Samples ::
                                      Ptr a -> IO (VkSparseResidency8SamplesMType a)

        writeVkSparseResidency8Samples ::
                                       Ptr a -> VkSparseResidency8SamplesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidency8Samples'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidency8Samples a

instance {-# OVERLAPPING #-}
         HasVkSparseResidency8Samples VkPhysicalDeviceFeatures where
        type VkSparseResidency8SamplesMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkSparseResidency8Samples #-}
        vkSparseResidency8Samples x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, sparseResidency8Samples})

        {-# INLINE vkSparseResidency8SamplesByteOffset #-}
        vkSparseResidency8SamplesByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidency8Samples}

        {-# INLINE readVkSparseResidency8Samples #-}
        readVkSparseResidency8Samples p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidency8Samples}

        {-# INLINE writeVkSparseResidency8Samples #-}
        writeVkSparseResidency8Samples p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidency8Samples}

class HasVkSparseResidency16Samples a where
        type VkSparseResidency16SamplesMType a :: *

        vkSparseResidency16Samples ::
                                   a -> VkSparseResidency16SamplesMType a

        vkSparseResidency16SamplesByteOffset :: a -> Int

        readVkSparseResidency16Samples ::
                                       Ptr a -> IO (VkSparseResidency16SamplesMType a)

        writeVkSparseResidency16Samples ::
                                        Ptr a -> VkSparseResidency16SamplesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidency16Samples'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidency16Samples a

instance {-# OVERLAPPING #-}
         HasVkSparseResidency16Samples VkPhysicalDeviceFeatures where
        type VkSparseResidency16SamplesMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkSparseResidency16Samples #-}
        vkSparseResidency16Samples x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, sparseResidency16Samples})

        {-# INLINE vkSparseResidency16SamplesByteOffset #-}
        vkSparseResidency16SamplesByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidency16Samples}

        {-# INLINE readVkSparseResidency16Samples #-}
        readVkSparseResidency16Samples p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidency16Samples}

        {-# INLINE writeVkSparseResidency16Samples #-}
        writeVkSparseResidency16Samples p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidency16Samples}

class HasVkSparseResidencyAliased a where
        type VkSparseResidencyAliasedMType a :: *

        vkSparseResidencyAliased :: a -> VkSparseResidencyAliasedMType a

        vkSparseResidencyAliasedByteOffset :: a -> Int

        readVkSparseResidencyAliased ::
                                     Ptr a -> IO (VkSparseResidencyAliasedMType a)

        writeVkSparseResidencyAliased ::
                                      Ptr a -> VkSparseResidencyAliasedMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidencyAliased'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidencyAliased a

instance {-# OVERLAPPING #-}
         HasVkSparseResidencyAliased VkPhysicalDeviceFeatures where
        type VkSparseResidencyAliasedMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkSparseResidencyAliased #-}
        vkSparseResidencyAliased x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, sparseResidencyAliased})

        {-# INLINE vkSparseResidencyAliasedByteOffset #-}
        vkSparseResidencyAliasedByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidencyAliased}

        {-# INLINE readVkSparseResidencyAliased #-}
        readVkSparseResidencyAliased p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidencyAliased}

        {-# INLINE writeVkSparseResidencyAliased #-}
        writeVkSparseResidencyAliased p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, sparseResidencyAliased}

class HasVkVariableMultisampleRate a where
        type VkVariableMultisampleRateMType a :: *

        vkVariableMultisampleRate :: a -> VkVariableMultisampleRateMType a

        vkVariableMultisampleRateByteOffset :: a -> Int

        readVkVariableMultisampleRate ::
                                      Ptr a -> IO (VkVariableMultisampleRateMType a)

        writeVkVariableMultisampleRate ::
                                       Ptr a -> VkVariableMultisampleRateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'variableMultisampleRate'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkVariableMultisampleRate a

instance {-# OVERLAPPING #-}
         HasVkVariableMultisampleRate VkPhysicalDeviceFeatures where
        type VkVariableMultisampleRateMType VkPhysicalDeviceFeatures =
             VkBool32

        {-# NOINLINE vkVariableMultisampleRate #-}
        vkVariableMultisampleRate x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, variableMultisampleRate})

        {-# INLINE vkVariableMultisampleRateByteOffset #-}
        vkVariableMultisampleRateByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, variableMultisampleRate}

        {-# INLINE readVkVariableMultisampleRate #-}
        readVkVariableMultisampleRate p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, variableMultisampleRate}

        {-# INLINE writeVkVariableMultisampleRate #-}
        writeVkVariableMultisampleRate p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, variableMultisampleRate}

class HasVkInheritedQueries a where
        type VkInheritedQueriesMType a :: *

        vkInheritedQueries :: a -> VkInheritedQueriesMType a

        vkInheritedQueriesByteOffset :: a -> Int

        readVkInheritedQueries :: Ptr a -> IO (VkInheritedQueriesMType a)

        writeVkInheritedQueries ::
                                Ptr a -> VkInheritedQueriesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'inheritedQueries'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkInheritedQueries a

instance {-# OVERLAPPING #-}
         HasVkInheritedQueries VkPhysicalDeviceFeatures where
        type VkInheritedQueriesMType VkPhysicalDeviceFeatures = VkBool32

        {-# NOINLINE vkInheritedQueries #-}
        vkInheritedQueries x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceFeatures, inheritedQueries})

        {-# INLINE vkInheritedQueriesByteOffset #-}
        vkInheritedQueriesByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, inheritedQueries}

        {-# INLINE readVkInheritedQueries #-}
        readVkInheritedQueries p
          = peekByteOff p
              #{offset VkPhysicalDeviceFeatures, inheritedQueries}

        {-# INLINE writeVkInheritedQueries #-}
        writeVkInheritedQueries p
          = pokeByteOff p
              #{offset VkPhysicalDeviceFeatures, inheritedQueries}

instance Show VkPhysicalDeviceFeatures where
        showsPrec d x
          = showString "VkPhysicalDeviceFeatures {" .
              showString "vkRobustBufferAccess = " .
                showsPrec d (vkRobustBufferAccess x) .
                  showString ", " .
                    showString "vkFullDrawIndexUint32 = " .
                      showsPrec d (vkFullDrawIndexUint32 x) .
                        showString ", " .
                          showString "vkImageCubeArray = " .
                            showsPrec d (vkImageCubeArray x) .
                              showString ", " .
                                showString "vkIndependentBlend = " .
                                  showsPrec d (vkIndependentBlend x) .
                                    showString ", " .
                                      showString "vkGeometryShader = " .
                                        showsPrec d (vkGeometryShader x) .
                                          showString ", " .
                                            showString "vkTessellationShader = " .
                                              showsPrec d (vkTessellationShader x) .
                                                showString ", " .
                                                  showString "vkSampleRateShading = " .
                                                    showsPrec d (vkSampleRateShading x) .
                                                      showString ", " .
                                                        showString "vkDualSrcBlend = " .
                                                          showsPrec d (vkDualSrcBlend x) .
                                                            showString ", " .
                                                              showString "vkLogicOp = " .
                                                                showsPrec d (vkLogicOp x) .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkMultiDrawIndirect = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkMultiDrawIndirect x)
                                                                        .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkDrawIndirectFirstInstance = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkDrawIndirectFirstInstance
                                                                                 x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkDepthClamp = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkDepthClamp x)
                                                                                    .
                                                                                    showString ", "
                                                                                      .
                                                                                      showString
                                                                                        "vkDepthBiasClamp = "
                                                                                        .
                                                                                        showsPrec d
                                                                                          (vkDepthBiasClamp
                                                                                             x)
                                                                                          .
                                                                                          showString
                                                                                            ", "
                                                                                            .
                                                                                            showString
                                                                                              "vkFillModeNonSolid = "
                                                                                              .
                                                                                              showsPrec
                                                                                                d
                                                                                                (vkFillModeNonSolid
                                                                                                   x)
                                                                                                .
                                                                                                showString
                                                                                                  ", "
                                                                                                  .
                                                                                                  showString
                                                                                                    "vkDepthBounds = "
                                                                                                    .
                                                                                                    showsPrec
                                                                                                      d
                                                                                                      (vkDepthBounds
                                                                                                         x)
                                                                                                      .
                                                                                                      showString
                                                                                                        ", "
                                                                                                        .
                                                                                                        showString
                                                                                                          "vkWideLines = "
                                                                                                          .
                                                                                                          showsPrec
                                                                                                            d
                                                                                                            (vkWideLines
                                                                                                               x)
                                                                                                            .
                                                                                                            showString
                                                                                                              ", "
                                                                                                              .
                                                                                                              showString
                                                                                                                "vkLargePoints = "
                                                                                                                .
                                                                                                                showsPrec
                                                                                                                  d
                                                                                                                  (vkLargePoints
                                                                                                                     x)
                                                                                                                  .
                                                                                                                  showString
                                                                                                                    ", "
                                                                                                                    .
                                                                                                                    showString
                                                                                                                      "vkAlphaToOne = "
                                                                                                                      .
                                                                                                                      showsPrec
                                                                                                                        d
                                                                                                                        (vkAlphaToOne
                                                                                                                           x)
                                                                                                                        .
                                                                                                                        showString
                                                                                                                          ", "
                                                                                                                          .
                                                                                                                          showString
                                                                                                                            "vkMultiViewport = "
                                                                                                                            .
                                                                                                                            showsPrec
                                                                                                                              d
                                                                                                                              (vkMultiViewport
                                                                                                                                 x)
                                                                                                                              .
                                                                                                                              showString
                                                                                                                                ", "
                                                                                                                                .
                                                                                                                                showString
                                                                                                                                  "vkSamplerAnisotropy = "
                                                                                                                                  .
                                                                                                                                  showsPrec
                                                                                                                                    d
                                                                                                                                    (vkSamplerAnisotropy
                                                                                                                                       x)
                                                                                                                                    .
                                                                                                                                    showString
                                                                                                                                      ", "
                                                                                                                                      .
                                                                                                                                      showString
                                                                                                                                        "vkTextureCompressionETC2 = "
                                                                                                                                        .
                                                                                                                                        showsPrec
                                                                                                                                          d
                                                                                                                                          (vkTextureCompressionETC2
                                                                                                                                             x)
                                                                                                                                          .
                                                                                                                                          showString
                                                                                                                                            ", "
                                                                                                                                            .
                                                                                                                                            showString
                                                                                                                                              "vkTextureCompressionASTC_LDR = "
                                                                                                                                              .
                                                                                                                                              showsPrec
                                                                                                                                                d
                                                                                                                                                (vkTextureCompressionASTC_LDR
                                                                                                                                                   x)
                                                                                                                                                .
                                                                                                                                                showString
                                                                                                                                                  ", "
                                                                                                                                                  .
                                                                                                                                                  showString
                                                                                                                                                    "vkTextureCompressionBC = "
                                                                                                                                                    .
                                                                                                                                                    showsPrec
                                                                                                                                                      d
                                                                                                                                                      (vkTextureCompressionBC
                                                                                                                                                         x)
                                                                                                                                                      .
                                                                                                                                                      showString
                                                                                                                                                        ", "
                                                                                                                                                        .
                                                                                                                                                        showString
                                                                                                                                                          "vkOcclusionQueryPrecise = "
                                                                                                                                                          .
                                                                                                                                                          showsPrec
                                                                                                                                                            d
                                                                                                                                                            (vkOcclusionQueryPrecise
                                                                                                                                                               x)
                                                                                                                                                            .
                                                                                                                                                            showString
                                                                                                                                                              ", "
                                                                                                                                                              .
                                                                                                                                                              showString
                                                                                                                                                                "vkPipelineStatisticsQuery = "
                                                                                                                                                                .
                                                                                                                                                                showsPrec
                                                                                                                                                                  d
                                                                                                                                                                  (vkPipelineStatisticsQuery
                                                                                                                                                                     x)
                                                                                                                                                                  .
                                                                                                                                                                  showString
                                                                                                                                                                    ", "
                                                                                                                                                                    .
                                                                                                                                                                    showString
                                                                                                                                                                      "vkVertexPipelineStoresAndAtomics = "
                                                                                                                                                                      .
                                                                                                                                                                      showsPrec
                                                                                                                                                                        d
                                                                                                                                                                        (vkVertexPipelineStoresAndAtomics
                                                                                                                                                                           x)
                                                                                                                                                                        .
                                                                                                                                                                        showString
                                                                                                                                                                          ", "
                                                                                                                                                                          .
                                                                                                                                                                          showString
                                                                                                                                                                            "vkFragmentStoresAndAtomics = "
                                                                                                                                                                            .
                                                                                                                                                                            showsPrec
                                                                                                                                                                              d
                                                                                                                                                                              (vkFragmentStoresAndAtomics
                                                                                                                                                                                 x)
                                                                                                                                                                              .
                                                                                                                                                                              showString
                                                                                                                                                                                ", "
                                                                                                                                                                                .
                                                                                                                                                                                showString
                                                                                                                                                                                  "vkShaderTessellationAndGeometryPointSize = "
                                                                                                                                                                                  .
                                                                                                                                                                                  showsPrec
                                                                                                                                                                                    d
                                                                                                                                                                                    (vkShaderTessellationAndGeometryPointSize
                                                                                                                                                                                       x)
                                                                                                                                                                                    .
                                                                                                                                                                                    showString
                                                                                                                                                                                      ", "
                                                                                                                                                                                      .
                                                                                                                                                                                      showString
                                                                                                                                                                                        "vkShaderImageGatherExtended = "
                                                                                                                                                                                        .
                                                                                                                                                                                        showsPrec
                                                                                                                                                                                          d
                                                                                                                                                                                          (vkShaderImageGatherExtended
                                                                                                                                                                                             x)
                                                                                                                                                                                          .
                                                                                                                                                                                          showString
                                                                                                                                                                                            ", "
                                                                                                                                                                                            .
                                                                                                                                                                                            showString
                                                                                                                                                                                              "vkShaderStorageImageExtendedFormats = "
                                                                                                                                                                                              .
                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                d
                                                                                                                                                                                                (vkShaderStorageImageExtendedFormats
                                                                                                                                                                                                   x)
                                                                                                                                                                                                .
                                                                                                                                                                                                showString
                                                                                                                                                                                                  ", "
                                                                                                                                                                                                  .
                                                                                                                                                                                                  showString
                                                                                                                                                                                                    "vkShaderStorageImageMultisample = "
                                                                                                                                                                                                    .
                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                      d
                                                                                                                                                                                                      (vkShaderStorageImageMultisample
                                                                                                                                                                                                         x)
                                                                                                                                                                                                      .
                                                                                                                                                                                                      showString
                                                                                                                                                                                                        ", "
                                                                                                                                                                                                        .
                                                                                                                                                                                                        showString
                                                                                                                                                                                                          "vkShaderStorageImageReadWithoutFormat = "
                                                                                                                                                                                                          .
                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                            d
                                                                                                                                                                                                            (vkShaderStorageImageReadWithoutFormat
                                                                                                                                                                                                               x)
                                                                                                                                                                                                            .
                                                                                                                                                                                                            showString
                                                                                                                                                                                                              ", "
                                                                                                                                                                                                              .
                                                                                                                                                                                                              showString
                                                                                                                                                                                                                "vkShaderStorageImageWriteWithoutFormat = "
                                                                                                                                                                                                                .
                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                  d
                                                                                                                                                                                                                  (vkShaderStorageImageWriteWithoutFormat
                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                  .
                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                    .
                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                      "vkShaderUniformBufferArrayDynamicIndexing = "
                                                                                                                                                                                                                      .
                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                        d
                                                                                                                                                                                                                        (vkShaderUniformBufferArrayDynamicIndexing
                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                        .
                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                          .
                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                            "vkShaderSampledImageArrayDynamicIndexing = "
                                                                                                                                                                                                                            .
                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                              d
                                                                                                                                                                                                                              (vkShaderSampledImageArrayDynamicIndexing
                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                              .
                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                  "vkShaderStorageBufferArrayDynamicIndexing = "
                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                    (vkShaderStorageBufferArrayDynamicIndexing
                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                        "vkShaderStorageImageArrayDynamicIndexing = "
                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                          (vkShaderStorageImageArrayDynamicIndexing
                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                              "vkShaderClipDistance = "
                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                (vkShaderClipDistance
                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                    "vkShaderCullDistance = "
                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                      (vkShaderCullDistance
                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                          "vkShaderFloat64 = "
                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                            (vkShaderFloat64
                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                "vkShaderInt64 = "
                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                  (vkShaderInt64
                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                      "vkShaderInt16 = "
                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                        (vkShaderInt16
                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                            "vkShaderResourceResidency = "
                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                              (vkShaderResourceResidency
                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                  "vkShaderResourceMinLod = "
                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                    (vkShaderResourceMinLod
                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                        "vkSparseBinding = "
                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                          (vkSparseBinding
                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                              "vkSparseResidencyBuffer = "
                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                (vkSparseResidencyBuffer
                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                    "vkSparseResidencyImage2D = "
                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                      (vkSparseResidencyImage2D
                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                          "vkSparseResidencyImage3D = "
                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                            (vkSparseResidencyImage3D
                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                "vkSparseResidency2Samples = "
                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                  (vkSparseResidency2Samples
                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                      "vkSparseResidency4Samples = "
                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                        (vkSparseResidency4Samples
                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                            "vkSparseResidency8Samples = "
                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                              (vkSparseResidency8Samples
                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                  "vkSparseResidency16Samples = "
                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                    (vkSparseResidency16Samples
                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                        "vkSparseResidencyAliased = "
                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                                                                          (vkSparseResidencyAliased
                                                                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                              "vkVariableMultisampleRate = "
                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                (vkVariableMultisampleRate
                                                                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                    "vkInheritedQueries = "
                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                                                                      (vkInheritedQueries
                                                                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                      showChar
                                                                                                                                                                                                                                                                                                                                                        '}'

data VkPhysicalDeviceSparseProperties = VkPhysicalDeviceSparseProperties## ByteArray##

instance Eq VkPhysicalDeviceSparseProperties where
        (VkPhysicalDeviceSparseProperties## a) ==
          (VkPhysicalDeviceSparseProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPhysicalDeviceSparseProperties where
        (VkPhysicalDeviceSparseProperties## a) `compare`
          (VkPhysicalDeviceSparseProperties## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPhysicalDeviceSparseProperties where
        sizeOf ~_ = #{size VkPhysicalDeviceSparseProperties}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPhysicalDeviceSparseProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceSparseProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceSparseProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPhysicalDeviceSparseProperties##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPhysicalDeviceSparseProperties## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceSparseProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPhysicalDeviceSparseProperties where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceSparseProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceSparseProperties) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPhysicalDeviceSparseProperties##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPhysicalDeviceSparseProperties## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkPhysicalDeviceSparseProperties##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPhysicalDeviceSparseProperties## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPhysicalDeviceSparseProperties## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPhysicalDeviceSparseProperties## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkResidencyStandard2DBlockShape a where
        type VkResidencyStandard2DBlockShapeMType a :: *

        vkResidencyStandard2DBlockShape ::
                                        a -> VkResidencyStandard2DBlockShapeMType a

        vkResidencyStandard2DBlockShapeByteOffset :: a -> Int

        readVkResidencyStandard2DBlockShape ::
                                            Ptr a -> IO (VkResidencyStandard2DBlockShapeMType a)

        writeVkResidencyStandard2DBlockShape ::
                                             Ptr a ->
                                               VkResidencyStandard2DBlockShapeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'residencyStandard2DBlockShape'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkResidencyStandard2DBlockShape a

instance {-# OVERLAPPING #-}
         HasVkResidencyStandard2DBlockShape VkPhysicalDeviceSparseProperties
         where
        type VkResidencyStandard2DBlockShapeMType
               VkPhysicalDeviceSparseProperties
             = VkBool32

        {-# NOINLINE vkResidencyStandard2DBlockShape #-}
        vkResidencyStandard2DBlockShape x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceSparseProperties, residencyStandard2DBlockShape})

        {-# INLINE vkResidencyStandard2DBlockShapeByteOffset #-}
        vkResidencyStandard2DBlockShapeByteOffset ~_
          = #{offset VkPhysicalDeviceSparseProperties, residencyStandard2DBlockShape}

        {-# INLINE readVkResidencyStandard2DBlockShape #-}
        readVkResidencyStandard2DBlockShape p
          = peekByteOff p
              #{offset VkPhysicalDeviceSparseProperties, residencyStandard2DBlockShape}

        {-# INLINE writeVkResidencyStandard2DBlockShape #-}
        writeVkResidencyStandard2DBlockShape p
          = pokeByteOff p
              #{offset VkPhysicalDeviceSparseProperties, residencyStandard2DBlockShape}

class HasVkResidencyStandard2DMultisampleBlockShape a where
        type VkResidencyStandard2DMultisampleBlockShapeMType a :: *

        vkResidencyStandard2DMultisampleBlockShape ::
                                                   a ->
                                                     VkResidencyStandard2DMultisampleBlockShapeMType
                                                       a

        vkResidencyStandard2DMultisampleBlockShapeByteOffset :: a -> Int

        readVkResidencyStandard2DMultisampleBlockShape ::
                                                       Ptr a ->
                                                         IO
                                                           (VkResidencyStandard2DMultisampleBlockShapeMType
                                                              a)

        writeVkResidencyStandard2DMultisampleBlockShape ::
                                                        Ptr a ->
                                                          VkResidencyStandard2DMultisampleBlockShapeMType
                                                            a
                                                            -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'residencyStandard2DMultisampleBlockShape'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkResidencyStandard2DMultisampleBlockShape a

instance {-# OVERLAPPING #-}
         HasVkResidencyStandard2DMultisampleBlockShape
           VkPhysicalDeviceSparseProperties
         where
        type VkResidencyStandard2DMultisampleBlockShapeMType
               VkPhysicalDeviceSparseProperties
             = VkBool32

        {-# NOINLINE vkResidencyStandard2DMultisampleBlockShape #-}
        vkResidencyStandard2DMultisampleBlockShape x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceSparseProperties, residencyStandard2DMultisampleBlockShape})

        {-# INLINE vkResidencyStandard2DMultisampleBlockShapeByteOffset #-}
        vkResidencyStandard2DMultisampleBlockShapeByteOffset ~_
          = #{offset VkPhysicalDeviceSparseProperties, residencyStandard2DMultisampleBlockShape}

        {-# INLINE readVkResidencyStandard2DMultisampleBlockShape #-}
        readVkResidencyStandard2DMultisampleBlockShape p
          = peekByteOff p
              #{offset VkPhysicalDeviceSparseProperties, residencyStandard2DMultisampleBlockShape}

        {-# INLINE writeVkResidencyStandard2DMultisampleBlockShape #-}
        writeVkResidencyStandard2DMultisampleBlockShape p
          = pokeByteOff p
              #{offset VkPhysicalDeviceSparseProperties, residencyStandard2DMultisampleBlockShape}

class HasVkResidencyStandard3DBlockShape a where
        type VkResidencyStandard3DBlockShapeMType a :: *

        vkResidencyStandard3DBlockShape ::
                                        a -> VkResidencyStandard3DBlockShapeMType a

        vkResidencyStandard3DBlockShapeByteOffset :: a -> Int

        readVkResidencyStandard3DBlockShape ::
                                            Ptr a -> IO (VkResidencyStandard3DBlockShapeMType a)

        writeVkResidencyStandard3DBlockShape ::
                                             Ptr a ->
                                               VkResidencyStandard3DBlockShapeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'residencyStandard3DBlockShape'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkResidencyStandard3DBlockShape a

instance {-# OVERLAPPING #-}
         HasVkResidencyStandard3DBlockShape VkPhysicalDeviceSparseProperties
         where
        type VkResidencyStandard3DBlockShapeMType
               VkPhysicalDeviceSparseProperties
             = VkBool32

        {-# NOINLINE vkResidencyStandard3DBlockShape #-}
        vkResidencyStandard3DBlockShape x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceSparseProperties, residencyStandard3DBlockShape})

        {-# INLINE vkResidencyStandard3DBlockShapeByteOffset #-}
        vkResidencyStandard3DBlockShapeByteOffset ~_
          = #{offset VkPhysicalDeviceSparseProperties, residencyStandard3DBlockShape}

        {-# INLINE readVkResidencyStandard3DBlockShape #-}
        readVkResidencyStandard3DBlockShape p
          = peekByteOff p
              #{offset VkPhysicalDeviceSparseProperties, residencyStandard3DBlockShape}

        {-# INLINE writeVkResidencyStandard3DBlockShape #-}
        writeVkResidencyStandard3DBlockShape p
          = pokeByteOff p
              #{offset VkPhysicalDeviceSparseProperties, residencyStandard3DBlockShape}

class HasVkResidencyAlignedMipSize a where
        type VkResidencyAlignedMipSizeMType a :: *

        vkResidencyAlignedMipSize :: a -> VkResidencyAlignedMipSizeMType a

        vkResidencyAlignedMipSizeByteOffset :: a -> Int

        readVkResidencyAlignedMipSize ::
                                      Ptr a -> IO (VkResidencyAlignedMipSizeMType a)

        writeVkResidencyAlignedMipSize ::
                                       Ptr a -> VkResidencyAlignedMipSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'residencyAlignedMipSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkResidencyAlignedMipSize a

instance {-# OVERLAPPING #-}
         HasVkResidencyAlignedMipSize VkPhysicalDeviceSparseProperties where
        type VkResidencyAlignedMipSizeMType
               VkPhysicalDeviceSparseProperties
             = VkBool32

        {-# NOINLINE vkResidencyAlignedMipSize #-}
        vkResidencyAlignedMipSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceSparseProperties, residencyAlignedMipSize})

        {-# INLINE vkResidencyAlignedMipSizeByteOffset #-}
        vkResidencyAlignedMipSizeByteOffset ~_
          = #{offset VkPhysicalDeviceSparseProperties, residencyAlignedMipSize}

        {-# INLINE readVkResidencyAlignedMipSize #-}
        readVkResidencyAlignedMipSize p
          = peekByteOff p
              #{offset VkPhysicalDeviceSparseProperties, residencyAlignedMipSize}

        {-# INLINE writeVkResidencyAlignedMipSize #-}
        writeVkResidencyAlignedMipSize p
          = pokeByteOff p
              #{offset VkPhysicalDeviceSparseProperties, residencyAlignedMipSize}

class HasVkResidencyNonResidentStrict a where
        type VkResidencyNonResidentStrictMType a :: *

        vkResidencyNonResidentStrict ::
                                     a -> VkResidencyNonResidentStrictMType a

        vkResidencyNonResidentStrictByteOffset :: a -> Int

        readVkResidencyNonResidentStrict ::
                                         Ptr a -> IO (VkResidencyNonResidentStrictMType a)

        writeVkResidencyNonResidentStrict ::
                                          Ptr a -> VkResidencyNonResidentStrictMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'residencyNonResidentStrict'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkResidencyNonResidentStrict a

instance {-# OVERLAPPING #-}
         HasVkResidencyNonResidentStrict VkPhysicalDeviceSparseProperties
         where
        type VkResidencyNonResidentStrictMType
               VkPhysicalDeviceSparseProperties
             = VkBool32

        {-# NOINLINE vkResidencyNonResidentStrict #-}
        vkResidencyNonResidentStrict x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceSparseProperties, residencyNonResidentStrict})

        {-# INLINE vkResidencyNonResidentStrictByteOffset #-}
        vkResidencyNonResidentStrictByteOffset ~_
          = #{offset VkPhysicalDeviceSparseProperties, residencyNonResidentStrict}

        {-# INLINE readVkResidencyNonResidentStrict #-}
        readVkResidencyNonResidentStrict p
          = peekByteOff p
              #{offset VkPhysicalDeviceSparseProperties, residencyNonResidentStrict}

        {-# INLINE writeVkResidencyNonResidentStrict #-}
        writeVkResidencyNonResidentStrict p
          = pokeByteOff p
              #{offset VkPhysicalDeviceSparseProperties, residencyNonResidentStrict}

instance Show VkPhysicalDeviceSparseProperties where
        showsPrec d x
          = showString "VkPhysicalDeviceSparseProperties {" .
              showString "vkResidencyStandard2DBlockShape = " .
                showsPrec d (vkResidencyStandard2DBlockShape x) .
                  showString ", " .
                    showString "vkResidencyStandard2DMultisampleBlockShape = " .
                      showsPrec d (vkResidencyStandard2DMultisampleBlockShape x) .
                        showString ", " .
                          showString "vkResidencyStandard3DBlockShape = " .
                            showsPrec d (vkResidencyStandard3DBlockShape x) .
                              showString ", " .
                                showString "vkResidencyAlignedMipSize = " .
                                  showsPrec d (vkResidencyAlignedMipSize x) .
                                    showString ", " .
                                      showString "vkResidencyNonResidentStrict = " .
                                        showsPrec d (vkResidencyNonResidentStrict x) . showChar '}'

data VkPhysicalDeviceLimits = VkPhysicalDeviceLimits## ByteArray##

instance Eq VkPhysicalDeviceLimits where
        (VkPhysicalDeviceLimits## a) == (VkPhysicalDeviceLimits## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPhysicalDeviceLimits where
        (VkPhysicalDeviceLimits## a) `compare` (VkPhysicalDeviceLimits## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPhysicalDeviceLimits where
        sizeOf ~_ = #{size VkPhysicalDeviceLimits}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPhysicalDeviceLimits}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceLimits),
            I## a <- alignment (undefined :: VkPhysicalDeviceLimits) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPhysicalDeviceLimits##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPhysicalDeviceLimits## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceLimits) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPhysicalDeviceLimits where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceLimits),
            I## a <- alignment (undefined :: VkPhysicalDeviceLimits) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPhysicalDeviceLimits##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPhysicalDeviceLimits## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkPhysicalDeviceLimits##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPhysicalDeviceLimits## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPhysicalDeviceLimits## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPhysicalDeviceLimits## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkMaxImageDimension1D a where
        type VkMaxImageDimension1DMType a :: *

        vkMaxImageDimension1D :: a -> VkMaxImageDimension1DMType a

        vkMaxImageDimension1DByteOffset :: a -> Int

        readVkMaxImageDimension1D ::
                                  Ptr a -> IO (VkMaxImageDimension1DMType a)

        writeVkMaxImageDimension1D ::
                                   Ptr a -> VkMaxImageDimension1DMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxImageDimension1D'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxImageDimension1D a

instance {-# OVERLAPPING #-}
         HasVkMaxImageDimension1D VkPhysicalDeviceLimits where
        type VkMaxImageDimension1DMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxImageDimension1D #-}
        vkMaxImageDimension1D x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxImageDimension1D})

        {-# INLINE vkMaxImageDimension1DByteOffset #-}
        vkMaxImageDimension1DByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxImageDimension1D}

        {-# INLINE readVkMaxImageDimension1D #-}
        readVkMaxImageDimension1D p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxImageDimension1D}

        {-# INLINE writeVkMaxImageDimension1D #-}
        writeVkMaxImageDimension1D p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxImageDimension1D}

class HasVkMaxImageDimension2D a where
        type VkMaxImageDimension2DMType a :: *

        vkMaxImageDimension2D :: a -> VkMaxImageDimension2DMType a

        vkMaxImageDimension2DByteOffset :: a -> Int

        readVkMaxImageDimension2D ::
                                  Ptr a -> IO (VkMaxImageDimension2DMType a)

        writeVkMaxImageDimension2D ::
                                   Ptr a -> VkMaxImageDimension2DMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxImageDimension2D'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxImageDimension2D a

instance {-# OVERLAPPING #-}
         HasVkMaxImageDimension2D VkPhysicalDeviceLimits where
        type VkMaxImageDimension2DMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxImageDimension2D #-}
        vkMaxImageDimension2D x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxImageDimension2D})

        {-# INLINE vkMaxImageDimension2DByteOffset #-}
        vkMaxImageDimension2DByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxImageDimension2D}

        {-# INLINE readVkMaxImageDimension2D #-}
        readVkMaxImageDimension2D p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxImageDimension2D}

        {-# INLINE writeVkMaxImageDimension2D #-}
        writeVkMaxImageDimension2D p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxImageDimension2D}

class HasVkMaxImageDimension3D a where
        type VkMaxImageDimension3DMType a :: *

        vkMaxImageDimension3D :: a -> VkMaxImageDimension3DMType a

        vkMaxImageDimension3DByteOffset :: a -> Int

        readVkMaxImageDimension3D ::
                                  Ptr a -> IO (VkMaxImageDimension3DMType a)

        writeVkMaxImageDimension3D ::
                                   Ptr a -> VkMaxImageDimension3DMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxImageDimension3D'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxImageDimension3D a

instance {-# OVERLAPPING #-}
         HasVkMaxImageDimension3D VkPhysicalDeviceLimits where
        type VkMaxImageDimension3DMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxImageDimension3D #-}
        vkMaxImageDimension3D x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxImageDimension3D})

        {-# INLINE vkMaxImageDimension3DByteOffset #-}
        vkMaxImageDimension3DByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxImageDimension3D}

        {-# INLINE readVkMaxImageDimension3D #-}
        readVkMaxImageDimension3D p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxImageDimension3D}

        {-# INLINE writeVkMaxImageDimension3D #-}
        writeVkMaxImageDimension3D p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxImageDimension3D}

class HasVkMaxImageDimensionCube a where
        type VkMaxImageDimensionCubeMType a :: *

        vkMaxImageDimensionCube :: a -> VkMaxImageDimensionCubeMType a

        vkMaxImageDimensionCubeByteOffset :: a -> Int

        readVkMaxImageDimensionCube ::
                                    Ptr a -> IO (VkMaxImageDimensionCubeMType a)

        writeVkMaxImageDimensionCube ::
                                     Ptr a -> VkMaxImageDimensionCubeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxImageDimensionCube'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxImageDimensionCube a

instance {-# OVERLAPPING #-}
         HasVkMaxImageDimensionCube VkPhysicalDeviceLimits where
        type VkMaxImageDimensionCubeMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxImageDimensionCube #-}
        vkMaxImageDimensionCube x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxImageDimensionCube})

        {-# INLINE vkMaxImageDimensionCubeByteOffset #-}
        vkMaxImageDimensionCubeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxImageDimensionCube}

        {-# INLINE readVkMaxImageDimensionCube #-}
        readVkMaxImageDimensionCube p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxImageDimensionCube}

        {-# INLINE writeVkMaxImageDimensionCube #-}
        writeVkMaxImageDimensionCube p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxImageDimensionCube}

class HasVkMaxImageArrayLayers a where
        type VkMaxImageArrayLayersMType a :: *

        vkMaxImageArrayLayers :: a -> VkMaxImageArrayLayersMType a

        vkMaxImageArrayLayersByteOffset :: a -> Int

        readVkMaxImageArrayLayers ::
                                  Ptr a -> IO (VkMaxImageArrayLayersMType a)

        writeVkMaxImageArrayLayers ::
                                   Ptr a -> VkMaxImageArrayLayersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxImageArrayLayers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxImageArrayLayers a

instance {-# OVERLAPPING #-}
         HasVkMaxImageArrayLayers VkPhysicalDeviceLimits where
        type VkMaxImageArrayLayersMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxImageArrayLayers #-}
        vkMaxImageArrayLayers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxImageArrayLayers})

        {-# INLINE vkMaxImageArrayLayersByteOffset #-}
        vkMaxImageArrayLayersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxImageArrayLayers}

        {-# INLINE readVkMaxImageArrayLayers #-}
        readVkMaxImageArrayLayers p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxImageArrayLayers}

        {-# INLINE writeVkMaxImageArrayLayers #-}
        writeVkMaxImageArrayLayers p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxImageArrayLayers}

class HasVkMaxTexelBufferElements a where
        type VkMaxTexelBufferElementsMType a :: *

        vkMaxTexelBufferElements :: a -> VkMaxTexelBufferElementsMType a

        vkMaxTexelBufferElementsByteOffset :: a -> Int

        readVkMaxTexelBufferElements ::
                                     Ptr a -> IO (VkMaxTexelBufferElementsMType a)

        writeVkMaxTexelBufferElements ::
                                      Ptr a -> VkMaxTexelBufferElementsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxTexelBufferElements'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTexelBufferElements a

instance {-# OVERLAPPING #-}
         HasVkMaxTexelBufferElements VkPhysicalDeviceLimits where
        type VkMaxTexelBufferElementsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxTexelBufferElements #-}
        vkMaxTexelBufferElements x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxTexelBufferElements})

        {-# INLINE vkMaxTexelBufferElementsByteOffset #-}
        vkMaxTexelBufferElementsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTexelBufferElements}

        {-# INLINE readVkMaxTexelBufferElements #-}
        readVkMaxTexelBufferElements p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxTexelBufferElements}

        {-# INLINE writeVkMaxTexelBufferElements #-}
        writeVkMaxTexelBufferElements p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxTexelBufferElements}

class HasVkMaxUniformBufferRange a where
        type VkMaxUniformBufferRangeMType a :: *

        vkMaxUniformBufferRange :: a -> VkMaxUniformBufferRangeMType a

        vkMaxUniformBufferRangeByteOffset :: a -> Int

        readVkMaxUniformBufferRange ::
                                    Ptr a -> IO (VkMaxUniformBufferRangeMType a)

        writeVkMaxUniformBufferRange ::
                                     Ptr a -> VkMaxUniformBufferRangeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxUniformBufferRange'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxUniformBufferRange a

instance {-# OVERLAPPING #-}
         HasVkMaxUniformBufferRange VkPhysicalDeviceLimits where
        type VkMaxUniformBufferRangeMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxUniformBufferRange #-}
        vkMaxUniformBufferRange x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxUniformBufferRange})

        {-# INLINE vkMaxUniformBufferRangeByteOffset #-}
        vkMaxUniformBufferRangeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxUniformBufferRange}

        {-# INLINE readVkMaxUniformBufferRange #-}
        readVkMaxUniformBufferRange p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxUniformBufferRange}

        {-# INLINE writeVkMaxUniformBufferRange #-}
        writeVkMaxUniformBufferRange p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxUniformBufferRange}

class HasVkMaxStorageBufferRange a where
        type VkMaxStorageBufferRangeMType a :: *

        vkMaxStorageBufferRange :: a -> VkMaxStorageBufferRangeMType a

        vkMaxStorageBufferRangeByteOffset :: a -> Int

        readVkMaxStorageBufferRange ::
                                    Ptr a -> IO (VkMaxStorageBufferRangeMType a)

        writeVkMaxStorageBufferRange ::
                                     Ptr a -> VkMaxStorageBufferRangeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxStorageBufferRange'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxStorageBufferRange a

instance {-# OVERLAPPING #-}
         HasVkMaxStorageBufferRange VkPhysicalDeviceLimits where
        type VkMaxStorageBufferRangeMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxStorageBufferRange #-}
        vkMaxStorageBufferRange x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxStorageBufferRange})

        {-# INLINE vkMaxStorageBufferRangeByteOffset #-}
        vkMaxStorageBufferRangeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxStorageBufferRange}

        {-# INLINE readVkMaxStorageBufferRange #-}
        readVkMaxStorageBufferRange p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxStorageBufferRange}

        {-# INLINE writeVkMaxStorageBufferRange #-}
        writeVkMaxStorageBufferRange p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxStorageBufferRange}

class HasVkMaxPushConstantsSize a where
        type VkMaxPushConstantsSizeMType a :: *

        vkMaxPushConstantsSize :: a -> VkMaxPushConstantsSizeMType a

        vkMaxPushConstantsSizeByteOffset :: a -> Int

        readVkMaxPushConstantsSize ::
                                   Ptr a -> IO (VkMaxPushConstantsSizeMType a)

        writeVkMaxPushConstantsSize ::
                                    Ptr a -> VkMaxPushConstantsSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxPushConstantsSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPushConstantsSize a

instance {-# OVERLAPPING #-}
         HasVkMaxPushConstantsSize VkPhysicalDeviceLimits where
        type VkMaxPushConstantsSizeMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxPushConstantsSize #-}
        vkMaxPushConstantsSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxPushConstantsSize})

        {-# INLINE vkMaxPushConstantsSizeByteOffset #-}
        vkMaxPushConstantsSizeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPushConstantsSize}

        {-# INLINE readVkMaxPushConstantsSize #-}
        readVkMaxPushConstantsSize p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxPushConstantsSize}

        {-# INLINE writeVkMaxPushConstantsSize #-}
        writeVkMaxPushConstantsSize p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxPushConstantsSize}

class HasVkMaxMemoryAllocationCount a where
        type VkMaxMemoryAllocationCountMType a :: *

        vkMaxMemoryAllocationCount ::
                                   a -> VkMaxMemoryAllocationCountMType a

        vkMaxMemoryAllocationCountByteOffset :: a -> Int

        readVkMaxMemoryAllocationCount ::
                                       Ptr a -> IO (VkMaxMemoryAllocationCountMType a)

        writeVkMaxMemoryAllocationCount ::
                                        Ptr a -> VkMaxMemoryAllocationCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxMemoryAllocationCount'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxMemoryAllocationCount a

instance {-# OVERLAPPING #-}
         HasVkMaxMemoryAllocationCount VkPhysicalDeviceLimits where
        type VkMaxMemoryAllocationCountMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxMemoryAllocationCount #-}
        vkMaxMemoryAllocationCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxMemoryAllocationCount})

        {-# INLINE vkMaxMemoryAllocationCountByteOffset #-}
        vkMaxMemoryAllocationCountByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxMemoryAllocationCount}

        {-# INLINE readVkMaxMemoryAllocationCount #-}
        readVkMaxMemoryAllocationCount p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxMemoryAllocationCount}

        {-# INLINE writeVkMaxMemoryAllocationCount #-}
        writeVkMaxMemoryAllocationCount p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxMemoryAllocationCount}

class HasVkMaxSamplerAllocationCount a where
        type VkMaxSamplerAllocationCountMType a :: *

        vkMaxSamplerAllocationCount ::
                                    a -> VkMaxSamplerAllocationCountMType a

        vkMaxSamplerAllocationCountByteOffset :: a -> Int

        readVkMaxSamplerAllocationCount ::
                                        Ptr a -> IO (VkMaxSamplerAllocationCountMType a)

        writeVkMaxSamplerAllocationCount ::
                                         Ptr a -> VkMaxSamplerAllocationCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxSamplerAllocationCount'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxSamplerAllocationCount a

instance {-# OVERLAPPING #-}
         HasVkMaxSamplerAllocationCount VkPhysicalDeviceLimits where
        type VkMaxSamplerAllocationCountMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxSamplerAllocationCount #-}
        vkMaxSamplerAllocationCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxSamplerAllocationCount})

        {-# INLINE vkMaxSamplerAllocationCountByteOffset #-}
        vkMaxSamplerAllocationCountByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxSamplerAllocationCount}

        {-# INLINE readVkMaxSamplerAllocationCount #-}
        readVkMaxSamplerAllocationCount p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxSamplerAllocationCount}

        {-# INLINE writeVkMaxSamplerAllocationCount #-}
        writeVkMaxSamplerAllocationCount p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxSamplerAllocationCount}

class HasVkBufferImageGranularity a where
        type VkBufferImageGranularityMType a :: *

        vkBufferImageGranularity :: a -> VkBufferImageGranularityMType a

        vkBufferImageGranularityByteOffset :: a -> Int

        readVkBufferImageGranularity ::
                                     Ptr a -> IO (VkBufferImageGranularityMType a)

        writeVkBufferImageGranularity ::
                                      Ptr a -> VkBufferImageGranularityMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bufferImageGranularity'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBufferImageGranularity a

instance {-# OVERLAPPING #-}
         HasVkBufferImageGranularity VkPhysicalDeviceLimits where
        type VkBufferImageGranularityMType VkPhysicalDeviceLimits =
             VkDeviceSize

        {-# NOINLINE vkBufferImageGranularity #-}
        vkBufferImageGranularity x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, bufferImageGranularity})

        {-# INLINE vkBufferImageGranularityByteOffset #-}
        vkBufferImageGranularityByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, bufferImageGranularity}

        {-# INLINE readVkBufferImageGranularity #-}
        readVkBufferImageGranularity p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, bufferImageGranularity}

        {-# INLINE writeVkBufferImageGranularity #-}
        writeVkBufferImageGranularity p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, bufferImageGranularity}

class HasVkSparseAddressSpaceSize a where
        type VkSparseAddressSpaceSizeMType a :: *

        vkSparseAddressSpaceSize :: a -> VkSparseAddressSpaceSizeMType a

        vkSparseAddressSpaceSizeByteOffset :: a -> Int

        readVkSparseAddressSpaceSize ::
                                     Ptr a -> IO (VkSparseAddressSpaceSizeMType a)

        writeVkSparseAddressSpaceSize ::
                                      Ptr a -> VkSparseAddressSpaceSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseAddressSpaceSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseAddressSpaceSize a

instance {-# OVERLAPPING #-}
         HasVkSparseAddressSpaceSize VkPhysicalDeviceLimits where
        type VkSparseAddressSpaceSizeMType VkPhysicalDeviceLimits =
             VkDeviceSize

        {-# NOINLINE vkSparseAddressSpaceSize #-}
        vkSparseAddressSpaceSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, sparseAddressSpaceSize})

        {-# INLINE vkSparseAddressSpaceSizeByteOffset #-}
        vkSparseAddressSpaceSizeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, sparseAddressSpaceSize}

        {-# INLINE readVkSparseAddressSpaceSize #-}
        readVkSparseAddressSpaceSize p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, sparseAddressSpaceSize}

        {-# INLINE writeVkSparseAddressSpaceSize #-}
        writeVkSparseAddressSpaceSize p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, sparseAddressSpaceSize}

class HasVkMaxBoundDescriptorSets a where
        type VkMaxBoundDescriptorSetsMType a :: *

        vkMaxBoundDescriptorSets :: a -> VkMaxBoundDescriptorSetsMType a

        vkMaxBoundDescriptorSetsByteOffset :: a -> Int

        readVkMaxBoundDescriptorSets ::
                                     Ptr a -> IO (VkMaxBoundDescriptorSetsMType a)

        writeVkMaxBoundDescriptorSets ::
                                      Ptr a -> VkMaxBoundDescriptorSetsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxBoundDescriptorSets'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxBoundDescriptorSets a

instance {-# OVERLAPPING #-}
         HasVkMaxBoundDescriptorSets VkPhysicalDeviceLimits where
        type VkMaxBoundDescriptorSetsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxBoundDescriptorSets #-}
        vkMaxBoundDescriptorSets x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxBoundDescriptorSets})

        {-# INLINE vkMaxBoundDescriptorSetsByteOffset #-}
        vkMaxBoundDescriptorSetsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxBoundDescriptorSets}

        {-# INLINE readVkMaxBoundDescriptorSets #-}
        readVkMaxBoundDescriptorSets p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxBoundDescriptorSets}

        {-# INLINE writeVkMaxBoundDescriptorSets #-}
        writeVkMaxBoundDescriptorSets p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxBoundDescriptorSets}

class HasVkMaxPerStageDescriptorSamplers a where
        type VkMaxPerStageDescriptorSamplersMType a :: *

        vkMaxPerStageDescriptorSamplers ::
                                        a -> VkMaxPerStageDescriptorSamplersMType a

        vkMaxPerStageDescriptorSamplersByteOffset :: a -> Int

        readVkMaxPerStageDescriptorSamplers ::
                                            Ptr a -> IO (VkMaxPerStageDescriptorSamplersMType a)

        writeVkMaxPerStageDescriptorSamplers ::
                                             Ptr a ->
                                               VkMaxPerStageDescriptorSamplersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxPerStageDescriptorSamplers'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPerStageDescriptorSamplers a

instance {-# OVERLAPPING #-}
         HasVkMaxPerStageDescriptorSamplers VkPhysicalDeviceLimits where
        type VkMaxPerStageDescriptorSamplersMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxPerStageDescriptorSamplers #-}
        vkMaxPerStageDescriptorSamplers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorSamplers})

        {-# INLINE vkMaxPerStageDescriptorSamplersByteOffset #-}
        vkMaxPerStageDescriptorSamplersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorSamplers}

        {-# INLINE readVkMaxPerStageDescriptorSamplers #-}
        readVkMaxPerStageDescriptorSamplers p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorSamplers}

        {-# INLINE writeVkMaxPerStageDescriptorSamplers #-}
        writeVkMaxPerStageDescriptorSamplers p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorSamplers}

class HasVkMaxPerStageDescriptorUniformBuffers a where
        type VkMaxPerStageDescriptorUniformBuffersMType a :: *

        vkMaxPerStageDescriptorUniformBuffers ::
                                              a -> VkMaxPerStageDescriptorUniformBuffersMType a

        vkMaxPerStageDescriptorUniformBuffersByteOffset :: a -> Int

        readVkMaxPerStageDescriptorUniformBuffers ::
                                                  Ptr a ->
                                                    IO
                                                      (VkMaxPerStageDescriptorUniformBuffersMType a)

        writeVkMaxPerStageDescriptorUniformBuffers ::
                                                   Ptr a ->
                                                     VkMaxPerStageDescriptorUniformBuffersMType a ->
                                                       IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxPerStageDescriptorUniformBuffers'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPerStageDescriptorUniformBuffers a

instance {-# OVERLAPPING #-}
         HasVkMaxPerStageDescriptorUniformBuffers VkPhysicalDeviceLimits
         where
        type VkMaxPerStageDescriptorUniformBuffersMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxPerStageDescriptorUniformBuffers #-}
        vkMaxPerStageDescriptorUniformBuffers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorUniformBuffers})

        {-# INLINE vkMaxPerStageDescriptorUniformBuffersByteOffset #-}
        vkMaxPerStageDescriptorUniformBuffersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorUniformBuffers}

        {-# INLINE readVkMaxPerStageDescriptorUniformBuffers #-}
        readVkMaxPerStageDescriptorUniformBuffers p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorUniformBuffers}

        {-# INLINE writeVkMaxPerStageDescriptorUniformBuffers #-}
        writeVkMaxPerStageDescriptorUniformBuffers p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorUniformBuffers}

class HasVkMaxPerStageDescriptorStorageBuffers a where
        type VkMaxPerStageDescriptorStorageBuffersMType a :: *

        vkMaxPerStageDescriptorStorageBuffers ::
                                              a -> VkMaxPerStageDescriptorStorageBuffersMType a

        vkMaxPerStageDescriptorStorageBuffersByteOffset :: a -> Int

        readVkMaxPerStageDescriptorStorageBuffers ::
                                                  Ptr a ->
                                                    IO
                                                      (VkMaxPerStageDescriptorStorageBuffersMType a)

        writeVkMaxPerStageDescriptorStorageBuffers ::
                                                   Ptr a ->
                                                     VkMaxPerStageDescriptorStorageBuffersMType a ->
                                                       IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxPerStageDescriptorStorageBuffers'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPerStageDescriptorStorageBuffers a

instance {-# OVERLAPPING #-}
         HasVkMaxPerStageDescriptorStorageBuffers VkPhysicalDeviceLimits
         where
        type VkMaxPerStageDescriptorStorageBuffersMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxPerStageDescriptorStorageBuffers #-}
        vkMaxPerStageDescriptorStorageBuffers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorStorageBuffers})

        {-# INLINE vkMaxPerStageDescriptorStorageBuffersByteOffset #-}
        vkMaxPerStageDescriptorStorageBuffersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorStorageBuffers}

        {-# INLINE readVkMaxPerStageDescriptorStorageBuffers #-}
        readVkMaxPerStageDescriptorStorageBuffers p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorStorageBuffers}

        {-# INLINE writeVkMaxPerStageDescriptorStorageBuffers #-}
        writeVkMaxPerStageDescriptorStorageBuffers p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorStorageBuffers}

class HasVkMaxPerStageDescriptorSampledImages a where
        type VkMaxPerStageDescriptorSampledImagesMType a :: *

        vkMaxPerStageDescriptorSampledImages ::
                                             a -> VkMaxPerStageDescriptorSampledImagesMType a

        vkMaxPerStageDescriptorSampledImagesByteOffset :: a -> Int

        readVkMaxPerStageDescriptorSampledImages ::
                                                 Ptr a ->
                                                   IO (VkMaxPerStageDescriptorSampledImagesMType a)

        writeVkMaxPerStageDescriptorSampledImages ::
                                                  Ptr a ->
                                                    VkMaxPerStageDescriptorSampledImagesMType a ->
                                                      IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxPerStageDescriptorSampledImages'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPerStageDescriptorSampledImages a

instance {-# OVERLAPPING #-}
         HasVkMaxPerStageDescriptorSampledImages VkPhysicalDeviceLimits
         where
        type VkMaxPerStageDescriptorSampledImagesMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxPerStageDescriptorSampledImages #-}
        vkMaxPerStageDescriptorSampledImages x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorSampledImages})

        {-# INLINE vkMaxPerStageDescriptorSampledImagesByteOffset #-}
        vkMaxPerStageDescriptorSampledImagesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorSampledImages}

        {-# INLINE readVkMaxPerStageDescriptorSampledImages #-}
        readVkMaxPerStageDescriptorSampledImages p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorSampledImages}

        {-# INLINE writeVkMaxPerStageDescriptorSampledImages #-}
        writeVkMaxPerStageDescriptorSampledImages p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorSampledImages}

class HasVkMaxPerStageDescriptorStorageImages a where
        type VkMaxPerStageDescriptorStorageImagesMType a :: *

        vkMaxPerStageDescriptorStorageImages ::
                                             a -> VkMaxPerStageDescriptorStorageImagesMType a

        vkMaxPerStageDescriptorStorageImagesByteOffset :: a -> Int

        readVkMaxPerStageDescriptorStorageImages ::
                                                 Ptr a ->
                                                   IO (VkMaxPerStageDescriptorStorageImagesMType a)

        writeVkMaxPerStageDescriptorStorageImages ::
                                                  Ptr a ->
                                                    VkMaxPerStageDescriptorStorageImagesMType a ->
                                                      IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxPerStageDescriptorStorageImages'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPerStageDescriptorStorageImages a

instance {-# OVERLAPPING #-}
         HasVkMaxPerStageDescriptorStorageImages VkPhysicalDeviceLimits
         where
        type VkMaxPerStageDescriptorStorageImagesMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxPerStageDescriptorStorageImages #-}
        vkMaxPerStageDescriptorStorageImages x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorStorageImages})

        {-# INLINE vkMaxPerStageDescriptorStorageImagesByteOffset #-}
        vkMaxPerStageDescriptorStorageImagesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorStorageImages}

        {-# INLINE readVkMaxPerStageDescriptorStorageImages #-}
        readVkMaxPerStageDescriptorStorageImages p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorStorageImages}

        {-# INLINE writeVkMaxPerStageDescriptorStorageImages #-}
        writeVkMaxPerStageDescriptorStorageImages p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorStorageImages}

class HasVkMaxPerStageDescriptorInputAttachments a where
        type VkMaxPerStageDescriptorInputAttachmentsMType a :: *

        vkMaxPerStageDescriptorInputAttachments ::
                                                a -> VkMaxPerStageDescriptorInputAttachmentsMType a

        vkMaxPerStageDescriptorInputAttachmentsByteOffset :: a -> Int

        readVkMaxPerStageDescriptorInputAttachments ::
                                                    Ptr a ->
                                                      IO
                                                        (VkMaxPerStageDescriptorInputAttachmentsMType
                                                           a)

        writeVkMaxPerStageDescriptorInputAttachments ::
                                                     Ptr a ->
                                                       VkMaxPerStageDescriptorInputAttachmentsMType
                                                         a
                                                         -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxPerStageDescriptorInputAttachments'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPerStageDescriptorInputAttachments a

instance {-# OVERLAPPING #-}
         HasVkMaxPerStageDescriptorInputAttachments VkPhysicalDeviceLimits
         where
        type VkMaxPerStageDescriptorInputAttachmentsMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxPerStageDescriptorInputAttachments #-}
        vkMaxPerStageDescriptorInputAttachments x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorInputAttachments})

        {-# INLINE vkMaxPerStageDescriptorInputAttachmentsByteOffset #-}
        vkMaxPerStageDescriptorInputAttachmentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorInputAttachments}

        {-# INLINE readVkMaxPerStageDescriptorInputAttachments #-}
        readVkMaxPerStageDescriptorInputAttachments p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorInputAttachments}

        {-# INLINE writeVkMaxPerStageDescriptorInputAttachments #-}
        writeVkMaxPerStageDescriptorInputAttachments p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorInputAttachments}

class HasVkMaxPerStageResources a where
        type VkMaxPerStageResourcesMType a :: *

        vkMaxPerStageResources :: a -> VkMaxPerStageResourcesMType a

        vkMaxPerStageResourcesByteOffset :: a -> Int

        readVkMaxPerStageResources ::
                                   Ptr a -> IO (VkMaxPerStageResourcesMType a)

        writeVkMaxPerStageResources ::
                                    Ptr a -> VkMaxPerStageResourcesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxPerStageResources'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPerStageResources a

instance {-# OVERLAPPING #-}
         HasVkMaxPerStageResources VkPhysicalDeviceLimits where
        type VkMaxPerStageResourcesMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxPerStageResources #-}
        vkMaxPerStageResources x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxPerStageResources})

        {-# INLINE vkMaxPerStageResourcesByteOffset #-}
        vkMaxPerStageResourcesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPerStageResources}

        {-# INLINE readVkMaxPerStageResources #-}
        readVkMaxPerStageResources p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxPerStageResources}

        {-# INLINE writeVkMaxPerStageResources #-}
        writeVkMaxPerStageResources p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxPerStageResources}

class HasVkMaxDescriptorSetSamplers a where
        type VkMaxDescriptorSetSamplersMType a :: *

        vkMaxDescriptorSetSamplers ::
                                   a -> VkMaxDescriptorSetSamplersMType a

        vkMaxDescriptorSetSamplersByteOffset :: a -> Int

        readVkMaxDescriptorSetSamplers ::
                                       Ptr a -> IO (VkMaxDescriptorSetSamplersMType a)

        writeVkMaxDescriptorSetSamplers ::
                                        Ptr a -> VkMaxDescriptorSetSamplersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxDescriptorSetSamplers'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetSamplers a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetSamplers VkPhysicalDeviceLimits where
        type VkMaxDescriptorSetSamplersMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxDescriptorSetSamplers #-}
        vkMaxDescriptorSetSamplers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxDescriptorSetSamplers})

        {-# INLINE vkMaxDescriptorSetSamplersByteOffset #-}
        vkMaxDescriptorSetSamplersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetSamplers}

        {-# INLINE readVkMaxDescriptorSetSamplers #-}
        readVkMaxDescriptorSetSamplers p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetSamplers}

        {-# INLINE writeVkMaxDescriptorSetSamplers #-}
        writeVkMaxDescriptorSetSamplers p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetSamplers}

class HasVkMaxDescriptorSetUniformBuffers a where
        type VkMaxDescriptorSetUniformBuffersMType a :: *

        vkMaxDescriptorSetUniformBuffers ::
                                         a -> VkMaxDescriptorSetUniformBuffersMType a

        vkMaxDescriptorSetUniformBuffersByteOffset :: a -> Int

        readVkMaxDescriptorSetUniformBuffers ::
                                             Ptr a -> IO (VkMaxDescriptorSetUniformBuffersMType a)

        writeVkMaxDescriptorSetUniformBuffers ::
                                              Ptr a ->
                                                VkMaxDescriptorSetUniformBuffersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxDescriptorSetUniformBuffers'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetUniformBuffers a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetUniformBuffers VkPhysicalDeviceLimits where
        type VkMaxDescriptorSetUniformBuffersMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxDescriptorSetUniformBuffers #-}
        vkMaxDescriptorSetUniformBuffers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxDescriptorSetUniformBuffers})

        {-# INLINE vkMaxDescriptorSetUniformBuffersByteOffset #-}
        vkMaxDescriptorSetUniformBuffersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetUniformBuffers}

        {-# INLINE readVkMaxDescriptorSetUniformBuffers #-}
        readVkMaxDescriptorSetUniformBuffers p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetUniformBuffers}

        {-# INLINE writeVkMaxDescriptorSetUniformBuffers #-}
        writeVkMaxDescriptorSetUniformBuffers p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetUniformBuffers}

class HasVkMaxDescriptorSetUniformBuffersDynamic a where
        type VkMaxDescriptorSetUniformBuffersDynamicMType a :: *

        vkMaxDescriptorSetUniformBuffersDynamic ::
                                                a -> VkMaxDescriptorSetUniformBuffersDynamicMType a

        vkMaxDescriptorSetUniformBuffersDynamicByteOffset :: a -> Int

        readVkMaxDescriptorSetUniformBuffersDynamic ::
                                                    Ptr a ->
                                                      IO
                                                        (VkMaxDescriptorSetUniformBuffersDynamicMType
                                                           a)

        writeVkMaxDescriptorSetUniformBuffersDynamic ::
                                                     Ptr a ->
                                                       VkMaxDescriptorSetUniformBuffersDynamicMType
                                                         a
                                                         -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxDescriptorSetUniformBuffersDynamic'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetUniformBuffersDynamic a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetUniformBuffersDynamic VkPhysicalDeviceLimits
         where
        type VkMaxDescriptorSetUniformBuffersDynamicMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxDescriptorSetUniformBuffersDynamic #-}
        vkMaxDescriptorSetUniformBuffersDynamic x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxDescriptorSetUniformBuffersDynamic})

        {-# INLINE vkMaxDescriptorSetUniformBuffersDynamicByteOffset #-}
        vkMaxDescriptorSetUniformBuffersDynamicByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetUniformBuffersDynamic}

        {-# INLINE readVkMaxDescriptorSetUniformBuffersDynamic #-}
        readVkMaxDescriptorSetUniformBuffersDynamic p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetUniformBuffersDynamic}

        {-# INLINE writeVkMaxDescriptorSetUniformBuffersDynamic #-}
        writeVkMaxDescriptorSetUniformBuffersDynamic p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetUniformBuffersDynamic}

class HasVkMaxDescriptorSetStorageBuffers a where
        type VkMaxDescriptorSetStorageBuffersMType a :: *

        vkMaxDescriptorSetStorageBuffers ::
                                         a -> VkMaxDescriptorSetStorageBuffersMType a

        vkMaxDescriptorSetStorageBuffersByteOffset :: a -> Int

        readVkMaxDescriptorSetStorageBuffers ::
                                             Ptr a -> IO (VkMaxDescriptorSetStorageBuffersMType a)

        writeVkMaxDescriptorSetStorageBuffers ::
                                              Ptr a ->
                                                VkMaxDescriptorSetStorageBuffersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxDescriptorSetStorageBuffers'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetStorageBuffers a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetStorageBuffers VkPhysicalDeviceLimits where
        type VkMaxDescriptorSetStorageBuffersMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxDescriptorSetStorageBuffers #-}
        vkMaxDescriptorSetStorageBuffers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageBuffers})

        {-# INLINE vkMaxDescriptorSetStorageBuffersByteOffset #-}
        vkMaxDescriptorSetStorageBuffersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageBuffers}

        {-# INLINE readVkMaxDescriptorSetStorageBuffers #-}
        readVkMaxDescriptorSetStorageBuffers p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageBuffers}

        {-# INLINE writeVkMaxDescriptorSetStorageBuffers #-}
        writeVkMaxDescriptorSetStorageBuffers p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageBuffers}

class HasVkMaxDescriptorSetStorageBuffersDynamic a where
        type VkMaxDescriptorSetStorageBuffersDynamicMType a :: *

        vkMaxDescriptorSetStorageBuffersDynamic ::
                                                a -> VkMaxDescriptorSetStorageBuffersDynamicMType a

        vkMaxDescriptorSetStorageBuffersDynamicByteOffset :: a -> Int

        readVkMaxDescriptorSetStorageBuffersDynamic ::
                                                    Ptr a ->
                                                      IO
                                                        (VkMaxDescriptorSetStorageBuffersDynamicMType
                                                           a)

        writeVkMaxDescriptorSetStorageBuffersDynamic ::
                                                     Ptr a ->
                                                       VkMaxDescriptorSetStorageBuffersDynamicMType
                                                         a
                                                         -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxDescriptorSetStorageBuffersDynamic'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetStorageBuffersDynamic a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetStorageBuffersDynamic VkPhysicalDeviceLimits
         where
        type VkMaxDescriptorSetStorageBuffersDynamicMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxDescriptorSetStorageBuffersDynamic #-}
        vkMaxDescriptorSetStorageBuffersDynamic x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageBuffersDynamic})

        {-# INLINE vkMaxDescriptorSetStorageBuffersDynamicByteOffset #-}
        vkMaxDescriptorSetStorageBuffersDynamicByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageBuffersDynamic}

        {-# INLINE readVkMaxDescriptorSetStorageBuffersDynamic #-}
        readVkMaxDescriptorSetStorageBuffersDynamic p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageBuffersDynamic}

        {-# INLINE writeVkMaxDescriptorSetStorageBuffersDynamic #-}
        writeVkMaxDescriptorSetStorageBuffersDynamic p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageBuffersDynamic}

class HasVkMaxDescriptorSetSampledImages a where
        type VkMaxDescriptorSetSampledImagesMType a :: *

        vkMaxDescriptorSetSampledImages ::
                                        a -> VkMaxDescriptorSetSampledImagesMType a

        vkMaxDescriptorSetSampledImagesByteOffset :: a -> Int

        readVkMaxDescriptorSetSampledImages ::
                                            Ptr a -> IO (VkMaxDescriptorSetSampledImagesMType a)

        writeVkMaxDescriptorSetSampledImages ::
                                             Ptr a ->
                                               VkMaxDescriptorSetSampledImagesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxDescriptorSetSampledImages'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetSampledImages a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetSampledImages VkPhysicalDeviceLimits where
        type VkMaxDescriptorSetSampledImagesMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxDescriptorSetSampledImages #-}
        vkMaxDescriptorSetSampledImages x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxDescriptorSetSampledImages})

        {-# INLINE vkMaxDescriptorSetSampledImagesByteOffset #-}
        vkMaxDescriptorSetSampledImagesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetSampledImages}

        {-# INLINE readVkMaxDescriptorSetSampledImages #-}
        readVkMaxDescriptorSetSampledImages p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetSampledImages}

        {-# INLINE writeVkMaxDescriptorSetSampledImages #-}
        writeVkMaxDescriptorSetSampledImages p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetSampledImages}

class HasVkMaxDescriptorSetStorageImages a where
        type VkMaxDescriptorSetStorageImagesMType a :: *

        vkMaxDescriptorSetStorageImages ::
                                        a -> VkMaxDescriptorSetStorageImagesMType a

        vkMaxDescriptorSetStorageImagesByteOffset :: a -> Int

        readVkMaxDescriptorSetStorageImages ::
                                            Ptr a -> IO (VkMaxDescriptorSetStorageImagesMType a)

        writeVkMaxDescriptorSetStorageImages ::
                                             Ptr a ->
                                               VkMaxDescriptorSetStorageImagesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxDescriptorSetStorageImages'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetStorageImages a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetStorageImages VkPhysicalDeviceLimits where
        type VkMaxDescriptorSetStorageImagesMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxDescriptorSetStorageImages #-}
        vkMaxDescriptorSetStorageImages x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageImages})

        {-# INLINE vkMaxDescriptorSetStorageImagesByteOffset #-}
        vkMaxDescriptorSetStorageImagesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageImages}

        {-# INLINE readVkMaxDescriptorSetStorageImages #-}
        readVkMaxDescriptorSetStorageImages p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageImages}

        {-# INLINE writeVkMaxDescriptorSetStorageImages #-}
        writeVkMaxDescriptorSetStorageImages p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageImages}

class HasVkMaxDescriptorSetInputAttachments a where
        type VkMaxDescriptorSetInputAttachmentsMType a :: *

        vkMaxDescriptorSetInputAttachments ::
                                           a -> VkMaxDescriptorSetInputAttachmentsMType a

        vkMaxDescriptorSetInputAttachmentsByteOffset :: a -> Int

        readVkMaxDescriptorSetInputAttachments ::
                                               Ptr a ->
                                                 IO (VkMaxDescriptorSetInputAttachmentsMType a)

        writeVkMaxDescriptorSetInputAttachments ::
                                                Ptr a ->
                                                  VkMaxDescriptorSetInputAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxDescriptorSetInputAttachments'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetInputAttachments a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetInputAttachments VkPhysicalDeviceLimits where
        type VkMaxDescriptorSetInputAttachmentsMType VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxDescriptorSetInputAttachments #-}
        vkMaxDescriptorSetInputAttachments x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxDescriptorSetInputAttachments})

        {-# INLINE vkMaxDescriptorSetInputAttachmentsByteOffset #-}
        vkMaxDescriptorSetInputAttachmentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetInputAttachments}

        {-# INLINE readVkMaxDescriptorSetInputAttachments #-}
        readVkMaxDescriptorSetInputAttachments p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetInputAttachments}

        {-# INLINE writeVkMaxDescriptorSetInputAttachments #-}
        writeVkMaxDescriptorSetInputAttachments p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxDescriptorSetInputAttachments}

class HasVkMaxVertexInputAttributes a where
        type VkMaxVertexInputAttributesMType a :: *

        vkMaxVertexInputAttributes ::
                                   a -> VkMaxVertexInputAttributesMType a

        vkMaxVertexInputAttributesByteOffset :: a -> Int

        readVkMaxVertexInputAttributes ::
                                       Ptr a -> IO (VkMaxVertexInputAttributesMType a)

        writeVkMaxVertexInputAttributes ::
                                        Ptr a -> VkMaxVertexInputAttributesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxVertexInputAttributes'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxVertexInputAttributes a

instance {-# OVERLAPPING #-}
         HasVkMaxVertexInputAttributes VkPhysicalDeviceLimits where
        type VkMaxVertexInputAttributesMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxVertexInputAttributes #-}
        vkMaxVertexInputAttributes x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxVertexInputAttributes})

        {-# INLINE vkMaxVertexInputAttributesByteOffset #-}
        vkMaxVertexInputAttributesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxVertexInputAttributes}

        {-# INLINE readVkMaxVertexInputAttributes #-}
        readVkMaxVertexInputAttributes p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxVertexInputAttributes}

        {-# INLINE writeVkMaxVertexInputAttributes #-}
        writeVkMaxVertexInputAttributes p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxVertexInputAttributes}

class HasVkMaxVertexInputBindings a where
        type VkMaxVertexInputBindingsMType a :: *

        vkMaxVertexInputBindings :: a -> VkMaxVertexInputBindingsMType a

        vkMaxVertexInputBindingsByteOffset :: a -> Int

        readVkMaxVertexInputBindings ::
                                     Ptr a -> IO (VkMaxVertexInputBindingsMType a)

        writeVkMaxVertexInputBindings ::
                                      Ptr a -> VkMaxVertexInputBindingsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxVertexInputBindings'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxVertexInputBindings a

instance {-# OVERLAPPING #-}
         HasVkMaxVertexInputBindings VkPhysicalDeviceLimits where
        type VkMaxVertexInputBindingsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxVertexInputBindings #-}
        vkMaxVertexInputBindings x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxVertexInputBindings})

        {-# INLINE vkMaxVertexInputBindingsByteOffset #-}
        vkMaxVertexInputBindingsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxVertexInputBindings}

        {-# INLINE readVkMaxVertexInputBindings #-}
        readVkMaxVertexInputBindings p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxVertexInputBindings}

        {-# INLINE writeVkMaxVertexInputBindings #-}
        writeVkMaxVertexInputBindings p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxVertexInputBindings}

class HasVkMaxVertexInputAttributeOffset a where
        type VkMaxVertexInputAttributeOffsetMType a :: *

        vkMaxVertexInputAttributeOffset ::
                                        a -> VkMaxVertexInputAttributeOffsetMType a

        vkMaxVertexInputAttributeOffsetByteOffset :: a -> Int

        readVkMaxVertexInputAttributeOffset ::
                                            Ptr a -> IO (VkMaxVertexInputAttributeOffsetMType a)

        writeVkMaxVertexInputAttributeOffset ::
                                             Ptr a ->
                                               VkMaxVertexInputAttributeOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxVertexInputAttributeOffset'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxVertexInputAttributeOffset a

instance {-# OVERLAPPING #-}
         HasVkMaxVertexInputAttributeOffset VkPhysicalDeviceLimits where
        type VkMaxVertexInputAttributeOffsetMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxVertexInputAttributeOffset #-}
        vkMaxVertexInputAttributeOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxVertexInputAttributeOffset})

        {-# INLINE vkMaxVertexInputAttributeOffsetByteOffset #-}
        vkMaxVertexInputAttributeOffsetByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxVertexInputAttributeOffset}

        {-# INLINE readVkMaxVertexInputAttributeOffset #-}
        readVkMaxVertexInputAttributeOffset p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxVertexInputAttributeOffset}

        {-# INLINE writeVkMaxVertexInputAttributeOffset #-}
        writeVkMaxVertexInputAttributeOffset p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxVertexInputAttributeOffset}

class HasVkMaxVertexInputBindingStride a where
        type VkMaxVertexInputBindingStrideMType a :: *

        vkMaxVertexInputBindingStride ::
                                      a -> VkMaxVertexInputBindingStrideMType a

        vkMaxVertexInputBindingStrideByteOffset :: a -> Int

        readVkMaxVertexInputBindingStride ::
                                          Ptr a -> IO (VkMaxVertexInputBindingStrideMType a)

        writeVkMaxVertexInputBindingStride ::
                                           Ptr a -> VkMaxVertexInputBindingStrideMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxVertexInputBindingStride'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxVertexInputBindingStride a

instance {-# OVERLAPPING #-}
         HasVkMaxVertexInputBindingStride VkPhysicalDeviceLimits where
        type VkMaxVertexInputBindingStrideMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxVertexInputBindingStride #-}
        vkMaxVertexInputBindingStride x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxVertexInputBindingStride})

        {-# INLINE vkMaxVertexInputBindingStrideByteOffset #-}
        vkMaxVertexInputBindingStrideByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxVertexInputBindingStride}

        {-# INLINE readVkMaxVertexInputBindingStride #-}
        readVkMaxVertexInputBindingStride p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxVertexInputBindingStride}

        {-# INLINE writeVkMaxVertexInputBindingStride #-}
        writeVkMaxVertexInputBindingStride p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxVertexInputBindingStride}

class HasVkMaxVertexOutputComponents a where
        type VkMaxVertexOutputComponentsMType a :: *

        vkMaxVertexOutputComponents ::
                                    a -> VkMaxVertexOutputComponentsMType a

        vkMaxVertexOutputComponentsByteOffset :: a -> Int

        readVkMaxVertexOutputComponents ::
                                        Ptr a -> IO (VkMaxVertexOutputComponentsMType a)

        writeVkMaxVertexOutputComponents ::
                                         Ptr a -> VkMaxVertexOutputComponentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxVertexOutputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxVertexOutputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxVertexOutputComponents VkPhysicalDeviceLimits where
        type VkMaxVertexOutputComponentsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxVertexOutputComponents #-}
        vkMaxVertexOutputComponents x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxVertexOutputComponents})

        {-# INLINE vkMaxVertexOutputComponentsByteOffset #-}
        vkMaxVertexOutputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxVertexOutputComponents}

        {-# INLINE readVkMaxVertexOutputComponents #-}
        readVkMaxVertexOutputComponents p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxVertexOutputComponents}

        {-# INLINE writeVkMaxVertexOutputComponents #-}
        writeVkMaxVertexOutputComponents p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxVertexOutputComponents}

class HasVkMaxTessellationGenerationLevel a where
        type VkMaxTessellationGenerationLevelMType a :: *

        vkMaxTessellationGenerationLevel ::
                                         a -> VkMaxTessellationGenerationLevelMType a

        vkMaxTessellationGenerationLevelByteOffset :: a -> Int

        readVkMaxTessellationGenerationLevel ::
                                             Ptr a -> IO (VkMaxTessellationGenerationLevelMType a)

        writeVkMaxTessellationGenerationLevel ::
                                              Ptr a ->
                                                VkMaxTessellationGenerationLevelMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxTessellationGenerationLevel'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationGenerationLevel a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationGenerationLevel VkPhysicalDeviceLimits where
        type VkMaxTessellationGenerationLevelMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxTessellationGenerationLevel #-}
        vkMaxTessellationGenerationLevel x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxTessellationGenerationLevel})

        {-# INLINE vkMaxTessellationGenerationLevelByteOffset #-}
        vkMaxTessellationGenerationLevelByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationGenerationLevel}

        {-# INLINE readVkMaxTessellationGenerationLevel #-}
        readVkMaxTessellationGenerationLevel p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationGenerationLevel}

        {-# INLINE writeVkMaxTessellationGenerationLevel #-}
        writeVkMaxTessellationGenerationLevel p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationGenerationLevel}

class HasVkMaxTessellationPatchSize a where
        type VkMaxTessellationPatchSizeMType a :: *

        vkMaxTessellationPatchSize ::
                                   a -> VkMaxTessellationPatchSizeMType a

        vkMaxTessellationPatchSizeByteOffset :: a -> Int

        readVkMaxTessellationPatchSize ::
                                       Ptr a -> IO (VkMaxTessellationPatchSizeMType a)

        writeVkMaxTessellationPatchSize ::
                                        Ptr a -> VkMaxTessellationPatchSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxTessellationPatchSize'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationPatchSize a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationPatchSize VkPhysicalDeviceLimits where
        type VkMaxTessellationPatchSizeMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxTessellationPatchSize #-}
        vkMaxTessellationPatchSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxTessellationPatchSize})

        {-# INLINE vkMaxTessellationPatchSizeByteOffset #-}
        vkMaxTessellationPatchSizeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationPatchSize}

        {-# INLINE readVkMaxTessellationPatchSize #-}
        readVkMaxTessellationPatchSize p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationPatchSize}

        {-# INLINE writeVkMaxTessellationPatchSize #-}
        writeVkMaxTessellationPatchSize p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationPatchSize}

class HasVkMaxTessellationControlPerVertexInputComponents a where
        type VkMaxTessellationControlPerVertexInputComponentsMType a :: *

        vkMaxTessellationControlPerVertexInputComponents ::
                                                         a ->
                                                           VkMaxTessellationControlPerVertexInputComponentsMType
                                                             a

        vkMaxTessellationControlPerVertexInputComponentsByteOffset ::
                                                                   a -> Int

        readVkMaxTessellationControlPerVertexInputComponents ::
                                                             Ptr a ->
                                                               IO
                                                                 (VkMaxTessellationControlPerVertexInputComponentsMType
                                                                    a)

        writeVkMaxTessellationControlPerVertexInputComponents ::
                                                              Ptr a ->
                                                                VkMaxTessellationControlPerVertexInputComponentsMType
                                                                  a
                                                                  -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxTessellationControlPerVertexInputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationControlPerVertexInputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationControlPerVertexInputComponents
           VkPhysicalDeviceLimits
         where
        type VkMaxTessellationControlPerVertexInputComponentsMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxTessellationControlPerVertexInputComponents #-}
        vkMaxTessellationControlPerVertexInputComponents x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxTessellationControlPerVertexInputComponents})

        {-# INLINE vkMaxTessellationControlPerVertexInputComponentsByteOffset
                   #-}
        vkMaxTessellationControlPerVertexInputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationControlPerVertexInputComponents}

        {-# INLINE readVkMaxTessellationControlPerVertexInputComponents #-}
        readVkMaxTessellationControlPerVertexInputComponents p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationControlPerVertexInputComponents}

        {-# INLINE writeVkMaxTessellationControlPerVertexInputComponents
                   #-}
        writeVkMaxTessellationControlPerVertexInputComponents p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationControlPerVertexInputComponents}

class HasVkMaxTessellationControlPerVertexOutputComponents a where
        type VkMaxTessellationControlPerVertexOutputComponentsMType a :: *

        vkMaxTessellationControlPerVertexOutputComponents ::
                                                          a ->
                                                            VkMaxTessellationControlPerVertexOutputComponentsMType
                                                              a

        vkMaxTessellationControlPerVertexOutputComponentsByteOffset ::
                                                                    a -> Int

        readVkMaxTessellationControlPerVertexOutputComponents ::
                                                              Ptr a ->
                                                                IO
                                                                  (VkMaxTessellationControlPerVertexOutputComponentsMType
                                                                     a)

        writeVkMaxTessellationControlPerVertexOutputComponents ::
                                                               Ptr a ->
                                                                 VkMaxTessellationControlPerVertexOutputComponentsMType
                                                                   a
                                                                   -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxTessellationControlPerVertexOutputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationControlPerVertexOutputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationControlPerVertexOutputComponents
           VkPhysicalDeviceLimits
         where
        type VkMaxTessellationControlPerVertexOutputComponentsMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxTessellationControlPerVertexOutputComponents #-}
        vkMaxTessellationControlPerVertexOutputComponents x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxTessellationControlPerVertexOutputComponents})

        {-# INLINE vkMaxTessellationControlPerVertexOutputComponentsByteOffset
                   #-}
        vkMaxTessellationControlPerVertexOutputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationControlPerVertexOutputComponents}

        {-# INLINE readVkMaxTessellationControlPerVertexOutputComponents
                   #-}
        readVkMaxTessellationControlPerVertexOutputComponents p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationControlPerVertexOutputComponents}

        {-# INLINE writeVkMaxTessellationControlPerVertexOutputComponents
                   #-}
        writeVkMaxTessellationControlPerVertexOutputComponents p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationControlPerVertexOutputComponents}

class HasVkMaxTessellationControlPerPatchOutputComponents a where
        type VkMaxTessellationControlPerPatchOutputComponentsMType a :: *

        vkMaxTessellationControlPerPatchOutputComponents ::
                                                         a ->
                                                           VkMaxTessellationControlPerPatchOutputComponentsMType
                                                             a

        vkMaxTessellationControlPerPatchOutputComponentsByteOffset ::
                                                                   a -> Int

        readVkMaxTessellationControlPerPatchOutputComponents ::
                                                             Ptr a ->
                                                               IO
                                                                 (VkMaxTessellationControlPerPatchOutputComponentsMType
                                                                    a)

        writeVkMaxTessellationControlPerPatchOutputComponents ::
                                                              Ptr a ->
                                                                VkMaxTessellationControlPerPatchOutputComponentsMType
                                                                  a
                                                                  -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxTessellationControlPerPatchOutputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationControlPerPatchOutputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationControlPerPatchOutputComponents
           VkPhysicalDeviceLimits
         where
        type VkMaxTessellationControlPerPatchOutputComponentsMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxTessellationControlPerPatchOutputComponents #-}
        vkMaxTessellationControlPerPatchOutputComponents x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxTessellationControlPerPatchOutputComponents})

        {-# INLINE vkMaxTessellationControlPerPatchOutputComponentsByteOffset
                   #-}
        vkMaxTessellationControlPerPatchOutputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationControlPerPatchOutputComponents}

        {-# INLINE readVkMaxTessellationControlPerPatchOutputComponents #-}
        readVkMaxTessellationControlPerPatchOutputComponents p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationControlPerPatchOutputComponents}

        {-# INLINE writeVkMaxTessellationControlPerPatchOutputComponents
                   #-}
        writeVkMaxTessellationControlPerPatchOutputComponents p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationControlPerPatchOutputComponents}

class HasVkMaxTessellationControlTotalOutputComponents a where
        type VkMaxTessellationControlTotalOutputComponentsMType a :: *

        vkMaxTessellationControlTotalOutputComponents ::
                                                      a ->
                                                        VkMaxTessellationControlTotalOutputComponentsMType
                                                          a

        vkMaxTessellationControlTotalOutputComponentsByteOffset :: a -> Int

        readVkMaxTessellationControlTotalOutputComponents ::
                                                          Ptr a ->
                                                            IO
                                                              (VkMaxTessellationControlTotalOutputComponentsMType
                                                                 a)

        writeVkMaxTessellationControlTotalOutputComponents ::
                                                           Ptr a ->
                                                             VkMaxTessellationControlTotalOutputComponentsMType
                                                               a
                                                               -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxTessellationControlTotalOutputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationControlTotalOutputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationControlTotalOutputComponents
           VkPhysicalDeviceLimits
         where
        type VkMaxTessellationControlTotalOutputComponentsMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxTessellationControlTotalOutputComponents #-}
        vkMaxTessellationControlTotalOutputComponents x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxTessellationControlTotalOutputComponents})

        {-# INLINE vkMaxTessellationControlTotalOutputComponentsByteOffset
                   #-}
        vkMaxTessellationControlTotalOutputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationControlTotalOutputComponents}

        {-# INLINE readVkMaxTessellationControlTotalOutputComponents #-}
        readVkMaxTessellationControlTotalOutputComponents p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationControlTotalOutputComponents}

        {-# INLINE writeVkMaxTessellationControlTotalOutputComponents #-}
        writeVkMaxTessellationControlTotalOutputComponents p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationControlTotalOutputComponents}

class HasVkMaxTessellationEvaluationInputComponents a where
        type VkMaxTessellationEvaluationInputComponentsMType a :: *

        vkMaxTessellationEvaluationInputComponents ::
                                                   a ->
                                                     VkMaxTessellationEvaluationInputComponentsMType
                                                       a

        vkMaxTessellationEvaluationInputComponentsByteOffset :: a -> Int

        readVkMaxTessellationEvaluationInputComponents ::
                                                       Ptr a ->
                                                         IO
                                                           (VkMaxTessellationEvaluationInputComponentsMType
                                                              a)

        writeVkMaxTessellationEvaluationInputComponents ::
                                                        Ptr a ->
                                                          VkMaxTessellationEvaluationInputComponentsMType
                                                            a
                                                            -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxTessellationEvaluationInputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationEvaluationInputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationEvaluationInputComponents
           VkPhysicalDeviceLimits
         where
        type VkMaxTessellationEvaluationInputComponentsMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxTessellationEvaluationInputComponents #-}
        vkMaxTessellationEvaluationInputComponents x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxTessellationEvaluationInputComponents})

        {-# INLINE vkMaxTessellationEvaluationInputComponentsByteOffset #-}
        vkMaxTessellationEvaluationInputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationEvaluationInputComponents}

        {-# INLINE readVkMaxTessellationEvaluationInputComponents #-}
        readVkMaxTessellationEvaluationInputComponents p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationEvaluationInputComponents}

        {-# INLINE writeVkMaxTessellationEvaluationInputComponents #-}
        writeVkMaxTessellationEvaluationInputComponents p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationEvaluationInputComponents}

class HasVkMaxTessellationEvaluationOutputComponents a where
        type VkMaxTessellationEvaluationOutputComponentsMType a :: *

        vkMaxTessellationEvaluationOutputComponents ::
                                                    a ->
                                                      VkMaxTessellationEvaluationOutputComponentsMType
                                                        a

        vkMaxTessellationEvaluationOutputComponentsByteOffset :: a -> Int

        readVkMaxTessellationEvaluationOutputComponents ::
                                                        Ptr a ->
                                                          IO
                                                            (VkMaxTessellationEvaluationOutputComponentsMType
                                                               a)

        writeVkMaxTessellationEvaluationOutputComponents ::
                                                         Ptr a ->
                                                           VkMaxTessellationEvaluationOutputComponentsMType
                                                             a
                                                             -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxTessellationEvaluationOutputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationEvaluationOutputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationEvaluationOutputComponents
           VkPhysicalDeviceLimits
         where
        type VkMaxTessellationEvaluationOutputComponentsMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxTessellationEvaluationOutputComponents #-}
        vkMaxTessellationEvaluationOutputComponents x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxTessellationEvaluationOutputComponents})

        {-# INLINE vkMaxTessellationEvaluationOutputComponentsByteOffset
                   #-}
        vkMaxTessellationEvaluationOutputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationEvaluationOutputComponents}

        {-# INLINE readVkMaxTessellationEvaluationOutputComponents #-}
        readVkMaxTessellationEvaluationOutputComponents p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationEvaluationOutputComponents}

        {-# INLINE writeVkMaxTessellationEvaluationOutputComponents #-}
        writeVkMaxTessellationEvaluationOutputComponents p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxTessellationEvaluationOutputComponents}

class HasVkMaxGeometryShaderInvocations a where
        type VkMaxGeometryShaderInvocationsMType a :: *

        vkMaxGeometryShaderInvocations ::
                                       a -> VkMaxGeometryShaderInvocationsMType a

        vkMaxGeometryShaderInvocationsByteOffset :: a -> Int

        readVkMaxGeometryShaderInvocations ::
                                           Ptr a -> IO (VkMaxGeometryShaderInvocationsMType a)

        writeVkMaxGeometryShaderInvocations ::
                                            Ptr a -> VkMaxGeometryShaderInvocationsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxGeometryShaderInvocations'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxGeometryShaderInvocations a

instance {-# OVERLAPPING #-}
         HasVkMaxGeometryShaderInvocations VkPhysicalDeviceLimits where
        type VkMaxGeometryShaderInvocationsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxGeometryShaderInvocations #-}
        vkMaxGeometryShaderInvocations x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxGeometryShaderInvocations})

        {-# INLINE vkMaxGeometryShaderInvocationsByteOffset #-}
        vkMaxGeometryShaderInvocationsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxGeometryShaderInvocations}

        {-# INLINE readVkMaxGeometryShaderInvocations #-}
        readVkMaxGeometryShaderInvocations p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxGeometryShaderInvocations}

        {-# INLINE writeVkMaxGeometryShaderInvocations #-}
        writeVkMaxGeometryShaderInvocations p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxGeometryShaderInvocations}

class HasVkMaxGeometryInputComponents a where
        type VkMaxGeometryInputComponentsMType a :: *

        vkMaxGeometryInputComponents ::
                                     a -> VkMaxGeometryInputComponentsMType a

        vkMaxGeometryInputComponentsByteOffset :: a -> Int

        readVkMaxGeometryInputComponents ::
                                         Ptr a -> IO (VkMaxGeometryInputComponentsMType a)

        writeVkMaxGeometryInputComponents ::
                                          Ptr a -> VkMaxGeometryInputComponentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxGeometryInputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxGeometryInputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxGeometryInputComponents VkPhysicalDeviceLimits where
        type VkMaxGeometryInputComponentsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxGeometryInputComponents #-}
        vkMaxGeometryInputComponents x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxGeometryInputComponents})

        {-# INLINE vkMaxGeometryInputComponentsByteOffset #-}
        vkMaxGeometryInputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxGeometryInputComponents}

        {-# INLINE readVkMaxGeometryInputComponents #-}
        readVkMaxGeometryInputComponents p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxGeometryInputComponents}

        {-# INLINE writeVkMaxGeometryInputComponents #-}
        writeVkMaxGeometryInputComponents p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxGeometryInputComponents}

class HasVkMaxGeometryOutputComponents a where
        type VkMaxGeometryOutputComponentsMType a :: *

        vkMaxGeometryOutputComponents ::
                                      a -> VkMaxGeometryOutputComponentsMType a

        vkMaxGeometryOutputComponentsByteOffset :: a -> Int

        readVkMaxGeometryOutputComponents ::
                                          Ptr a -> IO (VkMaxGeometryOutputComponentsMType a)

        writeVkMaxGeometryOutputComponents ::
                                           Ptr a -> VkMaxGeometryOutputComponentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxGeometryOutputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxGeometryOutputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxGeometryOutputComponents VkPhysicalDeviceLimits where
        type VkMaxGeometryOutputComponentsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxGeometryOutputComponents #-}
        vkMaxGeometryOutputComponents x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxGeometryOutputComponents})

        {-# INLINE vkMaxGeometryOutputComponentsByteOffset #-}
        vkMaxGeometryOutputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxGeometryOutputComponents}

        {-# INLINE readVkMaxGeometryOutputComponents #-}
        readVkMaxGeometryOutputComponents p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxGeometryOutputComponents}

        {-# INLINE writeVkMaxGeometryOutputComponents #-}
        writeVkMaxGeometryOutputComponents p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxGeometryOutputComponents}

class HasVkMaxGeometryOutputVertices a where
        type VkMaxGeometryOutputVerticesMType a :: *

        vkMaxGeometryOutputVertices ::
                                    a -> VkMaxGeometryOutputVerticesMType a

        vkMaxGeometryOutputVerticesByteOffset :: a -> Int

        readVkMaxGeometryOutputVertices ::
                                        Ptr a -> IO (VkMaxGeometryOutputVerticesMType a)

        writeVkMaxGeometryOutputVertices ::
                                         Ptr a -> VkMaxGeometryOutputVerticesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxGeometryOutputVertices'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxGeometryOutputVertices a

instance {-# OVERLAPPING #-}
         HasVkMaxGeometryOutputVertices VkPhysicalDeviceLimits where
        type VkMaxGeometryOutputVerticesMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxGeometryOutputVertices #-}
        vkMaxGeometryOutputVertices x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxGeometryOutputVertices})

        {-# INLINE vkMaxGeometryOutputVerticesByteOffset #-}
        vkMaxGeometryOutputVerticesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxGeometryOutputVertices}

        {-# INLINE readVkMaxGeometryOutputVertices #-}
        readVkMaxGeometryOutputVertices p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxGeometryOutputVertices}

        {-# INLINE writeVkMaxGeometryOutputVertices #-}
        writeVkMaxGeometryOutputVertices p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxGeometryOutputVertices}

class HasVkMaxGeometryTotalOutputComponents a where
        type VkMaxGeometryTotalOutputComponentsMType a :: *

        vkMaxGeometryTotalOutputComponents ::
                                           a -> VkMaxGeometryTotalOutputComponentsMType a

        vkMaxGeometryTotalOutputComponentsByteOffset :: a -> Int

        readVkMaxGeometryTotalOutputComponents ::
                                               Ptr a ->
                                                 IO (VkMaxGeometryTotalOutputComponentsMType a)

        writeVkMaxGeometryTotalOutputComponents ::
                                                Ptr a ->
                                                  VkMaxGeometryTotalOutputComponentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxGeometryTotalOutputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxGeometryTotalOutputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxGeometryTotalOutputComponents VkPhysicalDeviceLimits where
        type VkMaxGeometryTotalOutputComponentsMType VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxGeometryTotalOutputComponents #-}
        vkMaxGeometryTotalOutputComponents x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxGeometryTotalOutputComponents})

        {-# INLINE vkMaxGeometryTotalOutputComponentsByteOffset #-}
        vkMaxGeometryTotalOutputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxGeometryTotalOutputComponents}

        {-# INLINE readVkMaxGeometryTotalOutputComponents #-}
        readVkMaxGeometryTotalOutputComponents p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxGeometryTotalOutputComponents}

        {-# INLINE writeVkMaxGeometryTotalOutputComponents #-}
        writeVkMaxGeometryTotalOutputComponents p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxGeometryTotalOutputComponents}

class HasVkMaxFragmentInputComponents a where
        type VkMaxFragmentInputComponentsMType a :: *

        vkMaxFragmentInputComponents ::
                                     a -> VkMaxFragmentInputComponentsMType a

        vkMaxFragmentInputComponentsByteOffset :: a -> Int

        readVkMaxFragmentInputComponents ::
                                         Ptr a -> IO (VkMaxFragmentInputComponentsMType a)

        writeVkMaxFragmentInputComponents ::
                                          Ptr a -> VkMaxFragmentInputComponentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxFragmentInputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxFragmentInputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxFragmentInputComponents VkPhysicalDeviceLimits where
        type VkMaxFragmentInputComponentsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxFragmentInputComponents #-}
        vkMaxFragmentInputComponents x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxFragmentInputComponents})

        {-# INLINE vkMaxFragmentInputComponentsByteOffset #-}
        vkMaxFragmentInputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxFragmentInputComponents}

        {-# INLINE readVkMaxFragmentInputComponents #-}
        readVkMaxFragmentInputComponents p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxFragmentInputComponents}

        {-# INLINE writeVkMaxFragmentInputComponents #-}
        writeVkMaxFragmentInputComponents p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxFragmentInputComponents}

class HasVkMaxFragmentOutputAttachments a where
        type VkMaxFragmentOutputAttachmentsMType a :: *

        vkMaxFragmentOutputAttachments ::
                                       a -> VkMaxFragmentOutputAttachmentsMType a

        vkMaxFragmentOutputAttachmentsByteOffset :: a -> Int

        readVkMaxFragmentOutputAttachments ::
                                           Ptr a -> IO (VkMaxFragmentOutputAttachmentsMType a)

        writeVkMaxFragmentOutputAttachments ::
                                            Ptr a -> VkMaxFragmentOutputAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxFragmentOutputAttachments'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxFragmentOutputAttachments a

instance {-# OVERLAPPING #-}
         HasVkMaxFragmentOutputAttachments VkPhysicalDeviceLimits where
        type VkMaxFragmentOutputAttachmentsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxFragmentOutputAttachments #-}
        vkMaxFragmentOutputAttachments x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxFragmentOutputAttachments})

        {-# INLINE vkMaxFragmentOutputAttachmentsByteOffset #-}
        vkMaxFragmentOutputAttachmentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxFragmentOutputAttachments}

        {-# INLINE readVkMaxFragmentOutputAttachments #-}
        readVkMaxFragmentOutputAttachments p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxFragmentOutputAttachments}

        {-# INLINE writeVkMaxFragmentOutputAttachments #-}
        writeVkMaxFragmentOutputAttachments p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxFragmentOutputAttachments}

class HasVkMaxFragmentDualSrcAttachments a where
        type VkMaxFragmentDualSrcAttachmentsMType a :: *

        vkMaxFragmentDualSrcAttachments ::
                                        a -> VkMaxFragmentDualSrcAttachmentsMType a

        vkMaxFragmentDualSrcAttachmentsByteOffset :: a -> Int

        readVkMaxFragmentDualSrcAttachments ::
                                            Ptr a -> IO (VkMaxFragmentDualSrcAttachmentsMType a)

        writeVkMaxFragmentDualSrcAttachments ::
                                             Ptr a ->
                                               VkMaxFragmentDualSrcAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxFragmentDualSrcAttachments'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxFragmentDualSrcAttachments a

instance {-# OVERLAPPING #-}
         HasVkMaxFragmentDualSrcAttachments VkPhysicalDeviceLimits where
        type VkMaxFragmentDualSrcAttachmentsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxFragmentDualSrcAttachments #-}
        vkMaxFragmentDualSrcAttachments x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxFragmentDualSrcAttachments})

        {-# INLINE vkMaxFragmentDualSrcAttachmentsByteOffset #-}
        vkMaxFragmentDualSrcAttachmentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxFragmentDualSrcAttachments}

        {-# INLINE readVkMaxFragmentDualSrcAttachments #-}
        readVkMaxFragmentDualSrcAttachments p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxFragmentDualSrcAttachments}

        {-# INLINE writeVkMaxFragmentDualSrcAttachments #-}
        writeVkMaxFragmentDualSrcAttachments p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxFragmentDualSrcAttachments}

class HasVkMaxFragmentCombinedOutputResources a where
        type VkMaxFragmentCombinedOutputResourcesMType a :: *

        vkMaxFragmentCombinedOutputResources ::
                                             a -> VkMaxFragmentCombinedOutputResourcesMType a

        vkMaxFragmentCombinedOutputResourcesByteOffset :: a -> Int

        readVkMaxFragmentCombinedOutputResources ::
                                                 Ptr a ->
                                                   IO (VkMaxFragmentCombinedOutputResourcesMType a)

        writeVkMaxFragmentCombinedOutputResources ::
                                                  Ptr a ->
                                                    VkMaxFragmentCombinedOutputResourcesMType a ->
                                                      IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxFragmentCombinedOutputResources'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxFragmentCombinedOutputResources a

instance {-# OVERLAPPING #-}
         HasVkMaxFragmentCombinedOutputResources VkPhysicalDeviceLimits
         where
        type VkMaxFragmentCombinedOutputResourcesMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxFragmentCombinedOutputResources #-}
        vkMaxFragmentCombinedOutputResources x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxFragmentCombinedOutputResources})

        {-# INLINE vkMaxFragmentCombinedOutputResourcesByteOffset #-}
        vkMaxFragmentCombinedOutputResourcesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxFragmentCombinedOutputResources}

        {-# INLINE readVkMaxFragmentCombinedOutputResources #-}
        readVkMaxFragmentCombinedOutputResources p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxFragmentCombinedOutputResources}

        {-# INLINE writeVkMaxFragmentCombinedOutputResources #-}
        writeVkMaxFragmentCombinedOutputResources p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxFragmentCombinedOutputResources}

class HasVkMaxComputeSharedMemorySize a where
        type VkMaxComputeSharedMemorySizeMType a :: *

        vkMaxComputeSharedMemorySize ::
                                     a -> VkMaxComputeSharedMemorySizeMType a

        vkMaxComputeSharedMemorySizeByteOffset :: a -> Int

        readVkMaxComputeSharedMemorySize ::
                                         Ptr a -> IO (VkMaxComputeSharedMemorySizeMType a)

        writeVkMaxComputeSharedMemorySize ::
                                          Ptr a -> VkMaxComputeSharedMemorySizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxComputeSharedMemorySize'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxComputeSharedMemorySize a

instance {-# OVERLAPPING #-}
         HasVkMaxComputeSharedMemorySize VkPhysicalDeviceLimits where
        type VkMaxComputeSharedMemorySizeMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxComputeSharedMemorySize #-}
        vkMaxComputeSharedMemorySize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxComputeSharedMemorySize})

        {-# INLINE vkMaxComputeSharedMemorySizeByteOffset #-}
        vkMaxComputeSharedMemorySizeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxComputeSharedMemorySize}

        {-# INLINE readVkMaxComputeSharedMemorySize #-}
        readVkMaxComputeSharedMemorySize p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxComputeSharedMemorySize}

        {-# INLINE writeVkMaxComputeSharedMemorySize #-}
        writeVkMaxComputeSharedMemorySize p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxComputeSharedMemorySize}

class HasVkMaxComputeWorkGroupCountArray a where
        type VkMaxComputeWorkGroupCountArrayMType a :: *

        vkMaxComputeWorkGroupCountArray ::
                                        a -> Int -> VkMaxComputeWorkGroupCountArrayMType a

        vkMaxComputeWorkGroupCountArrayByteOffset :: a -> Int

        readVkMaxComputeWorkGroupCountArray ::
                                            Ptr a ->
                                              Int -> IO (VkMaxComputeWorkGroupCountArrayMType a)

        writeVkMaxComputeWorkGroupCountArray ::
                                             Ptr a ->
                                               Int ->
                                                 VkMaxComputeWorkGroupCountArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxComputeWorkGroupCount'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxComputeWorkGroupCountArray a

instance {-# OVERLAPPING #-}
         HasVkMaxComputeWorkGroupCountArray VkPhysicalDeviceLimits where
        type VkMaxComputeWorkGroupCountArrayMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxComputeWorkGroupCountArray #-}
        vkMaxComputeWorkGroupCountArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Data.Word.Word32) +
                    #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupCount}))

        {-# INLINE vkMaxComputeWorkGroupCountArrayByteOffset #-}
        vkMaxComputeWorkGroupCountArrayByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupCount}

        {-# INLINE readVkMaxComputeWorkGroupCountArray #-}
        readVkMaxComputeWorkGroupCountArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Data.Word.Word32) +
                 #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupCount})

        {-# INLINE writeVkMaxComputeWorkGroupCountArray #-}
        writeVkMaxComputeWorkGroupCountArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Data.Word.Word32) +
                 #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupCount})

class HasVkMaxComputeWorkGroupInvocations a where
        type VkMaxComputeWorkGroupInvocationsMType a :: *

        vkMaxComputeWorkGroupInvocations ::
                                         a -> VkMaxComputeWorkGroupInvocationsMType a

        vkMaxComputeWorkGroupInvocationsByteOffset :: a -> Int

        readVkMaxComputeWorkGroupInvocations ::
                                             Ptr a -> IO (VkMaxComputeWorkGroupInvocationsMType a)

        writeVkMaxComputeWorkGroupInvocations ::
                                              Ptr a ->
                                                VkMaxComputeWorkGroupInvocationsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxComputeWorkGroupInvocations'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxComputeWorkGroupInvocations a

instance {-# OVERLAPPING #-}
         HasVkMaxComputeWorkGroupInvocations VkPhysicalDeviceLimits where
        type VkMaxComputeWorkGroupInvocationsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxComputeWorkGroupInvocations #-}
        vkMaxComputeWorkGroupInvocations x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupInvocations})

        {-# INLINE vkMaxComputeWorkGroupInvocationsByteOffset #-}
        vkMaxComputeWorkGroupInvocationsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupInvocations}

        {-# INLINE readVkMaxComputeWorkGroupInvocations #-}
        readVkMaxComputeWorkGroupInvocations p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupInvocations}

        {-# INLINE writeVkMaxComputeWorkGroupInvocations #-}
        writeVkMaxComputeWorkGroupInvocations p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupInvocations}

class HasVkMaxComputeWorkGroupSizeArray a where
        type VkMaxComputeWorkGroupSizeArrayMType a :: *

        vkMaxComputeWorkGroupSizeArray ::
                                       a -> Int -> VkMaxComputeWorkGroupSizeArrayMType a

        vkMaxComputeWorkGroupSizeArrayByteOffset :: a -> Int

        readVkMaxComputeWorkGroupSizeArray ::
                                           Ptr a ->
                                             Int -> IO (VkMaxComputeWorkGroupSizeArrayMType a)

        writeVkMaxComputeWorkGroupSizeArray ::
                                            Ptr a ->
                                              Int -> VkMaxComputeWorkGroupSizeArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxComputeWorkGroupSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxComputeWorkGroupSizeArray a

instance {-# OVERLAPPING #-}
         HasVkMaxComputeWorkGroupSizeArray VkPhysicalDeviceLimits where
        type VkMaxComputeWorkGroupSizeArrayMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxComputeWorkGroupSizeArray #-}
        vkMaxComputeWorkGroupSizeArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Data.Word.Word32) +
                    #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupSize}))

        {-# INLINE vkMaxComputeWorkGroupSizeArrayByteOffset #-}
        vkMaxComputeWorkGroupSizeArrayByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupSize}

        {-# INLINE readVkMaxComputeWorkGroupSizeArray #-}
        readVkMaxComputeWorkGroupSizeArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Data.Word.Word32) +
                 #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupSize})

        {-# INLINE writeVkMaxComputeWorkGroupSizeArray #-}
        writeVkMaxComputeWorkGroupSizeArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Data.Word.Word32) +
                 #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupSize})

class HasVkSubPixelPrecisionBits a where
        type VkSubPixelPrecisionBitsMType a :: *

        vkSubPixelPrecisionBits :: a -> VkSubPixelPrecisionBitsMType a

        vkSubPixelPrecisionBitsByteOffset :: a -> Int

        readVkSubPixelPrecisionBits ::
                                    Ptr a -> IO (VkSubPixelPrecisionBitsMType a)

        writeVkSubPixelPrecisionBits ::
                                     Ptr a -> VkSubPixelPrecisionBitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'subPixelPrecisionBits'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSubPixelPrecisionBits a

instance {-# OVERLAPPING #-}
         HasVkSubPixelPrecisionBits VkPhysicalDeviceLimits where
        type VkSubPixelPrecisionBitsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkSubPixelPrecisionBits #-}
        vkSubPixelPrecisionBits x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, subPixelPrecisionBits})

        {-# INLINE vkSubPixelPrecisionBitsByteOffset #-}
        vkSubPixelPrecisionBitsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, subPixelPrecisionBits}

        {-# INLINE readVkSubPixelPrecisionBits #-}
        readVkSubPixelPrecisionBits p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, subPixelPrecisionBits}

        {-# INLINE writeVkSubPixelPrecisionBits #-}
        writeVkSubPixelPrecisionBits p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, subPixelPrecisionBits}

class HasVkSubTexelPrecisionBits a where
        type VkSubTexelPrecisionBitsMType a :: *

        vkSubTexelPrecisionBits :: a -> VkSubTexelPrecisionBitsMType a

        vkSubTexelPrecisionBitsByteOffset :: a -> Int

        readVkSubTexelPrecisionBits ::
                                    Ptr a -> IO (VkSubTexelPrecisionBitsMType a)

        writeVkSubTexelPrecisionBits ::
                                     Ptr a -> VkSubTexelPrecisionBitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'subTexelPrecisionBits'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSubTexelPrecisionBits a

instance {-# OVERLAPPING #-}
         HasVkSubTexelPrecisionBits VkPhysicalDeviceLimits where
        type VkSubTexelPrecisionBitsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkSubTexelPrecisionBits #-}
        vkSubTexelPrecisionBits x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, subTexelPrecisionBits})

        {-# INLINE vkSubTexelPrecisionBitsByteOffset #-}
        vkSubTexelPrecisionBitsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, subTexelPrecisionBits}

        {-# INLINE readVkSubTexelPrecisionBits #-}
        readVkSubTexelPrecisionBits p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, subTexelPrecisionBits}

        {-# INLINE writeVkSubTexelPrecisionBits #-}
        writeVkSubTexelPrecisionBits p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, subTexelPrecisionBits}

class HasVkMipmapPrecisionBits a where
        type VkMipmapPrecisionBitsMType a :: *

        vkMipmapPrecisionBits :: a -> VkMipmapPrecisionBitsMType a

        vkMipmapPrecisionBitsByteOffset :: a -> Int

        readVkMipmapPrecisionBits ::
                                  Ptr a -> IO (VkMipmapPrecisionBitsMType a)

        writeVkMipmapPrecisionBits ::
                                   Ptr a -> VkMipmapPrecisionBitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'mipmapPrecisionBits'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMipmapPrecisionBits a

instance {-# OVERLAPPING #-}
         HasVkMipmapPrecisionBits VkPhysicalDeviceLimits where
        type VkMipmapPrecisionBitsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMipmapPrecisionBits #-}
        vkMipmapPrecisionBits x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, mipmapPrecisionBits})

        {-# INLINE vkMipmapPrecisionBitsByteOffset #-}
        vkMipmapPrecisionBitsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, mipmapPrecisionBits}

        {-# INLINE readVkMipmapPrecisionBits #-}
        readVkMipmapPrecisionBits p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, mipmapPrecisionBits}

        {-# INLINE writeVkMipmapPrecisionBits #-}
        writeVkMipmapPrecisionBits p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, mipmapPrecisionBits}

class HasVkMaxDrawIndexedIndexValue a where
        type VkMaxDrawIndexedIndexValueMType a :: *

        vkMaxDrawIndexedIndexValue ::
                                   a -> VkMaxDrawIndexedIndexValueMType a

        vkMaxDrawIndexedIndexValueByteOffset :: a -> Int

        readVkMaxDrawIndexedIndexValue ::
                                       Ptr a -> IO (VkMaxDrawIndexedIndexValueMType a)

        writeVkMaxDrawIndexedIndexValue ::
                                        Ptr a -> VkMaxDrawIndexedIndexValueMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxDrawIndexedIndexValue'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDrawIndexedIndexValue a

instance {-# OVERLAPPING #-}
         HasVkMaxDrawIndexedIndexValue VkPhysicalDeviceLimits where
        type VkMaxDrawIndexedIndexValueMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxDrawIndexedIndexValue #-}
        vkMaxDrawIndexedIndexValue x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxDrawIndexedIndexValue})

        {-# INLINE vkMaxDrawIndexedIndexValueByteOffset #-}
        vkMaxDrawIndexedIndexValueByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDrawIndexedIndexValue}

        {-# INLINE readVkMaxDrawIndexedIndexValue #-}
        readVkMaxDrawIndexedIndexValue p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxDrawIndexedIndexValue}

        {-# INLINE writeVkMaxDrawIndexedIndexValue #-}
        writeVkMaxDrawIndexedIndexValue p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxDrawIndexedIndexValue}

class HasVkMaxDrawIndirectCount a where
        type VkMaxDrawIndirectCountMType a :: *

        vkMaxDrawIndirectCount :: a -> VkMaxDrawIndirectCountMType a

        vkMaxDrawIndirectCountByteOffset :: a -> Int

        readVkMaxDrawIndirectCount ::
                                   Ptr a -> IO (VkMaxDrawIndirectCountMType a)

        writeVkMaxDrawIndirectCount ::
                                    Ptr a -> VkMaxDrawIndirectCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxDrawIndirectCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDrawIndirectCount a

instance {-# OVERLAPPING #-}
         HasVkMaxDrawIndirectCount VkPhysicalDeviceLimits where
        type VkMaxDrawIndirectCountMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxDrawIndirectCount #-}
        vkMaxDrawIndirectCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxDrawIndirectCount})

        {-# INLINE vkMaxDrawIndirectCountByteOffset #-}
        vkMaxDrawIndirectCountByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDrawIndirectCount}

        {-# INLINE readVkMaxDrawIndirectCount #-}
        readVkMaxDrawIndirectCount p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxDrawIndirectCount}

        {-# INLINE writeVkMaxDrawIndirectCount #-}
        writeVkMaxDrawIndirectCount p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxDrawIndirectCount}

class HasVkMaxSamplerLodBias a where
        type VkMaxSamplerLodBiasMType a :: *

        vkMaxSamplerLodBias :: a -> VkMaxSamplerLodBiasMType a

        vkMaxSamplerLodBiasByteOffset :: a -> Int

        readVkMaxSamplerLodBias :: Ptr a -> IO (VkMaxSamplerLodBiasMType a)

        writeVkMaxSamplerLodBias ::
                                 Ptr a -> VkMaxSamplerLodBiasMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxSamplerLodBias'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxSamplerLodBias a

instance {-# OVERLAPPING #-}
         HasVkMaxSamplerLodBias VkPhysicalDeviceLimits where
        type VkMaxSamplerLodBiasMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkMaxSamplerLodBias #-}
        vkMaxSamplerLodBias x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxSamplerLodBias})

        {-# INLINE vkMaxSamplerLodBiasByteOffset #-}
        vkMaxSamplerLodBiasByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxSamplerLodBias}

        {-# INLINE readVkMaxSamplerLodBias #-}
        readVkMaxSamplerLodBias p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxSamplerLodBias}

        {-# INLINE writeVkMaxSamplerLodBias #-}
        writeVkMaxSamplerLodBias p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxSamplerLodBias}

class HasVkMaxSamplerAnisotropy a where
        type VkMaxSamplerAnisotropyMType a :: *

        vkMaxSamplerAnisotropy :: a -> VkMaxSamplerAnisotropyMType a

        vkMaxSamplerAnisotropyByteOffset :: a -> Int

        readVkMaxSamplerAnisotropy ::
                                   Ptr a -> IO (VkMaxSamplerAnisotropyMType a)

        writeVkMaxSamplerAnisotropy ::
                                    Ptr a -> VkMaxSamplerAnisotropyMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxSamplerAnisotropy'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxSamplerAnisotropy a

instance {-# OVERLAPPING #-}
         HasVkMaxSamplerAnisotropy VkPhysicalDeviceLimits where
        type VkMaxSamplerAnisotropyMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkMaxSamplerAnisotropy #-}
        vkMaxSamplerAnisotropy x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxSamplerAnisotropy})

        {-# INLINE vkMaxSamplerAnisotropyByteOffset #-}
        vkMaxSamplerAnisotropyByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxSamplerAnisotropy}

        {-# INLINE readVkMaxSamplerAnisotropy #-}
        readVkMaxSamplerAnisotropy p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxSamplerAnisotropy}

        {-# INLINE writeVkMaxSamplerAnisotropy #-}
        writeVkMaxSamplerAnisotropy p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxSamplerAnisotropy}

class HasVkMaxViewports a where
        type VkMaxViewportsMType a :: *

        vkMaxViewports :: a -> VkMaxViewportsMType a

        vkMaxViewportsByteOffset :: a -> Int

        readVkMaxViewports :: Ptr a -> IO (VkMaxViewportsMType a)

        writeVkMaxViewports :: Ptr a -> VkMaxViewportsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxViewports'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxViewports a

instance {-# OVERLAPPING #-}
         HasVkMaxViewports VkPhysicalDeviceLimits where
        type VkMaxViewportsMType VkPhysicalDeviceLimits = Data.Word.Word32

        {-# NOINLINE vkMaxViewports #-}
        vkMaxViewports x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxViewports})

        {-# INLINE vkMaxViewportsByteOffset #-}
        vkMaxViewportsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxViewports}

        {-# INLINE readVkMaxViewports #-}
        readVkMaxViewports p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxViewports}

        {-# INLINE writeVkMaxViewports #-}
        writeVkMaxViewports p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxViewports}

class HasVkMaxViewportDimensionsArray a where
        type VkMaxViewportDimensionsArrayMType a :: *

        vkMaxViewportDimensionsArray ::
                                     a -> Int -> VkMaxViewportDimensionsArrayMType a

        vkMaxViewportDimensionsArrayByteOffset :: a -> Int

        readVkMaxViewportDimensionsArray ::
                                         Ptr a -> Int -> IO (VkMaxViewportDimensionsArrayMType a)

        writeVkMaxViewportDimensionsArray ::
                                          Ptr a ->
                                            Int -> VkMaxViewportDimensionsArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxViewportDimensions'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxViewportDimensionsArray a

instance {-# OVERLAPPING #-}
         HasVkMaxViewportDimensionsArray VkPhysicalDeviceLimits where
        type VkMaxViewportDimensionsArrayMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxViewportDimensionsArray #-}
        vkMaxViewportDimensionsArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Data.Word.Word32) +
                    #{offset VkPhysicalDeviceLimits, maxViewportDimensions}))

        {-# INLINE vkMaxViewportDimensionsArrayByteOffset #-}
        vkMaxViewportDimensionsArrayByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxViewportDimensions}

        {-# INLINE readVkMaxViewportDimensionsArray #-}
        readVkMaxViewportDimensionsArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Data.Word.Word32) +
                 #{offset VkPhysicalDeviceLimits, maxViewportDimensions})

        {-# INLINE writeVkMaxViewportDimensionsArray #-}
        writeVkMaxViewportDimensionsArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Data.Word.Word32) +
                 #{offset VkPhysicalDeviceLimits, maxViewportDimensions})

class HasVkViewportBoundsRangeArray a where
        type VkViewportBoundsRangeArrayMType a :: *

        vkViewportBoundsRangeArray ::
                                   a -> Int -> VkViewportBoundsRangeArrayMType a

        vkViewportBoundsRangeArrayByteOffset :: a -> Int

        readVkViewportBoundsRangeArray ::
                                       Ptr a -> Int -> IO (VkViewportBoundsRangeArrayMType a)

        writeVkViewportBoundsRangeArray ::
                                        Ptr a -> Int -> VkViewportBoundsRangeArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'viewportBoundsRange'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkViewportBoundsRangeArray a

instance {-# OVERLAPPING #-}
         HasVkViewportBoundsRangeArray VkPhysicalDeviceLimits where
        type VkViewportBoundsRangeArrayMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkViewportBoundsRangeArray #-}
        vkViewportBoundsRangeArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                    #{offset VkPhysicalDeviceLimits, viewportBoundsRange}))

        {-# INLINE vkViewportBoundsRangeArrayByteOffset #-}
        vkViewportBoundsRangeArrayByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, viewportBoundsRange}

        {-# INLINE readVkViewportBoundsRangeArray #-}
        readVkViewportBoundsRangeArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                 #{offset VkPhysicalDeviceLimits, viewportBoundsRange})

        {-# INLINE writeVkViewportBoundsRangeArray #-}
        writeVkViewportBoundsRangeArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                 #{offset VkPhysicalDeviceLimits, viewportBoundsRange})

class HasVkViewportSubPixelBits a where
        type VkViewportSubPixelBitsMType a :: *

        vkViewportSubPixelBits :: a -> VkViewportSubPixelBitsMType a

        vkViewportSubPixelBitsByteOffset :: a -> Int

        readVkViewportSubPixelBits ::
                                   Ptr a -> IO (VkViewportSubPixelBitsMType a)

        writeVkViewportSubPixelBits ::
                                    Ptr a -> VkViewportSubPixelBitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'viewportSubPixelBits'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkViewportSubPixelBits a

instance {-# OVERLAPPING #-}
         HasVkViewportSubPixelBits VkPhysicalDeviceLimits where
        type VkViewportSubPixelBitsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkViewportSubPixelBits #-}
        vkViewportSubPixelBits x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, viewportSubPixelBits})

        {-# INLINE vkViewportSubPixelBitsByteOffset #-}
        vkViewportSubPixelBitsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, viewportSubPixelBits}

        {-# INLINE readVkViewportSubPixelBits #-}
        readVkViewportSubPixelBits p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, viewportSubPixelBits}

        {-# INLINE writeVkViewportSubPixelBits #-}
        writeVkViewportSubPixelBits p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, viewportSubPixelBits}

class HasVkMinMemoryMapAlignment a where
        type VkMinMemoryMapAlignmentMType a :: *

        vkMinMemoryMapAlignment :: a -> VkMinMemoryMapAlignmentMType a

        vkMinMemoryMapAlignmentByteOffset :: a -> Int

        readVkMinMemoryMapAlignment ::
                                    Ptr a -> IO (VkMinMemoryMapAlignmentMType a)

        writeVkMinMemoryMapAlignment ::
                                     Ptr a -> VkMinMemoryMapAlignmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minMemoryMapAlignment'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinMemoryMapAlignment a

instance {-# OVERLAPPING #-}
         HasVkMinMemoryMapAlignment VkPhysicalDeviceLimits where
        type VkMinMemoryMapAlignmentMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CSize

        {-# NOINLINE vkMinMemoryMapAlignment #-}
        vkMinMemoryMapAlignment x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, minMemoryMapAlignment})

        {-# INLINE vkMinMemoryMapAlignmentByteOffset #-}
        vkMinMemoryMapAlignmentByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, minMemoryMapAlignment}

        {-# INLINE readVkMinMemoryMapAlignment #-}
        readVkMinMemoryMapAlignment p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, minMemoryMapAlignment}

        {-# INLINE writeVkMinMemoryMapAlignment #-}
        writeVkMinMemoryMapAlignment p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, minMemoryMapAlignment}

class HasVkMinTexelBufferOffsetAlignment a where
        type VkMinTexelBufferOffsetAlignmentMType a :: *

        vkMinTexelBufferOffsetAlignment ::
                                        a -> VkMinTexelBufferOffsetAlignmentMType a

        vkMinTexelBufferOffsetAlignmentByteOffset :: a -> Int

        readVkMinTexelBufferOffsetAlignment ::
                                            Ptr a -> IO (VkMinTexelBufferOffsetAlignmentMType a)

        writeVkMinTexelBufferOffsetAlignment ::
                                             Ptr a ->
                                               VkMinTexelBufferOffsetAlignmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'minTexelBufferOffsetAlignment'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinTexelBufferOffsetAlignment a

instance {-# OVERLAPPING #-}
         HasVkMinTexelBufferOffsetAlignment VkPhysicalDeviceLimits where
        type VkMinTexelBufferOffsetAlignmentMType VkPhysicalDeviceLimits =
             VkDeviceSize

        {-# NOINLINE vkMinTexelBufferOffsetAlignment #-}
        vkMinTexelBufferOffsetAlignment x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, minTexelBufferOffsetAlignment})

        {-# INLINE vkMinTexelBufferOffsetAlignmentByteOffset #-}
        vkMinTexelBufferOffsetAlignmentByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, minTexelBufferOffsetAlignment}

        {-# INLINE readVkMinTexelBufferOffsetAlignment #-}
        readVkMinTexelBufferOffsetAlignment p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, minTexelBufferOffsetAlignment}

        {-# INLINE writeVkMinTexelBufferOffsetAlignment #-}
        writeVkMinTexelBufferOffsetAlignment p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, minTexelBufferOffsetAlignment}

class HasVkMinUniformBufferOffsetAlignment a where
        type VkMinUniformBufferOffsetAlignmentMType a :: *

        vkMinUniformBufferOffsetAlignment ::
                                          a -> VkMinUniformBufferOffsetAlignmentMType a

        vkMinUniformBufferOffsetAlignmentByteOffset :: a -> Int

        readVkMinUniformBufferOffsetAlignment ::
                                              Ptr a -> IO (VkMinUniformBufferOffsetAlignmentMType a)

        writeVkMinUniformBufferOffsetAlignment ::
                                               Ptr a ->
                                                 VkMinUniformBufferOffsetAlignmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'minUniformBufferOffsetAlignment'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinUniformBufferOffsetAlignment a

instance {-# OVERLAPPING #-}
         HasVkMinUniformBufferOffsetAlignment VkPhysicalDeviceLimits where
        type VkMinUniformBufferOffsetAlignmentMType VkPhysicalDeviceLimits
             = VkDeviceSize

        {-# NOINLINE vkMinUniformBufferOffsetAlignment #-}
        vkMinUniformBufferOffsetAlignment x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, minUniformBufferOffsetAlignment})

        {-# INLINE vkMinUniformBufferOffsetAlignmentByteOffset #-}
        vkMinUniformBufferOffsetAlignmentByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, minUniformBufferOffsetAlignment}

        {-# INLINE readVkMinUniformBufferOffsetAlignment #-}
        readVkMinUniformBufferOffsetAlignment p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, minUniformBufferOffsetAlignment}

        {-# INLINE writeVkMinUniformBufferOffsetAlignment #-}
        writeVkMinUniformBufferOffsetAlignment p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, minUniformBufferOffsetAlignment}

class HasVkMinStorageBufferOffsetAlignment a where
        type VkMinStorageBufferOffsetAlignmentMType a :: *

        vkMinStorageBufferOffsetAlignment ::
                                          a -> VkMinStorageBufferOffsetAlignmentMType a

        vkMinStorageBufferOffsetAlignmentByteOffset :: a -> Int

        readVkMinStorageBufferOffsetAlignment ::
                                              Ptr a -> IO (VkMinStorageBufferOffsetAlignmentMType a)

        writeVkMinStorageBufferOffsetAlignment ::
                                               Ptr a ->
                                                 VkMinStorageBufferOffsetAlignmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'minStorageBufferOffsetAlignment'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinStorageBufferOffsetAlignment a

instance {-# OVERLAPPING #-}
         HasVkMinStorageBufferOffsetAlignment VkPhysicalDeviceLimits where
        type VkMinStorageBufferOffsetAlignmentMType VkPhysicalDeviceLimits
             = VkDeviceSize

        {-# NOINLINE vkMinStorageBufferOffsetAlignment #-}
        vkMinStorageBufferOffsetAlignment x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, minStorageBufferOffsetAlignment})

        {-# INLINE vkMinStorageBufferOffsetAlignmentByteOffset #-}
        vkMinStorageBufferOffsetAlignmentByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, minStorageBufferOffsetAlignment}

        {-# INLINE readVkMinStorageBufferOffsetAlignment #-}
        readVkMinStorageBufferOffsetAlignment p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, minStorageBufferOffsetAlignment}

        {-# INLINE writeVkMinStorageBufferOffsetAlignment #-}
        writeVkMinStorageBufferOffsetAlignment p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, minStorageBufferOffsetAlignment}

class HasVkMinTexelOffset a where
        type VkMinTexelOffsetMType a :: *

        vkMinTexelOffset :: a -> VkMinTexelOffsetMType a

        vkMinTexelOffsetByteOffset :: a -> Int

        readVkMinTexelOffset :: Ptr a -> IO (VkMinTexelOffsetMType a)

        writeVkMinTexelOffset :: Ptr a -> VkMinTexelOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minTexelOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinTexelOffset a

instance {-# OVERLAPPING #-}
         HasVkMinTexelOffset VkPhysicalDeviceLimits where
        type VkMinTexelOffsetMType VkPhysicalDeviceLimits = Data.Int.Int32

        {-# NOINLINE vkMinTexelOffset #-}
        vkMinTexelOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, minTexelOffset})

        {-# INLINE vkMinTexelOffsetByteOffset #-}
        vkMinTexelOffsetByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, minTexelOffset}

        {-# INLINE readVkMinTexelOffset #-}
        readVkMinTexelOffset p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, minTexelOffset}

        {-# INLINE writeVkMinTexelOffset #-}
        writeVkMinTexelOffset p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, minTexelOffset}

class HasVkMaxTexelOffset a where
        type VkMaxTexelOffsetMType a :: *

        vkMaxTexelOffset :: a -> VkMaxTexelOffsetMType a

        vkMaxTexelOffsetByteOffset :: a -> Int

        readVkMaxTexelOffset :: Ptr a -> IO (VkMaxTexelOffsetMType a)

        writeVkMaxTexelOffset :: Ptr a -> VkMaxTexelOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxTexelOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTexelOffset a

instance {-# OVERLAPPING #-}
         HasVkMaxTexelOffset VkPhysicalDeviceLimits where
        type VkMaxTexelOffsetMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxTexelOffset #-}
        vkMaxTexelOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxTexelOffset})

        {-# INLINE vkMaxTexelOffsetByteOffset #-}
        vkMaxTexelOffsetByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTexelOffset}

        {-# INLINE readVkMaxTexelOffset #-}
        readVkMaxTexelOffset p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxTexelOffset}

        {-# INLINE writeVkMaxTexelOffset #-}
        writeVkMaxTexelOffset p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxTexelOffset}

class HasVkMinTexelGatherOffset a where
        type VkMinTexelGatherOffsetMType a :: *

        vkMinTexelGatherOffset :: a -> VkMinTexelGatherOffsetMType a

        vkMinTexelGatherOffsetByteOffset :: a -> Int

        readVkMinTexelGatherOffset ::
                                   Ptr a -> IO (VkMinTexelGatherOffsetMType a)

        writeVkMinTexelGatherOffset ::
                                    Ptr a -> VkMinTexelGatherOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minTexelGatherOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinTexelGatherOffset a

instance {-# OVERLAPPING #-}
         HasVkMinTexelGatherOffset VkPhysicalDeviceLimits where
        type VkMinTexelGatherOffsetMType VkPhysicalDeviceLimits =
             Data.Int.Int32

        {-# NOINLINE vkMinTexelGatherOffset #-}
        vkMinTexelGatherOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, minTexelGatherOffset})

        {-# INLINE vkMinTexelGatherOffsetByteOffset #-}
        vkMinTexelGatherOffsetByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, minTexelGatherOffset}

        {-# INLINE readVkMinTexelGatherOffset #-}
        readVkMinTexelGatherOffset p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, minTexelGatherOffset}

        {-# INLINE writeVkMinTexelGatherOffset #-}
        writeVkMinTexelGatherOffset p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, minTexelGatherOffset}

class HasVkMaxTexelGatherOffset a where
        type VkMaxTexelGatherOffsetMType a :: *

        vkMaxTexelGatherOffset :: a -> VkMaxTexelGatherOffsetMType a

        vkMaxTexelGatherOffsetByteOffset :: a -> Int

        readVkMaxTexelGatherOffset ::
                                   Ptr a -> IO (VkMaxTexelGatherOffsetMType a)

        writeVkMaxTexelGatherOffset ::
                                    Ptr a -> VkMaxTexelGatherOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxTexelGatherOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTexelGatherOffset a

instance {-# OVERLAPPING #-}
         HasVkMaxTexelGatherOffset VkPhysicalDeviceLimits where
        type VkMaxTexelGatherOffsetMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxTexelGatherOffset #-}
        vkMaxTexelGatherOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxTexelGatherOffset})

        {-# INLINE vkMaxTexelGatherOffsetByteOffset #-}
        vkMaxTexelGatherOffsetByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTexelGatherOffset}

        {-# INLINE readVkMaxTexelGatherOffset #-}
        readVkMaxTexelGatherOffset p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxTexelGatherOffset}

        {-# INLINE writeVkMaxTexelGatherOffset #-}
        writeVkMaxTexelGatherOffset p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxTexelGatherOffset}

class HasVkMinInterpolationOffset a where
        type VkMinInterpolationOffsetMType a :: *

        vkMinInterpolationOffset :: a -> VkMinInterpolationOffsetMType a

        vkMinInterpolationOffsetByteOffset :: a -> Int

        readVkMinInterpolationOffset ::
                                     Ptr a -> IO (VkMinInterpolationOffsetMType a)

        writeVkMinInterpolationOffset ::
                                      Ptr a -> VkMinInterpolationOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minInterpolationOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinInterpolationOffset a

instance {-# OVERLAPPING #-}
         HasVkMinInterpolationOffset VkPhysicalDeviceLimits where
        type VkMinInterpolationOffsetMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkMinInterpolationOffset #-}
        vkMinInterpolationOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, minInterpolationOffset})

        {-# INLINE vkMinInterpolationOffsetByteOffset #-}
        vkMinInterpolationOffsetByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, minInterpolationOffset}

        {-# INLINE readVkMinInterpolationOffset #-}
        readVkMinInterpolationOffset p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, minInterpolationOffset}

        {-# INLINE writeVkMinInterpolationOffset #-}
        writeVkMinInterpolationOffset p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, minInterpolationOffset}

class HasVkMaxInterpolationOffset a where
        type VkMaxInterpolationOffsetMType a :: *

        vkMaxInterpolationOffset :: a -> VkMaxInterpolationOffsetMType a

        vkMaxInterpolationOffsetByteOffset :: a -> Int

        readVkMaxInterpolationOffset ::
                                     Ptr a -> IO (VkMaxInterpolationOffsetMType a)

        writeVkMaxInterpolationOffset ::
                                      Ptr a -> VkMaxInterpolationOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxInterpolationOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxInterpolationOffset a

instance {-# OVERLAPPING #-}
         HasVkMaxInterpolationOffset VkPhysicalDeviceLimits where
        type VkMaxInterpolationOffsetMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkMaxInterpolationOffset #-}
        vkMaxInterpolationOffset x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxInterpolationOffset})

        {-# INLINE vkMaxInterpolationOffsetByteOffset #-}
        vkMaxInterpolationOffsetByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxInterpolationOffset}

        {-# INLINE readVkMaxInterpolationOffset #-}
        readVkMaxInterpolationOffset p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxInterpolationOffset}

        {-# INLINE writeVkMaxInterpolationOffset #-}
        writeVkMaxInterpolationOffset p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxInterpolationOffset}

class HasVkSubPixelInterpolationOffsetBits a where
        type VkSubPixelInterpolationOffsetBitsMType a :: *

        vkSubPixelInterpolationOffsetBits ::
                                          a -> VkSubPixelInterpolationOffsetBitsMType a

        vkSubPixelInterpolationOffsetBitsByteOffset :: a -> Int

        readVkSubPixelInterpolationOffsetBits ::
                                              Ptr a -> IO (VkSubPixelInterpolationOffsetBitsMType a)

        writeVkSubPixelInterpolationOffsetBits ::
                                               Ptr a ->
                                                 VkSubPixelInterpolationOffsetBitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'subPixelInterpolationOffsetBits'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSubPixelInterpolationOffsetBits a

instance {-# OVERLAPPING #-}
         HasVkSubPixelInterpolationOffsetBits VkPhysicalDeviceLimits where
        type VkSubPixelInterpolationOffsetBitsMType VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkSubPixelInterpolationOffsetBits #-}
        vkSubPixelInterpolationOffsetBits x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, subPixelInterpolationOffsetBits})

        {-# INLINE vkSubPixelInterpolationOffsetBitsByteOffset #-}
        vkSubPixelInterpolationOffsetBitsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, subPixelInterpolationOffsetBits}

        {-# INLINE readVkSubPixelInterpolationOffsetBits #-}
        readVkSubPixelInterpolationOffsetBits p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, subPixelInterpolationOffsetBits}

        {-# INLINE writeVkSubPixelInterpolationOffsetBits #-}
        writeVkSubPixelInterpolationOffsetBits p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, subPixelInterpolationOffsetBits}

class HasVkMaxFramebufferWidth a where
        type VkMaxFramebufferWidthMType a :: *

        vkMaxFramebufferWidth :: a -> VkMaxFramebufferWidthMType a

        vkMaxFramebufferWidthByteOffset :: a -> Int

        readVkMaxFramebufferWidth ::
                                  Ptr a -> IO (VkMaxFramebufferWidthMType a)

        writeVkMaxFramebufferWidth ::
                                   Ptr a -> VkMaxFramebufferWidthMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxFramebufferWidth'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxFramebufferWidth a

instance {-# OVERLAPPING #-}
         HasVkMaxFramebufferWidth VkPhysicalDeviceLimits where
        type VkMaxFramebufferWidthMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxFramebufferWidth #-}
        vkMaxFramebufferWidth x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxFramebufferWidth})

        {-# INLINE vkMaxFramebufferWidthByteOffset #-}
        vkMaxFramebufferWidthByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxFramebufferWidth}

        {-# INLINE readVkMaxFramebufferWidth #-}
        readVkMaxFramebufferWidth p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxFramebufferWidth}

        {-# INLINE writeVkMaxFramebufferWidth #-}
        writeVkMaxFramebufferWidth p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxFramebufferWidth}

class HasVkMaxFramebufferHeight a where
        type VkMaxFramebufferHeightMType a :: *

        vkMaxFramebufferHeight :: a -> VkMaxFramebufferHeightMType a

        vkMaxFramebufferHeightByteOffset :: a -> Int

        readVkMaxFramebufferHeight ::
                                   Ptr a -> IO (VkMaxFramebufferHeightMType a)

        writeVkMaxFramebufferHeight ::
                                    Ptr a -> VkMaxFramebufferHeightMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxFramebufferHeight'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxFramebufferHeight a

instance {-# OVERLAPPING #-}
         HasVkMaxFramebufferHeight VkPhysicalDeviceLimits where
        type VkMaxFramebufferHeightMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxFramebufferHeight #-}
        vkMaxFramebufferHeight x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxFramebufferHeight})

        {-# INLINE vkMaxFramebufferHeightByteOffset #-}
        vkMaxFramebufferHeightByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxFramebufferHeight}

        {-# INLINE readVkMaxFramebufferHeight #-}
        readVkMaxFramebufferHeight p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxFramebufferHeight}

        {-# INLINE writeVkMaxFramebufferHeight #-}
        writeVkMaxFramebufferHeight p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxFramebufferHeight}

class HasVkMaxFramebufferLayers a where
        type VkMaxFramebufferLayersMType a :: *

        vkMaxFramebufferLayers :: a -> VkMaxFramebufferLayersMType a

        vkMaxFramebufferLayersByteOffset :: a -> Int

        readVkMaxFramebufferLayers ::
                                   Ptr a -> IO (VkMaxFramebufferLayersMType a)

        writeVkMaxFramebufferLayers ::
                                    Ptr a -> VkMaxFramebufferLayersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxFramebufferLayers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxFramebufferLayers a

instance {-# OVERLAPPING #-}
         HasVkMaxFramebufferLayers VkPhysicalDeviceLimits where
        type VkMaxFramebufferLayersMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxFramebufferLayers #-}
        vkMaxFramebufferLayers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxFramebufferLayers})

        {-# INLINE vkMaxFramebufferLayersByteOffset #-}
        vkMaxFramebufferLayersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxFramebufferLayers}

        {-# INLINE readVkMaxFramebufferLayers #-}
        readVkMaxFramebufferLayers p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxFramebufferLayers}

        {-# INLINE writeVkMaxFramebufferLayers #-}
        writeVkMaxFramebufferLayers p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxFramebufferLayers}

class HasVkFramebufferColorSampleCounts a where
        type VkFramebufferColorSampleCountsMType a :: *

        vkFramebufferColorSampleCounts ::
                                       a -> VkFramebufferColorSampleCountsMType a

        vkFramebufferColorSampleCountsByteOffset :: a -> Int

        readVkFramebufferColorSampleCounts ::
                                           Ptr a -> IO (VkFramebufferColorSampleCountsMType a)

        writeVkFramebufferColorSampleCounts ::
                                            Ptr a -> VkFramebufferColorSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'framebufferColorSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFramebufferColorSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkFramebufferColorSampleCounts VkPhysicalDeviceLimits where
        type VkFramebufferColorSampleCountsMType VkPhysicalDeviceLimits =
             VkSampleCountFlags

        {-# NOINLINE vkFramebufferColorSampleCounts #-}
        vkFramebufferColorSampleCounts x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, framebufferColorSampleCounts})

        {-# INLINE vkFramebufferColorSampleCountsByteOffset #-}
        vkFramebufferColorSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, framebufferColorSampleCounts}

        {-# INLINE readVkFramebufferColorSampleCounts #-}
        readVkFramebufferColorSampleCounts p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, framebufferColorSampleCounts}

        {-# INLINE writeVkFramebufferColorSampleCounts #-}
        writeVkFramebufferColorSampleCounts p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, framebufferColorSampleCounts}

class HasVkFramebufferDepthSampleCounts a where
        type VkFramebufferDepthSampleCountsMType a :: *

        vkFramebufferDepthSampleCounts ::
                                       a -> VkFramebufferDepthSampleCountsMType a

        vkFramebufferDepthSampleCountsByteOffset :: a -> Int

        readVkFramebufferDepthSampleCounts ::
                                           Ptr a -> IO (VkFramebufferDepthSampleCountsMType a)

        writeVkFramebufferDepthSampleCounts ::
                                            Ptr a -> VkFramebufferDepthSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'framebufferDepthSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFramebufferDepthSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkFramebufferDepthSampleCounts VkPhysicalDeviceLimits where
        type VkFramebufferDepthSampleCountsMType VkPhysicalDeviceLimits =
             VkSampleCountFlags

        {-# NOINLINE vkFramebufferDepthSampleCounts #-}
        vkFramebufferDepthSampleCounts x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, framebufferDepthSampleCounts})

        {-# INLINE vkFramebufferDepthSampleCountsByteOffset #-}
        vkFramebufferDepthSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, framebufferDepthSampleCounts}

        {-# INLINE readVkFramebufferDepthSampleCounts #-}
        readVkFramebufferDepthSampleCounts p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, framebufferDepthSampleCounts}

        {-# INLINE writeVkFramebufferDepthSampleCounts #-}
        writeVkFramebufferDepthSampleCounts p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, framebufferDepthSampleCounts}

class HasVkFramebufferStencilSampleCounts a where
        type VkFramebufferStencilSampleCountsMType a :: *

        vkFramebufferStencilSampleCounts ::
                                         a -> VkFramebufferStencilSampleCountsMType a

        vkFramebufferStencilSampleCountsByteOffset :: a -> Int

        readVkFramebufferStencilSampleCounts ::
                                             Ptr a -> IO (VkFramebufferStencilSampleCountsMType a)

        writeVkFramebufferStencilSampleCounts ::
                                              Ptr a ->
                                                VkFramebufferStencilSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'framebufferStencilSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFramebufferStencilSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkFramebufferStencilSampleCounts VkPhysicalDeviceLimits where
        type VkFramebufferStencilSampleCountsMType VkPhysicalDeviceLimits =
             VkSampleCountFlags

        {-# NOINLINE vkFramebufferStencilSampleCounts #-}
        vkFramebufferStencilSampleCounts x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, framebufferStencilSampleCounts})

        {-# INLINE vkFramebufferStencilSampleCountsByteOffset #-}
        vkFramebufferStencilSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, framebufferStencilSampleCounts}

        {-# INLINE readVkFramebufferStencilSampleCounts #-}
        readVkFramebufferStencilSampleCounts p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, framebufferStencilSampleCounts}

        {-# INLINE writeVkFramebufferStencilSampleCounts #-}
        writeVkFramebufferStencilSampleCounts p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, framebufferStencilSampleCounts}

class HasVkFramebufferNoAttachmentsSampleCounts a where
        type VkFramebufferNoAttachmentsSampleCountsMType a :: *

        vkFramebufferNoAttachmentsSampleCounts ::
                                               a -> VkFramebufferNoAttachmentsSampleCountsMType a

        vkFramebufferNoAttachmentsSampleCountsByteOffset :: a -> Int

        readVkFramebufferNoAttachmentsSampleCounts ::
                                                   Ptr a ->
                                                     IO
                                                       (VkFramebufferNoAttachmentsSampleCountsMType
                                                          a)

        writeVkFramebufferNoAttachmentsSampleCounts ::
                                                    Ptr a ->
                                                      VkFramebufferNoAttachmentsSampleCountsMType a
                                                        -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'framebufferNoAttachmentsSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFramebufferNoAttachmentsSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkFramebufferNoAttachmentsSampleCounts VkPhysicalDeviceLimits
         where
        type VkFramebufferNoAttachmentsSampleCountsMType
               VkPhysicalDeviceLimits
             = VkSampleCountFlags

        {-# NOINLINE vkFramebufferNoAttachmentsSampleCounts #-}
        vkFramebufferNoAttachmentsSampleCounts x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, framebufferNoAttachmentsSampleCounts})

        {-# INLINE vkFramebufferNoAttachmentsSampleCountsByteOffset #-}
        vkFramebufferNoAttachmentsSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, framebufferNoAttachmentsSampleCounts}

        {-# INLINE readVkFramebufferNoAttachmentsSampleCounts #-}
        readVkFramebufferNoAttachmentsSampleCounts p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, framebufferNoAttachmentsSampleCounts}

        {-# INLINE writeVkFramebufferNoAttachmentsSampleCounts #-}
        writeVkFramebufferNoAttachmentsSampleCounts p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, framebufferNoAttachmentsSampleCounts}

class HasVkMaxColorAttachments a where
        type VkMaxColorAttachmentsMType a :: *

        vkMaxColorAttachments :: a -> VkMaxColorAttachmentsMType a

        vkMaxColorAttachmentsByteOffset :: a -> Int

        readVkMaxColorAttachments ::
                                  Ptr a -> IO (VkMaxColorAttachmentsMType a)

        writeVkMaxColorAttachments ::
                                   Ptr a -> VkMaxColorAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxColorAttachments'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxColorAttachments a

instance {-# OVERLAPPING #-}
         HasVkMaxColorAttachments VkPhysicalDeviceLimits where
        type VkMaxColorAttachmentsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxColorAttachments #-}
        vkMaxColorAttachments x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxColorAttachments})

        {-# INLINE vkMaxColorAttachmentsByteOffset #-}
        vkMaxColorAttachmentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxColorAttachments}

        {-# INLINE readVkMaxColorAttachments #-}
        readVkMaxColorAttachments p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxColorAttachments}

        {-# INLINE writeVkMaxColorAttachments #-}
        writeVkMaxColorAttachments p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxColorAttachments}

class HasVkSampledImageColorSampleCounts a where
        type VkSampledImageColorSampleCountsMType a :: *

        vkSampledImageColorSampleCounts ::
                                        a -> VkSampledImageColorSampleCountsMType a

        vkSampledImageColorSampleCountsByteOffset :: a -> Int

        readVkSampledImageColorSampleCounts ::
                                            Ptr a -> IO (VkSampledImageColorSampleCountsMType a)

        writeVkSampledImageColorSampleCounts ::
                                             Ptr a ->
                                               VkSampledImageColorSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'sampledImageColorSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampledImageColorSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkSampledImageColorSampleCounts VkPhysicalDeviceLimits where
        type VkSampledImageColorSampleCountsMType VkPhysicalDeviceLimits =
             VkSampleCountFlags

        {-# NOINLINE vkSampledImageColorSampleCounts #-}
        vkSampledImageColorSampleCounts x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, sampledImageColorSampleCounts})

        {-# INLINE vkSampledImageColorSampleCountsByteOffset #-}
        vkSampledImageColorSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, sampledImageColorSampleCounts}

        {-# INLINE readVkSampledImageColorSampleCounts #-}
        readVkSampledImageColorSampleCounts p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, sampledImageColorSampleCounts}

        {-# INLINE writeVkSampledImageColorSampleCounts #-}
        writeVkSampledImageColorSampleCounts p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, sampledImageColorSampleCounts}

class HasVkSampledImageIntegerSampleCounts a where
        type VkSampledImageIntegerSampleCountsMType a :: *

        vkSampledImageIntegerSampleCounts ::
                                          a -> VkSampledImageIntegerSampleCountsMType a

        vkSampledImageIntegerSampleCountsByteOffset :: a -> Int

        readVkSampledImageIntegerSampleCounts ::
                                              Ptr a -> IO (VkSampledImageIntegerSampleCountsMType a)

        writeVkSampledImageIntegerSampleCounts ::
                                               Ptr a ->
                                                 VkSampledImageIntegerSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'sampledImageIntegerSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampledImageIntegerSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkSampledImageIntegerSampleCounts VkPhysicalDeviceLimits where
        type VkSampledImageIntegerSampleCountsMType VkPhysicalDeviceLimits
             = VkSampleCountFlags

        {-# NOINLINE vkSampledImageIntegerSampleCounts #-}
        vkSampledImageIntegerSampleCounts x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, sampledImageIntegerSampleCounts})

        {-# INLINE vkSampledImageIntegerSampleCountsByteOffset #-}
        vkSampledImageIntegerSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, sampledImageIntegerSampleCounts}

        {-# INLINE readVkSampledImageIntegerSampleCounts #-}
        readVkSampledImageIntegerSampleCounts p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, sampledImageIntegerSampleCounts}

        {-# INLINE writeVkSampledImageIntegerSampleCounts #-}
        writeVkSampledImageIntegerSampleCounts p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, sampledImageIntegerSampleCounts}

class HasVkSampledImageDepthSampleCounts a where
        type VkSampledImageDepthSampleCountsMType a :: *

        vkSampledImageDepthSampleCounts ::
                                        a -> VkSampledImageDepthSampleCountsMType a

        vkSampledImageDepthSampleCountsByteOffset :: a -> Int

        readVkSampledImageDepthSampleCounts ::
                                            Ptr a -> IO (VkSampledImageDepthSampleCountsMType a)

        writeVkSampledImageDepthSampleCounts ::
                                             Ptr a ->
                                               VkSampledImageDepthSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'sampledImageDepthSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampledImageDepthSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkSampledImageDepthSampleCounts VkPhysicalDeviceLimits where
        type VkSampledImageDepthSampleCountsMType VkPhysicalDeviceLimits =
             VkSampleCountFlags

        {-# NOINLINE vkSampledImageDepthSampleCounts #-}
        vkSampledImageDepthSampleCounts x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, sampledImageDepthSampleCounts})

        {-# INLINE vkSampledImageDepthSampleCountsByteOffset #-}
        vkSampledImageDepthSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, sampledImageDepthSampleCounts}

        {-# INLINE readVkSampledImageDepthSampleCounts #-}
        readVkSampledImageDepthSampleCounts p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, sampledImageDepthSampleCounts}

        {-# INLINE writeVkSampledImageDepthSampleCounts #-}
        writeVkSampledImageDepthSampleCounts p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, sampledImageDepthSampleCounts}

class HasVkSampledImageStencilSampleCounts a where
        type VkSampledImageStencilSampleCountsMType a :: *

        vkSampledImageStencilSampleCounts ::
                                          a -> VkSampledImageStencilSampleCountsMType a

        vkSampledImageStencilSampleCountsByteOffset :: a -> Int

        readVkSampledImageStencilSampleCounts ::
                                              Ptr a -> IO (VkSampledImageStencilSampleCountsMType a)

        writeVkSampledImageStencilSampleCounts ::
                                               Ptr a ->
                                                 VkSampledImageStencilSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'sampledImageStencilSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampledImageStencilSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkSampledImageStencilSampleCounts VkPhysicalDeviceLimits where
        type VkSampledImageStencilSampleCountsMType VkPhysicalDeviceLimits
             = VkSampleCountFlags

        {-# NOINLINE vkSampledImageStencilSampleCounts #-}
        vkSampledImageStencilSampleCounts x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, sampledImageStencilSampleCounts})

        {-# INLINE vkSampledImageStencilSampleCountsByteOffset #-}
        vkSampledImageStencilSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, sampledImageStencilSampleCounts}

        {-# INLINE readVkSampledImageStencilSampleCounts #-}
        readVkSampledImageStencilSampleCounts p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, sampledImageStencilSampleCounts}

        {-# INLINE writeVkSampledImageStencilSampleCounts #-}
        writeVkSampledImageStencilSampleCounts p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, sampledImageStencilSampleCounts}

class HasVkStorageImageSampleCounts a where
        type VkStorageImageSampleCountsMType a :: *

        vkStorageImageSampleCounts ::
                                   a -> VkStorageImageSampleCountsMType a

        vkStorageImageSampleCountsByteOffset :: a -> Int

        readVkStorageImageSampleCounts ::
                                       Ptr a -> IO (VkStorageImageSampleCountsMType a)

        writeVkStorageImageSampleCounts ::
                                        Ptr a -> VkStorageImageSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'storageImageSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStorageImageSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkStorageImageSampleCounts VkPhysicalDeviceLimits where
        type VkStorageImageSampleCountsMType VkPhysicalDeviceLimits =
             VkSampleCountFlags

        {-# NOINLINE vkStorageImageSampleCounts #-}
        vkStorageImageSampleCounts x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, storageImageSampleCounts})

        {-# INLINE vkStorageImageSampleCountsByteOffset #-}
        vkStorageImageSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, storageImageSampleCounts}

        {-# INLINE readVkStorageImageSampleCounts #-}
        readVkStorageImageSampleCounts p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, storageImageSampleCounts}

        {-# INLINE writeVkStorageImageSampleCounts #-}
        writeVkStorageImageSampleCounts p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, storageImageSampleCounts}

class HasVkMaxSampleMaskWords a where
        type VkMaxSampleMaskWordsMType a :: *

        vkMaxSampleMaskWords :: a -> VkMaxSampleMaskWordsMType a

        vkMaxSampleMaskWordsByteOffset :: a -> Int

        readVkMaxSampleMaskWords ::
                                 Ptr a -> IO (VkMaxSampleMaskWordsMType a)

        writeVkMaxSampleMaskWords ::
                                  Ptr a -> VkMaxSampleMaskWordsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxSampleMaskWords'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxSampleMaskWords a

instance {-# OVERLAPPING #-}
         HasVkMaxSampleMaskWords VkPhysicalDeviceLimits where
        type VkMaxSampleMaskWordsMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxSampleMaskWords #-}
        vkMaxSampleMaskWords x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxSampleMaskWords})

        {-# INLINE vkMaxSampleMaskWordsByteOffset #-}
        vkMaxSampleMaskWordsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxSampleMaskWords}

        {-# INLINE readVkMaxSampleMaskWords #-}
        readVkMaxSampleMaskWords p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxSampleMaskWords}

        {-# INLINE writeVkMaxSampleMaskWords #-}
        writeVkMaxSampleMaskWords p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxSampleMaskWords}

class HasVkTimestampComputeAndGraphics a where
        type VkTimestampComputeAndGraphicsMType a :: *

        vkTimestampComputeAndGraphics ::
                                      a -> VkTimestampComputeAndGraphicsMType a

        vkTimestampComputeAndGraphicsByteOffset :: a -> Int

        readVkTimestampComputeAndGraphics ::
                                          Ptr a -> IO (VkTimestampComputeAndGraphicsMType a)

        writeVkTimestampComputeAndGraphics ::
                                           Ptr a -> VkTimestampComputeAndGraphicsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'timestampComputeAndGraphics'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTimestampComputeAndGraphics a

instance {-# OVERLAPPING #-}
         HasVkTimestampComputeAndGraphics VkPhysicalDeviceLimits where
        type VkTimestampComputeAndGraphicsMType VkPhysicalDeviceLimits =
             VkBool32

        {-# NOINLINE vkTimestampComputeAndGraphics #-}
        vkTimestampComputeAndGraphics x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, timestampComputeAndGraphics})

        {-# INLINE vkTimestampComputeAndGraphicsByteOffset #-}
        vkTimestampComputeAndGraphicsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, timestampComputeAndGraphics}

        {-# INLINE readVkTimestampComputeAndGraphics #-}
        readVkTimestampComputeAndGraphics p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, timestampComputeAndGraphics}

        {-# INLINE writeVkTimestampComputeAndGraphics #-}
        writeVkTimestampComputeAndGraphics p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, timestampComputeAndGraphics}

class HasVkTimestampPeriod a where
        type VkTimestampPeriodMType a :: *

        vkTimestampPeriod :: a -> VkTimestampPeriodMType a

        vkTimestampPeriodByteOffset :: a -> Int

        readVkTimestampPeriod :: Ptr a -> IO (VkTimestampPeriodMType a)

        writeVkTimestampPeriod ::
                               Ptr a -> VkTimestampPeriodMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'timestampPeriod'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTimestampPeriod a

instance {-# OVERLAPPING #-}
         HasVkTimestampPeriod VkPhysicalDeviceLimits where
        type VkTimestampPeriodMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkTimestampPeriod #-}
        vkTimestampPeriod x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, timestampPeriod})

        {-# INLINE vkTimestampPeriodByteOffset #-}
        vkTimestampPeriodByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, timestampPeriod}

        {-# INLINE readVkTimestampPeriod #-}
        readVkTimestampPeriod p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, timestampPeriod}

        {-# INLINE writeVkTimestampPeriod #-}
        writeVkTimestampPeriod p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, timestampPeriod}

class HasVkMaxClipDistances a where
        type VkMaxClipDistancesMType a :: *

        vkMaxClipDistances :: a -> VkMaxClipDistancesMType a

        vkMaxClipDistancesByteOffset :: a -> Int

        readVkMaxClipDistances :: Ptr a -> IO (VkMaxClipDistancesMType a)

        writeVkMaxClipDistances ::
                                Ptr a -> VkMaxClipDistancesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxClipDistances'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxClipDistances a

instance {-# OVERLAPPING #-}
         HasVkMaxClipDistances VkPhysicalDeviceLimits where
        type VkMaxClipDistancesMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxClipDistances #-}
        vkMaxClipDistances x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxClipDistances})

        {-# INLINE vkMaxClipDistancesByteOffset #-}
        vkMaxClipDistancesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxClipDistances}

        {-# INLINE readVkMaxClipDistances #-}
        readVkMaxClipDistances p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxClipDistances}

        {-# INLINE writeVkMaxClipDistances #-}
        writeVkMaxClipDistances p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxClipDistances}

class HasVkMaxCullDistances a where
        type VkMaxCullDistancesMType a :: *

        vkMaxCullDistances :: a -> VkMaxCullDistancesMType a

        vkMaxCullDistancesByteOffset :: a -> Int

        readVkMaxCullDistances :: Ptr a -> IO (VkMaxCullDistancesMType a)

        writeVkMaxCullDistances ::
                                Ptr a -> VkMaxCullDistancesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxCullDistances'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxCullDistances a

instance {-# OVERLAPPING #-}
         HasVkMaxCullDistances VkPhysicalDeviceLimits where
        type VkMaxCullDistancesMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkMaxCullDistances #-}
        vkMaxCullDistances x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxCullDistances})

        {-# INLINE vkMaxCullDistancesByteOffset #-}
        vkMaxCullDistancesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxCullDistances}

        {-# INLINE readVkMaxCullDistances #-}
        readVkMaxCullDistances p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxCullDistances}

        {-# INLINE writeVkMaxCullDistances #-}
        writeVkMaxCullDistances p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxCullDistances}

class HasVkMaxCombinedClipAndCullDistances a where
        type VkMaxCombinedClipAndCullDistancesMType a :: *

        vkMaxCombinedClipAndCullDistances ::
                                          a -> VkMaxCombinedClipAndCullDistancesMType a

        vkMaxCombinedClipAndCullDistancesByteOffset :: a -> Int

        readVkMaxCombinedClipAndCullDistances ::
                                              Ptr a -> IO (VkMaxCombinedClipAndCullDistancesMType a)

        writeVkMaxCombinedClipAndCullDistances ::
                                               Ptr a ->
                                                 VkMaxCombinedClipAndCullDistancesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxCombinedClipAndCullDistances'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxCombinedClipAndCullDistances a

instance {-# OVERLAPPING #-}
         HasVkMaxCombinedClipAndCullDistances VkPhysicalDeviceLimits where
        type VkMaxCombinedClipAndCullDistancesMType VkPhysicalDeviceLimits
             = Data.Word.Word32

        {-# NOINLINE vkMaxCombinedClipAndCullDistances #-}
        vkMaxCombinedClipAndCullDistances x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, maxCombinedClipAndCullDistances})

        {-# INLINE vkMaxCombinedClipAndCullDistancesByteOffset #-}
        vkMaxCombinedClipAndCullDistancesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxCombinedClipAndCullDistances}

        {-# INLINE readVkMaxCombinedClipAndCullDistances #-}
        readVkMaxCombinedClipAndCullDistances p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, maxCombinedClipAndCullDistances}

        {-# INLINE writeVkMaxCombinedClipAndCullDistances #-}
        writeVkMaxCombinedClipAndCullDistances p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, maxCombinedClipAndCullDistances}

class HasVkDiscreteQueuePriorities a where
        type VkDiscreteQueuePrioritiesMType a :: *

        vkDiscreteQueuePriorities :: a -> VkDiscreteQueuePrioritiesMType a

        vkDiscreteQueuePrioritiesByteOffset :: a -> Int

        readVkDiscreteQueuePriorities ::
                                      Ptr a -> IO (VkDiscreteQueuePrioritiesMType a)

        writeVkDiscreteQueuePriorities ::
                                       Ptr a -> VkDiscreteQueuePrioritiesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'discreteQueuePriorities'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDiscreteQueuePriorities a

instance {-# OVERLAPPING #-}
         HasVkDiscreteQueuePriorities VkPhysicalDeviceLimits where
        type VkDiscreteQueuePrioritiesMType VkPhysicalDeviceLimits =
             Data.Word.Word32

        {-# NOINLINE vkDiscreteQueuePriorities #-}
        vkDiscreteQueuePriorities x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, discreteQueuePriorities})

        {-# INLINE vkDiscreteQueuePrioritiesByteOffset #-}
        vkDiscreteQueuePrioritiesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, discreteQueuePriorities}

        {-# INLINE readVkDiscreteQueuePriorities #-}
        readVkDiscreteQueuePriorities p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, discreteQueuePriorities}

        {-# INLINE writeVkDiscreteQueuePriorities #-}
        writeVkDiscreteQueuePriorities p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, discreteQueuePriorities}

class HasVkPointSizeRangeArray a where
        type VkPointSizeRangeArrayMType a :: *

        vkPointSizeRangeArray :: a -> Int -> VkPointSizeRangeArrayMType a

        vkPointSizeRangeArrayByteOffset :: a -> Int

        readVkPointSizeRangeArray ::
                                  Ptr a -> Int -> IO (VkPointSizeRangeArrayMType a)

        writeVkPointSizeRangeArray ::
                                   Ptr a -> Int -> VkPointSizeRangeArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pointSizeRange'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPointSizeRangeArray a

instance {-# OVERLAPPING #-}
         HasVkPointSizeRangeArray VkPhysicalDeviceLimits where
        type VkPointSizeRangeArrayMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkPointSizeRangeArray #-}
        vkPointSizeRangeArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                    #{offset VkPhysicalDeviceLimits, pointSizeRange}))

        {-# INLINE vkPointSizeRangeArrayByteOffset #-}
        vkPointSizeRangeArrayByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, pointSizeRange}

        {-# INLINE readVkPointSizeRangeArray #-}
        readVkPointSizeRangeArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                 #{offset VkPhysicalDeviceLimits, pointSizeRange})

        {-# INLINE writeVkPointSizeRangeArray #-}
        writeVkPointSizeRangeArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                 #{offset VkPhysicalDeviceLimits, pointSizeRange})

class HasVkLineWidthRangeArray a where
        type VkLineWidthRangeArrayMType a :: *

        vkLineWidthRangeArray :: a -> Int -> VkLineWidthRangeArrayMType a

        vkLineWidthRangeArrayByteOffset :: a -> Int

        readVkLineWidthRangeArray ::
                                  Ptr a -> Int -> IO (VkLineWidthRangeArrayMType a)

        writeVkLineWidthRangeArray ::
                                   Ptr a -> Int -> VkLineWidthRangeArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'lineWidthRange'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLineWidthRangeArray a

instance {-# OVERLAPPING #-}
         HasVkLineWidthRangeArray VkPhysicalDeviceLimits where
        type VkLineWidthRangeArrayMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkLineWidthRangeArray #-}
        vkLineWidthRangeArray x idx
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                    #{offset VkPhysicalDeviceLimits, lineWidthRange}))

        {-# INLINE vkLineWidthRangeArrayByteOffset #-}
        vkLineWidthRangeArrayByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, lineWidthRange}

        {-# INLINE readVkLineWidthRangeArray #-}
        readVkLineWidthRangeArray p idx
          = peekByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                 #{offset VkPhysicalDeviceLimits, lineWidthRange})

        {-# INLINE writeVkLineWidthRangeArray #-}
        writeVkLineWidthRangeArray p idx
          = pokeByteOff p
              (idx * sizeOf (undefined :: Foreign.C.Types.CFloat) +
                 #{offset VkPhysicalDeviceLimits, lineWidthRange})

class HasVkPointSizeGranularity a where
        type VkPointSizeGranularityMType a :: *

        vkPointSizeGranularity :: a -> VkPointSizeGranularityMType a

        vkPointSizeGranularityByteOffset :: a -> Int

        readVkPointSizeGranularity ::
                                   Ptr a -> IO (VkPointSizeGranularityMType a)

        writeVkPointSizeGranularity ::
                                    Ptr a -> VkPointSizeGranularityMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pointSizeGranularity'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPointSizeGranularity a

instance {-# OVERLAPPING #-}
         HasVkPointSizeGranularity VkPhysicalDeviceLimits where
        type VkPointSizeGranularityMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkPointSizeGranularity #-}
        vkPointSizeGranularity x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, pointSizeGranularity})

        {-# INLINE vkPointSizeGranularityByteOffset #-}
        vkPointSizeGranularityByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, pointSizeGranularity}

        {-# INLINE readVkPointSizeGranularity #-}
        readVkPointSizeGranularity p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, pointSizeGranularity}

        {-# INLINE writeVkPointSizeGranularity #-}
        writeVkPointSizeGranularity p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, pointSizeGranularity}

class HasVkLineWidthGranularity a where
        type VkLineWidthGranularityMType a :: *

        vkLineWidthGranularity :: a -> VkLineWidthGranularityMType a

        vkLineWidthGranularityByteOffset :: a -> Int

        readVkLineWidthGranularity ::
                                   Ptr a -> IO (VkLineWidthGranularityMType a)

        writeVkLineWidthGranularity ::
                                    Ptr a -> VkLineWidthGranularityMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'lineWidthGranularity'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLineWidthGranularity a

instance {-# OVERLAPPING #-}
         HasVkLineWidthGranularity VkPhysicalDeviceLimits where
        type VkLineWidthGranularityMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat

        {-# NOINLINE vkLineWidthGranularity #-}
        vkLineWidthGranularity x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, lineWidthGranularity})

        {-# INLINE vkLineWidthGranularityByteOffset #-}
        vkLineWidthGranularityByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, lineWidthGranularity}

        {-# INLINE readVkLineWidthGranularity #-}
        readVkLineWidthGranularity p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, lineWidthGranularity}

        {-# INLINE writeVkLineWidthGranularity #-}
        writeVkLineWidthGranularity p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, lineWidthGranularity}

class HasVkStrictLines a where
        type VkStrictLinesMType a :: *

        vkStrictLines :: a -> VkStrictLinesMType a

        vkStrictLinesByteOffset :: a -> Int

        readVkStrictLines :: Ptr a -> IO (VkStrictLinesMType a)

        writeVkStrictLines :: Ptr a -> VkStrictLinesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'strictLines'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStrictLines a

instance {-# OVERLAPPING #-}
         HasVkStrictLines VkPhysicalDeviceLimits where
        type VkStrictLinesMType VkPhysicalDeviceLimits = VkBool32

        {-# NOINLINE vkStrictLines #-}
        vkStrictLines x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, strictLines})

        {-# INLINE vkStrictLinesByteOffset #-}
        vkStrictLinesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, strictLines}

        {-# INLINE readVkStrictLines #-}
        readVkStrictLines p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, strictLines}

        {-# INLINE writeVkStrictLines #-}
        writeVkStrictLines p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, strictLines}

class HasVkStandardSampleLocations a where
        type VkStandardSampleLocationsMType a :: *

        vkStandardSampleLocations :: a -> VkStandardSampleLocationsMType a

        vkStandardSampleLocationsByteOffset :: a -> Int

        readVkStandardSampleLocations ::
                                      Ptr a -> IO (VkStandardSampleLocationsMType a)

        writeVkStandardSampleLocations ::
                                       Ptr a -> VkStandardSampleLocationsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'standardSampleLocations'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStandardSampleLocations a

instance {-# OVERLAPPING #-}
         HasVkStandardSampleLocations VkPhysicalDeviceLimits where
        type VkStandardSampleLocationsMType VkPhysicalDeviceLimits =
             VkBool32

        {-# NOINLINE vkStandardSampleLocations #-}
        vkStandardSampleLocations x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, standardSampleLocations})

        {-# INLINE vkStandardSampleLocationsByteOffset #-}
        vkStandardSampleLocationsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, standardSampleLocations}

        {-# INLINE readVkStandardSampleLocations #-}
        readVkStandardSampleLocations p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, standardSampleLocations}

        {-# INLINE writeVkStandardSampleLocations #-}
        writeVkStandardSampleLocations p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, standardSampleLocations}

class HasVkOptimalBufferCopyOffsetAlignment a where
        type VkOptimalBufferCopyOffsetAlignmentMType a :: *

        vkOptimalBufferCopyOffsetAlignment ::
                                           a -> VkOptimalBufferCopyOffsetAlignmentMType a

        vkOptimalBufferCopyOffsetAlignmentByteOffset :: a -> Int

        readVkOptimalBufferCopyOffsetAlignment ::
                                               Ptr a ->
                                                 IO (VkOptimalBufferCopyOffsetAlignmentMType a)

        writeVkOptimalBufferCopyOffsetAlignment ::
                                                Ptr a ->
                                                  VkOptimalBufferCopyOffsetAlignmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'optimalBufferCopyOffsetAlignment'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkOptimalBufferCopyOffsetAlignment a

instance {-# OVERLAPPING #-}
         HasVkOptimalBufferCopyOffsetAlignment VkPhysicalDeviceLimits where
        type VkOptimalBufferCopyOffsetAlignmentMType VkPhysicalDeviceLimits
             = VkDeviceSize

        {-# NOINLINE vkOptimalBufferCopyOffsetAlignment #-}
        vkOptimalBufferCopyOffsetAlignment x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, optimalBufferCopyOffsetAlignment})

        {-# INLINE vkOptimalBufferCopyOffsetAlignmentByteOffset #-}
        vkOptimalBufferCopyOffsetAlignmentByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, optimalBufferCopyOffsetAlignment}

        {-# INLINE readVkOptimalBufferCopyOffsetAlignment #-}
        readVkOptimalBufferCopyOffsetAlignment p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, optimalBufferCopyOffsetAlignment}

        {-# INLINE writeVkOptimalBufferCopyOffsetAlignment #-}
        writeVkOptimalBufferCopyOffsetAlignment p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, optimalBufferCopyOffsetAlignment}

class HasVkOptimalBufferCopyRowPitchAlignment a where
        type VkOptimalBufferCopyRowPitchAlignmentMType a :: *

        vkOptimalBufferCopyRowPitchAlignment ::
                                             a -> VkOptimalBufferCopyRowPitchAlignmentMType a

        vkOptimalBufferCopyRowPitchAlignmentByteOffset :: a -> Int

        readVkOptimalBufferCopyRowPitchAlignment ::
                                                 Ptr a ->
                                                   IO (VkOptimalBufferCopyRowPitchAlignmentMType a)

        writeVkOptimalBufferCopyRowPitchAlignment ::
                                                  Ptr a ->
                                                    VkOptimalBufferCopyRowPitchAlignmentMType a ->
                                                      IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'optimalBufferCopyRowPitchAlignment'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkOptimalBufferCopyRowPitchAlignment a

instance {-# OVERLAPPING #-}
         HasVkOptimalBufferCopyRowPitchAlignment VkPhysicalDeviceLimits
         where
        type VkOptimalBufferCopyRowPitchAlignmentMType
               VkPhysicalDeviceLimits
             = VkDeviceSize

        {-# NOINLINE vkOptimalBufferCopyRowPitchAlignment #-}
        vkOptimalBufferCopyRowPitchAlignment x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, optimalBufferCopyRowPitchAlignment})

        {-# INLINE vkOptimalBufferCopyRowPitchAlignmentByteOffset #-}
        vkOptimalBufferCopyRowPitchAlignmentByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, optimalBufferCopyRowPitchAlignment}

        {-# INLINE readVkOptimalBufferCopyRowPitchAlignment #-}
        readVkOptimalBufferCopyRowPitchAlignment p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, optimalBufferCopyRowPitchAlignment}

        {-# INLINE writeVkOptimalBufferCopyRowPitchAlignment #-}
        writeVkOptimalBufferCopyRowPitchAlignment p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, optimalBufferCopyRowPitchAlignment}

class HasVkNonCoherentAtomSize a where
        type VkNonCoherentAtomSizeMType a :: *

        vkNonCoherentAtomSize :: a -> VkNonCoherentAtomSizeMType a

        vkNonCoherentAtomSizeByteOffset :: a -> Int

        readVkNonCoherentAtomSize ::
                                  Ptr a -> IO (VkNonCoherentAtomSizeMType a)

        writeVkNonCoherentAtomSize ::
                                   Ptr a -> VkNonCoherentAtomSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'nonCoherentAtomSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkNonCoherentAtomSize a

instance {-# OVERLAPPING #-}
         HasVkNonCoherentAtomSize VkPhysicalDeviceLimits where
        type VkNonCoherentAtomSizeMType VkPhysicalDeviceLimits =
             VkDeviceSize

        {-# NOINLINE vkNonCoherentAtomSize #-}
        vkNonCoherentAtomSize x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPhysicalDeviceLimits, nonCoherentAtomSize})

        {-# INLINE vkNonCoherentAtomSizeByteOffset #-}
        vkNonCoherentAtomSizeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, nonCoherentAtomSize}

        {-# INLINE readVkNonCoherentAtomSize #-}
        readVkNonCoherentAtomSize p
          = peekByteOff p
              #{offset VkPhysicalDeviceLimits, nonCoherentAtomSize}

        {-# INLINE writeVkNonCoherentAtomSize #-}
        writeVkNonCoherentAtomSize p
          = pokeByteOff p
              #{offset VkPhysicalDeviceLimits, nonCoherentAtomSize}

instance Show VkPhysicalDeviceLimits where
        showsPrec d x
          = showString "VkPhysicalDeviceLimits {" .
              showString "vkMaxImageDimension1D = " .
                showsPrec d (vkMaxImageDimension1D x) .
                  showString ", " .
                    showString "vkMaxImageDimension2D = " .
                      showsPrec d (vkMaxImageDimension2D x) .
                        showString ", " .
                          showString "vkMaxImageDimension3D = " .
                            showsPrec d (vkMaxImageDimension3D x) .
                              showString ", " .
                                showString "vkMaxImageDimensionCube = " .
                                  showsPrec d (vkMaxImageDimensionCube x) .
                                    showString ", " .
                                      showString "vkMaxImageArrayLayers = " .
                                        showsPrec d (vkMaxImageArrayLayers x) .
                                          showString ", " .
                                            showString "vkMaxTexelBufferElements = " .
                                              showsPrec d (vkMaxTexelBufferElements x) .
                                                showString ", " .
                                                  showString "vkMaxUniformBufferRange = " .
                                                    showsPrec d (vkMaxUniformBufferRange x) .
                                                      showString ", " .
                                                        showString "vkMaxStorageBufferRange = " .
                                                          showsPrec d (vkMaxStorageBufferRange x) .
                                                            showString ", " .
                                                              showString "vkMaxPushConstantsSize = "
                                                                .
                                                                showsPrec d
                                                                  (vkMaxPushConstantsSize x)
                                                                  .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkMaxMemoryAllocationCount = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkMaxMemoryAllocationCount
                                                                           x)
                                                                        .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkMaxSamplerAllocationCount = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkMaxSamplerAllocationCount
                                                                                 x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkBufferImageGranularity = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkBufferImageGranularity
                                                                                       x)
                                                                                    .
                                                                                    showString ", "
                                                                                      .
                                                                                      showString
                                                                                        "vkSparseAddressSpaceSize = "
                                                                                        .
                                                                                        showsPrec d
                                                                                          (vkSparseAddressSpaceSize
                                                                                             x)
                                                                                          .
                                                                                          showString
                                                                                            ", "
                                                                                            .
                                                                                            showString
                                                                                              "vkMaxBoundDescriptorSets = "
                                                                                              .
                                                                                              showsPrec
                                                                                                d
                                                                                                (vkMaxBoundDescriptorSets
                                                                                                   x)
                                                                                                .
                                                                                                showString
                                                                                                  ", "
                                                                                                  .
                                                                                                  showString
                                                                                                    "vkMaxPerStageDescriptorSamplers = "
                                                                                                    .
                                                                                                    showsPrec
                                                                                                      d
                                                                                                      (vkMaxPerStageDescriptorSamplers
                                                                                                         x)
                                                                                                      .
                                                                                                      showString
                                                                                                        ", "
                                                                                                        .
                                                                                                        showString
                                                                                                          "vkMaxPerStageDescriptorUniformBuffers = "
                                                                                                          .
                                                                                                          showsPrec
                                                                                                            d
                                                                                                            (vkMaxPerStageDescriptorUniformBuffers
                                                                                                               x)
                                                                                                            .
                                                                                                            showString
                                                                                                              ", "
                                                                                                              .
                                                                                                              showString
                                                                                                                "vkMaxPerStageDescriptorStorageBuffers = "
                                                                                                                .
                                                                                                                showsPrec
                                                                                                                  d
                                                                                                                  (vkMaxPerStageDescriptorStorageBuffers
                                                                                                                     x)
                                                                                                                  .
                                                                                                                  showString
                                                                                                                    ", "
                                                                                                                    .
                                                                                                                    showString
                                                                                                                      "vkMaxPerStageDescriptorSampledImages = "
                                                                                                                      .
                                                                                                                      showsPrec
                                                                                                                        d
                                                                                                                        (vkMaxPerStageDescriptorSampledImages
                                                                                                                           x)
                                                                                                                        .
                                                                                                                        showString
                                                                                                                          ", "
                                                                                                                          .
                                                                                                                          showString
                                                                                                                            "vkMaxPerStageDescriptorStorageImages = "
                                                                                                                            .
                                                                                                                            showsPrec
                                                                                                                              d
                                                                                                                              (vkMaxPerStageDescriptorStorageImages
                                                                                                                                 x)
                                                                                                                              .
                                                                                                                              showString
                                                                                                                                ", "
                                                                                                                                .
                                                                                                                                showString
                                                                                                                                  "vkMaxPerStageDescriptorInputAttachments = "
                                                                                                                                  .
                                                                                                                                  showsPrec
                                                                                                                                    d
                                                                                                                                    (vkMaxPerStageDescriptorInputAttachments
                                                                                                                                       x)
                                                                                                                                    .
                                                                                                                                    showString
                                                                                                                                      ", "
                                                                                                                                      .
                                                                                                                                      showString
                                                                                                                                        "vkMaxPerStageResources = "
                                                                                                                                        .
                                                                                                                                        showsPrec
                                                                                                                                          d
                                                                                                                                          (vkMaxPerStageResources
                                                                                                                                             x)
                                                                                                                                          .
                                                                                                                                          showString
                                                                                                                                            ", "
                                                                                                                                            .
                                                                                                                                            showString
                                                                                                                                              "vkMaxDescriptorSetSamplers = "
                                                                                                                                              .
                                                                                                                                              showsPrec
                                                                                                                                                d
                                                                                                                                                (vkMaxDescriptorSetSamplers
                                                                                                                                                   x)
                                                                                                                                                .
                                                                                                                                                showString
                                                                                                                                                  ", "
                                                                                                                                                  .
                                                                                                                                                  showString
                                                                                                                                                    "vkMaxDescriptorSetUniformBuffers = "
                                                                                                                                                    .
                                                                                                                                                    showsPrec
                                                                                                                                                      d
                                                                                                                                                      (vkMaxDescriptorSetUniformBuffers
                                                                                                                                                         x)
                                                                                                                                                      .
                                                                                                                                                      showString
                                                                                                                                                        ", "
                                                                                                                                                        .
                                                                                                                                                        showString
                                                                                                                                                          "vkMaxDescriptorSetUniformBuffersDynamic = "
                                                                                                                                                          .
                                                                                                                                                          showsPrec
                                                                                                                                                            d
                                                                                                                                                            (vkMaxDescriptorSetUniformBuffersDynamic
                                                                                                                                                               x)
                                                                                                                                                            .
                                                                                                                                                            showString
                                                                                                                                                              ", "
                                                                                                                                                              .
                                                                                                                                                              showString
                                                                                                                                                                "vkMaxDescriptorSetStorageBuffers = "
                                                                                                                                                                .
                                                                                                                                                                showsPrec
                                                                                                                                                                  d
                                                                                                                                                                  (vkMaxDescriptorSetStorageBuffers
                                                                                                                                                                     x)
                                                                                                                                                                  .
                                                                                                                                                                  showString
                                                                                                                                                                    ", "
                                                                                                                                                                    .
                                                                                                                                                                    showString
                                                                                                                                                                      "vkMaxDescriptorSetStorageBuffersDynamic = "
                                                                                                                                                                      .
                                                                                                                                                                      showsPrec
                                                                                                                                                                        d
                                                                                                                                                                        (vkMaxDescriptorSetStorageBuffersDynamic
                                                                                                                                                                           x)
                                                                                                                                                                        .
                                                                                                                                                                        showString
                                                                                                                                                                          ", "
                                                                                                                                                                          .
                                                                                                                                                                          showString
                                                                                                                                                                            "vkMaxDescriptorSetSampledImages = "
                                                                                                                                                                            .
                                                                                                                                                                            showsPrec
                                                                                                                                                                              d
                                                                                                                                                                              (vkMaxDescriptorSetSampledImages
                                                                                                                                                                                 x)
                                                                                                                                                                              .
                                                                                                                                                                              showString
                                                                                                                                                                                ", "
                                                                                                                                                                                .
                                                                                                                                                                                showString
                                                                                                                                                                                  "vkMaxDescriptorSetStorageImages = "
                                                                                                                                                                                  .
                                                                                                                                                                                  showsPrec
                                                                                                                                                                                    d
                                                                                                                                                                                    (vkMaxDescriptorSetStorageImages
                                                                                                                                                                                       x)
                                                                                                                                                                                    .
                                                                                                                                                                                    showString
                                                                                                                                                                                      ", "
                                                                                                                                                                                      .
                                                                                                                                                                                      showString
                                                                                                                                                                                        "vkMaxDescriptorSetInputAttachments = "
                                                                                                                                                                                        .
                                                                                                                                                                                        showsPrec
                                                                                                                                                                                          d
                                                                                                                                                                                          (vkMaxDescriptorSetInputAttachments
                                                                                                                                                                                             x)
                                                                                                                                                                                          .
                                                                                                                                                                                          showString
                                                                                                                                                                                            ", "
                                                                                                                                                                                            .
                                                                                                                                                                                            showString
                                                                                                                                                                                              "vkMaxVertexInputAttributes = "
                                                                                                                                                                                              .
                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                d
                                                                                                                                                                                                (vkMaxVertexInputAttributes
                                                                                                                                                                                                   x)
                                                                                                                                                                                                .
                                                                                                                                                                                                showString
                                                                                                                                                                                                  ", "
                                                                                                                                                                                                  .
                                                                                                                                                                                                  showString
                                                                                                                                                                                                    "vkMaxVertexInputBindings = "
                                                                                                                                                                                                    .
                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                      d
                                                                                                                                                                                                      (vkMaxVertexInputBindings
                                                                                                                                                                                                         x)
                                                                                                                                                                                                      .
                                                                                                                                                                                                      showString
                                                                                                                                                                                                        ", "
                                                                                                                                                                                                        .
                                                                                                                                                                                                        showString
                                                                                                                                                                                                          "vkMaxVertexInputAttributeOffset = "
                                                                                                                                                                                                          .
                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                            d
                                                                                                                                                                                                            (vkMaxVertexInputAttributeOffset
                                                                                                                                                                                                               x)
                                                                                                                                                                                                            .
                                                                                                                                                                                                            showString
                                                                                                                                                                                                              ", "
                                                                                                                                                                                                              .
                                                                                                                                                                                                              showString
                                                                                                                                                                                                                "vkMaxVertexInputBindingStride = "
                                                                                                                                                                                                                .
                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                  d
                                                                                                                                                                                                                  (vkMaxVertexInputBindingStride
                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                  .
                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                    .
                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                      "vkMaxVertexOutputComponents = "
                                                                                                                                                                                                                      .
                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                        d
                                                                                                                                                                                                                        (vkMaxVertexOutputComponents
                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                        .
                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                          .
                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                            "vkMaxTessellationGenerationLevel = "
                                                                                                                                                                                                                            .
                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                              d
                                                                                                                                                                                                                              (vkMaxTessellationGenerationLevel
                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                              .
                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                  "vkMaxTessellationPatchSize = "
                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                    (vkMaxTessellationPatchSize
                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                        "vkMaxTessellationControlPerVertexInputComponents = "
                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                          (vkMaxTessellationControlPerVertexInputComponents
                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                              "vkMaxTessellationControlPerVertexOutputComponents = "
                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                (vkMaxTessellationControlPerVertexOutputComponents
                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                    "vkMaxTessellationControlPerPatchOutputComponents = "
                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                      (vkMaxTessellationControlPerPatchOutputComponents
                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                          "vkMaxTessellationControlTotalOutputComponents = "
                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                            (vkMaxTessellationControlTotalOutputComponents
                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                "vkMaxTessellationEvaluationInputComponents = "
                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                  (vkMaxTessellationEvaluationInputComponents
                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                      "vkMaxTessellationEvaluationOutputComponents = "
                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                        (vkMaxTessellationEvaluationOutputComponents
                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                            "vkMaxGeometryShaderInvocations = "
                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                              (vkMaxGeometryShaderInvocations
                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                  "vkMaxGeometryInputComponents = "
                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                    (vkMaxGeometryInputComponents
                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                        "vkMaxGeometryOutputComponents = "
                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                          (vkMaxGeometryOutputComponents
                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                              "vkMaxGeometryOutputVertices = "
                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                (vkMaxGeometryOutputVertices
                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                    "vkMaxGeometryTotalOutputComponents = "
                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                      (vkMaxGeometryTotalOutputComponents
                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                          "vkMaxFragmentInputComponents = "
                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                            (vkMaxFragmentInputComponents
                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                "vkMaxFragmentOutputAttachments = "
                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                  (vkMaxFragmentOutputAttachments
                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                      "vkMaxFragmentDualSrcAttachments = "
                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                        (vkMaxFragmentDualSrcAttachments
                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                            "vkMaxFragmentCombinedOutputResources = "
                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                              (vkMaxFragmentCombinedOutputResources
                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                  "vkMaxComputeSharedMemorySize = "
                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                    (vkMaxComputeSharedMemorySize
                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                        "vkMaxComputeWorkGroupCountArray = ["
                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                                                                          (map
                                                                                                                                                                                                                                                                                                                                             (vkMaxComputeWorkGroupCountArray
                                                                                                                                                                                                                                                                                                                                                x)
                                                                                                                                                                                                                                                                                                                                             [1
                                                                                                                                                                                                                                                                                                                                              ..
                                                                                                                                                                                                                                                                                                                                              3])
                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                          showChar
                                                                                                                                                                                                                                                                                                                                            ']'
                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                "vkMaxComputeWorkGroupInvocations = "
                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                                                  (vkMaxComputeWorkGroupInvocations
                                                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                      "vkMaxComputeWorkGroupSizeArray = ["
                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                        (map
                                                                                                                                                                                                                                                                                                                                                           (vkMaxComputeWorkGroupSizeArray
                                                                                                                                                                                                                                                                                                                                                              x)
                                                                                                                                                                                                                                                                                                                                                           [1
                                                                                                                                                                                                                                                                                                                                                            ..
                                                                                                                                                                                                                                                                                                                                                            3])
                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                        showChar
                                                                                                                                                                                                                                                                                                                                                          ']'
                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                              "vkSubPixelPrecisionBits = "
                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                (vkSubPixelPrecisionBits
                                                                                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                    "vkSubTexelPrecisionBits = "
                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                                                                                      (vkSubTexelPrecisionBits
                                                                                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                          "vkMipmapPrecisionBits = "
                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                                                                                            (vkMipmapPrecisionBits
                                                                                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                "vkMaxDrawIndexedIndexValue = "
                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                                                                                  (vkMaxDrawIndexedIndexValue
                                                                                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                      "vkMaxDrawIndirectCount = "
                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                        (vkMaxDrawIndirectCount
                                                                                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                            "vkMaxSamplerLodBias = "
                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                                                                                              (vkMaxSamplerLodBias
                                                                                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                  "vkMaxSamplerAnisotropy = "
                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                                                                                    (vkMaxSamplerAnisotropy
                                                                                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                        "vkMaxViewports = "
                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                                                                                                                                          (vkMaxViewports
                                                                                                                                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                              "vkMaxViewportDimensionsArray = ["
                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                                                                (map
                                                                                                                                                                                                                                                                                                                                                                                                                   (vkMaxViewportDimensionsArray
                                                                                                                                                                                                                                                                                                                                                                                                                      x)
                                                                                                                                                                                                                                                                                                                                                                                                                   [1
                                                                                                                                                                                                                                                                                                                                                                                                                    ..
                                                                                                                                                                                                                                                                                                                                                                                                                    2])
                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                showChar
                                                                                                                                                                                                                                                                                                                                                                                                                  ']'
                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                      "vkViewportBoundsRangeArray = ["
                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                                                        (map
                                                                                                                                                                                                                                                                                                                                                                                                                           (vkViewportBoundsRangeArray
                                                                                                                                                                                                                                                                                                                                                                                                                              x)
                                                                                                                                                                                                                                                                                                                                                                                                                           [1
                                                                                                                                                                                                                                                                                                                                                                                                                            ..
                                                                                                                                                                                                                                                                                                                                                                                                                            2])
                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                        showChar
                                                                                                                                                                                                                                                                                                                                                                                                                          ']'
                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                              "vkViewportSubPixelBits = "
                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                                                                                (vkViewportSubPixelBits
                                                                                                                                                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                    "vkMinMemoryMapAlignment = "
                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                                                                                                                                                      (vkMinMemoryMapAlignment
                                                                                                                                                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                          "vkMinTexelBufferOffsetAlignment = "
                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                                                                                                                                                            (vkMinTexelBufferOffsetAlignment
                                                                                                                                                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                "vkMinUniformBufferOffsetAlignment = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                                                                                                                                                  (vkMinUniformBufferOffsetAlignment
                                                                                                                                                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                      "vkMinStorageBufferOffsetAlignment = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                                                                                        (vkMinStorageBufferOffsetAlignment
                                                                                                                                                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                            "vkMinTexelOffset = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                                                                                                                                                              (vkMinTexelOffset
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "vkMaxTexelOffset = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (vkMaxTexelOffset
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "vkMinTexelGatherOffset = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (vkMinTexelGatherOffset
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "vkMaxTexelGatherOffset = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (vkMaxTexelGatherOffset
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "vkMinInterpolationOffset = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (vkMinInterpolationOffset
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "vkMaxInterpolationOffset = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (vkMaxInterpolationOffset
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "vkSubPixelInterpolationOffsetBits = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (vkSubPixelInterpolationOffsetBits
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "vkMaxFramebufferWidth = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (vkMaxFramebufferWidth
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "vkMaxFramebufferHeight = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (vkMaxFramebufferHeight
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "vkMaxFramebufferLayers = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (vkMaxFramebufferLayers
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "vkFramebufferColorSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (vkFramebufferColorSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "vkFramebufferDepthSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (vkFramebufferDepthSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "vkFramebufferStencilSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (vkFramebufferStencilSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "vkFramebufferNoAttachmentsSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (vkFramebufferNoAttachmentsSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "vkMaxColorAttachments = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (vkMaxColorAttachments
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "vkSampledImageColorSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (vkSampledImageColorSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "vkSampledImageIntegerSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (vkSampledImageIntegerSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "vkSampledImageDepthSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (vkSampledImageDepthSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "vkSampledImageStencilSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (vkSampledImageStencilSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "vkStorageImageSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (vkStorageImageSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "vkMaxSampleMaskWords = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (vkMaxSampleMaskWords
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "vkTimestampComputeAndGraphics = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (vkTimestampComputeAndGraphics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "vkTimestampPeriod = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (vkTimestampPeriod
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "vkMaxClipDistances = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (vkMaxClipDistances
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "vkMaxCullDistances = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (vkMaxCullDistances
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "vkMaxCombinedClipAndCullDistances = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (vkMaxCombinedClipAndCullDistances
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "vkDiscreteQueuePriorities = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (vkDiscreteQueuePriorities
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "vkPointSizeRangeArray = ["
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (map
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   (vkPointSizeRangeArray
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   [1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ..
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    2])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showChar
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ']'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "vkLineWidthRangeArray = ["
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (map
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (vkLineWidthRangeArray
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           [1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ..
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            2])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showChar
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ']'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "vkPointSizeGranularity = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (vkPointSizeGranularity
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "vkLineWidthGranularity = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (vkLineWidthGranularity
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "vkStrictLines = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (vkStrictLines
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "vkStandardSampleLocations = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (vkStandardSampleLocations
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "vkOptimalBufferCopyOffsetAlignment = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (vkOptimalBufferCopyOffsetAlignment
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "vkOptimalBufferCopyRowPitchAlignment = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (vkOptimalBufferCopyRowPitchAlignment
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "vkNonCoherentAtomSize = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (vkNonCoherentAtomSize
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showChar
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      '}'

data VkSemaphoreCreateInfo = VkSemaphoreCreateInfo## ByteArray##

instance Eq VkSemaphoreCreateInfo where
        (VkSemaphoreCreateInfo## a) == (VkSemaphoreCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSemaphoreCreateInfo where
        (VkSemaphoreCreateInfo## a) `compare` (VkSemaphoreCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSemaphoreCreateInfo where
        sizeOf ~_ = #{size VkSemaphoreCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSemaphoreCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSemaphoreCreateInfo),
            I## a <- alignment (undefined :: VkSemaphoreCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSemaphoreCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSemaphoreCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkSemaphoreCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSemaphoreCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSemaphoreCreateInfo),
            I## a <- alignment (undefined :: VkSemaphoreCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSemaphoreCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSemaphoreCreateInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSemaphoreCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSemaphoreCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSemaphoreCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSemaphoreCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkSemaphoreCreateInfo where
        type VkSTypeMType VkSemaphoreCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSemaphoreCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkSemaphoreCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkSemaphoreCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkSemaphoreCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkSemaphoreCreateInfo where
        type VkPNextMType VkSemaphoreCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSemaphoreCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkSemaphoreCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkSemaphoreCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkSemaphoreCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkSemaphoreCreateInfo where
        type VkFlagsMType VkSemaphoreCreateInfo = VkSemaphoreCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSemaphoreCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkSemaphoreCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkSemaphoreCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkSemaphoreCreateInfo, flags}

instance Show VkSemaphoreCreateInfo where
        showsPrec d x
          = showString "VkSemaphoreCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " . showsPrec d (vkFlags x) . showChar '}'

data VkQueryPoolCreateInfo = VkQueryPoolCreateInfo## ByteArray##

instance Eq VkQueryPoolCreateInfo where
        (VkQueryPoolCreateInfo## a) == (VkQueryPoolCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkQueryPoolCreateInfo where
        (VkQueryPoolCreateInfo## a) `compare` (VkQueryPoolCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkQueryPoolCreateInfo where
        sizeOf ~_ = #{size VkQueryPoolCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkQueryPoolCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkQueryPoolCreateInfo),
            I## a <- alignment (undefined :: VkQueryPoolCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkQueryPoolCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkQueryPoolCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkQueryPoolCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkQueryPoolCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkQueryPoolCreateInfo),
            I## a <- alignment (undefined :: VkQueryPoolCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkQueryPoolCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkQueryPoolCreateInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkQueryPoolCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkQueryPoolCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkQueryPoolCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkQueryPoolCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkQueryPoolCreateInfo where
        type VkSTypeMType VkQueryPoolCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkQueryPoolCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkQueryPoolCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkQueryPoolCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkQueryPoolCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkQueryPoolCreateInfo where
        type VkPNextMType VkQueryPoolCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkQueryPoolCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkQueryPoolCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkQueryPoolCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkQueryPoolCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkQueryPoolCreateInfo where
        type VkFlagsMType VkQueryPoolCreateInfo = VkQueryPoolCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkQueryPoolCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkQueryPoolCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkQueryPoolCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkQueryPoolCreateInfo, flags}

class HasVkQueryType a where
        type VkQueryTypeMType a :: *

        vkQueryType :: a -> VkQueryTypeMType a

        vkQueryTypeByteOffset :: a -> Int

        readVkQueryType :: Ptr a -> IO (VkQueryTypeMType a)

        writeVkQueryType :: Ptr a -> VkQueryTypeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queryType'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueryType a

instance {-# OVERLAPPING #-} HasVkQueryType VkQueryPoolCreateInfo
         where
        type VkQueryTypeMType VkQueryPoolCreateInfo = VkQueryType

        {-# NOINLINE vkQueryType #-}
        vkQueryType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkQueryPoolCreateInfo, queryType})

        {-# INLINE vkQueryTypeByteOffset #-}
        vkQueryTypeByteOffset ~_
          = #{offset VkQueryPoolCreateInfo, queryType}

        {-# INLINE readVkQueryType #-}
        readVkQueryType p
          = peekByteOff p #{offset VkQueryPoolCreateInfo, queryType}

        {-# INLINE writeVkQueryType #-}
        writeVkQueryType p
          = pokeByteOff p #{offset VkQueryPoolCreateInfo, queryType}

class HasVkQueryCount a where
        type VkQueryCountMType a :: *

        vkQueryCount :: a -> VkQueryCountMType a

        vkQueryCountByteOffset :: a -> Int

        readVkQueryCount :: Ptr a -> IO (VkQueryCountMType a)

        writeVkQueryCount :: Ptr a -> VkQueryCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queryCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueryCount a

instance {-# OVERLAPPING #-} HasVkQueryCount VkQueryPoolCreateInfo
         where
        type VkQueryCountMType VkQueryPoolCreateInfo = Data.Word.Word32

        {-# NOINLINE vkQueryCount #-}
        vkQueryCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkQueryPoolCreateInfo, queryCount})

        {-# INLINE vkQueryCountByteOffset #-}
        vkQueryCountByteOffset ~_
          = #{offset VkQueryPoolCreateInfo, queryCount}

        {-# INLINE readVkQueryCount #-}
        readVkQueryCount p
          = peekByteOff p
              #{offset VkQueryPoolCreateInfo, queryCount}

        {-# INLINE writeVkQueryCount #-}
        writeVkQueryCount p
          = pokeByteOff p
              #{offset VkQueryPoolCreateInfo, queryCount}

instance {-# OVERLAPPING #-}
         HasVkPipelineStatistics VkQueryPoolCreateInfo where
        type VkPipelineStatisticsMType VkQueryPoolCreateInfo =
             VkQueryPipelineStatisticFlags

        {-# NOINLINE vkPipelineStatistics #-}
        vkPipelineStatistics x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkQueryPoolCreateInfo, pipelineStatistics})

        {-# INLINE vkPipelineStatisticsByteOffset #-}
        vkPipelineStatisticsByteOffset ~_
          = #{offset VkQueryPoolCreateInfo, pipelineStatistics}

        {-# INLINE readVkPipelineStatistics #-}
        readVkPipelineStatistics p
          = peekByteOff p
              #{offset VkQueryPoolCreateInfo, pipelineStatistics}

        {-# INLINE writeVkPipelineStatistics #-}
        writeVkPipelineStatistics p
          = pokeByteOff p
              #{offset VkQueryPoolCreateInfo, pipelineStatistics}

instance Show VkQueryPoolCreateInfo where
        showsPrec d x
          = showString "VkQueryPoolCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkQueryType = " .
                                  showsPrec d (vkQueryType x) .
                                    showString ", " .
                                      showString "vkQueryCount = " .
                                        showsPrec d (vkQueryCount x) .
                                          showString ", " .
                                            showString "vkPipelineStatistics = " .
                                              showsPrec d (vkPipelineStatistics x) . showChar '}'

data VkFramebufferCreateInfo = VkFramebufferCreateInfo## ByteArray##

instance Eq VkFramebufferCreateInfo where
        (VkFramebufferCreateInfo## a) == (VkFramebufferCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkFramebufferCreateInfo where
        (VkFramebufferCreateInfo## a) `compare` (VkFramebufferCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkFramebufferCreateInfo where
        sizeOf ~_ = #{size VkFramebufferCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkFramebufferCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkFramebufferCreateInfo),
            I## a <- alignment (undefined :: VkFramebufferCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkFramebufferCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkFramebufferCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkFramebufferCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkFramebufferCreateInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkFramebufferCreateInfo),
            I## a <- alignment (undefined :: VkFramebufferCreateInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkFramebufferCreateInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkFramebufferCreateInfo## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkFramebufferCreateInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkFramebufferCreateInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkFramebufferCreateInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkFramebufferCreateInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkFramebufferCreateInfo
         where
        type VkSTypeMType VkFramebufferCreateInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFramebufferCreateInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkFramebufferCreateInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkFramebufferCreateInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkFramebufferCreateInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkFramebufferCreateInfo
         where
        type VkPNextMType VkFramebufferCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFramebufferCreateInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkFramebufferCreateInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkFramebufferCreateInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkFramebufferCreateInfo, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkFramebufferCreateInfo
         where
        type VkFlagsMType VkFramebufferCreateInfo =
             VkFramebufferCreateFlags

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFramebufferCreateInfo, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkFramebufferCreateInfo, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkFramebufferCreateInfo, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkFramebufferCreateInfo, flags}

instance {-# OVERLAPPING #-}
         HasVkRenderPass VkFramebufferCreateInfo where
        type VkRenderPassMType VkFramebufferCreateInfo = VkRenderPass

        {-# NOINLINE vkRenderPass #-}
        vkRenderPass x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFramebufferCreateInfo, renderPass})

        {-# INLINE vkRenderPassByteOffset #-}
        vkRenderPassByteOffset ~_
          = #{offset VkFramebufferCreateInfo, renderPass}

        {-# INLINE readVkRenderPass #-}
        readVkRenderPass p
          = peekByteOff p
              #{offset VkFramebufferCreateInfo, renderPass}

        {-# INLINE writeVkRenderPass #-}
        writeVkRenderPass p
          = pokeByteOff p
              #{offset VkFramebufferCreateInfo, renderPass}

instance {-# OVERLAPPING #-}
         HasVkAttachmentCount VkFramebufferCreateInfo where
        type VkAttachmentCountMType VkFramebufferCreateInfo =
             Data.Word.Word32

        {-# NOINLINE vkAttachmentCount #-}
        vkAttachmentCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFramebufferCreateInfo, attachmentCount})

        {-# INLINE vkAttachmentCountByteOffset #-}
        vkAttachmentCountByteOffset ~_
          = #{offset VkFramebufferCreateInfo, attachmentCount}

        {-# INLINE readVkAttachmentCount #-}
        readVkAttachmentCount p
          = peekByteOff p
              #{offset VkFramebufferCreateInfo, attachmentCount}

        {-# INLINE writeVkAttachmentCount #-}
        writeVkAttachmentCount p
          = pokeByteOff p
              #{offset VkFramebufferCreateInfo, attachmentCount}

instance {-# OVERLAPPING #-}
         HasVkPAttachments VkFramebufferCreateInfo where
        type VkPAttachmentsMType VkFramebufferCreateInfo =
             Foreign.Ptr.Ptr VkImageView

        {-# NOINLINE vkPAttachments #-}
        vkPAttachments x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFramebufferCreateInfo, pAttachments})

        {-# INLINE vkPAttachmentsByteOffset #-}
        vkPAttachmentsByteOffset ~_
          = #{offset VkFramebufferCreateInfo, pAttachments}

        {-# INLINE readVkPAttachments #-}
        readVkPAttachments p
          = peekByteOff p
              #{offset VkFramebufferCreateInfo, pAttachments}

        {-# INLINE writeVkPAttachments #-}
        writeVkPAttachments p
          = pokeByteOff p
              #{offset VkFramebufferCreateInfo, pAttachments}

instance {-# OVERLAPPING #-} HasVkWidth VkFramebufferCreateInfo
         where
        type VkWidthMType VkFramebufferCreateInfo = Data.Word.Word32

        {-# NOINLINE vkWidth #-}
        vkWidth x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFramebufferCreateInfo, width})

        {-# INLINE vkWidthByteOffset #-}
        vkWidthByteOffset ~_
          = #{offset VkFramebufferCreateInfo, width}

        {-# INLINE readVkWidth #-}
        readVkWidth p
          = peekByteOff p #{offset VkFramebufferCreateInfo, width}

        {-# INLINE writeVkWidth #-}
        writeVkWidth p
          = pokeByteOff p #{offset VkFramebufferCreateInfo, width}

instance {-# OVERLAPPING #-} HasVkHeight VkFramebufferCreateInfo
         where
        type VkHeightMType VkFramebufferCreateInfo = Data.Word.Word32

        {-# NOINLINE vkHeight #-}
        vkHeight x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFramebufferCreateInfo, height})

        {-# INLINE vkHeightByteOffset #-}
        vkHeightByteOffset ~_
          = #{offset VkFramebufferCreateInfo, height}

        {-# INLINE readVkHeight #-}
        readVkHeight p
          = peekByteOff p #{offset VkFramebufferCreateInfo, height}

        {-# INLINE writeVkHeight #-}
        writeVkHeight p
          = pokeByteOff p #{offset VkFramebufferCreateInfo, height}

class HasVkLayers a where
        type VkLayersMType a :: *

        vkLayers :: a -> VkLayersMType a

        vkLayersByteOffset :: a -> Int

        readVkLayers :: Ptr a -> IO (VkLayersMType a)

        writeVkLayers :: Ptr a -> VkLayersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'layers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLayers a

instance {-# OVERLAPPING #-} HasVkLayers VkFramebufferCreateInfo
         where
        type VkLayersMType VkFramebufferCreateInfo = Data.Word.Word32

        {-# NOINLINE vkLayers #-}
        vkLayers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkFramebufferCreateInfo, layers})

        {-# INLINE vkLayersByteOffset #-}
        vkLayersByteOffset ~_
          = #{offset VkFramebufferCreateInfo, layers}

        {-# INLINE readVkLayers #-}
        readVkLayers p
          = peekByteOff p #{offset VkFramebufferCreateInfo, layers}

        {-# INLINE writeVkLayers #-}
        writeVkLayers p
          = pokeByteOff p #{offset VkFramebufferCreateInfo, layers}

instance Show VkFramebufferCreateInfo where
        showsPrec d x
          = showString "VkFramebufferCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkRenderPass = " .
                                  showsPrec d (vkRenderPass x) .
                                    showString ", " .
                                      showString "vkAttachmentCount = " .
                                        showsPrec d (vkAttachmentCount x) .
                                          showString ", " .
                                            showString "vkPAttachments = " .
                                              showsPrec d (vkPAttachments x) .
                                                showString ", " .
                                                  showString "vkWidth = " .
                                                    showsPrec d (vkWidth x) .
                                                      showString ", " .
                                                        showString "vkHeight = " .
                                                          showsPrec d (vkHeight x) .
                                                            showString ", " .
                                                              showString "vkLayers = " .
                                                                showsPrec d (vkLayers x) .
                                                                  showChar '}'

data VkSubmitInfo = VkSubmitInfo## ByteArray##

instance Eq VkSubmitInfo where
        (VkSubmitInfo## a) == (VkSubmitInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSubmitInfo where
        (VkSubmitInfo## a) `compare` (VkSubmitInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSubmitInfo where
        sizeOf ~_ = #{size VkSubmitInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSubmitInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSubmitInfo),
            I## a <- alignment (undefined :: VkSubmitInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkSubmitInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSubmitInfo## ba)
          | I## n <- sizeOf (undefined :: VkSubmitInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSubmitInfo where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSubmitInfo),
            I## a <- alignment (undefined :: VkSubmitInfo) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSubmitInfo##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSubmitInfo## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSubmitInfo##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSubmitInfo## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSubmitInfo## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSubmitInfo## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkSubmitInfo where
        type VkSTypeMType VkSubmitInfo = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkSubmitInfo, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_ = #{offset VkSubmitInfo, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkSubmitInfo, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkSubmitInfo, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkSubmitInfo where
        type VkPNextMType VkSubmitInfo = Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x) #{offset VkSubmitInfo, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_ = #{offset VkSubmitInfo, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkSubmitInfo, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkSubmitInfo, pNext}

instance {-# OVERLAPPING #-} HasVkWaitSemaphoreCount VkSubmitInfo
         where
        type VkWaitSemaphoreCountMType VkSubmitInfo = Data.Word.Word32

        {-# NOINLINE vkWaitSemaphoreCount #-}
        vkWaitSemaphoreCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubmitInfo, waitSemaphoreCount})

        {-# INLINE vkWaitSemaphoreCountByteOffset #-}
        vkWaitSemaphoreCountByteOffset ~_
          = #{offset VkSubmitInfo, waitSemaphoreCount}

        {-# INLINE readVkWaitSemaphoreCount #-}
        readVkWaitSemaphoreCount p
          = peekByteOff p #{offset VkSubmitInfo, waitSemaphoreCount}

        {-# INLINE writeVkWaitSemaphoreCount #-}
        writeVkWaitSemaphoreCount p
          = pokeByteOff p #{offset VkSubmitInfo, waitSemaphoreCount}

instance {-# OVERLAPPING #-} HasVkPWaitSemaphores VkSubmitInfo
         where
        type VkPWaitSemaphoresMType VkSubmitInfo =
             Foreign.Ptr.Ptr VkSemaphore

        {-# NOINLINE vkPWaitSemaphores #-}
        vkPWaitSemaphores x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubmitInfo, pWaitSemaphores})

        {-# INLINE vkPWaitSemaphoresByteOffset #-}
        vkPWaitSemaphoresByteOffset ~_
          = #{offset VkSubmitInfo, pWaitSemaphores}

        {-# INLINE readVkPWaitSemaphores #-}
        readVkPWaitSemaphores p
          = peekByteOff p #{offset VkSubmitInfo, pWaitSemaphores}

        {-# INLINE writeVkPWaitSemaphores #-}
        writeVkPWaitSemaphores p
          = pokeByteOff p #{offset VkSubmitInfo, pWaitSemaphores}

class HasVkPWaitDstStageMask a where
        type VkPWaitDstStageMaskMType a :: *

        vkPWaitDstStageMask :: a -> VkPWaitDstStageMaskMType a

        vkPWaitDstStageMaskByteOffset :: a -> Int

        readVkPWaitDstStageMask :: Ptr a -> IO (VkPWaitDstStageMaskMType a)

        writeVkPWaitDstStageMask ::
                                 Ptr a -> VkPWaitDstStageMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pWaitDstStageMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPWaitDstStageMask a

instance {-# OVERLAPPING #-} HasVkPWaitDstStageMask VkSubmitInfo
         where
        type VkPWaitDstStageMaskMType VkSubmitInfo =
             Foreign.Ptr.Ptr VkPipelineStageFlags

        {-# NOINLINE vkPWaitDstStageMask #-}
        vkPWaitDstStageMask x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubmitInfo, pWaitDstStageMask})

        {-# INLINE vkPWaitDstStageMaskByteOffset #-}
        vkPWaitDstStageMaskByteOffset ~_
          = #{offset VkSubmitInfo, pWaitDstStageMask}

        {-# INLINE readVkPWaitDstStageMask #-}
        readVkPWaitDstStageMask p
          = peekByteOff p #{offset VkSubmitInfo, pWaitDstStageMask}

        {-# INLINE writeVkPWaitDstStageMask #-}
        writeVkPWaitDstStageMask p
          = pokeByteOff p #{offset VkSubmitInfo, pWaitDstStageMask}

instance {-# OVERLAPPING #-} HasVkCommandBufferCount VkSubmitInfo
         where
        type VkCommandBufferCountMType VkSubmitInfo = Data.Word.Word32

        {-# NOINLINE vkCommandBufferCount #-}
        vkCommandBufferCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubmitInfo, commandBufferCount})

        {-# INLINE vkCommandBufferCountByteOffset #-}
        vkCommandBufferCountByteOffset ~_
          = #{offset VkSubmitInfo, commandBufferCount}

        {-# INLINE readVkCommandBufferCount #-}
        readVkCommandBufferCount p
          = peekByteOff p #{offset VkSubmitInfo, commandBufferCount}

        {-# INLINE writeVkCommandBufferCount #-}
        writeVkCommandBufferCount p
          = pokeByteOff p #{offset VkSubmitInfo, commandBufferCount}

class HasVkPCommandBuffers a where
        type VkPCommandBuffersMType a :: *

        vkPCommandBuffers :: a -> VkPCommandBuffersMType a

        vkPCommandBuffersByteOffset :: a -> Int

        readVkPCommandBuffers :: Ptr a -> IO (VkPCommandBuffersMType a)

        writeVkPCommandBuffers ::
                               Ptr a -> VkPCommandBuffersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pCommandBuffers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPCommandBuffers a

instance {-# OVERLAPPING #-} HasVkPCommandBuffers VkSubmitInfo
         where
        type VkPCommandBuffersMType VkSubmitInfo =
             Foreign.Ptr.Ptr VkCommandBuffer

        {-# NOINLINE vkPCommandBuffers #-}
        vkPCommandBuffers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubmitInfo, pCommandBuffers})

        {-# INLINE vkPCommandBuffersByteOffset #-}
        vkPCommandBuffersByteOffset ~_
          = #{offset VkSubmitInfo, pCommandBuffers}

        {-# INLINE readVkPCommandBuffers #-}
        readVkPCommandBuffers p
          = peekByteOff p #{offset VkSubmitInfo, pCommandBuffers}

        {-# INLINE writeVkPCommandBuffers #-}
        writeVkPCommandBuffers p
          = pokeByteOff p #{offset VkSubmitInfo, pCommandBuffers}

instance {-# OVERLAPPING #-} HasVkSignalSemaphoreCount VkSubmitInfo
         where
        type VkSignalSemaphoreCountMType VkSubmitInfo = Data.Word.Word32

        {-# NOINLINE vkSignalSemaphoreCount #-}
        vkSignalSemaphoreCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubmitInfo, signalSemaphoreCount})

        {-# INLINE vkSignalSemaphoreCountByteOffset #-}
        vkSignalSemaphoreCountByteOffset ~_
          = #{offset VkSubmitInfo, signalSemaphoreCount}

        {-# INLINE readVkSignalSemaphoreCount #-}
        readVkSignalSemaphoreCount p
          = peekByteOff p
              #{offset VkSubmitInfo, signalSemaphoreCount}

        {-# INLINE writeVkSignalSemaphoreCount #-}
        writeVkSignalSemaphoreCount p
          = pokeByteOff p
              #{offset VkSubmitInfo, signalSemaphoreCount}

instance {-# OVERLAPPING #-} HasVkPSignalSemaphores VkSubmitInfo
         where
        type VkPSignalSemaphoresMType VkSubmitInfo =
             Foreign.Ptr.Ptr VkSemaphore

        {-# NOINLINE vkPSignalSemaphores #-}
        vkPSignalSemaphores x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSubmitInfo, pSignalSemaphores})

        {-# INLINE vkPSignalSemaphoresByteOffset #-}
        vkPSignalSemaphoresByteOffset ~_
          = #{offset VkSubmitInfo, pSignalSemaphores}

        {-# INLINE readVkPSignalSemaphores #-}
        readVkPSignalSemaphores p
          = peekByteOff p #{offset VkSubmitInfo, pSignalSemaphores}

        {-# INLINE writeVkPSignalSemaphores #-}
        writeVkPSignalSemaphores p
          = pokeByteOff p #{offset VkSubmitInfo, pSignalSemaphores}

instance Show VkSubmitInfo where
        showsPrec d x
          = showString "VkSubmitInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkWaitSemaphoreCount = " .
                            showsPrec d (vkWaitSemaphoreCount x) .
                              showString ", " .
                                showString "vkPWaitSemaphores = " .
                                  showsPrec d (vkPWaitSemaphores x) .
                                    showString ", " .
                                      showString "vkPWaitDstStageMask = " .
                                        showsPrec d (vkPWaitDstStageMask x) .
                                          showString ", " .
                                            showString "vkCommandBufferCount = " .
                                              showsPrec d (vkCommandBufferCount x) .
                                                showString ", " .
                                                  showString "vkPCommandBuffers = " .
                                                    showsPrec d (vkPCommandBuffers x) .
                                                      showString ", " .
                                                        showString "vkSignalSemaphoreCount = " .
                                                          showsPrec d (vkSignalSemaphoreCount x) .
                                                            showString ", " .
                                                              showString "vkPSignalSemaphores = " .
                                                                showsPrec d (vkPSignalSemaphores x)
                                                                  . showChar '}'

data VkSurfaceCapabilitiesKHR = VkSurfaceCapabilitiesKHR## ByteArray##

instance Eq VkSurfaceCapabilitiesKHR where
        (VkSurfaceCapabilitiesKHR## a) == (VkSurfaceCapabilitiesKHR## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSurfaceCapabilitiesKHR where
        (VkSurfaceCapabilitiesKHR## a) `compare`
          (VkSurfaceCapabilitiesKHR## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSurfaceCapabilitiesKHR where
        sizeOf ~_ = #{size VkSurfaceCapabilitiesKHR}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSurfaceCapabilitiesKHR}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSurfaceCapabilitiesKHR),
            I## a <- alignment (undefined :: VkSurfaceCapabilitiesKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSurfaceCapabilitiesKHR##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSurfaceCapabilitiesKHR## ba)
          | I## n <- sizeOf (undefined :: VkSurfaceCapabilitiesKHR) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSurfaceCapabilitiesKHR where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSurfaceCapabilitiesKHR),
            I## a <- alignment (undefined :: VkSurfaceCapabilitiesKHR) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSurfaceCapabilitiesKHR##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSurfaceCapabilitiesKHR## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSurfaceCapabilitiesKHR##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSurfaceCapabilitiesKHR## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSurfaceCapabilitiesKHR## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSurfaceCapabilitiesKHR## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

class HasVkMinImageCount a where
        type VkMinImageCountMType a :: *

        vkMinImageCount :: a -> VkMinImageCountMType a

        vkMinImageCountByteOffset :: a -> Int

        readVkMinImageCount :: Ptr a -> IO (VkMinImageCountMType a)

        writeVkMinImageCount :: Ptr a -> VkMinImageCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minImageCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinImageCount a

instance {-# OVERLAPPING #-}
         HasVkMinImageCount VkSurfaceCapabilitiesKHR where
        type VkMinImageCountMType VkSurfaceCapabilitiesKHR =
             Data.Word.Word32

        {-# NOINLINE vkMinImageCount #-}
        vkMinImageCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSurfaceCapabilitiesKHR, minImageCount})

        {-# INLINE vkMinImageCountByteOffset #-}
        vkMinImageCountByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, minImageCount}

        {-# INLINE readVkMinImageCount #-}
        readVkMinImageCount p
          = peekByteOff p
              #{offset VkSurfaceCapabilitiesKHR, minImageCount}

        {-# INLINE writeVkMinImageCount #-}
        writeVkMinImageCount p
          = pokeByteOff p
              #{offset VkSurfaceCapabilitiesKHR, minImageCount}

class HasVkMaxImageCount a where
        type VkMaxImageCountMType a :: *

        vkMaxImageCount :: a -> VkMaxImageCountMType a

        vkMaxImageCountByteOffset :: a -> Int

        readVkMaxImageCount :: Ptr a -> IO (VkMaxImageCountMType a)

        writeVkMaxImageCount :: Ptr a -> VkMaxImageCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxImageCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxImageCount a

instance {-# OVERLAPPING #-}
         HasVkMaxImageCount VkSurfaceCapabilitiesKHR where
        type VkMaxImageCountMType VkSurfaceCapabilitiesKHR =
             Data.Word.Word32

        {-# NOINLINE vkMaxImageCount #-}
        vkMaxImageCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSurfaceCapabilitiesKHR, maxImageCount})

        {-# INLINE vkMaxImageCountByteOffset #-}
        vkMaxImageCountByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, maxImageCount}

        {-# INLINE readVkMaxImageCount #-}
        readVkMaxImageCount p
          = peekByteOff p
              #{offset VkSurfaceCapabilitiesKHR, maxImageCount}

        {-# INLINE writeVkMaxImageCount #-}
        writeVkMaxImageCount p
          = pokeByteOff p
              #{offset VkSurfaceCapabilitiesKHR, maxImageCount}

class HasVkCurrentExtent a where
        type VkCurrentExtentMType a :: *

        vkCurrentExtent :: a -> VkCurrentExtentMType a

        vkCurrentExtentByteOffset :: a -> Int

        readVkCurrentExtent :: Ptr a -> IO (VkCurrentExtentMType a)

        writeVkCurrentExtent :: Ptr a -> VkCurrentExtentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'currentExtent'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCurrentExtent a

instance {-# OVERLAPPING #-}
         HasVkCurrentExtent VkSurfaceCapabilitiesKHR where
        type VkCurrentExtentMType VkSurfaceCapabilitiesKHR = VkExtent2D

        {-# NOINLINE vkCurrentExtent #-}
        vkCurrentExtent x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSurfaceCapabilitiesKHR, currentExtent})

        {-# INLINE vkCurrentExtentByteOffset #-}
        vkCurrentExtentByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, currentExtent}

        {-# INLINE readVkCurrentExtent #-}
        readVkCurrentExtent p
          = peekByteOff p
              #{offset VkSurfaceCapabilitiesKHR, currentExtent}

        {-# INLINE writeVkCurrentExtent #-}
        writeVkCurrentExtent p
          = pokeByteOff p
              #{offset VkSurfaceCapabilitiesKHR, currentExtent}

class HasVkMinImageExtent a where
        type VkMinImageExtentMType a :: *

        vkMinImageExtent :: a -> VkMinImageExtentMType a

        vkMinImageExtentByteOffset :: a -> Int

        readVkMinImageExtent :: Ptr a -> IO (VkMinImageExtentMType a)

        writeVkMinImageExtent :: Ptr a -> VkMinImageExtentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minImageExtent'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinImageExtent a

instance {-# OVERLAPPING #-}
         HasVkMinImageExtent VkSurfaceCapabilitiesKHR where
        type VkMinImageExtentMType VkSurfaceCapabilitiesKHR = VkExtent2D

        {-# NOINLINE vkMinImageExtent #-}
        vkMinImageExtent x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSurfaceCapabilitiesKHR, minImageExtent})

        {-# INLINE vkMinImageExtentByteOffset #-}
        vkMinImageExtentByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, minImageExtent}

        {-# INLINE readVkMinImageExtent #-}
        readVkMinImageExtent p
          = peekByteOff p
              #{offset VkSurfaceCapabilitiesKHR, minImageExtent}

        {-# INLINE writeVkMinImageExtent #-}
        writeVkMinImageExtent p
          = pokeByteOff p
              #{offset VkSurfaceCapabilitiesKHR, minImageExtent}

class HasVkMaxImageExtent a where
        type VkMaxImageExtentMType a :: *

        vkMaxImageExtent :: a -> VkMaxImageExtentMType a

        vkMaxImageExtentByteOffset :: a -> Int

        readVkMaxImageExtent :: Ptr a -> IO (VkMaxImageExtentMType a)

        writeVkMaxImageExtent :: Ptr a -> VkMaxImageExtentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxImageExtent'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxImageExtent a

instance {-# OVERLAPPING #-}
         HasVkMaxImageExtent VkSurfaceCapabilitiesKHR where
        type VkMaxImageExtentMType VkSurfaceCapabilitiesKHR = VkExtent2D

        {-# NOINLINE vkMaxImageExtent #-}
        vkMaxImageExtent x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSurfaceCapabilitiesKHR, maxImageExtent})

        {-# INLINE vkMaxImageExtentByteOffset #-}
        vkMaxImageExtentByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, maxImageExtent}

        {-# INLINE readVkMaxImageExtent #-}
        readVkMaxImageExtent p
          = peekByteOff p
              #{offset VkSurfaceCapabilitiesKHR, maxImageExtent}

        {-# INLINE writeVkMaxImageExtent #-}
        writeVkMaxImageExtent p
          = pokeByteOff p
              #{offset VkSurfaceCapabilitiesKHR, maxImageExtent}

instance {-# OVERLAPPING #-}
         HasVkMaxImageArrayLayers VkSurfaceCapabilitiesKHR where
        type VkMaxImageArrayLayersMType VkSurfaceCapabilitiesKHR =
             Data.Word.Word32

        {-# NOINLINE vkMaxImageArrayLayers #-}
        vkMaxImageArrayLayers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSurfaceCapabilitiesKHR, maxImageArrayLayers})

        {-# INLINE vkMaxImageArrayLayersByteOffset #-}
        vkMaxImageArrayLayersByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, maxImageArrayLayers}

        {-# INLINE readVkMaxImageArrayLayers #-}
        readVkMaxImageArrayLayers p
          = peekByteOff p
              #{offset VkSurfaceCapabilitiesKHR, maxImageArrayLayers}

        {-# INLINE writeVkMaxImageArrayLayers #-}
        writeVkMaxImageArrayLayers p
          = pokeByteOff p
              #{offset VkSurfaceCapabilitiesKHR, maxImageArrayLayers}

class HasVkSupportedTransforms a where
        type VkSupportedTransformsMType a :: *

        vkSupportedTransforms :: a -> VkSupportedTransformsMType a

        vkSupportedTransformsByteOffset :: a -> Int

        readVkSupportedTransforms ::
                                  Ptr a -> IO (VkSupportedTransformsMType a)

        writeVkSupportedTransforms ::
                                   Ptr a -> VkSupportedTransformsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'supportedTransforms'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSupportedTransforms a

instance {-# OVERLAPPING #-}
         HasVkSupportedTransforms VkSurfaceCapabilitiesKHR where
        type VkSupportedTransformsMType VkSurfaceCapabilitiesKHR =
             VkSurfaceTransformFlagsKHR

        {-# NOINLINE vkSupportedTransforms #-}
        vkSupportedTransforms x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSurfaceCapabilitiesKHR, supportedTransforms})

        {-# INLINE vkSupportedTransformsByteOffset #-}
        vkSupportedTransformsByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, supportedTransforms}

        {-# INLINE readVkSupportedTransforms #-}
        readVkSupportedTransforms p
          = peekByteOff p
              #{offset VkSurfaceCapabilitiesKHR, supportedTransforms}

        {-# INLINE writeVkSupportedTransforms #-}
        writeVkSupportedTransforms p
          = pokeByteOff p
              #{offset VkSurfaceCapabilitiesKHR, supportedTransforms}

class HasVkCurrentTransform a where
        type VkCurrentTransformMType a :: *

        vkCurrentTransform :: a -> VkCurrentTransformMType a

        vkCurrentTransformByteOffset :: a -> Int

        readVkCurrentTransform :: Ptr a -> IO (VkCurrentTransformMType a)

        writeVkCurrentTransform ::
                                Ptr a -> VkCurrentTransformMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'currentTransform'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCurrentTransform a

instance {-# OVERLAPPING #-}
         HasVkCurrentTransform VkSurfaceCapabilitiesKHR where
        type VkCurrentTransformMType VkSurfaceCapabilitiesKHR =
             VkSurfaceTransformFlagBitsKHR

        {-# NOINLINE vkCurrentTransform #-}
        vkCurrentTransform x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSurfaceCapabilitiesKHR, currentTransform})

        {-# INLINE vkCurrentTransformByteOffset #-}
        vkCurrentTransformByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, currentTransform}

        {-# INLINE readVkCurrentTransform #-}
        readVkCurrentTransform p
          = peekByteOff p
              #{offset VkSurfaceCapabilitiesKHR, currentTransform}

        {-# INLINE writeVkCurrentTransform #-}
        writeVkCurrentTransform p
          = pokeByteOff p
              #{offset VkSurfaceCapabilitiesKHR, currentTransform}

class HasVkSupportedCompositeAlpha a where
        type VkSupportedCompositeAlphaMType a :: *

        vkSupportedCompositeAlpha :: a -> VkSupportedCompositeAlphaMType a

        vkSupportedCompositeAlphaByteOffset :: a -> Int

        readVkSupportedCompositeAlpha ::
                                      Ptr a -> IO (VkSupportedCompositeAlphaMType a)

        writeVkSupportedCompositeAlpha ::
                                       Ptr a -> VkSupportedCompositeAlphaMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'supportedCompositeAlpha'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSupportedCompositeAlpha a

instance {-# OVERLAPPING #-}
         HasVkSupportedCompositeAlpha VkSurfaceCapabilitiesKHR where
        type VkSupportedCompositeAlphaMType VkSurfaceCapabilitiesKHR =
             VkCompositeAlphaFlagsKHR

        {-# NOINLINE vkSupportedCompositeAlpha #-}
        vkSupportedCompositeAlpha x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSurfaceCapabilitiesKHR, supportedCompositeAlpha})

        {-# INLINE vkSupportedCompositeAlphaByteOffset #-}
        vkSupportedCompositeAlphaByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, supportedCompositeAlpha}

        {-# INLINE readVkSupportedCompositeAlpha #-}
        readVkSupportedCompositeAlpha p
          = peekByteOff p
              #{offset VkSurfaceCapabilitiesKHR, supportedCompositeAlpha}

        {-# INLINE writeVkSupportedCompositeAlpha #-}
        writeVkSupportedCompositeAlpha p
          = pokeByteOff p
              #{offset VkSurfaceCapabilitiesKHR, supportedCompositeAlpha}

class HasVkSupportedUsageFlags a where
        type VkSupportedUsageFlagsMType a :: *

        vkSupportedUsageFlags :: a -> VkSupportedUsageFlagsMType a

        vkSupportedUsageFlagsByteOffset :: a -> Int

        readVkSupportedUsageFlags ::
                                  Ptr a -> IO (VkSupportedUsageFlagsMType a)

        writeVkSupportedUsageFlags ::
                                   Ptr a -> VkSupportedUsageFlagsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'supportedUsageFlags'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSupportedUsageFlags a

instance {-# OVERLAPPING #-}
         HasVkSupportedUsageFlags VkSurfaceCapabilitiesKHR where
        type VkSupportedUsageFlagsMType VkSurfaceCapabilitiesKHR =
             VkImageUsageFlags

        {-# NOINLINE vkSupportedUsageFlags #-}
        vkSupportedUsageFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSurfaceCapabilitiesKHR, supportedUsageFlags})

        {-# INLINE vkSupportedUsageFlagsByteOffset #-}
        vkSupportedUsageFlagsByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, supportedUsageFlags}

        {-# INLINE readVkSupportedUsageFlags #-}
        readVkSupportedUsageFlags p
          = peekByteOff p
              #{offset VkSurfaceCapabilitiesKHR, supportedUsageFlags}

        {-# INLINE writeVkSupportedUsageFlags #-}
        writeVkSupportedUsageFlags p
          = pokeByteOff p
              #{offset VkSurfaceCapabilitiesKHR, supportedUsageFlags}

instance Show VkSurfaceCapabilitiesKHR where
        showsPrec d x
          = showString "VkSurfaceCapabilitiesKHR {" .
              showString "vkMinImageCount = " .
                showsPrec d (vkMinImageCount x) .
                  showString ", " .
                    showString "vkMaxImageCount = " .
                      showsPrec d (vkMaxImageCount x) .
                        showString ", " .
                          showString "vkCurrentExtent = " .
                            showsPrec d (vkCurrentExtent x) .
                              showString ", " .
                                showString "vkMinImageExtent = " .
                                  showsPrec d (vkMinImageExtent x) .
                                    showString ", " .
                                      showString "vkMaxImageExtent = " .
                                        showsPrec d (vkMaxImageExtent x) .
                                          showString ", " .
                                            showString "vkMaxImageArrayLayers = " .
                                              showsPrec d (vkMaxImageArrayLayers x) .
                                                showString ", " .
                                                  showString "vkSupportedTransforms = " .
                                                    showsPrec d (vkSupportedTransforms x) .
                                                      showString ", " .
                                                        showString "vkCurrentTransform = " .
                                                          showsPrec d (vkCurrentTransform x) .
                                                            showString ", " .
                                                              showString
                                                                "vkSupportedCompositeAlpha = "
                                                                .
                                                                showsPrec d
                                                                  (vkSupportedCompositeAlpha x)
                                                                  .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkSupportedUsageFlags = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkSupportedUsageFlags x)
                                                                        . showChar '}'

data VkSurfaceFormatKHR = VkSurfaceFormatKHR## ByteArray##

instance Eq VkSurfaceFormatKHR where
        (VkSurfaceFormatKHR## a) == (VkSurfaceFormatKHR## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSurfaceFormatKHR where
        (VkSurfaceFormatKHR## a) `compare` (VkSurfaceFormatKHR## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSurfaceFormatKHR where
        sizeOf ~_ = #{size VkSurfaceFormatKHR}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSurfaceFormatKHR}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSurfaceFormatKHR),
            I## a <- alignment (undefined :: VkSurfaceFormatKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSurfaceFormatKHR## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSurfaceFormatKHR## ba)
          | I## n <- sizeOf (undefined :: VkSurfaceFormatKHR) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSurfaceFormatKHR where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSurfaceFormatKHR),
            I## a <- alignment (undefined :: VkSurfaceFormatKHR) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSurfaceFormatKHR##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSurfaceFormatKHR## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSurfaceFormatKHR##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSurfaceFormatKHR## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSurfaceFormatKHR## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSurfaceFormatKHR## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkFormat VkSurfaceFormatKHR where
        type VkFormatMType VkSurfaceFormatKHR = VkFormat

        {-# NOINLINE vkFormat #-}
        vkFormat x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSurfaceFormatKHR, format})

        {-# INLINE vkFormatByteOffset #-}
        vkFormatByteOffset ~_
          = #{offset VkSurfaceFormatKHR, format}

        {-# INLINE readVkFormat #-}
        readVkFormat p
          = peekByteOff p #{offset VkSurfaceFormatKHR, format}

        {-# INLINE writeVkFormat #-}
        writeVkFormat p
          = pokeByteOff p #{offset VkSurfaceFormatKHR, format}

class HasVkColorSpace a where
        type VkColorSpaceMType a :: *

        vkColorSpace :: a -> VkColorSpaceMType a

        vkColorSpaceByteOffset :: a -> Int

        readVkColorSpace :: Ptr a -> IO (VkColorSpaceMType a)

        writeVkColorSpace :: Ptr a -> VkColorSpaceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'colorSpace'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkColorSpace a

instance {-# OVERLAPPING #-} HasVkColorSpace VkSurfaceFormatKHR
         where
        type VkColorSpaceMType VkSurfaceFormatKHR = VkColorSpaceKHR

        {-# NOINLINE vkColorSpace #-}
        vkColorSpace x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSurfaceFormatKHR, colorSpace})

        {-# INLINE vkColorSpaceByteOffset #-}
        vkColorSpaceByteOffset ~_
          = #{offset VkSurfaceFormatKHR, colorSpace}

        {-# INLINE readVkColorSpace #-}
        readVkColorSpace p
          = peekByteOff p #{offset VkSurfaceFormatKHR, colorSpace}

        {-# INLINE writeVkColorSpace #-}
        writeVkColorSpace p
          = pokeByteOff p #{offset VkSurfaceFormatKHR, colorSpace}

instance Show VkSurfaceFormatKHR where
        showsPrec d x
          = showString "VkSurfaceFormatKHR {" .
              showString "vkFormat = " .
                showsPrec d (vkFormat x) .
                  showString ", " .
                    showString "vkColorSpace = " .
                      showsPrec d (vkColorSpace x) . showChar '}'

data VkSwapchainCreateInfoKHR = VkSwapchainCreateInfoKHR## ByteArray##

instance Eq VkSwapchainCreateInfoKHR where
        (VkSwapchainCreateInfoKHR## a) == (VkSwapchainCreateInfoKHR## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSwapchainCreateInfoKHR where
        (VkSwapchainCreateInfoKHR## a) `compare`
          (VkSwapchainCreateInfoKHR## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSwapchainCreateInfoKHR where
        sizeOf ~_ = #{size VkSwapchainCreateInfoKHR}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSwapchainCreateInfoKHR}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSwapchainCreateInfoKHR),
            I## a <- alignment (undefined :: VkSwapchainCreateInfoKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSwapchainCreateInfoKHR##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSwapchainCreateInfoKHR## ba)
          | I## n <- sizeOf (undefined :: VkSwapchainCreateInfoKHR) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSwapchainCreateInfoKHR where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkSwapchainCreateInfoKHR),
            I## a <- alignment (undefined :: VkSwapchainCreateInfoKHR) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkSwapchainCreateInfoKHR##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkSwapchainCreateInfoKHR## ba)
          = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkSwapchainCreateInfoKHR##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkSwapchainCreateInfoKHR## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkSwapchainCreateInfoKHR## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkSwapchainCreateInfoKHR## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkSwapchainCreateInfoKHR
         where
        type VkSTypeMType VkSwapchainCreateInfoKHR = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkSwapchainCreateInfoKHR, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkSwapchainCreateInfoKHR, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkSwapchainCreateInfoKHR
         where
        type VkPNextMType VkSwapchainCreateInfoKHR =
             Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkSwapchainCreateInfoKHR, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkSwapchainCreateInfoKHR, pNext}

instance {-# OVERLAPPING #-} HasVkFlags VkSwapchainCreateInfoKHR
         where
        type VkFlagsMType VkSwapchainCreateInfoKHR =
             VkSwapchainCreateFlagsKHR

        {-# NOINLINE vkFlags #-}
        vkFlags x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, flags})

        {-# INLINE vkFlagsByteOffset #-}
        vkFlagsByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, flags}

        {-# INLINE readVkFlags #-}
        readVkFlags p
          = peekByteOff p #{offset VkSwapchainCreateInfoKHR, flags}

        {-# INLINE writeVkFlags #-}
        writeVkFlags p
          = pokeByteOff p #{offset VkSwapchainCreateInfoKHR, flags}

class HasVkSurface a where
        type VkSurfaceMType a :: *

        vkSurface :: a -> VkSurfaceMType a

        vkSurfaceByteOffset :: a -> Int

        readVkSurface :: Ptr a -> IO (VkSurfaceMType a)

        writeVkSurface :: Ptr a -> VkSurfaceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'surface'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSurface a

instance {-# OVERLAPPING #-} HasVkSurface VkSwapchainCreateInfoKHR
         where
        type VkSurfaceMType VkSwapchainCreateInfoKHR = VkSurfaceKHR

        {-# NOINLINE vkSurface #-}
        vkSurface x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, surface})

        {-# INLINE vkSurfaceByteOffset #-}
        vkSurfaceByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, surface}

        {-# INLINE readVkSurface #-}
        readVkSurface p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, surface}

        {-# INLINE writeVkSurface #-}
        writeVkSurface p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, surface}

instance {-# OVERLAPPING #-}
         HasVkMinImageCount VkSwapchainCreateInfoKHR where
        type VkMinImageCountMType VkSwapchainCreateInfoKHR =
             Data.Word.Word32

        {-# NOINLINE vkMinImageCount #-}
        vkMinImageCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, minImageCount})

        {-# INLINE vkMinImageCountByteOffset #-}
        vkMinImageCountByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, minImageCount}

        {-# INLINE readVkMinImageCount #-}
        readVkMinImageCount p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, minImageCount}

        {-# INLINE writeVkMinImageCount #-}
        writeVkMinImageCount p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, minImageCount}

class HasVkImageFormat a where
        type VkImageFormatMType a :: *

        vkImageFormat :: a -> VkImageFormatMType a

        vkImageFormatByteOffset :: a -> Int

        readVkImageFormat :: Ptr a -> IO (VkImageFormatMType a)

        writeVkImageFormat :: Ptr a -> VkImageFormatMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageFormat'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageFormat a

instance {-# OVERLAPPING #-}
         HasVkImageFormat VkSwapchainCreateInfoKHR where
        type VkImageFormatMType VkSwapchainCreateInfoKHR = VkFormat

        {-# NOINLINE vkImageFormat #-}
        vkImageFormat x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, imageFormat})

        {-# INLINE vkImageFormatByteOffset #-}
        vkImageFormatByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, imageFormat}

        {-# INLINE readVkImageFormat #-}
        readVkImageFormat p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, imageFormat}

        {-# INLINE writeVkImageFormat #-}
        writeVkImageFormat p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, imageFormat}

class HasVkImageColorSpace a where
        type VkImageColorSpaceMType a :: *

        vkImageColorSpace :: a -> VkImageColorSpaceMType a

        vkImageColorSpaceByteOffset :: a -> Int

        readVkImageColorSpace :: Ptr a -> IO (VkImageColorSpaceMType a)

        writeVkImageColorSpace ::
                               Ptr a -> VkImageColorSpaceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageColorSpace'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageColorSpace a

instance {-# OVERLAPPING #-}
         HasVkImageColorSpace VkSwapchainCreateInfoKHR where
        type VkImageColorSpaceMType VkSwapchainCreateInfoKHR =
             VkColorSpaceKHR

        {-# NOINLINE vkImageColorSpace #-}
        vkImageColorSpace x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, imageColorSpace})

        {-# INLINE vkImageColorSpaceByteOffset #-}
        vkImageColorSpaceByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, imageColorSpace}

        {-# INLINE readVkImageColorSpace #-}
        readVkImageColorSpace p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, imageColorSpace}

        {-# INLINE writeVkImageColorSpace #-}
        writeVkImageColorSpace p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, imageColorSpace}

instance {-# OVERLAPPING #-}
         HasVkImageExtent VkSwapchainCreateInfoKHR where
        type VkImageExtentMType VkSwapchainCreateInfoKHR = VkExtent2D

        {-# NOINLINE vkImageExtent #-}
        vkImageExtent x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, imageExtent})

        {-# INLINE vkImageExtentByteOffset #-}
        vkImageExtentByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, imageExtent}

        {-# INLINE readVkImageExtent #-}
        readVkImageExtent p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, imageExtent}

        {-# INLINE writeVkImageExtent #-}
        writeVkImageExtent p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, imageExtent}

class HasVkImageArrayLayers a where
        type VkImageArrayLayersMType a :: *

        vkImageArrayLayers :: a -> VkImageArrayLayersMType a

        vkImageArrayLayersByteOffset :: a -> Int

        readVkImageArrayLayers :: Ptr a -> IO (VkImageArrayLayersMType a)

        writeVkImageArrayLayers ::
                                Ptr a -> VkImageArrayLayersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageArrayLayers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageArrayLayers a

instance {-# OVERLAPPING #-}
         HasVkImageArrayLayers VkSwapchainCreateInfoKHR where
        type VkImageArrayLayersMType VkSwapchainCreateInfoKHR =
             Data.Word.Word32

        {-# NOINLINE vkImageArrayLayers #-}
        vkImageArrayLayers x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, imageArrayLayers})

        {-# INLINE vkImageArrayLayersByteOffset #-}
        vkImageArrayLayersByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, imageArrayLayers}

        {-# INLINE readVkImageArrayLayers #-}
        readVkImageArrayLayers p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, imageArrayLayers}

        {-# INLINE writeVkImageArrayLayers #-}
        writeVkImageArrayLayers p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, imageArrayLayers}

class HasVkImageUsage a where
        type VkImageUsageMType a :: *

        vkImageUsage :: a -> VkImageUsageMType a

        vkImageUsageByteOffset :: a -> Int

        readVkImageUsage :: Ptr a -> IO (VkImageUsageMType a)

        writeVkImageUsage :: Ptr a -> VkImageUsageMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageUsage'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageUsage a

instance {-# OVERLAPPING #-}
         HasVkImageUsage VkSwapchainCreateInfoKHR where
        type VkImageUsageMType VkSwapchainCreateInfoKHR = VkImageUsageFlags

        {-# NOINLINE vkImageUsage #-}
        vkImageUsage x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, imageUsage})

        {-# INLINE vkImageUsageByteOffset #-}
        vkImageUsageByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, imageUsage}

        {-# INLINE readVkImageUsage #-}
        readVkImageUsage p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, imageUsage}

        {-# INLINE writeVkImageUsage #-}
        writeVkImageUsage p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, imageUsage}

class HasVkImageSharingMode a where
        type VkImageSharingModeMType a :: *

        vkImageSharingMode :: a -> VkImageSharingModeMType a

        vkImageSharingModeByteOffset :: a -> Int

        readVkImageSharingMode :: Ptr a -> IO (VkImageSharingModeMType a)

        writeVkImageSharingMode ::
                                Ptr a -> VkImageSharingModeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageSharingMode'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageSharingMode a

instance {-# OVERLAPPING #-}
         HasVkImageSharingMode VkSwapchainCreateInfoKHR where
        type VkImageSharingModeMType VkSwapchainCreateInfoKHR =
             VkSharingMode

        {-# NOINLINE vkImageSharingMode #-}
        vkImageSharingMode x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, imageSharingMode})

        {-# INLINE vkImageSharingModeByteOffset #-}
        vkImageSharingModeByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, imageSharingMode}

        {-# INLINE readVkImageSharingMode #-}
        readVkImageSharingMode p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, imageSharingMode}

        {-# INLINE writeVkImageSharingMode #-}
        writeVkImageSharingMode p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, imageSharingMode}

instance {-# OVERLAPPING #-}
         HasVkQueueFamilyIndexCount VkSwapchainCreateInfoKHR where
        type VkQueueFamilyIndexCountMType VkSwapchainCreateInfoKHR =
             Data.Word.Word32

        {-# NOINLINE vkQueueFamilyIndexCount #-}
        vkQueueFamilyIndexCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, queueFamilyIndexCount})

        {-# INLINE vkQueueFamilyIndexCountByteOffset #-}
        vkQueueFamilyIndexCountByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, queueFamilyIndexCount}

        {-# INLINE readVkQueueFamilyIndexCount #-}
        readVkQueueFamilyIndexCount p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, queueFamilyIndexCount}

        {-# INLINE writeVkQueueFamilyIndexCount #-}
        writeVkQueueFamilyIndexCount p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, queueFamilyIndexCount}

instance {-# OVERLAPPING #-}
         HasVkPQueueFamilyIndices VkSwapchainCreateInfoKHR where
        type VkPQueueFamilyIndicesMType VkSwapchainCreateInfoKHR =
             Foreign.Ptr.Ptr Data.Word.Word32

        {-# NOINLINE vkPQueueFamilyIndices #-}
        vkPQueueFamilyIndices x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, pQueueFamilyIndices})

        {-# INLINE vkPQueueFamilyIndicesByteOffset #-}
        vkPQueueFamilyIndicesByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, pQueueFamilyIndices}

        {-# INLINE readVkPQueueFamilyIndices #-}
        readVkPQueueFamilyIndices p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, pQueueFamilyIndices}

        {-# INLINE writeVkPQueueFamilyIndices #-}
        writeVkPQueueFamilyIndices p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, pQueueFamilyIndices}

class HasVkPreTransform a where
        type VkPreTransformMType a :: *

        vkPreTransform :: a -> VkPreTransformMType a

        vkPreTransformByteOffset :: a -> Int

        readVkPreTransform :: Ptr a -> IO (VkPreTransformMType a)

        writeVkPreTransform :: Ptr a -> VkPreTransformMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'preTransform'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPreTransform a

instance {-# OVERLAPPING #-}
         HasVkPreTransform VkSwapchainCreateInfoKHR where
        type VkPreTransformMType VkSwapchainCreateInfoKHR =
             VkSurfaceTransformFlagBitsKHR

        {-# NOINLINE vkPreTransform #-}
        vkPreTransform x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, preTransform})

        {-# INLINE vkPreTransformByteOffset #-}
        vkPreTransformByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, preTransform}

        {-# INLINE readVkPreTransform #-}
        readVkPreTransform p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, preTransform}

        {-# INLINE writeVkPreTransform #-}
        writeVkPreTransform p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, preTransform}

class HasVkCompositeAlpha a where
        type VkCompositeAlphaMType a :: *

        vkCompositeAlpha :: a -> VkCompositeAlphaMType a

        vkCompositeAlphaByteOffset :: a -> Int

        readVkCompositeAlpha :: Ptr a -> IO (VkCompositeAlphaMType a)

        writeVkCompositeAlpha :: Ptr a -> VkCompositeAlphaMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'compositeAlpha'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCompositeAlpha a

instance {-# OVERLAPPING #-}
         HasVkCompositeAlpha VkSwapchainCreateInfoKHR where
        type VkCompositeAlphaMType VkSwapchainCreateInfoKHR =
             VkCompositeAlphaFlagBitsKHR

        {-# NOINLINE vkCompositeAlpha #-}
        vkCompositeAlpha x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, compositeAlpha})

        {-# INLINE vkCompositeAlphaByteOffset #-}
        vkCompositeAlphaByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, compositeAlpha}

        {-# INLINE readVkCompositeAlpha #-}
        readVkCompositeAlpha p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, compositeAlpha}

        {-# INLINE writeVkCompositeAlpha #-}
        writeVkCompositeAlpha p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, compositeAlpha}

class HasVkPresentMode a where
        type VkPresentModeMType a :: *

        vkPresentMode :: a -> VkPresentModeMType a

        vkPresentModeByteOffset :: a -> Int

        readVkPresentMode :: Ptr a -> IO (VkPresentModeMType a)

        writeVkPresentMode :: Ptr a -> VkPresentModeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'presentMode'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPresentMode a

instance {-# OVERLAPPING #-}
         HasVkPresentMode VkSwapchainCreateInfoKHR where
        type VkPresentModeMType VkSwapchainCreateInfoKHR = VkPresentModeKHR

        {-# NOINLINE vkPresentMode #-}
        vkPresentMode x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, presentMode})

        {-# INLINE vkPresentModeByteOffset #-}
        vkPresentModeByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, presentMode}

        {-# INLINE readVkPresentMode #-}
        readVkPresentMode p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, presentMode}

        {-# INLINE writeVkPresentMode #-}
        writeVkPresentMode p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, presentMode}

class HasVkClipped a where
        type VkClippedMType a :: *

        vkClipped :: a -> VkClippedMType a

        vkClippedByteOffset :: a -> Int

        readVkClipped :: Ptr a -> IO (VkClippedMType a)

        writeVkClipped :: Ptr a -> VkClippedMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'clipped'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkClipped a

instance {-# OVERLAPPING #-} HasVkClipped VkSwapchainCreateInfoKHR
         where
        type VkClippedMType VkSwapchainCreateInfoKHR = VkBool32

        {-# NOINLINE vkClipped #-}
        vkClipped x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, clipped})

        {-# INLINE vkClippedByteOffset #-}
        vkClippedByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, clipped}

        {-# INLINE readVkClipped #-}
        readVkClipped p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, clipped}

        {-# INLINE writeVkClipped #-}
        writeVkClipped p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, clipped}

class HasVkOldSwapchain a where
        type VkOldSwapchainMType a :: *

        vkOldSwapchain :: a -> VkOldSwapchainMType a

        vkOldSwapchainByteOffset :: a -> Int

        readVkOldSwapchain :: Ptr a -> IO (VkOldSwapchainMType a)

        writeVkOldSwapchain :: Ptr a -> VkOldSwapchainMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'oldSwapchain'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkOldSwapchain a

instance {-# OVERLAPPING #-}
         HasVkOldSwapchain VkSwapchainCreateInfoKHR where
        type VkOldSwapchainMType VkSwapchainCreateInfoKHR = VkSwapchainKHR

        {-# NOINLINE vkOldSwapchain #-}
        vkOldSwapchain x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkSwapchainCreateInfoKHR, oldSwapchain})

        {-# INLINE vkOldSwapchainByteOffset #-}
        vkOldSwapchainByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, oldSwapchain}

        {-# INLINE readVkOldSwapchain #-}
        readVkOldSwapchain p
          = peekByteOff p
              #{offset VkSwapchainCreateInfoKHR, oldSwapchain}

        {-# INLINE writeVkOldSwapchain #-}
        writeVkOldSwapchain p
          = pokeByteOff p
              #{offset VkSwapchainCreateInfoKHR, oldSwapchain}

instance Show VkSwapchainCreateInfoKHR where
        showsPrec d x
          = showString "VkSwapchainCreateInfoKHR {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkSurface = " .
                                  showsPrec d (vkSurface x) .
                                    showString ", " .
                                      showString "vkMinImageCount = " .
                                        showsPrec d (vkMinImageCount x) .
                                          showString ", " .
                                            showString "vkImageFormat = " .
                                              showsPrec d (vkImageFormat x) .
                                                showString ", " .
                                                  showString "vkImageColorSpace = " .
                                                    showsPrec d (vkImageColorSpace x) .
                                                      showString ", " .
                                                        showString "vkImageExtent = " .
                                                          showsPrec d (vkImageExtent x) .
                                                            showString ", " .
                                                              showString "vkImageArrayLayers = " .
                                                                showsPrec d (vkImageArrayLayers x) .
                                                                  showString ", " .
                                                                    showString "vkImageUsage = " .
                                                                      showsPrec d (vkImageUsage x) .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkImageSharingMode = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkImageSharingMode x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkQueueFamilyIndexCount = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkQueueFamilyIndexCount
                                                                                       x)
                                                                                    .
                                                                                    showString ", "
                                                                                      .
                                                                                      showString
                                                                                        "vkPQueueFamilyIndices = "
                                                                                        .
                                                                                        showsPrec d
                                                                                          (vkPQueueFamilyIndices
                                                                                             x)
                                                                                          .
                                                                                          showString
                                                                                            ", "
                                                                                            .
                                                                                            showString
                                                                                              "vkPreTransform = "
                                                                                              .
                                                                                              showsPrec
                                                                                                d
                                                                                                (vkPreTransform
                                                                                                   x)
                                                                                                .
                                                                                                showString
                                                                                                  ", "
                                                                                                  .
                                                                                                  showString
                                                                                                    "vkCompositeAlpha = "
                                                                                                    .
                                                                                                    showsPrec
                                                                                                      d
                                                                                                      (vkCompositeAlpha
                                                                                                         x)
                                                                                                      .
                                                                                                      showString
                                                                                                        ", "
                                                                                                        .
                                                                                                        showString
                                                                                                          "vkPresentMode = "
                                                                                                          .
                                                                                                          showsPrec
                                                                                                            d
                                                                                                            (vkPresentMode
                                                                                                               x)
                                                                                                            .
                                                                                                            showString
                                                                                                              ", "
                                                                                                              .
                                                                                                              showString
                                                                                                                "vkClipped = "
                                                                                                                .
                                                                                                                showsPrec
                                                                                                                  d
                                                                                                                  (vkClipped
                                                                                                                     x)
                                                                                                                  .
                                                                                                                  showString
                                                                                                                    ", "
                                                                                                                    .
                                                                                                                    showString
                                                                                                                      "vkOldSwapchain = "
                                                                                                                      .
                                                                                                                      showsPrec
                                                                                                                        d
                                                                                                                        (vkOldSwapchain
                                                                                                                           x)
                                                                                                                        .
                                                                                                                        showChar
                                                                                                                          '}'

data VkPresentInfoKHR = VkPresentInfoKHR## ByteArray##

instance Eq VkPresentInfoKHR where
        (VkPresentInfoKHR## a) == (VkPresentInfoKHR## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPresentInfoKHR where
        (VkPresentInfoKHR## a) `compare` (VkPresentInfoKHR## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPresentInfoKHR where
        sizeOf ~_ = #{size VkPresentInfoKHR}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPresentInfoKHR}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPresentInfoKHR),
            I## a <- alignment (undefined :: VkPresentInfoKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkPresentInfoKHR## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPresentInfoKHR## ba)
          | I## n <- sizeOf (undefined :: VkPresentInfoKHR) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPresentInfoKHR where
        {-# INLINE newVkData #-}
        newVkData f
          | I## n <- sizeOf (undefined :: VkPresentInfoKHR),
            I## a <- alignment (undefined :: VkPresentInfoKHR) =
            IO
              (\ s0 ->
                 case newAlignedPinnedByteArray## n a s0 of
                     (## s1, mba ##) -> case unsafeFreezeByteArray## mba s1 of
                                          (## s2, ba ##) -> case f (Ptr (byteArrayContents## ba)) of
                                                              IO k -> case k s2 of
                                                                          (## s3, () ##) -> (## s3,
                                                                                             VkPresentInfoKHR##
                                                                                               ba ##))

        {-# INLINE unsafePtr #-}
        unsafePtr (VkPresentInfoKHR## ba) = Ptr (byteArrayContents## ba)

        {-# INLINE fromForeignPtr #-}
        fromForeignPtr = fromForeignPtr## VkPresentInfoKHR##

        {-# INLINE toForeignPtr #-}
        toForeignPtr (VkPresentInfoKHR## ba)
          = do ForeignPtr addr (PlainForeignPtr r) <- newForeignPtr_
                                                        (Ptr (byteArrayContents## ba))
               IO
                 (\ s -> (## s, ForeignPtr addr (MallocPtr (unsafeCoerce## ba) r) ##))

        {-# INLINE toPlainForeignPtr #-}
        toPlainForeignPtr (VkPresentInfoKHR## ba)
          = IO
              (\ s ->
                 (## s,
                    ForeignPtr (byteArrayContents## ba)
                      (PlainPtr (unsafeCoerce## ba)) ##))

        {-# INLINE touchVkData #-}
        touchVkData x@(VkPresentInfoKHR## ba)
          = IO (\ s -> (## touch## x (touch## ba s), () ##))

instance {-# OVERLAPPING #-} HasVkSType VkPresentInfoKHR where
        type VkSTypeMType VkPresentInfoKHR = VkStructureType

        {-# NOINLINE vkSType #-}
        vkSType x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPresentInfoKHR, sType})

        {-# INLINE vkSTypeByteOffset #-}
        vkSTypeByteOffset ~_ = #{offset VkPresentInfoKHR, sType}

        {-# INLINE readVkSType #-}
        readVkSType p
          = peekByteOff p #{offset VkPresentInfoKHR, sType}

        {-# INLINE writeVkSType #-}
        writeVkSType p
          = pokeByteOff p #{offset VkPresentInfoKHR, sType}

instance {-# OVERLAPPING #-} HasVkPNext VkPresentInfoKHR where
        type VkPNextMType VkPresentInfoKHR = Foreign.Ptr.Ptr Data.Void.Void

        {-# NOINLINE vkPNext #-}
        vkPNext x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPresentInfoKHR, pNext})

        {-# INLINE vkPNextByteOffset #-}
        vkPNextByteOffset ~_ = #{offset VkPresentInfoKHR, pNext}

        {-# INLINE readVkPNext #-}
        readVkPNext p
          = peekByteOff p #{offset VkPresentInfoKHR, pNext}

        {-# INLINE writeVkPNext #-}
        writeVkPNext p
          = pokeByteOff p #{offset VkPresentInfoKHR, pNext}

instance {-# OVERLAPPING #-}
         HasVkWaitSemaphoreCount VkPresentInfoKHR where
        type VkWaitSemaphoreCountMType VkPresentInfoKHR = Data.Word.Word32

        {-# NOINLINE vkWaitSemaphoreCount #-}
        vkWaitSemaphoreCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPresentInfoKHR, waitSemaphoreCount})

        {-# INLINE vkWaitSemaphoreCountByteOffset #-}
        vkWaitSemaphoreCountByteOffset ~_
          = #{offset VkPresentInfoKHR, waitSemaphoreCount}

        {-# INLINE readVkWaitSemaphoreCount #-}
        readVkWaitSemaphoreCount p
          = peekByteOff p
              #{offset VkPresentInfoKHR, waitSemaphoreCount}

        {-# INLINE writeVkWaitSemaphoreCount #-}
        writeVkWaitSemaphoreCount p
          = pokeByteOff p
              #{offset VkPresentInfoKHR, waitSemaphoreCount}

instance {-# OVERLAPPING #-} HasVkPWaitSemaphores VkPresentInfoKHR
         where
        type VkPWaitSemaphoresMType VkPresentInfoKHR =
             Foreign.Ptr.Ptr VkSemaphore

        {-# NOINLINE vkPWaitSemaphores #-}
        vkPWaitSemaphores x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPresentInfoKHR, pWaitSemaphores})

        {-# INLINE vkPWaitSemaphoresByteOffset #-}
        vkPWaitSemaphoresByteOffset ~_
          = #{offset VkPresentInfoKHR, pWaitSemaphores}

        {-# INLINE readVkPWaitSemaphores #-}
        readVkPWaitSemaphores p
          = peekByteOff p
              #{offset VkPresentInfoKHR, pWaitSemaphores}

        {-# INLINE writeVkPWaitSemaphores #-}
        writeVkPWaitSemaphores p
          = pokeByteOff p
              #{offset VkPresentInfoKHR, pWaitSemaphores}

class HasVkSwapchainCount a where
        type VkSwapchainCountMType a :: *

        vkSwapchainCount :: a -> VkSwapchainCountMType a

        vkSwapchainCountByteOffset :: a -> Int

        readVkSwapchainCount :: Ptr a -> IO (VkSwapchainCountMType a)

        writeVkSwapchainCount :: Ptr a -> VkSwapchainCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'swapchainCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSwapchainCount a

instance {-# OVERLAPPING #-} HasVkSwapchainCount VkPresentInfoKHR
         where
        type VkSwapchainCountMType VkPresentInfoKHR = Data.Word.Word32

        {-# NOINLINE vkSwapchainCount #-}
        vkSwapchainCount x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPresentInfoKHR, swapchainCount})

        {-# INLINE vkSwapchainCountByteOffset #-}
        vkSwapchainCountByteOffset ~_
          = #{offset VkPresentInfoKHR, swapchainCount}

        {-# INLINE readVkSwapchainCount #-}
        readVkSwapchainCount p
          = peekByteOff p #{offset VkPresentInfoKHR, swapchainCount}

        {-# INLINE writeVkSwapchainCount #-}
        writeVkSwapchainCount p
          = pokeByteOff p #{offset VkPresentInfoKHR, swapchainCount}

class HasVkPSwapchains a where
        type VkPSwapchainsMType a :: *

        vkPSwapchains :: a -> VkPSwapchainsMType a

        vkPSwapchainsByteOffset :: a -> Int

        readVkPSwapchains :: Ptr a -> IO (VkPSwapchainsMType a)

        writeVkPSwapchains :: Ptr a -> VkPSwapchainsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pSwapchains'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPSwapchains a

instance {-# OVERLAPPING #-} HasVkPSwapchains VkPresentInfoKHR
         where
        type VkPSwapchainsMType VkPresentInfoKHR =
             Foreign.Ptr.Ptr VkSwapchainKHR

        {-# NOINLINE vkPSwapchains #-}
        vkPSwapchains x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPresentInfoKHR, pSwapchains})

        {-# INLINE vkPSwapchainsByteOffset #-}
        vkPSwapchainsByteOffset ~_
          = #{offset VkPresentInfoKHR, pSwapchains}

        {-# INLINE readVkPSwapchains #-}
        readVkPSwapchains p
          = peekByteOff p #{offset VkPresentInfoKHR, pSwapchains}

        {-# INLINE writeVkPSwapchains #-}
        writeVkPSwapchains p
          = pokeByteOff p #{offset VkPresentInfoKHR, pSwapchains}

class HasVkPImageIndices a where
        type VkPImageIndicesMType a :: *

        vkPImageIndices :: a -> VkPImageIndicesMType a

        vkPImageIndicesByteOffset :: a -> Int

        readVkPImageIndices :: Ptr a -> IO (VkPImageIndicesMType a)

        writeVkPImageIndices :: Ptr a -> VkPImageIndicesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pImageIndices'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPImageIndices a

instance {-# OVERLAPPING #-} HasVkPImageIndices VkPresentInfoKHR
         where
        type VkPImageIndicesMType VkPresentInfoKHR =
             Foreign.Ptr.Ptr Data.Word.Word32

        {-# NOINLINE vkPImageIndices #-}
        vkPImageIndices x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPresentInfoKHR, pImageIndices})

        {-# INLINE vkPImageIndicesByteOffset #-}
        vkPImageIndicesByteOffset ~_
          = #{offset VkPresentInfoKHR, pImageIndices}

        {-# INLINE readVkPImageIndices #-}
        readVkPImageIndices p
          = peekByteOff p #{offset VkPresentInfoKHR, pImageIndices}

        {-# INLINE writeVkPImageIndices #-}
        writeVkPImageIndices p
          = pokeByteOff p #{offset VkPresentInfoKHR, pImageIndices}

class HasVkPResults a where
        type VkPResultsMType a :: *

        vkPResults :: a -> VkPResultsMType a

        vkPResultsByteOffset :: a -> Int

        readVkPResults :: Ptr a -> IO (VkPResultsMType a)

        writeVkPResults :: Ptr a -> VkPResultsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pResults'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPResults a

instance {-# OVERLAPPING #-} HasVkPResults VkPresentInfoKHR where
        type VkPResultsMType VkPresentInfoKHR = Foreign.Ptr.Ptr VkResult

        {-# NOINLINE vkPResults #-}
        vkPResults x
          = unsafeDupablePerformIO
              (peekByteOff (unsafePtr x)
                 #{offset VkPresentInfoKHR, pResults})

        {-# INLINE vkPResultsByteOffset #-}
        vkPResultsByteOffset ~_
          = #{offset VkPresentInfoKHR, pResults}

        {-# INLINE readVkPResults #-}
        readVkPResults p
          = peekByteOff p #{offset VkPresentInfoKHR, pResults}

        {-# INLINE writeVkPResults #-}
        writeVkPResults p
          = pokeByteOff p #{offset VkPresentInfoKHR, pResults}

instance Show VkPresentInfoKHR where
        showsPrec d x
          = showString "VkPresentInfoKHR {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkWaitSemaphoreCount = " .
                            showsPrec d (vkWaitSemaphoreCount x) .
                              showString ", " .
                                showString "vkPWaitSemaphores = " .
                                  showsPrec d (vkPWaitSemaphores x) .
                                    showString ", " .
                                      showString "vkSwapchainCount = " .
                                        showsPrec d (vkSwapchainCount x) .
                                          showString ", " .
                                            showString "vkPSwapchains = " .
                                              showsPrec d (vkPSwapchains x) .
                                                showString ", " .
                                                  showString "vkPImageIndices = " .
                                                    showsPrec d (vkPImageIndices x) .
                                                      showString ", " .
                                                        showString "vkPResults = " .
                                                          showsPrec d (vkPResults x) . showChar '}'
