#include "vulkan/vulkan.h"
{-# OPTIONS_GHC -fno-warn-missing-methods#-}
{-# OPTIONS_GHC -fno-warn-unticked-promoted-constructors#-}
{-# LANGUAGE DataKinds            #-}
{-# LANGUAGE FlexibleContexts     #-}
{-# LANGUAGE FlexibleInstances    #-}
{-# LANGUAGE MagicHash            #-}
{-# LANGUAGE Strict               #-}
{-# LANGUAGE TypeFamilies         #-}
{-# LANGUAGE TypeOperators        #-}
{-# LANGUAGE UnboxedTuples        #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE UnliftedFFITypes     #-}
module Graphics.Vulkan.Base
       (-- > ##include "vulkan.h"
        --
        -- > ##include <X11/Xlib.h>
        --
        -- > ##include <X11/extensions/Xrandr.h>
        --
        -- > ##include <android/native_window.h>
        --
        -- > ##include <mir_toolkit/client_types.h>
        --
        -- > ##include <wayland-client.h>
        --
        -- > ##include <windows.h>
        --
        -- > ##include <xcb/xcb.h>
        HasVkX(..), HasVkY(..), VkOffset2D(..), HasVkZ(..),
        VkOffset3D(..), HasVkWidth(..), HasVkHeight(..), VkExtent2D(..),
        HasVkDepth(..), VkExtent3D(..), HasVkMinDepth(..),
        HasVkMaxDepth(..), VkViewport(..), HasVkOffset(..),
        HasVkExtent(..), VkRect2D(..), HasVkRect(..),
        HasVkBaseArrayLayer(..), HasVkLayerCount(..), VkClearRect(..),
        HasVkR(..), HasVkG(..), HasVkB(..), HasVkA(..),
        VkComponentMapping(..), HasVkApiVersion(..),
        HasVkDriverVersion(..), HasVkVendorID(..), HasVkDeviceID(..),
        HasVkDeviceType(..), HasVkDeviceNameArray(..),
        HasVkPipelineCacheUUIDArray(..), HasVkLimits(..),
        HasVkSparseProperties(..), VkPhysicalDeviceProperties(..),
        HasVkExtensionNameArray(..), HasVkSpecVersion(..),
        VkExtensionProperties(..), HasVkLayerNameArray(..),
        HasVkImplementationVersion(..), HasVkDescriptionArray(..),
        VkLayerProperties(..), HasVkSType(..), HasVkPNext(..),
        HasVkPApplicationName(..), HasVkApplicationVersion(..),
        HasVkPEngineName(..), HasVkEngineVersion(..),
        VkApplicationInfo(..), HasVkPUserData(..), HasVkPfnAllocation(..),
        HasVkPfnReallocation(..), HasVkPfnFree(..),
        HasVkPfnInternalAllocation(..), HasVkPfnInternalFree(..),
        VkAllocationCallbacks(..), HasVkFlags(..),
        HasVkQueueFamilyIndex(..), HasVkQueueCount(..),
        HasVkPQueuePriorities(..), VkDeviceQueueCreateInfo(..),
        HasVkQueueCreateInfoCount(..), HasVkPQueueCreateInfos(..),
        HasVkEnabledLayerCount(..), HasVkPpEnabledLayerNames(..),
        HasVkEnabledExtensionCount(..), HasVkPpEnabledExtensionNames(..),
        HasVkPEnabledFeatures(..), VkDeviceCreateInfo(..),
        HasVkPApplicationInfo(..), VkInstanceCreateInfo(..),
        HasVkQueueFlags(..), HasVkTimestampValidBits(..),
        HasVkMinImageTransferGranularity(..), VkQueueFamilyProperties(..),
        HasVkMemoryTypeCount(..), HasVkMemoryTypesArray(..),
        HasVkMemoryHeapCount(..), HasVkMemoryHeapsArray(..),
        VkPhysicalDeviceMemoryProperties(..), HasVkAllocationSize(..),
        HasVkMemoryTypeIndex(..), VkMemoryAllocateInfo(..), HasVkSize(..),
        HasVkAlignment(..), HasVkMemoryTypeBits(..),
        VkMemoryRequirements(..), HasVkAspectMask(..),
        HasVkImageGranularity(..), VkSparseImageFormatProperties(..),
        HasVkFormatProperties(..), HasVkImageMipTailFirstLod(..),
        HasVkImageMipTailSize(..), HasVkImageMipTailOffset(..),
        HasVkImageMipTailStride(..), VkSparseImageMemoryRequirements(..),
        HasVkPropertyFlags(..), HasVkHeapIndex(..), VkMemoryType(..),
        VkMemoryHeap(..), HasVkMemory(..), VkMappedMemoryRange(..),
        HasVkLinearTilingFeatures(..), HasVkOptimalTilingFeatures(..),
        HasVkBufferFeatures(..), VkFormatProperties(..),
        HasVkMaxExtent(..), HasVkMaxMipLevels(..), HasVkMaxArrayLayers(..),
        HasVkSampleCounts(..), HasVkMaxResourceSize(..),
        VkImageFormatProperties(..), HasVkBuffer(..), HasVkRange(..),
        VkDescriptorBufferInfo(..), HasVkSampler(..), HasVkImageView(..),
        HasVkImageLayout(..), VkDescriptorImageInfo(..), HasVkDstSet(..),
        HasVkDstBinding(..), HasVkDstArrayElement(..),
        HasVkDescriptorCount(..), HasVkDescriptorType(..),
        HasVkPImageInfo(..), HasVkPBufferInfo(..),
        HasVkPTexelBufferView(..), VkWriteDescriptorSet(..),
        HasVkSrcSet(..), HasVkSrcBinding(..), HasVkSrcArrayElement(..),
        VkCopyDescriptorSet(..), HasVkUsage(..), HasVkSharingMode(..),
        HasVkQueueFamilyIndexCount(..), HasVkPQueueFamilyIndices(..),
        VkBufferCreateInfo(..), HasVkFormat(..),
        VkBufferViewCreateInfo(..), HasVkMipLevel(..), HasVkArrayLayer(..),
        VkImageSubresource(..), VkImageSubresourceLayers(..),
        HasVkBaseMipLevel(..), HasVkLevelCount(..),
        VkImageSubresourceRange(..), HasVkImageType(..),
        HasVkMipLevels(..), HasVkArrayLayers(..), HasVkSamples(..),
        HasVkTiling(..), HasVkInitialLayout(..), VkImageCreateInfo(..),
        HasVkRowPitch(..), HasVkArrayPitch(..), HasVkDepthPitch(..),
        VkSubresourceLayout(..), HasVkImage(..), HasVkViewType(..),
        HasVkComponents(..), HasVkSubresourceRange(..),
        VkImageViewCreateInfo(..), HasVkSrcOffset(..), HasVkDstOffset(..),
        VkBufferCopy(..), HasVkResourceOffset(..), HasVkMemoryOffset(..),
        VkSparseMemoryBind(..), HasVkSubresource(..),
        VkSparseImageMemoryBind(..), HasVkBindCount(..), HasVkPBinds(..),
        VkSparseBufferMemoryBindInfo(..),
        VkSparseImageOpaqueMemoryBindInfo(..),
        VkSparseImageMemoryBindInfo(..), HasVkWaitSemaphoreCount(..),
        HasVkPWaitSemaphores(..), HasVkBufferBindCount(..),
        HasVkPBufferBinds(..), HasVkImageOpaqueBindCount(..),
        HasVkPImageOpaqueBinds(..), HasVkImageBindCount(..),
        HasVkPImageBinds(..), HasVkSignalSemaphoreCount(..),
        HasVkPSignalSemaphores(..), VkBindSparseInfo(..),
        HasVkSrcSubresource(..), HasVkDstSubresource(..), VkImageCopy(..),
        HasVkSrcOffsetsArray(..), HasVkDstOffsetsArray(..),
        VkImageBlit(..), HasVkBufferOffset(..), HasVkBufferRowLength(..),
        HasVkBufferImageHeight(..), HasVkImageSubresource(..),
        HasVkImageOffset(..), HasVkImageExtent(..), VkBufferImageCopy(..),
        VkImageResolve(..), HasVkCodeSize(..), HasVkPCode(..),
        VkShaderModuleCreateInfo(..), HasVkBinding(..),
        HasVkStageFlags(..), HasVkPImmutableSamplers(..),
        VkDescriptorSetLayoutBinding(..), HasVkBindingCount(..),
        HasVkPBindings(..), VkDescriptorSetLayoutCreateInfo(..),
        HasVkType(..), VkDescriptorPoolSize(..), HasVkMaxSets(..),
        HasVkPoolSizeCount(..), HasVkPPoolSizes(..),
        VkDescriptorPoolCreateInfo(..), HasVkDescriptorPool(..),
        HasVkDescriptorSetCount(..), HasVkPSetLayouts(..),
        VkDescriptorSetAllocateInfo(..), HasVkConstantID(..),
        VkSpecializationMapEntry(..), HasVkMapEntryCount(..),
        HasVkPMapEntries(..), HasVkDataSize(..), HasVkPData(..),
        VkSpecializationInfo(..), HasVkStage(..), HasVkModule(..),
        HasVkPName(..), HasVkPSpecializationInfo(..),
        VkPipelineShaderStageCreateInfo(..), HasVkLayout(..),
        HasVkBasePipelineHandle(..), HasVkBasePipelineIndex(..),
        VkComputePipelineCreateInfo(..), HasVkStride(..),
        HasVkInputRate(..), VkVertexInputBindingDescription(..),
        HasVkLocation(..), VkVertexInputAttributeDescription(..),
        HasVkVertexBindingDescriptionCount(..),
        HasVkPVertexBindingDescriptions(..),
        HasVkVertexAttributeDescriptionCount(..),
        HasVkPVertexAttributeDescriptions(..),
        VkPipelineVertexInputStateCreateInfo(..), HasVkTopology(..),
        HasVkPrimitiveRestartEnable(..),
        VkPipelineInputAssemblyStateCreateInfo(..),
        HasVkPatchControlPoints(..),
        VkPipelineTessellationStateCreateInfo(..), HasVkViewportCount(..),
        HasVkPViewports(..), HasVkScissorCount(..), HasVkPScissors(..),
        VkPipelineViewportStateCreateInfo(..), HasVkDepthClampEnable(..),
        HasVkRasterizerDiscardEnable(..), HasVkPolygonMode(..),
        HasVkCullMode(..), HasVkFrontFace(..), HasVkDepthBiasEnable(..),
        HasVkDepthBiasConstantFactor(..), HasVkDepthBiasClamp(..),
        HasVkDepthBiasSlopeFactor(..), HasVkLineWidth(..),
        VkPipelineRasterizationStateCreateInfo(..),
        HasVkRasterizationSamples(..), HasVkSampleShadingEnable(..),
        HasVkMinSampleShading(..), HasVkPSampleMask(..),
        HasVkAlphaToCoverageEnable(..), HasVkAlphaToOneEnable(..),
        VkPipelineMultisampleStateCreateInfo(..), HasVkBlendEnable(..),
        HasVkSrcColorBlendFactor(..), HasVkDstColorBlendFactor(..),
        HasVkColorBlendOp(..), HasVkSrcAlphaBlendFactor(..),
        HasVkDstAlphaBlendFactor(..), HasVkAlphaBlendOp(..),
        HasVkColorWriteMask(..), VkPipelineColorBlendAttachmentState(..),
        HasVkLogicOpEnable(..), HasVkLogicOp(..), HasVkAttachmentCount(..),
        HasVkPAttachments(..), HasVkBlendConstantsArray(..),
        VkPipelineColorBlendStateCreateInfo(..),
        HasVkDynamicStateCount(..), HasVkPDynamicStates(..),
        VkPipelineDynamicStateCreateInfo(..), HasVkFailOp(..),
        HasVkPassOp(..), HasVkDepthFailOp(..), HasVkCompareOp(..),
        HasVkCompareMask(..), HasVkWriteMask(..), HasVkReference(..),
        VkStencilOpState(..), HasVkDepthTestEnable(..),
        HasVkDepthWriteEnable(..), HasVkDepthCompareOp(..),
        HasVkDepthBoundsTestEnable(..), HasVkStencilTestEnable(..),
        HasVkFront(..), HasVkBack(..), HasVkMinDepthBounds(..),
        HasVkMaxDepthBounds(..), VkPipelineDepthStencilStateCreateInfo(..),
        HasVkStageCount(..), HasVkPStages(..), HasVkPVertexInputState(..),
        HasVkPInputAssemblyState(..), HasVkPTessellationState(..),
        HasVkPViewportState(..), HasVkPRasterizationState(..),
        HasVkPMultisampleState(..), HasVkPDepthStencilState(..),
        HasVkPColorBlendState(..), HasVkPDynamicState(..),
        HasVkRenderPass(..), HasVkSubpass(..),
        VkGraphicsPipelineCreateInfo(..), HasVkInitialDataSize(..),
        HasVkPInitialData(..), VkPipelineCacheCreateInfo(..),
        VkPushConstantRange(..), HasVkSetLayoutCount(..),
        HasVkPushConstantRangeCount(..), HasVkPPushConstantRanges(..),
        VkPipelineLayoutCreateInfo(..), HasVkMagFilter(..),
        HasVkMinFilter(..), HasVkMipmapMode(..), HasVkAddressModeU(..),
        HasVkAddressModeV(..), HasVkAddressModeW(..), HasVkMipLodBias(..),
        HasVkAnisotropyEnable(..), HasVkMaxAnisotropy(..),
        HasVkCompareEnable(..), HasVkMinLod(..), HasVkMaxLod(..),
        HasVkBorderColor(..), HasVkUnnormalizedCoordinates(..),
        VkSamplerCreateInfo(..), VkCommandPoolCreateInfo(..),
        HasVkCommandPool(..), HasVkLevel(..), HasVkCommandBufferCount(..),
        VkCommandBufferAllocateInfo(..), HasVkFramebuffer(..),
        HasVkOcclusionQueryEnable(..), HasVkQueryFlags(..),
        HasVkPipelineStatistics(..), VkCommandBufferInheritanceInfo(..),
        HasVkPInheritanceInfo(..), VkCommandBufferBeginInfo(..),
        HasVkRenderArea(..), HasVkClearValueCount(..),
        HasVkPClearValues(..), VkRenderPassBeginInfo(..),
        HasVkFloat32Array(..), HasVkInt32Array(..), HasVkUint32Array(..),
        VkClearColorValue(..), HasVkStencil(..),
        VkClearDepthStencilValue(..), HasVkColor(..),
        HasVkDepthStencil(..), VkClearValue(..), HasVkColorAttachment(..),
        HasVkClearValue(..), VkClearAttachment(..), HasVkLoadOp(..),
        HasVkStoreOp(..), HasVkStencilLoadOp(..), HasVkStencilStoreOp(..),
        HasVkFinalLayout(..), VkAttachmentDescription(..),
        HasVkAttachment(..), VkAttachmentReference(..),
        HasVkPipelineBindPoint(..), HasVkInputAttachmentCount(..),
        HasVkPInputAttachments(..), HasVkColorAttachmentCount(..),
        HasVkPColorAttachments(..), HasVkPResolveAttachments(..),
        HasVkPDepthStencilAttachment(..), HasVkPreserveAttachmentCount(..),
        HasVkPPreserveAttachments(..), VkSubpassDescription(..),
        HasVkSrcSubpass(..), HasVkDstSubpass(..), HasVkSrcStageMask(..),
        HasVkDstStageMask(..), HasVkSrcAccessMask(..),
        HasVkDstAccessMask(..), HasVkDependencyFlags(..),
        VkSubpassDependency(..), HasVkSubpassCount(..),
        HasVkPSubpasses(..), HasVkDependencyCount(..),
        HasVkPDependencies(..), VkRenderPassCreateInfo(..),
        VkEventCreateInfo(..), VkFenceCreateInfo(..),
        HasVkRobustBufferAccess(..), HasVkFullDrawIndexUint32(..),
        HasVkImageCubeArray(..), HasVkIndependentBlend(..),
        HasVkGeometryShader(..), HasVkTessellationShader(..),
        HasVkSampleRateShading(..), HasVkDualSrcBlend(..),
        HasVkMultiDrawIndirect(..), HasVkDrawIndirectFirstInstance(..),
        HasVkDepthClamp(..), HasVkFillModeNonSolid(..),
        HasVkDepthBounds(..), HasVkWideLines(..), HasVkLargePoints(..),
        HasVkAlphaToOne(..), HasVkMultiViewport(..),
        HasVkSamplerAnisotropy(..), HasVkTextureCompressionETC2(..),
        HasVkTextureCompressionASTC_LDR(..), HasVkTextureCompressionBC(..),
        HasVkOcclusionQueryPrecise(..), HasVkPipelineStatisticsQuery(..),
        HasVkVertexPipelineStoresAndAtomics(..),
        HasVkFragmentStoresAndAtomics(..),
        HasVkShaderTessellationAndGeometryPointSize(..),
        HasVkShaderImageGatherExtended(..),
        HasVkShaderStorageImageExtendedFormats(..),
        HasVkShaderStorageImageMultisample(..),
        HasVkShaderStorageImageReadWithoutFormat(..),
        HasVkShaderStorageImageWriteWithoutFormat(..),
        HasVkShaderUniformBufferArrayDynamicIndexing(..),
        HasVkShaderSampledImageArrayDynamicIndexing(..),
        HasVkShaderStorageBufferArrayDynamicIndexing(..),
        HasVkShaderStorageImageArrayDynamicIndexing(..),
        HasVkShaderClipDistance(..), HasVkShaderCullDistance(..),
        HasVkShaderFloat64(..), HasVkShaderInt64(..), HasVkShaderInt16(..),
        HasVkShaderResourceResidency(..), HasVkShaderResourceMinLod(..),
        HasVkSparseBinding(..), HasVkSparseResidencyBuffer(..),
        HasVkSparseResidencyImage2D(..), HasVkSparseResidencyImage3D(..),
        HasVkSparseResidency2Samples(..), HasVkSparseResidency4Samples(..),
        HasVkSparseResidency8Samples(..),
        HasVkSparseResidency16Samples(..), HasVkSparseResidencyAliased(..),
        HasVkVariableMultisampleRate(..), HasVkInheritedQueries(..),
        VkPhysicalDeviceFeatures(..),
        HasVkResidencyStandard2DBlockShape(..),
        HasVkResidencyStandard2DMultisampleBlockShape(..),
        HasVkResidencyStandard3DBlockShape(..),
        HasVkResidencyAlignedMipSize(..),
        HasVkResidencyNonResidentStrict(..),
        VkPhysicalDeviceSparseProperties(..), HasVkMaxImageDimension1D(..),
        HasVkMaxImageDimension2D(..), HasVkMaxImageDimension3D(..),
        HasVkMaxImageDimensionCube(..), HasVkMaxImageArrayLayers(..),
        HasVkMaxTexelBufferElements(..), HasVkMaxUniformBufferRange(..),
        HasVkMaxStorageBufferRange(..), HasVkMaxPushConstantsSize(..),
        HasVkMaxMemoryAllocationCount(..),
        HasVkMaxSamplerAllocationCount(..),
        HasVkBufferImageGranularity(..), HasVkSparseAddressSpaceSize(..),
        HasVkMaxBoundDescriptorSets(..),
        HasVkMaxPerStageDescriptorSamplers(..),
        HasVkMaxPerStageDescriptorUniformBuffers(..),
        HasVkMaxPerStageDescriptorStorageBuffers(..),
        HasVkMaxPerStageDescriptorSampledImages(..),
        HasVkMaxPerStageDescriptorStorageImages(..),
        HasVkMaxPerStageDescriptorInputAttachments(..),
        HasVkMaxPerStageResources(..), HasVkMaxDescriptorSetSamplers(..),
        HasVkMaxDescriptorSetUniformBuffers(..),
        HasVkMaxDescriptorSetUniformBuffersDynamic(..),
        HasVkMaxDescriptorSetStorageBuffers(..),
        HasVkMaxDescriptorSetStorageBuffersDynamic(..),
        HasVkMaxDescriptorSetSampledImages(..),
        HasVkMaxDescriptorSetStorageImages(..),
        HasVkMaxDescriptorSetInputAttachments(..),
        HasVkMaxVertexInputAttributes(..), HasVkMaxVertexInputBindings(..),
        HasVkMaxVertexInputAttributeOffset(..),
        HasVkMaxVertexInputBindingStride(..),
        HasVkMaxVertexOutputComponents(..),
        HasVkMaxTessellationGenerationLevel(..),
        HasVkMaxTessellationPatchSize(..),
        HasVkMaxTessellationControlPerVertexInputComponents(..),
        HasVkMaxTessellationControlPerVertexOutputComponents(..),
        HasVkMaxTessellationControlPerPatchOutputComponents(..),
        HasVkMaxTessellationControlTotalOutputComponents(..),
        HasVkMaxTessellationEvaluationInputComponents(..),
        HasVkMaxTessellationEvaluationOutputComponents(..),
        HasVkMaxGeometryShaderInvocations(..),
        HasVkMaxGeometryInputComponents(..),
        HasVkMaxGeometryOutputComponents(..),
        HasVkMaxGeometryOutputVertices(..),
        HasVkMaxGeometryTotalOutputComponents(..),
        HasVkMaxFragmentInputComponents(..),
        HasVkMaxFragmentOutputAttachments(..),
        HasVkMaxFragmentDualSrcAttachments(..),
        HasVkMaxFragmentCombinedOutputResources(..),
        HasVkMaxComputeSharedMemorySize(..),
        HasVkMaxComputeWorkGroupCountArray(..),
        HasVkMaxComputeWorkGroupInvocations(..),
        HasVkMaxComputeWorkGroupSizeArray(..),
        HasVkSubPixelPrecisionBits(..), HasVkSubTexelPrecisionBits(..),
        HasVkMipmapPrecisionBits(..), HasVkMaxDrawIndexedIndexValue(..),
        HasVkMaxDrawIndirectCount(..), HasVkMaxSamplerLodBias(..),
        HasVkMaxSamplerAnisotropy(..), HasVkMaxViewports(..),
        HasVkMaxViewportDimensionsArray(..),
        HasVkViewportBoundsRangeArray(..), HasVkViewportSubPixelBits(..),
        HasVkMinMemoryMapAlignment(..),
        HasVkMinTexelBufferOffsetAlignment(..),
        HasVkMinUniformBufferOffsetAlignment(..),
        HasVkMinStorageBufferOffsetAlignment(..), HasVkMinTexelOffset(..),
        HasVkMaxTexelOffset(..), HasVkMinTexelGatherOffset(..),
        HasVkMaxTexelGatherOffset(..), HasVkMinInterpolationOffset(..),
        HasVkMaxInterpolationOffset(..),
        HasVkSubPixelInterpolationOffsetBits(..),
        HasVkMaxFramebufferWidth(..), HasVkMaxFramebufferHeight(..),
        HasVkMaxFramebufferLayers(..),
        HasVkFramebufferColorSampleCounts(..),
        HasVkFramebufferDepthSampleCounts(..),
        HasVkFramebufferStencilSampleCounts(..),
        HasVkFramebufferNoAttachmentsSampleCounts(..),
        HasVkMaxColorAttachments(..),
        HasVkSampledImageColorSampleCounts(..),
        HasVkSampledImageIntegerSampleCounts(..),
        HasVkSampledImageDepthSampleCounts(..),
        HasVkSampledImageStencilSampleCounts(..),
        HasVkStorageImageSampleCounts(..), HasVkMaxSampleMaskWords(..),
        HasVkTimestampComputeAndGraphics(..), HasVkTimestampPeriod(..),
        HasVkMaxClipDistances(..), HasVkMaxCullDistances(..),
        HasVkMaxCombinedClipAndCullDistances(..),
        HasVkDiscreteQueuePriorities(..), HasVkPointSizeRangeArray(..),
        HasVkLineWidthRangeArray(..), HasVkPointSizeGranularity(..),
        HasVkLineWidthGranularity(..), HasVkStrictLines(..),
        HasVkStandardSampleLocations(..),
        HasVkOptimalBufferCopyOffsetAlignment(..),
        HasVkOptimalBufferCopyRowPitchAlignment(..),
        HasVkNonCoherentAtomSize(..), VkPhysicalDeviceLimits(..),
        VkSemaphoreCreateInfo(..), HasVkQueryType(..), HasVkQueryCount(..),
        VkQueryPoolCreateInfo(..), HasVkLayers(..),
        VkFramebufferCreateInfo(..), HasVkPWaitDstStageMask(..),
        HasVkPCommandBuffers(..), VkSubmitInfo(..), HasVkMinImageCount(..),
        HasVkMaxImageCount(..), HasVkCurrentExtent(..),
        HasVkMinImageExtent(..), HasVkMaxImageExtent(..),
        HasVkSupportedTransforms(..), HasVkCurrentTransform(..),
        HasVkSupportedCompositeAlpha(..), HasVkSupportedUsageFlags(..),
        VkSurfaceCapabilitiesKHR(..), HasVkColorSpace(..),
        VkSurfaceFormatKHR(..), HasVkSurface(..), HasVkImageFormat(..),
        HasVkImageColorSpace(..), HasVkImageArrayLayers(..),
        HasVkImageUsage(..), HasVkImageSharingMode(..),
        HasVkPreTransform(..), HasVkCompositeAlpha(..),
        HasVkPresentMode(..), HasVkClipped(..), HasVkOldSwapchain(..),
        VkSwapchainCreateInfoKHR(..), HasVkSwapchainCount(..),
        HasVkPSwapchains(..), HasVkPImageIndices(..), HasVkPResults(..),
        VkPresentInfoKHR(..))
       where
import           Data.Int                (Int32)
import           Data.Void               (Void)
import           Data.Word               (Word32, Word64, Word8)
import           Foreign.C.Types         (CChar, CFloat, CInt, CSize)
import           Foreign.Ptr             (Ptr)
import           Foreign.Storable        (Storable (..))
import           GHC.Prim
import           GHC.Ptr                 (Ptr (..))
import           GHC.TypeLits            (ErrorMessage (..), TypeError)
import           GHC.Types               (IO (..), Int (..))
import           Graphics.Vulkan.Common
import           Graphics.Vulkan.Marshal
import           System.IO.Unsafe        (unsafeDupablePerformIO)

data VkOffset2D = VkOffset2D## ByteArray##

instance Eq VkOffset2D where
        (VkOffset2D## a) == (VkOffset2D## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkOffset2D where
        (VkOffset2D## a) `compare` (VkOffset2D## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkOffset2D where
        sizeOf ~_ = #{size VkOffset2D}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkOffset2D}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkOffset2D),
            I## a <- alignment (undefined :: VkOffset2D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkOffset2D## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkOffset2D## ba)
          | I## n <- sizeOf (undefined :: VkOffset2D) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkOffset2D where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkOffset2D),
            I## a <- alignment (undefined :: VkOffset2D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkOffset2D## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkOffset2D## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkOffset2D## ba)
          | I## n <- sizeOf (undefined :: VkOffset2D),
            I## a <- alignment (undefined :: VkOffset2D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkOffset2D## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkOffset2D## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkX a where
        type VkXMType a :: *

        vkX :: a -> VkXMType a

        vkXByteOffset :: a -> Int

        readVkX :: Mutable a -> IO (VkXMType a)

        writeVkX :: Mutable a -> VkXMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'x'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkX a

instance {-# OVERLAPPING #-} HasVkX VkOffset2D where
        type VkXMType VkOffset2D = Data.Int.Int32
        vkX (VkOffset2D## ba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkXByteOffset (undefined :: VkOffset2D) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkX #-}
        vkXByteOffset ~_ = #{offset VkOffset2D, x}

        {-# INLINE vkXByteOffset #-}
        readVkX (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkXByteOffset (undefined :: VkOffset2D) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkX #-}
        writeVkX (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkXByteOffset (undefined :: VkOffset2D) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkX #-}

class HasVkY a where
        type VkYMType a :: *

        vkY :: a -> VkYMType a

        vkYByteOffset :: a -> Int

        readVkY :: Mutable a -> IO (VkYMType a)

        writeVkY :: Mutable a -> VkYMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'y'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkY a

instance {-# OVERLAPPING #-} HasVkY VkOffset2D where
        type VkYMType VkOffset2D = Data.Int.Int32
        vkY (VkOffset2D## ba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkYByteOffset (undefined :: VkOffset2D) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkY #-}
        vkYByteOffset ~_ = #{offset VkOffset2D, y}

        {-# INLINE vkYByteOffset #-}
        readVkY (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkYByteOffset (undefined :: VkOffset2D) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkY #-}
        writeVkY (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkYByteOffset (undefined :: VkOffset2D) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkY #-}

instance Show VkOffset2D where
        showsPrec d x
          = showString "VkOffset2D {" .
              showString "vkX = " .
                showsPrec d (vkX x) .
                  showString ", " .
                    showString "vkY = " . showsPrec d (vkY x) . showChar '}'

data VkOffset3D = VkOffset3D## ByteArray##

instance Eq VkOffset3D where
        (VkOffset3D## a) == (VkOffset3D## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkOffset3D where
        (VkOffset3D## a) `compare` (VkOffset3D## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkOffset3D where
        sizeOf ~_ = #{size VkOffset3D}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkOffset3D}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkOffset3D),
            I## a <- alignment (undefined :: VkOffset3D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkOffset3D## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkOffset3D## ba)
          | I## n <- sizeOf (undefined :: VkOffset3D) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkOffset3D where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkOffset3D),
            I## a <- alignment (undefined :: VkOffset3D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkOffset3D## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkOffset3D## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkOffset3D## ba)
          | I## n <- sizeOf (undefined :: VkOffset3D),
            I## a <- alignment (undefined :: VkOffset3D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkOffset3D## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkOffset3D## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkX VkOffset3D where
        type VkXMType VkOffset3D = Data.Int.Int32
        vkX (VkOffset3D## ba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkXByteOffset (undefined :: VkOffset3D) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkX #-}
        vkXByteOffset ~_ = #{offset VkOffset3D, x}

        {-# INLINE vkXByteOffset #-}
        readVkX (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkXByteOffset (undefined :: VkOffset3D) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkX #-}
        writeVkX (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkXByteOffset (undefined :: VkOffset3D) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkX #-}

instance {-# OVERLAPPING #-} HasVkY VkOffset3D where
        type VkYMType VkOffset3D = Data.Int.Int32
        vkY (VkOffset3D## ba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkYByteOffset (undefined :: VkOffset3D) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkY #-}
        vkYByteOffset ~_ = #{offset VkOffset3D, y}

        {-# INLINE vkYByteOffset #-}
        readVkY (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkYByteOffset (undefined :: VkOffset3D) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkY #-}
        writeVkY (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkYByteOffset (undefined :: VkOffset3D) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkY #-}

class HasVkZ a where
        type VkZMType a :: *

        vkZ :: a -> VkZMType a

        vkZByteOffset :: a -> Int

        readVkZ :: Mutable a -> IO (VkZMType a)

        writeVkZ :: Mutable a -> VkZMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'z'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkZ a

instance {-# OVERLAPPING #-} HasVkZ VkOffset3D where
        type VkZMType VkOffset3D = Data.Int.Int32
        vkZ (VkOffset3D## ba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkZByteOffset (undefined :: VkOffset3D) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkZ #-}
        vkZByteOffset ~_ = #{offset VkOffset3D, z}

        {-# INLINE vkZByteOffset #-}
        readVkZ (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkZByteOffset (undefined :: VkOffset3D) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkZ #-}
        writeVkZ (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkZByteOffset (undefined :: VkOffset3D) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkZ #-}

instance Show VkOffset3D where
        showsPrec d x
          = showString "VkOffset3D {" .
              showString "vkX = " .
                showsPrec d (vkX x) .
                  showString ", " .
                    showString "vkY = " .
                      showsPrec d (vkY x) .
                        showString ", " .
                          showString "vkZ = " . showsPrec d (vkZ x) . showChar '}'

data VkExtent2D = VkExtent2D## ByteArray##

instance Eq VkExtent2D where
        (VkExtent2D## a) == (VkExtent2D## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkExtent2D where
        (VkExtent2D## a) `compare` (VkExtent2D## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkExtent2D where
        sizeOf ~_ = #{size VkExtent2D}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkExtent2D}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkExtent2D),
            I## a <- alignment (undefined :: VkExtent2D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkExtent2D## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkExtent2D## ba)
          | I## n <- sizeOf (undefined :: VkExtent2D) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkExtent2D where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkExtent2D),
            I## a <- alignment (undefined :: VkExtent2D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkExtent2D## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkExtent2D## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkExtent2D## ba)
          | I## n <- sizeOf (undefined :: VkExtent2D),
            I## a <- alignment (undefined :: VkExtent2D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkExtent2D## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkExtent2D## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkWidth a where
        type VkWidthMType a :: *

        vkWidth :: a -> VkWidthMType a

        vkWidthByteOffset :: a -> Int

        readVkWidth :: Mutable a -> IO (VkWidthMType a)

        writeVkWidth :: Mutable a -> VkWidthMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'width'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkWidth a

instance {-# OVERLAPPING #-} HasVkWidth VkExtent2D where
        type VkWidthMType VkExtent2D = Data.Word.Word32
        vkWidth (VkExtent2D## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkWidthByteOffset (undefined :: VkExtent2D) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkWidth #-}
        vkWidthByteOffset ~_ = #{offset VkExtent2D, width}

        {-# INLINE vkWidthByteOffset #-}
        readVkWidth (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkWidthByteOffset (undefined :: VkExtent2D) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkWidth #-}
        writeVkWidth (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkWidthByteOffset (undefined :: VkExtent2D) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkWidth #-}

class HasVkHeight a where
        type VkHeightMType a :: *

        vkHeight :: a -> VkHeightMType a

        vkHeightByteOffset :: a -> Int

        readVkHeight :: Mutable a -> IO (VkHeightMType a)

        writeVkHeight :: Mutable a -> VkHeightMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'height'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkHeight a

instance {-# OVERLAPPING #-} HasVkHeight VkExtent2D where
        type VkHeightMType VkExtent2D = Data.Word.Word32
        vkHeight (VkExtent2D## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkHeightByteOffset (undefined :: VkExtent2D) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkHeight #-}
        vkHeightByteOffset ~_ = #{offset VkExtent2D, height}

        {-# INLINE vkHeightByteOffset #-}
        readVkHeight (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkHeightByteOffset (undefined :: VkExtent2D) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkHeight #-}
        writeVkHeight (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkHeightByteOffset (undefined :: VkExtent2D) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkHeight #-}

instance Show VkExtent2D where
        showsPrec d x
          = showString "VkExtent2D {" .
              showString "vkWidth = " .
                showsPrec d (vkWidth x) .
                  showString ", " .
                    showString "vkHeight = " . showsPrec d (vkHeight x) . showChar '}'

data VkExtent3D = VkExtent3D## ByteArray##

instance Eq VkExtent3D where
        (VkExtent3D## a) == (VkExtent3D## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkExtent3D where
        (VkExtent3D## a) `compare` (VkExtent3D## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkExtent3D where
        sizeOf ~_ = #{size VkExtent3D}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkExtent3D}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkExtent3D),
            I## a <- alignment (undefined :: VkExtent3D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkExtent3D## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkExtent3D## ba)
          | I## n <- sizeOf (undefined :: VkExtent3D) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkExtent3D where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkExtent3D),
            I## a <- alignment (undefined :: VkExtent3D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkExtent3D## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkExtent3D## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkExtent3D## ba)
          | I## n <- sizeOf (undefined :: VkExtent3D),
            I## a <- alignment (undefined :: VkExtent3D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkExtent3D## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkExtent3D## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkWidth VkExtent3D where
        type VkWidthMType VkExtent3D = Data.Word.Word32
        vkWidth (VkExtent3D## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkWidthByteOffset (undefined :: VkExtent3D) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkWidth #-}
        vkWidthByteOffset ~_ = #{offset VkExtent3D, width}

        {-# INLINE vkWidthByteOffset #-}
        readVkWidth (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkWidthByteOffset (undefined :: VkExtent3D) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkWidth #-}
        writeVkWidth (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkWidthByteOffset (undefined :: VkExtent3D) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkWidth #-}

instance {-# OVERLAPPING #-} HasVkHeight VkExtent3D where
        type VkHeightMType VkExtent3D = Data.Word.Word32
        vkHeight (VkExtent3D## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkHeightByteOffset (undefined :: VkExtent3D) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkHeight #-}
        vkHeightByteOffset ~_ = #{offset VkExtent3D, height}

        {-# INLINE vkHeightByteOffset #-}
        readVkHeight (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkHeightByteOffset (undefined :: VkExtent3D) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkHeight #-}
        writeVkHeight (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkHeightByteOffset (undefined :: VkExtent3D) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkHeight #-}

class HasVkDepth a where
        type VkDepthMType a :: *

        vkDepth :: a -> VkDepthMType a

        vkDepthByteOffset :: a -> Int

        readVkDepth :: Mutable a -> IO (VkDepthMType a)

        writeVkDepth :: Mutable a -> VkDepthMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depth'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepth a

instance {-# OVERLAPPING #-} HasVkDepth VkExtent3D where
        type VkDepthMType VkExtent3D = Data.Word.Word32
        vkDepth (VkExtent3D## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDepthByteOffset (undefined :: VkExtent3D) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepth #-}
        vkDepthByteOffset ~_ = #{offset VkExtent3D, depth}

        {-# INLINE vkDepthByteOffset #-}
        readVkDepth (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDepthByteOffset (undefined :: VkExtent3D) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepth #-}
        writeVkDepth (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthByteOffset (undefined :: VkExtent3D) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepth #-}

instance Show VkExtent3D where
        showsPrec d x
          = showString "VkExtent3D {" .
              showString "vkWidth = " .
                showsPrec d (vkWidth x) .
                  showString ", " .
                    showString "vkHeight = " .
                      showsPrec d (vkHeight x) .
                        showString ", " .
                          showString "vkDepth = " . showsPrec d (vkDepth x) . showChar '}'

data VkViewport = VkViewport## ByteArray##

instance Eq VkViewport where
        (VkViewport## a) == (VkViewport## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkViewport where
        (VkViewport## a) `compare` (VkViewport## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkViewport where
        sizeOf ~_ = #{size VkViewport}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkViewport}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkViewport),
            I## a <- alignment (undefined :: VkViewport) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkViewport## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkViewport## ba)
          | I## n <- sizeOf (undefined :: VkViewport) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkViewport where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkViewport),
            I## a <- alignment (undefined :: VkViewport) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkViewport## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkViewport## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkViewport## ba)
          | I## n <- sizeOf (undefined :: VkViewport),
            I## a <- alignment (undefined :: VkViewport) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkViewport## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkViewport## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkX VkViewport where
        type VkXMType VkViewport = Foreign.C.Types.CFloat
        vkX (VkViewport## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkXByteOffset (undefined :: VkViewport) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkX #-}
        vkXByteOffset ~_ = #{offset VkViewport, x}

        {-# INLINE vkXByteOffset #-}
        readVkX (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkXByteOffset (undefined :: VkViewport) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkX #-}
        writeVkX (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkXByteOffset (undefined :: VkViewport) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkX #-}

instance {-# OVERLAPPING #-} HasVkY VkViewport where
        type VkYMType VkViewport = Foreign.C.Types.CFloat
        vkY (VkViewport## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkYByteOffset (undefined :: VkViewport) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkY #-}
        vkYByteOffset ~_ = #{offset VkViewport, y}

        {-# INLINE vkYByteOffset #-}
        readVkY (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkYByteOffset (undefined :: VkViewport) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkY #-}
        writeVkY (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkYByteOffset (undefined :: VkViewport) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkY #-}

instance {-# OVERLAPPING #-} HasVkWidth VkViewport where
        type VkWidthMType VkViewport = Foreign.C.Types.CFloat
        vkWidth (VkViewport## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkWidthByteOffset (undefined :: VkViewport) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkWidth #-}
        vkWidthByteOffset ~_ = #{offset VkViewport, width}

        {-# INLINE vkWidthByteOffset #-}
        readVkWidth (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkWidthByteOffset (undefined :: VkViewport) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkWidth #-}
        writeVkWidth (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkWidthByteOffset (undefined :: VkViewport) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkWidth #-}

instance {-# OVERLAPPING #-} HasVkHeight VkViewport where
        type VkHeightMType VkViewport = Foreign.C.Types.CFloat
        vkHeight (VkViewport## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkHeightByteOffset (undefined :: VkViewport) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkHeight #-}
        vkHeightByteOffset ~_ = #{offset VkViewport, height}

        {-# INLINE vkHeightByteOffset #-}
        readVkHeight (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkHeightByteOffset (undefined :: VkViewport) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkHeight #-}
        writeVkHeight (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkHeightByteOffset (undefined :: VkViewport) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkHeight #-}

class HasVkMinDepth a where
        type VkMinDepthMType a :: *

        vkMinDepth :: a -> VkMinDepthMType a

        vkMinDepthByteOffset :: a -> Int

        readVkMinDepth :: Mutable a -> IO (VkMinDepthMType a)

        writeVkMinDepth :: Mutable a -> VkMinDepthMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minDepth'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinDepth a

instance {-# OVERLAPPING #-} HasVkMinDepth VkViewport where
        type VkMinDepthMType VkViewport = Foreign.C.Types.CFloat
        vkMinDepth (VkViewport## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMinDepthByteOffset (undefined :: VkViewport) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinDepth #-}
        vkMinDepthByteOffset ~_ = #{offset VkViewport, minDepth}

        {-# INLINE vkMinDepthByteOffset #-}
        readVkMinDepth (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMinDepthByteOffset (undefined :: VkViewport) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinDepth #-}
        writeVkMinDepth (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinDepthByteOffset (undefined :: VkViewport) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinDepth #-}

class HasVkMaxDepth a where
        type VkMaxDepthMType a :: *

        vkMaxDepth :: a -> VkMaxDepthMType a

        vkMaxDepthByteOffset :: a -> Int

        readVkMaxDepth :: Mutable a -> IO (VkMaxDepthMType a)

        writeVkMaxDepth :: Mutable a -> VkMaxDepthMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxDepth'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDepth a

instance {-# OVERLAPPING #-} HasVkMaxDepth VkViewport where
        type VkMaxDepthMType VkViewport = Foreign.C.Types.CFloat
        vkMaxDepth (VkViewport## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMaxDepthByteOffset (undefined :: VkViewport) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxDepth #-}
        vkMaxDepthByteOffset ~_ = #{offset VkViewport, maxDepth}

        {-# INLINE vkMaxDepthByteOffset #-}
        readVkMaxDepth (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMaxDepthByteOffset (undefined :: VkViewport) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxDepth #-}
        writeVkMaxDepth (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxDepthByteOffset (undefined :: VkViewport) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxDepth #-}

instance Show VkViewport where
        showsPrec d x
          = showString "VkViewport {" .
              showString "vkX = " .
                showsPrec d (vkX x) .
                  showString ", " .
                    showString "vkY = " .
                      showsPrec d (vkY x) .
                        showString ", " .
                          showString "vkWidth = " .
                            showsPrec d (vkWidth x) .
                              showString ", " .
                                showString "vkHeight = " .
                                  showsPrec d (vkHeight x) .
                                    showString ", " .
                                      showString "vkMinDepth = " .
                                        showsPrec d (vkMinDepth x) .
                                          showString ", " .
                                            showString "vkMaxDepth = " .
                                              showsPrec d (vkMaxDepth x) . showChar '}'

data VkRect2D = VkRect2D## ByteArray##

instance Eq VkRect2D where
        (VkRect2D## a) == (VkRect2D## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkRect2D where
        (VkRect2D## a) `compare` (VkRect2D## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkRect2D where
        sizeOf ~_ = #{size VkRect2D}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkRect2D}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkRect2D),
            I## a <- alignment (undefined :: VkRect2D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkRect2D## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkRect2D## ba)
          | I## n <- sizeOf (undefined :: VkRect2D) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkRect2D where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkRect2D),
            I## a <- alignment (undefined :: VkRect2D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkRect2D## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkRect2D## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkRect2D## ba)
          | I## n <- sizeOf (undefined :: VkRect2D),
            I## a <- alignment (undefined :: VkRect2D) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkRect2D## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkRect2D## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkOffset a where
        type VkOffsetMType a :: *

        vkOffset :: a -> VkOffsetMType a

        vkOffsetByteOffset :: a -> Int

        readVkOffset :: Mutable a -> IO (VkOffsetMType a)

        writeVkOffset :: Mutable a -> VkOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'offset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkOffset a

instance {-# OVERLAPPING #-} HasVkOffset VkRect2D where
        type VkOffsetMType VkRect2D = VkOffset2D
        vkOffset (VkRect2D## ba)
          | I## _n <- sizeOf (undefined :: VkOffset2D),
            I## o <- vkOffsetByteOffset (undefined :: VkRect2D) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOffset #-}
        vkOffsetByteOffset ~_ = #{offset VkRect2D, offset}

        {-# INLINE vkOffsetByteOffset #-}
        readVkOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkOffset2D),
            I## o <- vkOffsetByteOffset (undefined :: VkRect2D) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOffset #-}
        writeVkOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOffsetByteOffset (undefined :: VkRect2D) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOffset #-}

class HasVkExtent a where
        type VkExtentMType a :: *

        vkExtent :: a -> VkExtentMType a

        vkExtentByteOffset :: a -> Int

        readVkExtent :: Mutable a -> IO (VkExtentMType a)

        writeVkExtent :: Mutable a -> VkExtentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'extent'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkExtent a

instance {-# OVERLAPPING #-} HasVkExtent VkRect2D where
        type VkExtentMType VkRect2D = VkExtent2D
        vkExtent (VkRect2D## ba)
          | I## _n <- sizeOf (undefined :: VkExtent2D),
            I## o <- vkExtentByteOffset (undefined :: VkRect2D) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkExtent #-}
        vkExtentByteOffset ~_ = #{offset VkRect2D, extent}

        {-# INLINE vkExtentByteOffset #-}
        readVkExtent (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkExtent2D),
            I## o <- vkExtentByteOffset (undefined :: VkRect2D) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkExtent #-}
        writeVkExtent (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkExtentByteOffset (undefined :: VkRect2D) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkExtent #-}

instance Show VkRect2D where
        showsPrec d x
          = showString "VkRect2D {" .
              showString "vkOffset = " .
                showsPrec d (vkOffset x) .
                  showString ", " .
                    showString "vkExtent = " . showsPrec d (vkExtent x) . showChar '}'

data VkClearRect = VkClearRect## ByteArray##

instance Eq VkClearRect where
        (VkClearRect## a) == (VkClearRect## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkClearRect where
        (VkClearRect## a) `compare` (VkClearRect## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkClearRect where
        sizeOf ~_ = #{size VkClearRect}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkClearRect}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkClearRect),
            I## a <- alignment (undefined :: VkClearRect) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkClearRect## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkClearRect## ba)
          | I## n <- sizeOf (undefined :: VkClearRect) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkClearRect where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkClearRect),
            I## a <- alignment (undefined :: VkClearRect) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkClearRect## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkClearRect## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkClearRect## ba)
          | I## n <- sizeOf (undefined :: VkClearRect),
            I## a <- alignment (undefined :: VkClearRect) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkClearRect## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkClearRect## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkRect a where
        type VkRectMType a :: *

        vkRect :: a -> VkRectMType a

        vkRectByteOffset :: a -> Int

        readVkRect :: Mutable a -> IO (VkRectMType a)

        writeVkRect :: Mutable a -> VkRectMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'rect'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRect a

instance {-# OVERLAPPING #-} HasVkRect VkClearRect where
        type VkRectMType VkClearRect = VkRect2D
        vkRect (VkClearRect## ba)
          | I## _n <- sizeOf (undefined :: VkRect2D),
            I## o <- vkRectByteOffset (undefined :: VkClearRect) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkRect #-}
        vkRectByteOffset ~_ = #{offset VkClearRect, rect}

        {-# INLINE vkRectByteOffset #-}
        readVkRect (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkRect2D),
            I## o <- vkRectByteOffset (undefined :: VkClearRect) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkRect #-}
        writeVkRect (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkRectByteOffset (undefined :: VkClearRect) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkRect #-}

class HasVkBaseArrayLayer a where
        type VkBaseArrayLayerMType a :: *

        vkBaseArrayLayer :: a -> VkBaseArrayLayerMType a

        vkBaseArrayLayerByteOffset :: a -> Int

        readVkBaseArrayLayer :: Mutable a -> IO (VkBaseArrayLayerMType a)

        writeVkBaseArrayLayer ::
                              Mutable a -> VkBaseArrayLayerMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'baseArrayLayer'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBaseArrayLayer a

instance {-# OVERLAPPING #-} HasVkBaseArrayLayer VkClearRect where
        type VkBaseArrayLayerMType VkClearRect = Data.Word.Word32
        vkBaseArrayLayer (VkClearRect## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBaseArrayLayerByteOffset (undefined :: VkClearRect) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBaseArrayLayer #-}
        vkBaseArrayLayerByteOffset ~_
          = #{offset VkClearRect, baseArrayLayer}

        {-# INLINE vkBaseArrayLayerByteOffset #-}
        readVkBaseArrayLayer (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBaseArrayLayerByteOffset (undefined :: VkClearRect) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBaseArrayLayer #-}
        writeVkBaseArrayLayer (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBaseArrayLayerByteOffset (undefined :: VkClearRect) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBaseArrayLayer #-}

class HasVkLayerCount a where
        type VkLayerCountMType a :: *

        vkLayerCount :: a -> VkLayerCountMType a

        vkLayerCountByteOffset :: a -> Int

        readVkLayerCount :: Mutable a -> IO (VkLayerCountMType a)

        writeVkLayerCount :: Mutable a -> VkLayerCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'layerCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLayerCount a

instance {-# OVERLAPPING #-} HasVkLayerCount VkClearRect where
        type VkLayerCountMType VkClearRect = Data.Word.Word32
        vkLayerCount (VkClearRect## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkLayerCountByteOffset (undefined :: VkClearRect) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLayerCount #-}
        vkLayerCountByteOffset ~_
          = #{offset VkClearRect, layerCount}

        {-# INLINE vkLayerCountByteOffset #-}
        readVkLayerCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkLayerCountByteOffset (undefined :: VkClearRect) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLayerCount #-}
        writeVkLayerCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLayerCountByteOffset (undefined :: VkClearRect) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLayerCount #-}

instance Show VkClearRect where
        showsPrec d x
          = showString "VkClearRect {" .
              showString "vkRect = " .
                showsPrec d (vkRect x) .
                  showString ", " .
                    showString "vkBaseArrayLayer = " .
                      showsPrec d (vkBaseArrayLayer x) .
                        showString ", " .
                          showString "vkLayerCount = " .
                            showsPrec d (vkLayerCount x) . showChar '}'

data VkComponentMapping = VkComponentMapping## ByteArray##

instance Eq VkComponentMapping where
        (VkComponentMapping## a) == (VkComponentMapping## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkComponentMapping where
        (VkComponentMapping## a) `compare` (VkComponentMapping## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkComponentMapping where
        sizeOf ~_ = #{size VkComponentMapping}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkComponentMapping}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkComponentMapping),
            I## a <- alignment (undefined :: VkComponentMapping) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkComponentMapping## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkComponentMapping## ba)
          | I## n <- sizeOf (undefined :: VkComponentMapping) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkComponentMapping where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkComponentMapping),
            I## a <- alignment (undefined :: VkComponentMapping) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkComponentMapping## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkComponentMapping## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkComponentMapping## ba)
          | I## n <- sizeOf (undefined :: VkComponentMapping),
            I## a <- alignment (undefined :: VkComponentMapping) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkComponentMapping## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkComponentMapping## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkR a where
        type VkRMType a :: *

        vkR :: a -> VkRMType a

        vkRByteOffset :: a -> Int

        readVkR :: Mutable a -> IO (VkRMType a)

        writeVkR :: Mutable a -> VkRMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'r'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkR a

instance {-# OVERLAPPING #-} HasVkR VkComponentMapping where
        type VkRMType VkComponentMapping = VkComponentSwizzle
        vkR (VkComponentMapping## ba)
          | I## _n <- sizeOf (undefined :: VkComponentSwizzle),
            I## o <- vkRByteOffset (undefined :: VkComponentMapping) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkR #-}
        vkRByteOffset ~_ = #{offset VkComponentMapping, r}

        {-# INLINE vkRByteOffset #-}
        readVkR (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkComponentSwizzle),
            I## o <- vkRByteOffset (undefined :: VkComponentMapping) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkR #-}
        writeVkR (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkRByteOffset (undefined :: VkComponentMapping) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkR #-}

class HasVkG a where
        type VkGMType a :: *

        vkG :: a -> VkGMType a

        vkGByteOffset :: a -> Int

        readVkG :: Mutable a -> IO (VkGMType a)

        writeVkG :: Mutable a -> VkGMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'g'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkG a

instance {-# OVERLAPPING #-} HasVkG VkComponentMapping where
        type VkGMType VkComponentMapping = VkComponentSwizzle
        vkG (VkComponentMapping## ba)
          | I## _n <- sizeOf (undefined :: VkComponentSwizzle),
            I## o <- vkGByteOffset (undefined :: VkComponentMapping) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkG #-}
        vkGByteOffset ~_ = #{offset VkComponentMapping, g}

        {-# INLINE vkGByteOffset #-}
        readVkG (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkComponentSwizzle),
            I## o <- vkGByteOffset (undefined :: VkComponentMapping) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkG #-}
        writeVkG (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkGByteOffset (undefined :: VkComponentMapping) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkG #-}

class HasVkB a where
        type VkBMType a :: *

        vkB :: a -> VkBMType a

        vkBByteOffset :: a -> Int

        readVkB :: Mutable a -> IO (VkBMType a)

        writeVkB :: Mutable a -> VkBMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'b'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkB a

instance {-# OVERLAPPING #-} HasVkB VkComponentMapping where
        type VkBMType VkComponentMapping = VkComponentSwizzle
        vkB (VkComponentMapping## ba)
          | I## _n <- sizeOf (undefined :: VkComponentSwizzle),
            I## o <- vkBByteOffset (undefined :: VkComponentMapping) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkB #-}
        vkBByteOffset ~_ = #{offset VkComponentMapping, b}

        {-# INLINE vkBByteOffset #-}
        readVkB (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkComponentSwizzle),
            I## o <- vkBByteOffset (undefined :: VkComponentMapping) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkB #-}
        writeVkB (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBByteOffset (undefined :: VkComponentMapping) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkB #-}

class HasVkA a where
        type VkAMType a :: *

        vkA :: a -> VkAMType a

        vkAByteOffset :: a -> Int

        readVkA :: Mutable a -> IO (VkAMType a)

        writeVkA :: Mutable a -> VkAMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'a'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkA a

instance {-# OVERLAPPING #-} HasVkA VkComponentMapping where
        type VkAMType VkComponentMapping = VkComponentSwizzle
        vkA (VkComponentMapping## ba)
          | I## _n <- sizeOf (undefined :: VkComponentSwizzle),
            I## o <- vkAByteOffset (undefined :: VkComponentMapping) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkA #-}
        vkAByteOffset ~_ = #{offset VkComponentMapping, a}

        {-# INLINE vkAByteOffset #-}
        readVkA (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkComponentSwizzle),
            I## o <- vkAByteOffset (undefined :: VkComponentMapping) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkA #-}
        writeVkA (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAByteOffset (undefined :: VkComponentMapping) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkA #-}

instance Show VkComponentMapping where
        showsPrec d x
          = showString "VkComponentMapping {" .
              showString "vkR = " .
                showsPrec d (vkR x) .
                  showString ", " .
                    showString "vkG = " .
                      showsPrec d (vkG x) .
                        showString ", " .
                          showString "vkB = " .
                            showsPrec d (vkB x) .
                              showString ", " .
                                showString "vkA = " . showsPrec d (vkA x) . showChar '}'

data VkPhysicalDeviceProperties = VkPhysicalDeviceProperties## ByteArray##

instance Eq VkPhysicalDeviceProperties where
        (VkPhysicalDeviceProperties## a) == (VkPhysicalDeviceProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPhysicalDeviceProperties where
        (VkPhysicalDeviceProperties## a) `compare`
          (VkPhysicalDeviceProperties## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPhysicalDeviceProperties where
        sizeOf ~_ = #{size VkPhysicalDeviceProperties}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPhysicalDeviceProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPhysicalDeviceProperties##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPhysicalDeviceProperties## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPhysicalDeviceProperties where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPhysicalDeviceProperties##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPhysicalDeviceProperties## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPhysicalDeviceProperties## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPhysicalDeviceProperties## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPhysicalDeviceProperties## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkApiVersion a where
        type VkApiVersionMType a :: *

        vkApiVersion :: a -> VkApiVersionMType a

        vkApiVersionByteOffset :: a -> Int

        readVkApiVersion :: Mutable a -> IO (VkApiVersionMType a)

        writeVkApiVersion :: Mutable a -> VkApiVersionMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'apiVersion'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkApiVersion a

instance {-# OVERLAPPING #-}
         HasVkApiVersion VkPhysicalDeviceProperties where
        type VkApiVersionMType VkPhysicalDeviceProperties =
             Data.Word.Word32
        vkApiVersion (VkPhysicalDeviceProperties## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkApiVersionByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkApiVersion #-}
        vkApiVersionByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, apiVersion}

        {-# INLINE vkApiVersionByteOffset #-}
        readVkApiVersion (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkApiVersionByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkApiVersion #-}
        writeVkApiVersion (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkApiVersionByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkApiVersion #-}

class HasVkDriverVersion a where
        type VkDriverVersionMType a :: *

        vkDriverVersion :: a -> VkDriverVersionMType a

        vkDriverVersionByteOffset :: a -> Int

        readVkDriverVersion :: Mutable a -> IO (VkDriverVersionMType a)

        writeVkDriverVersion ::
                             Mutable a -> VkDriverVersionMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'driverVersion'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDriverVersion a

instance {-# OVERLAPPING #-}
         HasVkDriverVersion VkPhysicalDeviceProperties where
        type VkDriverVersionMType VkPhysicalDeviceProperties =
             Data.Word.Word32
        vkDriverVersion (VkPhysicalDeviceProperties## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDriverVersionByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDriverVersion #-}
        vkDriverVersionByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, driverVersion}

        {-# INLINE vkDriverVersionByteOffset #-}
        readVkDriverVersion (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDriverVersionByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDriverVersion #-}
        writeVkDriverVersion (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDriverVersionByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDriverVersion #-}

class HasVkVendorID a where
        type VkVendorIDMType a :: *

        vkVendorID :: a -> VkVendorIDMType a

        vkVendorIDByteOffset :: a -> Int

        readVkVendorID :: Mutable a -> IO (VkVendorIDMType a)

        writeVkVendorID :: Mutable a -> VkVendorIDMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'vendorID'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkVendorID a

instance {-# OVERLAPPING #-}
         HasVkVendorID VkPhysicalDeviceProperties where
        type VkVendorIDMType VkPhysicalDeviceProperties = Data.Word.Word32
        vkVendorID (VkPhysicalDeviceProperties## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkVendorIDByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkVendorID #-}
        vkVendorIDByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, vendorID}

        {-# INLINE vkVendorIDByteOffset #-}
        readVkVendorID (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkVendorIDByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkVendorID #-}
        writeVkVendorID (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkVendorIDByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkVendorID #-}

class HasVkDeviceID a where
        type VkDeviceIDMType a :: *

        vkDeviceID :: a -> VkDeviceIDMType a

        vkDeviceIDByteOffset :: a -> Int

        readVkDeviceID :: Mutable a -> IO (VkDeviceIDMType a)

        writeVkDeviceID :: Mutable a -> VkDeviceIDMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'deviceID'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDeviceID a

instance {-# OVERLAPPING #-}
         HasVkDeviceID VkPhysicalDeviceProperties where
        type VkDeviceIDMType VkPhysicalDeviceProperties = Data.Word.Word32
        vkDeviceID (VkPhysicalDeviceProperties## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDeviceIDByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDeviceID #-}
        vkDeviceIDByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, deviceID}

        {-# INLINE vkDeviceIDByteOffset #-}
        readVkDeviceID (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDeviceIDByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDeviceID #-}
        writeVkDeviceID (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDeviceIDByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDeviceID #-}

class HasVkDeviceType a where
        type VkDeviceTypeMType a :: *

        vkDeviceType :: a -> VkDeviceTypeMType a

        vkDeviceTypeByteOffset :: a -> Int

        readVkDeviceType :: Mutable a -> IO (VkDeviceTypeMType a)

        writeVkDeviceType :: Mutable a -> VkDeviceTypeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'deviceType'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDeviceType a

instance {-# OVERLAPPING #-}
         HasVkDeviceType VkPhysicalDeviceProperties where
        type VkDeviceTypeMType VkPhysicalDeviceProperties =
             VkPhysicalDeviceType
        vkDeviceType (VkPhysicalDeviceProperties## ba)
          | I## _n <- sizeOf (undefined :: VkPhysicalDeviceType),
            I## o <- vkDeviceTypeByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDeviceType #-}
        vkDeviceTypeByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, deviceType}

        {-# INLINE vkDeviceTypeByteOffset #-}
        readVkDeviceType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPhysicalDeviceType),
            I## o <- vkDeviceTypeByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDeviceType #-}
        writeVkDeviceType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDeviceTypeByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDeviceType #-}

class HasVkDeviceNameArray a where
        type VkDeviceNameArrayMType a :: *

        vkDeviceNameArray :: a -> Int -> VkDeviceNameArrayMType a

        vkDeviceNameArrayByteOffset :: a -> Int

        readVkDeviceNameArray ::
                              Mutable a -> Int -> IO (VkDeviceNameArrayMType a)

        writeVkDeviceNameArray ::
                               Mutable a -> Int -> VkDeviceNameArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'deviceName'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDeviceNameArray a

instance {-# OVERLAPPING #-}
         HasVkDeviceNameArray VkPhysicalDeviceProperties where
        type VkDeviceNameArrayMType VkPhysicalDeviceProperties =
             Foreign.C.Types.CChar
        vkDeviceNameArray (VkPhysicalDeviceProperties## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CChar),
            I## o <- vkDeviceNameArrayByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkDeviceNameArray #-}
        vkDeviceNameArrayByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, deviceName}

        {-# INLINE vkDeviceNameArrayByteOffset #-}
        readVkDeviceNameArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CChar),
            I## o <- vkDeviceNameArrayByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkDeviceNameArray #-}
        writeVkDeviceNameArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkDeviceNameArrayByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkDeviceNameArray #-}

class HasVkPipelineCacheUUIDArray a where
        type VkPipelineCacheUUIDArrayMType a :: *

        vkPipelineCacheUUIDArray ::
                                 a -> Int -> VkPipelineCacheUUIDArrayMType a

        vkPipelineCacheUUIDArrayByteOffset :: a -> Int

        readVkPipelineCacheUUIDArray ::
                                     Mutable a -> Int -> IO (VkPipelineCacheUUIDArrayMType a)

        writeVkPipelineCacheUUIDArray ::
                                      Mutable a -> Int -> VkPipelineCacheUUIDArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pipelineCacheUUID'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPipelineCacheUUIDArray a

instance {-# OVERLAPPING #-}
         HasVkPipelineCacheUUIDArray VkPhysicalDeviceProperties where
        type VkPipelineCacheUUIDArrayMType VkPhysicalDeviceProperties =
             Data.Word.Word8
        vkPipelineCacheUUIDArray (VkPhysicalDeviceProperties## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: Data.Word.Word8),
            I## o <- vkPipelineCacheUUIDArrayByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkPipelineCacheUUIDArray #-}
        vkPipelineCacheUUIDArrayByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, pipelineCacheUUID}

        {-# INLINE vkPipelineCacheUUIDArrayByteOffset #-}
        readVkPipelineCacheUUIDArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Data.Word.Word8),
            I## o <- vkPipelineCacheUUIDArrayByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkPipelineCacheUUIDArray #-}
        writeVkPipelineCacheUUIDArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkPipelineCacheUUIDArrayByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkPipelineCacheUUIDArray #-}

class HasVkLimits a where
        type VkLimitsMType a :: *

        vkLimits :: a -> VkLimitsMType a

        vkLimitsByteOffset :: a -> Int

        readVkLimits :: Mutable a -> IO (VkLimitsMType a)

        writeVkLimits :: Mutable a -> VkLimitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'limits'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLimits a

instance {-# OVERLAPPING #-} HasVkLimits VkPhysicalDeviceProperties
         where
        type VkLimitsMType VkPhysicalDeviceProperties =
             VkPhysicalDeviceLimits
        vkLimits (VkPhysicalDeviceProperties## ba)
          | I## _n <- sizeOf (undefined :: VkPhysicalDeviceLimits),
            I## o <- vkLimitsByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLimits #-}
        vkLimitsByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, limits}

        {-# INLINE vkLimitsByteOffset #-}
        readVkLimits (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPhysicalDeviceLimits),
            I## o <- vkLimitsByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLimits #-}
        writeVkLimits (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLimitsByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLimits #-}

class HasVkSparseProperties a where
        type VkSparsePropertiesMType a :: *

        vkSparseProperties :: a -> VkSparsePropertiesMType a

        vkSparsePropertiesByteOffset :: a -> Int

        readVkSparseProperties ::
                               Mutable a -> IO (VkSparsePropertiesMType a)

        writeVkSparseProperties ::
                                Mutable a -> VkSparsePropertiesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseProperties'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseProperties a

instance {-# OVERLAPPING #-}
         HasVkSparseProperties VkPhysicalDeviceProperties where
        type VkSparsePropertiesMType VkPhysicalDeviceProperties =
             VkPhysicalDeviceSparseProperties
        vkSparseProperties (VkPhysicalDeviceProperties## ba)
          | I## _n <- sizeOf (undefined :: VkPhysicalDeviceSparseProperties),
            I## o <- vkSparsePropertiesByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSparseProperties #-}
        vkSparsePropertiesByteOffset ~_
          = #{offset VkPhysicalDeviceProperties, sparseProperties}

        {-# INLINE vkSparsePropertiesByteOffset #-}
        readVkSparseProperties (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPhysicalDeviceSparseProperties),
            I## o <- vkSparsePropertiesByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSparseProperties #-}
        writeVkSparseProperties (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSparsePropertiesByteOffset
                      (undefined :: VkPhysicalDeviceProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSparseProperties #-}

instance Show VkPhysicalDeviceProperties where
        showsPrec d x
          = showString "VkPhysicalDeviceProperties {" .
              showString "vkApiVersion = " .
                showsPrec d (vkApiVersion x) .
                  showString ", " .
                    showString "vkDriverVersion = " .
                      showsPrec d (vkDriverVersion x) .
                        showString ", " .
                          showString "vkVendorID = " .
                            showsPrec d (vkVendorID x) .
                              showString ", " .
                                showString "vkDeviceID = " .
                                  showsPrec d (vkDeviceID x) .
                                    showString ", " .
                                      showString "vkDeviceType = " .
                                        showsPrec d (vkDeviceType x) .
                                          showString ", " .
                                            showString "vkDeviceNameArray = [" .
                                              showsPrec d
                                                (map (vkDeviceNameArray x)
                                                   [1 .. VK_MAX_PHYSICAL_DEVICE_NAME_SIZE])
                                                .
                                                showChar ']' .
                                                  showString ", " .
                                                    showString "vkPipelineCacheUUIDArray = [" .
                                                      showsPrec d
                                                        (map (vkPipelineCacheUUIDArray x)
                                                           [1 .. VK_UUID_SIZE])
                                                        .
                                                        showChar ']' .
                                                          showString ", " .
                                                            showString "vkLimits = " .
                                                              showsPrec d (vkLimits x) .
                                                                showString ", " .
                                                                  showString "vkSparseProperties = "
                                                                    .
                                                                    showsPrec d
                                                                      (vkSparseProperties x)
                                                                      . showChar '}'

data VkExtensionProperties = VkExtensionProperties## ByteArray##

instance Eq VkExtensionProperties where
        (VkExtensionProperties## a) == (VkExtensionProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkExtensionProperties where
        (VkExtensionProperties## a) `compare` (VkExtensionProperties## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkExtensionProperties where
        sizeOf ~_ = #{size VkExtensionProperties}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkExtensionProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkExtensionProperties),
            I## a <- alignment (undefined :: VkExtensionProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkExtensionProperties## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkExtensionProperties## ba)
          | I## n <- sizeOf (undefined :: VkExtensionProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkExtensionProperties where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkExtensionProperties),
            I## a <- alignment (undefined :: VkExtensionProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkExtensionProperties##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkExtensionProperties## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkExtensionProperties## ba)
          | I## n <- sizeOf (undefined :: VkExtensionProperties),
            I## a <- alignment (undefined :: VkExtensionProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkExtensionProperties## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkExtensionProperties## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkExtensionNameArray a where
        type VkExtensionNameArrayMType a :: *

        vkExtensionNameArray :: a -> Int -> VkExtensionNameArrayMType a

        vkExtensionNameArrayByteOffset :: a -> Int

        readVkExtensionNameArray ::
                                 Mutable a -> Int -> IO (VkExtensionNameArrayMType a)

        writeVkExtensionNameArray ::
                                  Mutable a -> Int -> VkExtensionNameArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'extensionName'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkExtensionNameArray a

instance {-# OVERLAPPING #-}
         HasVkExtensionNameArray VkExtensionProperties where
        type VkExtensionNameArrayMType VkExtensionProperties =
             Foreign.C.Types.CChar
        vkExtensionNameArray (VkExtensionProperties## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CChar),
            I## o <- vkExtensionNameArrayByteOffset
                      (undefined :: VkExtensionProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkExtensionNameArray #-}
        vkExtensionNameArrayByteOffset ~_
          = #{offset VkExtensionProperties, extensionName}

        {-# INLINE vkExtensionNameArrayByteOffset #-}
        readVkExtensionNameArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CChar),
            I## o <- vkExtensionNameArrayByteOffset
                      (undefined :: VkExtensionProperties)
            =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkExtensionNameArray #-}
        writeVkExtensionNameArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkExtensionNameArrayByteOffset
                      (undefined :: VkExtensionProperties)
            =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkExtensionNameArray #-}

class HasVkSpecVersion a where
        type VkSpecVersionMType a :: *

        vkSpecVersion :: a -> VkSpecVersionMType a

        vkSpecVersionByteOffset :: a -> Int

        readVkSpecVersion :: Mutable a -> IO (VkSpecVersionMType a)

        writeVkSpecVersion :: Mutable a -> VkSpecVersionMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'specVersion'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSpecVersion a

instance {-# OVERLAPPING #-} HasVkSpecVersion VkExtensionProperties
         where
        type VkSpecVersionMType VkExtensionProperties = Data.Word.Word32
        vkSpecVersion (VkExtensionProperties## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSpecVersionByteOffset
                      (undefined :: VkExtensionProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSpecVersion #-}
        vkSpecVersionByteOffset ~_
          = #{offset VkExtensionProperties, specVersion}

        {-# INLINE vkSpecVersionByteOffset #-}
        readVkSpecVersion (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSpecVersionByteOffset
                      (undefined :: VkExtensionProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSpecVersion #-}
        writeVkSpecVersion (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSpecVersionByteOffset
                      (undefined :: VkExtensionProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSpecVersion #-}

instance Show VkExtensionProperties where
        showsPrec d x
          = showString "VkExtensionProperties {" .
              showString "vkExtensionNameArray = [" .
                showsPrec d
                  (map (vkExtensionNameArray x) [1 .. VK_MAX_EXTENSION_NAME_SIZE])
                  .
                  showChar ']' .
                    showString ", " .
                      showString "vkSpecVersion = " .
                        showsPrec d (vkSpecVersion x) . showChar '}'

data VkLayerProperties = VkLayerProperties## ByteArray##

instance Eq VkLayerProperties where
        (VkLayerProperties## a) == (VkLayerProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkLayerProperties where
        (VkLayerProperties## a) `compare` (VkLayerProperties## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkLayerProperties where
        sizeOf ~_ = #{size VkLayerProperties}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkLayerProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkLayerProperties),
            I## a <- alignment (undefined :: VkLayerProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkLayerProperties## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkLayerProperties## ba)
          | I## n <- sizeOf (undefined :: VkLayerProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkLayerProperties where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkLayerProperties),
            I## a <- alignment (undefined :: VkLayerProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkLayerProperties## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkLayerProperties## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkLayerProperties## ba)
          | I## n <- sizeOf (undefined :: VkLayerProperties),
            I## a <- alignment (undefined :: VkLayerProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkLayerProperties## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkLayerProperties## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkLayerNameArray a where
        type VkLayerNameArrayMType a :: *

        vkLayerNameArray :: a -> Int -> VkLayerNameArrayMType a

        vkLayerNameArrayByteOffset :: a -> Int

        readVkLayerNameArray ::
                             Mutable a -> Int -> IO (VkLayerNameArrayMType a)

        writeVkLayerNameArray ::
                              Mutable a -> Int -> VkLayerNameArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'layerName'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLayerNameArray a

instance {-# OVERLAPPING #-} HasVkLayerNameArray VkLayerProperties
         where
        type VkLayerNameArrayMType VkLayerProperties =
             Foreign.C.Types.CChar
        vkLayerNameArray (VkLayerProperties## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CChar),
            I## o <- vkLayerNameArrayByteOffset (undefined :: VkLayerProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkLayerNameArray #-}
        vkLayerNameArrayByteOffset ~_
          = #{offset VkLayerProperties, layerName}

        {-# INLINE vkLayerNameArrayByteOffset #-}
        readVkLayerNameArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CChar),
            I## o <- vkLayerNameArrayByteOffset (undefined :: VkLayerProperties)
            =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkLayerNameArray #-}
        writeVkLayerNameArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkLayerNameArrayByteOffset (undefined :: VkLayerProperties)
            =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkLayerNameArray #-}

instance {-# OVERLAPPING #-} HasVkSpecVersion VkLayerProperties
         where
        type VkSpecVersionMType VkLayerProperties = Data.Word.Word32
        vkSpecVersion (VkLayerProperties## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSpecVersionByteOffset (undefined :: VkLayerProperties) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSpecVersion #-}
        vkSpecVersionByteOffset ~_
          = #{offset VkLayerProperties, specVersion}

        {-# INLINE vkSpecVersionByteOffset #-}
        readVkSpecVersion (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSpecVersionByteOffset (undefined :: VkLayerProperties) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSpecVersion #-}
        writeVkSpecVersion (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSpecVersionByteOffset (undefined :: VkLayerProperties) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSpecVersion #-}

class HasVkImplementationVersion a where
        type VkImplementationVersionMType a :: *

        vkImplementationVersion :: a -> VkImplementationVersionMType a

        vkImplementationVersionByteOffset :: a -> Int

        readVkImplementationVersion ::
                                    Mutable a -> IO (VkImplementationVersionMType a)

        writeVkImplementationVersion ::
                                     Mutable a -> VkImplementationVersionMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'implementationVersion'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImplementationVersion a

instance {-# OVERLAPPING #-}
         HasVkImplementationVersion VkLayerProperties where
        type VkImplementationVersionMType VkLayerProperties =
             Data.Word.Word32
        vkImplementationVersion (VkLayerProperties## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkImplementationVersionByteOffset
                      (undefined :: VkLayerProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImplementationVersion #-}
        vkImplementationVersionByteOffset ~_
          = #{offset VkLayerProperties, implementationVersion}

        {-# INLINE vkImplementationVersionByteOffset #-}
        readVkImplementationVersion (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkImplementationVersionByteOffset
                      (undefined :: VkLayerProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImplementationVersion #-}
        writeVkImplementationVersion (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImplementationVersionByteOffset
                      (undefined :: VkLayerProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImplementationVersion #-}

class HasVkDescriptionArray a where
        type VkDescriptionArrayMType a :: *

        vkDescriptionArray :: a -> Int -> VkDescriptionArrayMType a

        vkDescriptionArrayByteOffset :: a -> Int

        readVkDescriptionArray ::
                               Mutable a -> Int -> IO (VkDescriptionArrayMType a)

        writeVkDescriptionArray ::
                                Mutable a -> Int -> VkDescriptionArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'description'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDescriptionArray a

instance {-# OVERLAPPING #-}
         HasVkDescriptionArray VkLayerProperties where
        type VkDescriptionArrayMType VkLayerProperties =
             Foreign.C.Types.CChar
        vkDescriptionArray (VkLayerProperties## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CChar),
            I## o <- vkDescriptionArrayByteOffset
                      (undefined :: VkLayerProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkDescriptionArray #-}
        vkDescriptionArrayByteOffset ~_
          = #{offset VkLayerProperties, description}

        {-# INLINE vkDescriptionArrayByteOffset #-}
        readVkDescriptionArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CChar),
            I## o <- vkDescriptionArrayByteOffset
                      (undefined :: VkLayerProperties)
            =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkDescriptionArray #-}
        writeVkDescriptionArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkDescriptionArrayByteOffset
                      (undefined :: VkLayerProperties)
            =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkDescriptionArray #-}

instance Show VkLayerProperties where
        showsPrec d x
          = showString "VkLayerProperties {" .
              showString "vkLayerNameArray = [" .
                showsPrec d
                  (map (vkLayerNameArray x) [1 .. VK_MAX_EXTENSION_NAME_SIZE])
                  .
                  showChar ']' .
                    showString ", " .
                      showString "vkSpecVersion = " .
                        showsPrec d (vkSpecVersion x) .
                          showString ", " .
                            showString "vkImplementationVersion = " .
                              showsPrec d (vkImplementationVersion x) .
                                showString ", " .
                                  showString "vkDescriptionArray = [" .
                                    showsPrec d
                                      (map (vkDescriptionArray x) [1 .. VK_MAX_DESCRIPTION_SIZE])
                                      . showChar ']' . showChar '}'

data VkApplicationInfo = VkApplicationInfo## ByteArray##

instance Eq VkApplicationInfo where
        (VkApplicationInfo## a) == (VkApplicationInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkApplicationInfo where
        (VkApplicationInfo## a) `compare` (VkApplicationInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkApplicationInfo where
        sizeOf ~_ = #{size VkApplicationInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkApplicationInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkApplicationInfo),
            I## a <- alignment (undefined :: VkApplicationInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkApplicationInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkApplicationInfo## ba)
          | I## n <- sizeOf (undefined :: VkApplicationInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkApplicationInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkApplicationInfo),
            I## a <- alignment (undefined :: VkApplicationInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkApplicationInfo## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkApplicationInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkApplicationInfo## ba)
          | I## n <- sizeOf (undefined :: VkApplicationInfo),
            I## a <- alignment (undefined :: VkApplicationInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkApplicationInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkApplicationInfo## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkSType a where
        type VkSTypeMType a :: *

        vkSType :: a -> VkSTypeMType a

        vkSTypeByteOffset :: a -> Int

        readVkSType :: Mutable a -> IO (VkSTypeMType a)

        writeVkSType :: Mutable a -> VkSTypeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sType'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSType a

instance {-# OVERLAPPING #-} HasVkSType VkApplicationInfo where
        type VkSTypeMType VkApplicationInfo = VkStructureType
        vkSType (VkApplicationInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkApplicationInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_ = #{offset VkApplicationInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkApplicationInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkApplicationInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

class HasVkPNext a where
        type VkPNextMType a :: *

        vkPNext :: a -> VkPNextMType a

        vkPNextByteOffset :: a -> Int

        readVkPNext :: Mutable a -> IO (VkPNextMType a)

        writeVkPNext :: Mutable a -> VkPNextMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pNext'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPNext a

instance {-# OVERLAPPING #-} HasVkPNext VkApplicationInfo where
        type VkPNextMType VkApplicationInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkApplicationInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkApplicationInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_ = #{offset VkApplicationInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkApplicationInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkApplicationInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

class HasVkPApplicationName a where
        type VkPApplicationNameMType a :: *

        vkPApplicationName :: a -> VkPApplicationNameMType a

        vkPApplicationNameByteOffset :: a -> Int

        readVkPApplicationName ::
                               Mutable a -> IO (VkPApplicationNameMType a)

        writeVkPApplicationName ::
                                Mutable a -> VkPApplicationNameMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pApplicationName'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPApplicationName a

instance {-# OVERLAPPING #-}
         HasVkPApplicationName VkApplicationInfo where
        type VkPApplicationNameMType VkApplicationInfo =
             Foreign.Ptr.Ptr Foreign.C.Types.CChar
        vkPApplicationName (VkApplicationInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr Foreign.C.Types.CChar),
            I## o <- vkPApplicationNameByteOffset
                      (undefined :: VkApplicationInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPApplicationName #-}
        vkPApplicationNameByteOffset ~_
          = #{offset VkApplicationInfo, pApplicationName}

        {-# INLINE vkPApplicationNameByteOffset #-}
        readVkPApplicationName (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr Foreign.C.Types.CChar),
            I## o <- vkPApplicationNameByteOffset
                      (undefined :: VkApplicationInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPApplicationName #-}
        writeVkPApplicationName (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPApplicationNameByteOffset
                      (undefined :: VkApplicationInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPApplicationName #-}

class HasVkApplicationVersion a where
        type VkApplicationVersionMType a :: *

        vkApplicationVersion :: a -> VkApplicationVersionMType a

        vkApplicationVersionByteOffset :: a -> Int

        readVkApplicationVersion ::
                                 Mutable a -> IO (VkApplicationVersionMType a)

        writeVkApplicationVersion ::
                                  Mutable a -> VkApplicationVersionMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'applicationVersion'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkApplicationVersion a

instance {-# OVERLAPPING #-}
         HasVkApplicationVersion VkApplicationInfo where
        type VkApplicationVersionMType VkApplicationInfo = Data.Word.Word32
        vkApplicationVersion (VkApplicationInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkApplicationVersionByteOffset
                      (undefined :: VkApplicationInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkApplicationVersion #-}
        vkApplicationVersionByteOffset ~_
          = #{offset VkApplicationInfo, applicationVersion}

        {-# INLINE vkApplicationVersionByteOffset #-}
        readVkApplicationVersion (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkApplicationVersionByteOffset
                      (undefined :: VkApplicationInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkApplicationVersion #-}
        writeVkApplicationVersion (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkApplicationVersionByteOffset
                      (undefined :: VkApplicationInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkApplicationVersion #-}

class HasVkPEngineName a where
        type VkPEngineNameMType a :: *

        vkPEngineName :: a -> VkPEngineNameMType a

        vkPEngineNameByteOffset :: a -> Int

        readVkPEngineName :: Mutable a -> IO (VkPEngineNameMType a)

        writeVkPEngineName :: Mutable a -> VkPEngineNameMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pEngineName'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPEngineName a

instance {-# OVERLAPPING #-} HasVkPEngineName VkApplicationInfo
         where
        type VkPEngineNameMType VkApplicationInfo =
             Foreign.Ptr.Ptr Foreign.C.Types.CChar
        vkPEngineName (VkApplicationInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr Foreign.C.Types.CChar),
            I## o <- vkPEngineNameByteOffset (undefined :: VkApplicationInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPEngineName #-}
        vkPEngineNameByteOffset ~_
          = #{offset VkApplicationInfo, pEngineName}

        {-# INLINE vkPEngineNameByteOffset #-}
        readVkPEngineName (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr Foreign.C.Types.CChar),
            I## o <- vkPEngineNameByteOffset (undefined :: VkApplicationInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPEngineName #-}
        writeVkPEngineName (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPEngineNameByteOffset (undefined :: VkApplicationInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPEngineName #-}

class HasVkEngineVersion a where
        type VkEngineVersionMType a :: *

        vkEngineVersion :: a -> VkEngineVersionMType a

        vkEngineVersionByteOffset :: a -> Int

        readVkEngineVersion :: Mutable a -> IO (VkEngineVersionMType a)

        writeVkEngineVersion ::
                             Mutable a -> VkEngineVersionMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'engineVersion'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkEngineVersion a

instance {-# OVERLAPPING #-} HasVkEngineVersion VkApplicationInfo
         where
        type VkEngineVersionMType VkApplicationInfo = Data.Word.Word32
        vkEngineVersion (VkApplicationInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkEngineVersionByteOffset (undefined :: VkApplicationInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkEngineVersion #-}
        vkEngineVersionByteOffset ~_
          = #{offset VkApplicationInfo, engineVersion}

        {-# INLINE vkEngineVersionByteOffset #-}
        readVkEngineVersion (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkEngineVersionByteOffset (undefined :: VkApplicationInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkEngineVersion #-}
        writeVkEngineVersion (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkEngineVersionByteOffset (undefined :: VkApplicationInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkEngineVersion #-}

instance {-# OVERLAPPING #-} HasVkApiVersion VkApplicationInfo
         where
        type VkApiVersionMType VkApplicationInfo = Data.Word.Word32
        vkApiVersion (VkApplicationInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkApiVersionByteOffset (undefined :: VkApplicationInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkApiVersion #-}
        vkApiVersionByteOffset ~_
          = #{offset VkApplicationInfo, apiVersion}

        {-# INLINE vkApiVersionByteOffset #-}
        readVkApiVersion (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkApiVersionByteOffset (undefined :: VkApplicationInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkApiVersion #-}
        writeVkApiVersion (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkApiVersionByteOffset (undefined :: VkApplicationInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkApiVersion #-}

instance Show VkApplicationInfo where
        showsPrec d x
          = showString "VkApplicationInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkPApplicationName = " .
                            showsPrec d (vkPApplicationName x) .
                              showString ", " .
                                showString "vkApplicationVersion = " .
                                  showsPrec d (vkApplicationVersion x) .
                                    showString ", " .
                                      showString "vkPEngineName = " .
                                        showsPrec d (vkPEngineName x) .
                                          showString ", " .
                                            showString "vkEngineVersion = " .
                                              showsPrec d (vkEngineVersion x) .
                                                showString ", " .
                                                  showString "vkApiVersion = " .
                                                    showsPrec d (vkApiVersion x) . showChar '}'

data VkAllocationCallbacks = VkAllocationCallbacks## ByteArray##

instance Eq VkAllocationCallbacks where
        (VkAllocationCallbacks## a) == (VkAllocationCallbacks## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkAllocationCallbacks where
        (VkAllocationCallbacks## a) `compare` (VkAllocationCallbacks## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkAllocationCallbacks where
        sizeOf ~_ = #{size VkAllocationCallbacks}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkAllocationCallbacks}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkAllocationCallbacks),
            I## a <- alignment (undefined :: VkAllocationCallbacks) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkAllocationCallbacks## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkAllocationCallbacks## ba)
          | I## n <- sizeOf (undefined :: VkAllocationCallbacks) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkAllocationCallbacks where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkAllocationCallbacks),
            I## a <- alignment (undefined :: VkAllocationCallbacks) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkAllocationCallbacks##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkAllocationCallbacks## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkAllocationCallbacks## ba)
          | I## n <- sizeOf (undefined :: VkAllocationCallbacks),
            I## a <- alignment (undefined :: VkAllocationCallbacks) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkAllocationCallbacks## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkAllocationCallbacks## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkPUserData a where
        type VkPUserDataMType a :: *

        vkPUserData :: a -> VkPUserDataMType a

        vkPUserDataByteOffset :: a -> Int

        readVkPUserData :: Mutable a -> IO (VkPUserDataMType a)

        writeVkPUserData :: Mutable a -> VkPUserDataMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pUserData'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPUserData a

instance {-# OVERLAPPING #-} HasVkPUserData VkAllocationCallbacks
         where
        type VkPUserDataMType VkAllocationCallbacks =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPUserData (VkAllocationCallbacks## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPUserDataByteOffset (undefined :: VkAllocationCallbacks)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPUserData #-}
        vkPUserDataByteOffset ~_
          = #{offset VkAllocationCallbacks, pUserData}

        {-# INLINE vkPUserDataByteOffset #-}
        readVkPUserData (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPUserDataByteOffset (undefined :: VkAllocationCallbacks)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPUserData #-}
        writeVkPUserData (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPUserDataByteOffset (undefined :: VkAllocationCallbacks)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPUserData #-}

class HasVkPfnAllocation a where
        type VkPfnAllocationMType a :: *

        vkPfnAllocation :: a -> VkPfnAllocationMType a

        vkPfnAllocationByteOffset :: a -> Int

        readVkPfnAllocation :: Mutable a -> IO (VkPfnAllocationMType a)

        writeVkPfnAllocation ::
                             Mutable a -> VkPfnAllocationMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pfnAllocation'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPfnAllocation a

instance {-# OVERLAPPING #-}
         HasVkPfnAllocation VkAllocationCallbacks where
        type VkPfnAllocationMType VkAllocationCallbacks =
             PFN_vkAllocationFunction
        vkPfnAllocation (VkAllocationCallbacks## ba)
          | I## _n <- sizeOf (undefined :: PFN_vkAllocationFunction),
            I## o <- vkPfnAllocationByteOffset
                      (undefined :: VkAllocationCallbacks)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPfnAllocation #-}
        vkPfnAllocationByteOffset ~_
          = #{offset VkAllocationCallbacks, pfnAllocation}

        {-# INLINE vkPfnAllocationByteOffset #-}
        readVkPfnAllocation (Mutable## mba)
          | I## _n <- sizeOf (undefined :: PFN_vkAllocationFunction),
            I## o <- vkPfnAllocationByteOffset
                      (undefined :: VkAllocationCallbacks)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPfnAllocation #-}
        writeVkPfnAllocation (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPfnAllocationByteOffset
                      (undefined :: VkAllocationCallbacks)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPfnAllocation #-}

class HasVkPfnReallocation a where
        type VkPfnReallocationMType a :: *

        vkPfnReallocation :: a -> VkPfnReallocationMType a

        vkPfnReallocationByteOffset :: a -> Int

        readVkPfnReallocation :: Mutable a -> IO (VkPfnReallocationMType a)

        writeVkPfnReallocation ::
                               Mutable a -> VkPfnReallocationMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pfnReallocation'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPfnReallocation a

instance {-# OVERLAPPING #-}
         HasVkPfnReallocation VkAllocationCallbacks where
        type VkPfnReallocationMType VkAllocationCallbacks =
             PFN_vkReallocationFunction
        vkPfnReallocation (VkAllocationCallbacks## ba)
          | I## _n <- sizeOf (undefined :: PFN_vkReallocationFunction),
            I## o <- vkPfnReallocationByteOffset
                      (undefined :: VkAllocationCallbacks)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPfnReallocation #-}
        vkPfnReallocationByteOffset ~_
          = #{offset VkAllocationCallbacks, pfnReallocation}

        {-# INLINE vkPfnReallocationByteOffset #-}
        readVkPfnReallocation (Mutable## mba)
          | I## _n <- sizeOf (undefined :: PFN_vkReallocationFunction),
            I## o <- vkPfnReallocationByteOffset
                      (undefined :: VkAllocationCallbacks)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPfnReallocation #-}
        writeVkPfnReallocation (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPfnReallocationByteOffset
                      (undefined :: VkAllocationCallbacks)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPfnReallocation #-}

class HasVkPfnFree a where
        type VkPfnFreeMType a :: *

        vkPfnFree :: a -> VkPfnFreeMType a

        vkPfnFreeByteOffset :: a -> Int

        readVkPfnFree :: Mutable a -> IO (VkPfnFreeMType a)

        writeVkPfnFree :: Mutable a -> VkPfnFreeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pfnFree'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPfnFree a

instance {-# OVERLAPPING #-} HasVkPfnFree VkAllocationCallbacks
         where
        type VkPfnFreeMType VkAllocationCallbacks = PFN_vkFreeFunction
        vkPfnFree (VkAllocationCallbacks## ba)
          | I## _n <- sizeOf (undefined :: PFN_vkFreeFunction),
            I## o <- vkPfnFreeByteOffset (undefined :: VkAllocationCallbacks) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPfnFree #-}
        vkPfnFreeByteOffset ~_
          = #{offset VkAllocationCallbacks, pfnFree}

        {-# INLINE vkPfnFreeByteOffset #-}
        readVkPfnFree (Mutable## mba)
          | I## _n <- sizeOf (undefined :: PFN_vkFreeFunction),
            I## o <- vkPfnFreeByteOffset (undefined :: VkAllocationCallbacks) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPfnFree #-}
        writeVkPfnFree (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPfnFreeByteOffset (undefined :: VkAllocationCallbacks) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPfnFree #-}

class HasVkPfnInternalAllocation a where
        type VkPfnInternalAllocationMType a :: *

        vkPfnInternalAllocation :: a -> VkPfnInternalAllocationMType a

        vkPfnInternalAllocationByteOffset :: a -> Int

        readVkPfnInternalAllocation ::
                                    Mutable a -> IO (VkPfnInternalAllocationMType a)

        writeVkPfnInternalAllocation ::
                                     Mutable a -> VkPfnInternalAllocationMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pfnInternalAllocation'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPfnInternalAllocation a

instance {-# OVERLAPPING #-}
         HasVkPfnInternalAllocation VkAllocationCallbacks where
        type VkPfnInternalAllocationMType VkAllocationCallbacks =
             PFN_vkInternalAllocationNotification
        vkPfnInternalAllocation (VkAllocationCallbacks## ba)
          | I## _n <- sizeOf
                       (undefined :: PFN_vkInternalAllocationNotification),
            I## o <- vkPfnInternalAllocationByteOffset
                      (undefined :: VkAllocationCallbacks)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPfnInternalAllocation #-}
        vkPfnInternalAllocationByteOffset ~_
          = #{offset VkAllocationCallbacks, pfnInternalAllocation}

        {-# INLINE vkPfnInternalAllocationByteOffset #-}
        readVkPfnInternalAllocation (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: PFN_vkInternalAllocationNotification),
            I## o <- vkPfnInternalAllocationByteOffset
                      (undefined :: VkAllocationCallbacks)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPfnInternalAllocation #-}
        writeVkPfnInternalAllocation (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPfnInternalAllocationByteOffset
                      (undefined :: VkAllocationCallbacks)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPfnInternalAllocation #-}

class HasVkPfnInternalFree a where
        type VkPfnInternalFreeMType a :: *

        vkPfnInternalFree :: a -> VkPfnInternalFreeMType a

        vkPfnInternalFreeByteOffset :: a -> Int

        readVkPfnInternalFree :: Mutable a -> IO (VkPfnInternalFreeMType a)

        writeVkPfnInternalFree ::
                               Mutable a -> VkPfnInternalFreeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pfnInternalFree'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPfnInternalFree a

instance {-# OVERLAPPING #-}
         HasVkPfnInternalFree VkAllocationCallbacks where
        type VkPfnInternalFreeMType VkAllocationCallbacks =
             PFN_vkInternalFreeNotification
        vkPfnInternalFree (VkAllocationCallbacks## ba)
          | I## _n <- sizeOf (undefined :: PFN_vkInternalFreeNotification),
            I## o <- vkPfnInternalFreeByteOffset
                      (undefined :: VkAllocationCallbacks)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPfnInternalFree #-}
        vkPfnInternalFreeByteOffset ~_
          = #{offset VkAllocationCallbacks, pfnInternalFree}

        {-# INLINE vkPfnInternalFreeByteOffset #-}
        readVkPfnInternalFree (Mutable## mba)
          | I## _n <- sizeOf (undefined :: PFN_vkInternalFreeNotification),
            I## o <- vkPfnInternalFreeByteOffset
                      (undefined :: VkAllocationCallbacks)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPfnInternalFree #-}
        writeVkPfnInternalFree (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPfnInternalFreeByteOffset
                      (undefined :: VkAllocationCallbacks)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPfnInternalFree #-}

instance Show VkAllocationCallbacks where
        showsPrec d x
          = showString "VkAllocationCallbacks {" .
              showString "vkPUserData = " .
                showsPrec d (vkPUserData x) .
                  showString ", " .
                    showString "vkPfnAllocation = " .
                      showsPrec d (vkPfnAllocation x) .
                        showString ", " .
                          showString "vkPfnReallocation = " .
                            showsPrec d (vkPfnReallocation x) .
                              showString ", " .
                                showString "vkPfnFree = " .
                                  showsPrec d (vkPfnFree x) .
                                    showString ", " .
                                      showString "vkPfnInternalAllocation = " .
                                        showsPrec d (vkPfnInternalAllocation x) .
                                          showString ", " .
                                            showString "vkPfnInternalFree = " .
                                              showsPrec d (vkPfnInternalFree x) . showChar '}'

data VkDeviceQueueCreateInfo = VkDeviceQueueCreateInfo## ByteArray##

instance Eq VkDeviceQueueCreateInfo where
        (VkDeviceQueueCreateInfo## a) == (VkDeviceQueueCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDeviceQueueCreateInfo where
        (VkDeviceQueueCreateInfo## a) `compare` (VkDeviceQueueCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDeviceQueueCreateInfo where
        sizeOf ~_ = #{size VkDeviceQueueCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDeviceQueueCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDeviceQueueCreateInfo),
            I## a <- alignment (undefined :: VkDeviceQueueCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDeviceQueueCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDeviceQueueCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDeviceQueueCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDeviceQueueCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkDeviceQueueCreateInfo),
            I## a <- alignment (undefined :: VkDeviceQueueCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkDeviceQueueCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkDeviceQueueCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkDeviceQueueCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDeviceQueueCreateInfo),
            I## a <- alignment (undefined :: VkDeviceQueueCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkDeviceQueueCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkDeviceQueueCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkDeviceQueueCreateInfo
         where
        type VkSTypeMType VkDeviceQueueCreateInfo = VkStructureType
        vkSType (VkDeviceQueueCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkDeviceQueueCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkDeviceQueueCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkDeviceQueueCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkDeviceQueueCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkDeviceQueueCreateInfo
         where
        type VkPNextMType VkDeviceQueueCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkDeviceQueueCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkDeviceQueueCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkDeviceQueueCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkDeviceQueueCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkDeviceQueueCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

class HasVkFlags a where
        type VkFlagsMType a :: *

        vkFlags :: a -> VkFlagsMType a

        vkFlagsByteOffset :: a -> Int

        readVkFlags :: Mutable a -> IO (VkFlagsMType a)

        writeVkFlags :: Mutable a -> VkFlagsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'flags'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFlags a

instance {-# OVERLAPPING #-} HasVkFlags VkDeviceQueueCreateInfo
         where
        type VkFlagsMType VkDeviceQueueCreateInfo =
             VkDeviceQueueCreateFlags
        vkFlags (VkDeviceQueueCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceQueueCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkDeviceQueueCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkDeviceQueueCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceQueueCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkDeviceQueueCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkDeviceQueueCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkQueueFamilyIndex a where
        type VkQueueFamilyIndexMType a :: *

        vkQueueFamilyIndex :: a -> VkQueueFamilyIndexMType a

        vkQueueFamilyIndexByteOffset :: a -> Int

        readVkQueueFamilyIndex ::
                               Mutable a -> IO (VkQueueFamilyIndexMType a)

        writeVkQueueFamilyIndex ::
                                Mutable a -> VkQueueFamilyIndexMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queueFamilyIndex'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueueFamilyIndex a

instance {-# OVERLAPPING #-}
         HasVkQueueFamilyIndex VkDeviceQueueCreateInfo where
        type VkQueueFamilyIndexMType VkDeviceQueueCreateInfo =
             Data.Word.Word32
        vkQueueFamilyIndex (VkDeviceQueueCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueFamilyIndexByteOffset
                      (undefined :: VkDeviceQueueCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkQueueFamilyIndex #-}
        vkQueueFamilyIndexByteOffset ~_
          = #{offset VkDeviceQueueCreateInfo, queueFamilyIndex}

        {-# INLINE vkQueueFamilyIndexByteOffset #-}
        readVkQueueFamilyIndex (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueFamilyIndexByteOffset
                      (undefined :: VkDeviceQueueCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkQueueFamilyIndex #-}
        writeVkQueueFamilyIndex (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkQueueFamilyIndexByteOffset
                      (undefined :: VkDeviceQueueCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkQueueFamilyIndex #-}

class HasVkQueueCount a where
        type VkQueueCountMType a :: *

        vkQueueCount :: a -> VkQueueCountMType a

        vkQueueCountByteOffset :: a -> Int

        readVkQueueCount :: Mutable a -> IO (VkQueueCountMType a)

        writeVkQueueCount :: Mutable a -> VkQueueCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queueCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueueCount a

instance {-# OVERLAPPING #-}
         HasVkQueueCount VkDeviceQueueCreateInfo where
        type VkQueueCountMType VkDeviceQueueCreateInfo = Data.Word.Word32
        vkQueueCount (VkDeviceQueueCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueCountByteOffset
                      (undefined :: VkDeviceQueueCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkQueueCount #-}
        vkQueueCountByteOffset ~_
          = #{offset VkDeviceQueueCreateInfo, queueCount}

        {-# INLINE vkQueueCountByteOffset #-}
        readVkQueueCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueCountByteOffset
                      (undefined :: VkDeviceQueueCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkQueueCount #-}
        writeVkQueueCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkQueueCountByteOffset
                      (undefined :: VkDeviceQueueCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkQueueCount #-}

class HasVkPQueuePriorities a where
        type VkPQueuePrioritiesMType a :: *

        vkPQueuePriorities :: a -> VkPQueuePrioritiesMType a

        vkPQueuePrioritiesByteOffset :: a -> Int

        readVkPQueuePriorities ::
                               Mutable a -> IO (VkPQueuePrioritiesMType a)

        writeVkPQueuePriorities ::
                                Mutable a -> VkPQueuePrioritiesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pQueuePriorities'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPQueuePriorities a

instance {-# OVERLAPPING #-}
         HasVkPQueuePriorities VkDeviceQueueCreateInfo where
        type VkPQueuePrioritiesMType VkDeviceQueueCreateInfo =
             Foreign.Ptr.Ptr Foreign.C.Types.CFloat
        vkPQueuePriorities (VkDeviceQueueCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr Foreign.C.Types.CFloat),
            I## o <- vkPQueuePrioritiesByteOffset
                      (undefined :: VkDeviceQueueCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPQueuePriorities #-}
        vkPQueuePrioritiesByteOffset ~_
          = #{offset VkDeviceQueueCreateInfo, pQueuePriorities}

        {-# INLINE vkPQueuePrioritiesByteOffset #-}
        readVkPQueuePriorities (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr Foreign.C.Types.CFloat),
            I## o <- vkPQueuePrioritiesByteOffset
                      (undefined :: VkDeviceQueueCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPQueuePriorities #-}
        writeVkPQueuePriorities (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPQueuePrioritiesByteOffset
                      (undefined :: VkDeviceQueueCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPQueuePriorities #-}

instance Show VkDeviceQueueCreateInfo where
        showsPrec d x
          = showString "VkDeviceQueueCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkQueueFamilyIndex = " .
                                  showsPrec d (vkQueueFamilyIndex x) .
                                    showString ", " .
                                      showString "vkQueueCount = " .
                                        showsPrec d (vkQueueCount x) .
                                          showString ", " .
                                            showString "vkPQueuePriorities = " .
                                              showsPrec d (vkPQueuePriorities x) . showChar '}'

data VkDeviceCreateInfo = VkDeviceCreateInfo## ByteArray##

instance Eq VkDeviceCreateInfo where
        (VkDeviceCreateInfo## a) == (VkDeviceCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDeviceCreateInfo where
        (VkDeviceCreateInfo## a) `compare` (VkDeviceCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDeviceCreateInfo where
        sizeOf ~_ = #{size VkDeviceCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDeviceCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDeviceCreateInfo),
            I## a <- alignment (undefined :: VkDeviceCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDeviceCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDeviceCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDeviceCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDeviceCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkDeviceCreateInfo),
            I## a <- alignment (undefined :: VkDeviceCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkDeviceCreateInfo## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkDeviceCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkDeviceCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDeviceCreateInfo),
            I## a <- alignment (undefined :: VkDeviceCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkDeviceCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkDeviceCreateInfo## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkDeviceCreateInfo where
        type VkSTypeMType VkDeviceCreateInfo = VkStructureType
        vkSType (VkDeviceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkDeviceCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_ = #{offset VkDeviceCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkDeviceCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkDeviceCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkDeviceCreateInfo where
        type VkPNextMType VkDeviceCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkDeviceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkDeviceCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_ = #{offset VkDeviceCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkDeviceCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkDeviceCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkDeviceCreateInfo where
        type VkFlagsMType VkDeviceCreateInfo = VkDeviceCreateFlags
        vkFlags (VkDeviceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkDeviceCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_ = #{offset VkDeviceCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkDeviceCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkDeviceCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkQueueCreateInfoCount a where
        type VkQueueCreateInfoCountMType a :: *

        vkQueueCreateInfoCount :: a -> VkQueueCreateInfoCountMType a

        vkQueueCreateInfoCountByteOffset :: a -> Int

        readVkQueueCreateInfoCount ::
                                   Mutable a -> IO (VkQueueCreateInfoCountMType a)

        writeVkQueueCreateInfoCount ::
                                    Mutable a -> VkQueueCreateInfoCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queueCreateInfoCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueueCreateInfoCount a

instance {-# OVERLAPPING #-}
         HasVkQueueCreateInfoCount VkDeviceCreateInfo where
        type VkQueueCreateInfoCountMType VkDeviceCreateInfo =
             Data.Word.Word32
        vkQueueCreateInfoCount (VkDeviceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueCreateInfoCountByteOffset
                      (undefined :: VkDeviceCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkQueueCreateInfoCount #-}
        vkQueueCreateInfoCountByteOffset ~_
          = #{offset VkDeviceCreateInfo, queueCreateInfoCount}

        {-# INLINE vkQueueCreateInfoCountByteOffset #-}
        readVkQueueCreateInfoCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueCreateInfoCountByteOffset
                      (undefined :: VkDeviceCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkQueueCreateInfoCount #-}
        writeVkQueueCreateInfoCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkQueueCreateInfoCountByteOffset
                      (undefined :: VkDeviceCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkQueueCreateInfoCount #-}

class HasVkPQueueCreateInfos a where
        type VkPQueueCreateInfosMType a :: *

        vkPQueueCreateInfos :: a -> VkPQueueCreateInfosMType a

        vkPQueueCreateInfosByteOffset :: a -> Int

        readVkPQueueCreateInfos ::
                                Mutable a -> IO (VkPQueueCreateInfosMType a)

        writeVkPQueueCreateInfos ::
                                 Mutable a -> VkPQueueCreateInfosMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pQueueCreateInfos'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPQueueCreateInfos a

instance {-# OVERLAPPING #-}
         HasVkPQueueCreateInfos VkDeviceCreateInfo where
        type VkPQueueCreateInfosMType VkDeviceCreateInfo =
             Foreign.Ptr.Ptr VkDeviceQueueCreateInfo
        vkPQueueCreateInfos (VkDeviceCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkDeviceQueueCreateInfo),
            I## o <- vkPQueueCreateInfosByteOffset
                      (undefined :: VkDeviceCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPQueueCreateInfos #-}
        vkPQueueCreateInfosByteOffset ~_
          = #{offset VkDeviceCreateInfo, pQueueCreateInfos}

        {-# INLINE vkPQueueCreateInfosByteOffset #-}
        readVkPQueueCreateInfos (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkDeviceQueueCreateInfo),
            I## o <- vkPQueueCreateInfosByteOffset
                      (undefined :: VkDeviceCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPQueueCreateInfos #-}
        writeVkPQueueCreateInfos (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPQueueCreateInfosByteOffset
                      (undefined :: VkDeviceCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPQueueCreateInfos #-}

class HasVkEnabledLayerCount a where
        type VkEnabledLayerCountMType a :: *

        vkEnabledLayerCount :: a -> VkEnabledLayerCountMType a

        vkEnabledLayerCountByteOffset :: a -> Int

        readVkEnabledLayerCount ::
                                Mutable a -> IO (VkEnabledLayerCountMType a)

        writeVkEnabledLayerCount ::
                                 Mutable a -> VkEnabledLayerCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'enabledLayerCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkEnabledLayerCount a

instance {-# OVERLAPPING #-}
         HasVkEnabledLayerCount VkDeviceCreateInfo where
        type VkEnabledLayerCountMType VkDeviceCreateInfo = Data.Word.Word32
        vkEnabledLayerCount (VkDeviceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkEnabledLayerCountByteOffset
                      (undefined :: VkDeviceCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkEnabledLayerCount #-}
        vkEnabledLayerCountByteOffset ~_
          = #{offset VkDeviceCreateInfo, enabledLayerCount}

        {-# INLINE vkEnabledLayerCountByteOffset #-}
        readVkEnabledLayerCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkEnabledLayerCountByteOffset
                      (undefined :: VkDeviceCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkEnabledLayerCount #-}
        writeVkEnabledLayerCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkEnabledLayerCountByteOffset
                      (undefined :: VkDeviceCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkEnabledLayerCount #-}

class HasVkPpEnabledLayerNames a where
        type VkPpEnabledLayerNamesMType a :: *

        vkPpEnabledLayerNames :: a -> VkPpEnabledLayerNamesMType a

        vkPpEnabledLayerNamesByteOffset :: a -> Int

        readVkPpEnabledLayerNames ::
                                  Mutable a -> IO (VkPpEnabledLayerNamesMType a)

        writeVkPpEnabledLayerNames ::
                                   Mutable a -> VkPpEnabledLayerNamesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'ppEnabledLayerNames'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPpEnabledLayerNames a

instance {-# OVERLAPPING #-}
         HasVkPpEnabledLayerNames VkDeviceCreateInfo where
        type VkPpEnabledLayerNamesMType VkDeviceCreateInfo =
             Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)
        vkPpEnabledLayerNames (VkDeviceCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)),
            I## o <- vkPpEnabledLayerNamesByteOffset
                      (undefined :: VkDeviceCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPpEnabledLayerNames #-}
        vkPpEnabledLayerNamesByteOffset ~_
          = #{offset VkDeviceCreateInfo, ppEnabledLayerNames}

        {-# INLINE vkPpEnabledLayerNamesByteOffset #-}
        readVkPpEnabledLayerNames (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)),
            I## o <- vkPpEnabledLayerNamesByteOffset
                      (undefined :: VkDeviceCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPpEnabledLayerNames #-}
        writeVkPpEnabledLayerNames (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPpEnabledLayerNamesByteOffset
                      (undefined :: VkDeviceCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPpEnabledLayerNames #-}

class HasVkEnabledExtensionCount a where
        type VkEnabledExtensionCountMType a :: *

        vkEnabledExtensionCount :: a -> VkEnabledExtensionCountMType a

        vkEnabledExtensionCountByteOffset :: a -> Int

        readVkEnabledExtensionCount ::
                                    Mutable a -> IO (VkEnabledExtensionCountMType a)

        writeVkEnabledExtensionCount ::
                                     Mutable a -> VkEnabledExtensionCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'enabledExtensionCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkEnabledExtensionCount a

instance {-# OVERLAPPING #-}
         HasVkEnabledExtensionCount VkDeviceCreateInfo where
        type VkEnabledExtensionCountMType VkDeviceCreateInfo =
             Data.Word.Word32
        vkEnabledExtensionCount (VkDeviceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkEnabledExtensionCountByteOffset
                      (undefined :: VkDeviceCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkEnabledExtensionCount #-}
        vkEnabledExtensionCountByteOffset ~_
          = #{offset VkDeviceCreateInfo, enabledExtensionCount}

        {-# INLINE vkEnabledExtensionCountByteOffset #-}
        readVkEnabledExtensionCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkEnabledExtensionCountByteOffset
                      (undefined :: VkDeviceCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkEnabledExtensionCount #-}
        writeVkEnabledExtensionCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkEnabledExtensionCountByteOffset
                      (undefined :: VkDeviceCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkEnabledExtensionCount #-}

class HasVkPpEnabledExtensionNames a where
        type VkPpEnabledExtensionNamesMType a :: *

        vkPpEnabledExtensionNames :: a -> VkPpEnabledExtensionNamesMType a

        vkPpEnabledExtensionNamesByteOffset :: a -> Int

        readVkPpEnabledExtensionNames ::
                                      Mutable a -> IO (VkPpEnabledExtensionNamesMType a)

        writeVkPpEnabledExtensionNames ::
                                       Mutable a -> VkPpEnabledExtensionNamesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'ppEnabledExtensionNames'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPpEnabledExtensionNames a

instance {-# OVERLAPPING #-}
         HasVkPpEnabledExtensionNames VkDeviceCreateInfo where
        type VkPpEnabledExtensionNamesMType VkDeviceCreateInfo =
             Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)
        vkPpEnabledExtensionNames (VkDeviceCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)),
            I## o <- vkPpEnabledExtensionNamesByteOffset
                      (undefined :: VkDeviceCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPpEnabledExtensionNames #-}
        vkPpEnabledExtensionNamesByteOffset ~_
          = #{offset VkDeviceCreateInfo, ppEnabledExtensionNames}

        {-# INLINE vkPpEnabledExtensionNamesByteOffset #-}
        readVkPpEnabledExtensionNames (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)),
            I## o <- vkPpEnabledExtensionNamesByteOffset
                      (undefined :: VkDeviceCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPpEnabledExtensionNames #-}
        writeVkPpEnabledExtensionNames (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPpEnabledExtensionNamesByteOffset
                      (undefined :: VkDeviceCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPpEnabledExtensionNames #-}

class HasVkPEnabledFeatures a where
        type VkPEnabledFeaturesMType a :: *

        vkPEnabledFeatures :: a -> VkPEnabledFeaturesMType a

        vkPEnabledFeaturesByteOffset :: a -> Int

        readVkPEnabledFeatures ::
                               Mutable a -> IO (VkPEnabledFeaturesMType a)

        writeVkPEnabledFeatures ::
                                Mutable a -> VkPEnabledFeaturesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pEnabledFeatures'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPEnabledFeatures a

instance {-# OVERLAPPING #-}
         HasVkPEnabledFeatures VkDeviceCreateInfo where
        type VkPEnabledFeaturesMType VkDeviceCreateInfo =
             Foreign.Ptr.Ptr VkPhysicalDeviceFeatures
        vkPEnabledFeatures (VkDeviceCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPhysicalDeviceFeatures),
            I## o <- vkPEnabledFeaturesByteOffset
                      (undefined :: VkDeviceCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPEnabledFeatures #-}
        vkPEnabledFeaturesByteOffset ~_
          = #{offset VkDeviceCreateInfo, pEnabledFeatures}

        {-# INLINE vkPEnabledFeaturesByteOffset #-}
        readVkPEnabledFeatures (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPhysicalDeviceFeatures),
            I## o <- vkPEnabledFeaturesByteOffset
                      (undefined :: VkDeviceCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPEnabledFeatures #-}
        writeVkPEnabledFeatures (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPEnabledFeaturesByteOffset
                      (undefined :: VkDeviceCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPEnabledFeatures #-}

instance Show VkDeviceCreateInfo where
        showsPrec d x
          = showString "VkDeviceCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkQueueCreateInfoCount = " .
                                  showsPrec d (vkQueueCreateInfoCount x) .
                                    showString ", " .
                                      showString "vkPQueueCreateInfos = " .
                                        showsPrec d (vkPQueueCreateInfos x) .
                                          showString ", " .
                                            showString "vkEnabledLayerCount = " .
                                              showsPrec d (vkEnabledLayerCount x) .
                                                showString ", " .
                                                  showString "vkPpEnabledLayerNames = " .
                                                    showsPrec d (vkPpEnabledLayerNames x) .
                                                      showString ", " .
                                                        showString "vkEnabledExtensionCount = " .
                                                          showsPrec d (vkEnabledExtensionCount x) .
                                                            showString ", " .
                                                              showString
                                                                "vkPpEnabledExtensionNames = "
                                                                .
                                                                showsPrec d
                                                                  (vkPpEnabledExtensionNames x)
                                                                  .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkPEnabledFeatures = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkPEnabledFeatures x)
                                                                        . showChar '}'

data VkInstanceCreateInfo = VkInstanceCreateInfo## ByteArray##

instance Eq VkInstanceCreateInfo where
        (VkInstanceCreateInfo## a) == (VkInstanceCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkInstanceCreateInfo where
        (VkInstanceCreateInfo## a) `compare` (VkInstanceCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkInstanceCreateInfo where
        sizeOf ~_ = #{size VkInstanceCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkInstanceCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkInstanceCreateInfo),
            I## a <- alignment (undefined :: VkInstanceCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkInstanceCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkInstanceCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkInstanceCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkInstanceCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkInstanceCreateInfo),
            I## a <- alignment (undefined :: VkInstanceCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkInstanceCreateInfo## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkInstanceCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkInstanceCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkInstanceCreateInfo),
            I## a <- alignment (undefined :: VkInstanceCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkInstanceCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkInstanceCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkInstanceCreateInfo where
        type VkSTypeMType VkInstanceCreateInfo = VkStructureType
        vkSType (VkInstanceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkInstanceCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkInstanceCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkInstanceCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkInstanceCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkInstanceCreateInfo where
        type VkPNextMType VkInstanceCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkInstanceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkInstanceCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkInstanceCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkInstanceCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkInstanceCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkInstanceCreateInfo where
        type VkFlagsMType VkInstanceCreateInfo = VkInstanceCreateFlags
        vkFlags (VkInstanceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkInstanceCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkInstanceCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkInstanceCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkInstanceCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkInstanceCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkInstanceCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkPApplicationInfo a where
        type VkPApplicationInfoMType a :: *

        vkPApplicationInfo :: a -> VkPApplicationInfoMType a

        vkPApplicationInfoByteOffset :: a -> Int

        readVkPApplicationInfo ::
                               Mutable a -> IO (VkPApplicationInfoMType a)

        writeVkPApplicationInfo ::
                                Mutable a -> VkPApplicationInfoMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pApplicationInfo'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPApplicationInfo a

instance {-# OVERLAPPING #-}
         HasVkPApplicationInfo VkInstanceCreateInfo where
        type VkPApplicationInfoMType VkInstanceCreateInfo =
             Foreign.Ptr.Ptr VkApplicationInfo
        vkPApplicationInfo (VkInstanceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkApplicationInfo),
            I## o <- vkPApplicationInfoByteOffset
                      (undefined :: VkInstanceCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPApplicationInfo #-}
        vkPApplicationInfoByteOffset ~_
          = #{offset VkInstanceCreateInfo, pApplicationInfo}

        {-# INLINE vkPApplicationInfoByteOffset #-}
        readVkPApplicationInfo (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkApplicationInfo),
            I## o <- vkPApplicationInfoByteOffset
                      (undefined :: VkInstanceCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPApplicationInfo #-}
        writeVkPApplicationInfo (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPApplicationInfoByteOffset
                      (undefined :: VkInstanceCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPApplicationInfo #-}

instance {-# OVERLAPPING #-}
         HasVkEnabledLayerCount VkInstanceCreateInfo where
        type VkEnabledLayerCountMType VkInstanceCreateInfo =
             Data.Word.Word32
        vkEnabledLayerCount (VkInstanceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkEnabledLayerCountByteOffset
                      (undefined :: VkInstanceCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkEnabledLayerCount #-}
        vkEnabledLayerCountByteOffset ~_
          = #{offset VkInstanceCreateInfo, enabledLayerCount}

        {-# INLINE vkEnabledLayerCountByteOffset #-}
        readVkEnabledLayerCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkEnabledLayerCountByteOffset
                      (undefined :: VkInstanceCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkEnabledLayerCount #-}
        writeVkEnabledLayerCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkEnabledLayerCountByteOffset
                      (undefined :: VkInstanceCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkEnabledLayerCount #-}

instance {-# OVERLAPPING #-}
         HasVkPpEnabledLayerNames VkInstanceCreateInfo where
        type VkPpEnabledLayerNamesMType VkInstanceCreateInfo =
             Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)
        vkPpEnabledLayerNames (VkInstanceCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)),
            I## o <- vkPpEnabledLayerNamesByteOffset
                      (undefined :: VkInstanceCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPpEnabledLayerNames #-}
        vkPpEnabledLayerNamesByteOffset ~_
          = #{offset VkInstanceCreateInfo, ppEnabledLayerNames}

        {-# INLINE vkPpEnabledLayerNamesByteOffset #-}
        readVkPpEnabledLayerNames (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)),
            I## o <- vkPpEnabledLayerNamesByteOffset
                      (undefined :: VkInstanceCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPpEnabledLayerNames #-}
        writeVkPpEnabledLayerNames (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPpEnabledLayerNamesByteOffset
                      (undefined :: VkInstanceCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPpEnabledLayerNames #-}

instance {-# OVERLAPPING #-}
         HasVkEnabledExtensionCount VkInstanceCreateInfo where
        type VkEnabledExtensionCountMType VkInstanceCreateInfo =
             Data.Word.Word32
        vkEnabledExtensionCount (VkInstanceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkEnabledExtensionCountByteOffset
                      (undefined :: VkInstanceCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkEnabledExtensionCount #-}
        vkEnabledExtensionCountByteOffset ~_
          = #{offset VkInstanceCreateInfo, enabledExtensionCount}

        {-# INLINE vkEnabledExtensionCountByteOffset #-}
        readVkEnabledExtensionCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkEnabledExtensionCountByteOffset
                      (undefined :: VkInstanceCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkEnabledExtensionCount #-}
        writeVkEnabledExtensionCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkEnabledExtensionCountByteOffset
                      (undefined :: VkInstanceCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkEnabledExtensionCount #-}

instance {-# OVERLAPPING #-}
         HasVkPpEnabledExtensionNames VkInstanceCreateInfo where
        type VkPpEnabledExtensionNamesMType VkInstanceCreateInfo =
             Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)
        vkPpEnabledExtensionNames (VkInstanceCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)),
            I## o <- vkPpEnabledExtensionNamesByteOffset
                      (undefined :: VkInstanceCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPpEnabledExtensionNames #-}
        vkPpEnabledExtensionNamesByteOffset ~_
          = #{offset VkInstanceCreateInfo, ppEnabledExtensionNames}

        {-# INLINE vkPpEnabledExtensionNamesByteOffset #-}
        readVkPpEnabledExtensionNames (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr (Foreign.Ptr.Ptr Foreign.C.Types.CChar)),
            I## o <- vkPpEnabledExtensionNamesByteOffset
                      (undefined :: VkInstanceCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPpEnabledExtensionNames #-}
        writeVkPpEnabledExtensionNames (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPpEnabledExtensionNamesByteOffset
                      (undefined :: VkInstanceCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPpEnabledExtensionNames #-}

instance Show VkInstanceCreateInfo where
        showsPrec d x
          = showString "VkInstanceCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkPApplicationInfo = " .
                                  showsPrec d (vkPApplicationInfo x) .
                                    showString ", " .
                                      showString "vkEnabledLayerCount = " .
                                        showsPrec d (vkEnabledLayerCount x) .
                                          showString ", " .
                                            showString "vkPpEnabledLayerNames = " .
                                              showsPrec d (vkPpEnabledLayerNames x) .
                                                showString ", " .
                                                  showString "vkEnabledExtensionCount = " .
                                                    showsPrec d (vkEnabledExtensionCount x) .
                                                      showString ", " .
                                                        showString "vkPpEnabledExtensionNames = " .
                                                          showsPrec d (vkPpEnabledExtensionNames x)
                                                            . showChar '}'

data VkQueueFamilyProperties = VkQueueFamilyProperties## ByteArray##

instance Eq VkQueueFamilyProperties where
        (VkQueueFamilyProperties## a) == (VkQueueFamilyProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkQueueFamilyProperties where
        (VkQueueFamilyProperties## a) `compare` (VkQueueFamilyProperties## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkQueueFamilyProperties where
        sizeOf ~_ = #{size VkQueueFamilyProperties}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkQueueFamilyProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkQueueFamilyProperties),
            I## a <- alignment (undefined :: VkQueueFamilyProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkQueueFamilyProperties##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkQueueFamilyProperties## ba)
          | I## n <- sizeOf (undefined :: VkQueueFamilyProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkQueueFamilyProperties where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkQueueFamilyProperties),
            I## a <- alignment (undefined :: VkQueueFamilyProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkQueueFamilyProperties##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkQueueFamilyProperties## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkQueueFamilyProperties## ba)
          | I## n <- sizeOf (undefined :: VkQueueFamilyProperties),
            I## a <- alignment (undefined :: VkQueueFamilyProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkQueueFamilyProperties## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkQueueFamilyProperties## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkQueueFlags a where
        type VkQueueFlagsMType a :: *

        vkQueueFlags :: a -> VkQueueFlagsMType a

        vkQueueFlagsByteOffset :: a -> Int

        readVkQueueFlags :: Mutable a -> IO (VkQueueFlagsMType a)

        writeVkQueueFlags :: Mutable a -> VkQueueFlagsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queueFlags'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueueFlags a

instance {-# OVERLAPPING #-}
         HasVkQueueFlags VkQueueFamilyProperties where
        type VkQueueFlagsMType VkQueueFamilyProperties = VkQueueFlags
        vkQueueFlags (VkQueueFamilyProperties## ba)
          | I## _n <- sizeOf (undefined :: VkQueueFlags),
            I## o <- vkQueueFlagsByteOffset
                      (undefined :: VkQueueFamilyProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkQueueFlags #-}
        vkQueueFlagsByteOffset ~_
          = #{offset VkQueueFamilyProperties, queueFlags}

        {-# INLINE vkQueueFlagsByteOffset #-}
        readVkQueueFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkQueueFlags),
            I## o <- vkQueueFlagsByteOffset
                      (undefined :: VkQueueFamilyProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkQueueFlags #-}
        writeVkQueueFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkQueueFlagsByteOffset
                      (undefined :: VkQueueFamilyProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkQueueFlags #-}

instance {-# OVERLAPPING #-}
         HasVkQueueCount VkQueueFamilyProperties where
        type VkQueueCountMType VkQueueFamilyProperties = Data.Word.Word32
        vkQueueCount (VkQueueFamilyProperties## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueCountByteOffset
                      (undefined :: VkQueueFamilyProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkQueueCount #-}
        vkQueueCountByteOffset ~_
          = #{offset VkQueueFamilyProperties, queueCount}

        {-# INLINE vkQueueCountByteOffset #-}
        readVkQueueCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueCountByteOffset
                      (undefined :: VkQueueFamilyProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkQueueCount #-}
        writeVkQueueCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkQueueCountByteOffset
                      (undefined :: VkQueueFamilyProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkQueueCount #-}

class HasVkTimestampValidBits a where
        type VkTimestampValidBitsMType a :: *

        vkTimestampValidBits :: a -> VkTimestampValidBitsMType a

        vkTimestampValidBitsByteOffset :: a -> Int

        readVkTimestampValidBits ::
                                 Mutable a -> IO (VkTimestampValidBitsMType a)

        writeVkTimestampValidBits ::
                                  Mutable a -> VkTimestampValidBitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'timestampValidBits'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTimestampValidBits a

instance {-# OVERLAPPING #-}
         HasVkTimestampValidBits VkQueueFamilyProperties where
        type VkTimestampValidBitsMType VkQueueFamilyProperties =
             Data.Word.Word32
        vkTimestampValidBits (VkQueueFamilyProperties## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkTimestampValidBitsByteOffset
                      (undefined :: VkQueueFamilyProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkTimestampValidBits #-}
        vkTimestampValidBitsByteOffset ~_
          = #{offset VkQueueFamilyProperties, timestampValidBits}

        {-# INLINE vkTimestampValidBitsByteOffset #-}
        readVkTimestampValidBits (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkTimestampValidBitsByteOffset
                      (undefined :: VkQueueFamilyProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkTimestampValidBits #-}
        writeVkTimestampValidBits (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkTimestampValidBitsByteOffset
                      (undefined :: VkQueueFamilyProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkTimestampValidBits #-}

class HasVkMinImageTransferGranularity a where
        type VkMinImageTransferGranularityMType a :: *

        vkMinImageTransferGranularity ::
                                      a -> VkMinImageTransferGranularityMType a

        vkMinImageTransferGranularityByteOffset :: a -> Int

        readVkMinImageTransferGranularity ::
                                          Mutable a -> IO (VkMinImageTransferGranularityMType a)

        writeVkMinImageTransferGranularity ::
                                           Mutable a ->
                                             VkMinImageTransferGranularityMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minImageTransferGranularity'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinImageTransferGranularity a

instance {-# OVERLAPPING #-}
         HasVkMinImageTransferGranularity VkQueueFamilyProperties where
        type VkMinImageTransferGranularityMType VkQueueFamilyProperties =
             VkExtent3D
        vkMinImageTransferGranularity (VkQueueFamilyProperties## ba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkMinImageTransferGranularityByteOffset
                      (undefined :: VkQueueFamilyProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinImageTransferGranularity #-}
        vkMinImageTransferGranularityByteOffset ~_
          = #{offset VkQueueFamilyProperties, minImageTransferGranularity}

        {-# INLINE vkMinImageTransferGranularityByteOffset #-}
        readVkMinImageTransferGranularity (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkMinImageTransferGranularityByteOffset
                      (undefined :: VkQueueFamilyProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinImageTransferGranularity #-}
        writeVkMinImageTransferGranularity (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinImageTransferGranularityByteOffset
                      (undefined :: VkQueueFamilyProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinImageTransferGranularity #-}

instance Show VkQueueFamilyProperties where
        showsPrec d x
          = showString "VkQueueFamilyProperties {" .
              showString "vkQueueFlags = " .
                showsPrec d (vkQueueFlags x) .
                  showString ", " .
                    showString "vkQueueCount = " .
                      showsPrec d (vkQueueCount x) .
                        showString ", " .
                          showString "vkTimestampValidBits = " .
                            showsPrec d (vkTimestampValidBits x) .
                              showString ", " .
                                showString "vkMinImageTransferGranularity = " .
                                  showsPrec d (vkMinImageTransferGranularity x) . showChar '}'

data VkPhysicalDeviceMemoryProperties = VkPhysicalDeviceMemoryProperties## ByteArray##

instance Eq VkPhysicalDeviceMemoryProperties where
        (VkPhysicalDeviceMemoryProperties## a) ==
          (VkPhysicalDeviceMemoryProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPhysicalDeviceMemoryProperties where
        (VkPhysicalDeviceMemoryProperties## a) `compare`
          (VkPhysicalDeviceMemoryProperties## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPhysicalDeviceMemoryProperties where
        sizeOf ~_ = #{size VkPhysicalDeviceMemoryProperties}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPhysicalDeviceMemoryProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceMemoryProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceMemoryProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPhysicalDeviceMemoryProperties##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPhysicalDeviceMemoryProperties## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceMemoryProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPhysicalDeviceMemoryProperties where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceMemoryProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceMemoryProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPhysicalDeviceMemoryProperties##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPhysicalDeviceMemoryProperties## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPhysicalDeviceMemoryProperties## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceMemoryProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceMemoryProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPhysicalDeviceMemoryProperties## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPhysicalDeviceMemoryProperties## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkMemoryTypeCount a where
        type VkMemoryTypeCountMType a :: *

        vkMemoryTypeCount :: a -> VkMemoryTypeCountMType a

        vkMemoryTypeCountByteOffset :: a -> Int

        readVkMemoryTypeCount :: Mutable a -> IO (VkMemoryTypeCountMType a)

        writeVkMemoryTypeCount ::
                               Mutable a -> VkMemoryTypeCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memoryTypeCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemoryTypeCount a

instance {-# OVERLAPPING #-}
         HasVkMemoryTypeCount VkPhysicalDeviceMemoryProperties where
        type VkMemoryTypeCountMType VkPhysicalDeviceMemoryProperties =
             Data.Word.Word32
        vkMemoryTypeCount (VkPhysicalDeviceMemoryProperties## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMemoryTypeCountByteOffset
                      (undefined :: VkPhysicalDeviceMemoryProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMemoryTypeCount #-}
        vkMemoryTypeCountByteOffset ~_
          = #{offset VkPhysicalDeviceMemoryProperties, memoryTypeCount}

        {-# INLINE vkMemoryTypeCountByteOffset #-}
        readVkMemoryTypeCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMemoryTypeCountByteOffset
                      (undefined :: VkPhysicalDeviceMemoryProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMemoryTypeCount #-}
        writeVkMemoryTypeCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMemoryTypeCountByteOffset
                      (undefined :: VkPhysicalDeviceMemoryProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMemoryTypeCount #-}

class HasVkMemoryTypesArray a where
        type VkMemoryTypesArrayMType a :: *

        vkMemoryTypesArray :: a -> Int -> VkMemoryTypesArrayMType a

        vkMemoryTypesArrayByteOffset :: a -> Int

        readVkMemoryTypesArray ::
                               Mutable a -> Int -> IO (VkMemoryTypesArrayMType a)

        writeVkMemoryTypesArray ::
                                Mutable a -> Int -> VkMemoryTypesArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memoryTypes'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemoryTypesArray a

instance {-# OVERLAPPING #-}
         HasVkMemoryTypesArray VkPhysicalDeviceMemoryProperties where
        type VkMemoryTypesArrayMType VkPhysicalDeviceMemoryProperties =
             VkMemoryType
        vkMemoryTypesArray (VkPhysicalDeviceMemoryProperties## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: VkMemoryType),
            I## o <- vkMemoryTypesArrayByteOffset
                      (undefined :: VkPhysicalDeviceMemoryProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkMemoryTypesArray #-}
        vkMemoryTypesArrayByteOffset ~_
          = #{offset VkPhysicalDeviceMemoryProperties, memoryTypes}

        {-# INLINE vkMemoryTypesArrayByteOffset #-}
        readVkMemoryTypesArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: VkMemoryType),
            I## o <- vkMemoryTypesArrayByteOffset
                      (undefined :: VkPhysicalDeviceMemoryProperties)
            =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkMemoryTypesArray #-}
        writeVkMemoryTypesArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkMemoryTypesArrayByteOffset
                      (undefined :: VkPhysicalDeviceMemoryProperties)
            =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkMemoryTypesArray #-}

class HasVkMemoryHeapCount a where
        type VkMemoryHeapCountMType a :: *

        vkMemoryHeapCount :: a -> VkMemoryHeapCountMType a

        vkMemoryHeapCountByteOffset :: a -> Int

        readVkMemoryHeapCount :: Mutable a -> IO (VkMemoryHeapCountMType a)

        writeVkMemoryHeapCount ::
                               Mutable a -> VkMemoryHeapCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memoryHeapCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemoryHeapCount a

instance {-# OVERLAPPING #-}
         HasVkMemoryHeapCount VkPhysicalDeviceMemoryProperties where
        type VkMemoryHeapCountMType VkPhysicalDeviceMemoryProperties =
             Data.Word.Word32
        vkMemoryHeapCount (VkPhysicalDeviceMemoryProperties## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMemoryHeapCountByteOffset
                      (undefined :: VkPhysicalDeviceMemoryProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMemoryHeapCount #-}
        vkMemoryHeapCountByteOffset ~_
          = #{offset VkPhysicalDeviceMemoryProperties, memoryHeapCount}

        {-# INLINE vkMemoryHeapCountByteOffset #-}
        readVkMemoryHeapCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMemoryHeapCountByteOffset
                      (undefined :: VkPhysicalDeviceMemoryProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMemoryHeapCount #-}
        writeVkMemoryHeapCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMemoryHeapCountByteOffset
                      (undefined :: VkPhysicalDeviceMemoryProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMemoryHeapCount #-}

class HasVkMemoryHeapsArray a where
        type VkMemoryHeapsArrayMType a :: *

        vkMemoryHeapsArray :: a -> Int -> VkMemoryHeapsArrayMType a

        vkMemoryHeapsArrayByteOffset :: a -> Int

        readVkMemoryHeapsArray ::
                               Mutable a -> Int -> IO (VkMemoryHeapsArrayMType a)

        writeVkMemoryHeapsArray ::
                                Mutable a -> Int -> VkMemoryHeapsArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memoryHeaps'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemoryHeapsArray a

instance {-# OVERLAPPING #-}
         HasVkMemoryHeapsArray VkPhysicalDeviceMemoryProperties where
        type VkMemoryHeapsArrayMType VkPhysicalDeviceMemoryProperties =
             VkMemoryHeap
        vkMemoryHeapsArray (VkPhysicalDeviceMemoryProperties## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: VkMemoryHeap),
            I## o <- vkMemoryHeapsArrayByteOffset
                      (undefined :: VkPhysicalDeviceMemoryProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkMemoryHeapsArray #-}
        vkMemoryHeapsArrayByteOffset ~_
          = #{offset VkPhysicalDeviceMemoryProperties, memoryHeaps}

        {-# INLINE vkMemoryHeapsArrayByteOffset #-}
        readVkMemoryHeapsArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: VkMemoryHeap),
            I## o <- vkMemoryHeapsArrayByteOffset
                      (undefined :: VkPhysicalDeviceMemoryProperties)
            =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkMemoryHeapsArray #-}
        writeVkMemoryHeapsArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkMemoryHeapsArrayByteOffset
                      (undefined :: VkPhysicalDeviceMemoryProperties)
            =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkMemoryHeapsArray #-}

instance Show VkPhysicalDeviceMemoryProperties where
        showsPrec d x
          = showString "VkPhysicalDeviceMemoryProperties {" .
              showString "vkMemoryTypeCount = " .
                showsPrec d (vkMemoryTypeCount x) .
                  showString ", " .
                    showString "vkMemoryTypesArray = [" .
                      showsPrec d (map (vkMemoryTypesArray x) [1 .. VK_MAX_MEMORY_TYPES])
                        .
                        showChar ']' .
                          showString ", " .
                            showString "vkMemoryHeapCount = " .
                              showsPrec d (vkMemoryHeapCount x) .
                                showString ", " .
                                  showString "vkMemoryHeapsArray = [" .
                                    showsPrec d
                                      (map (vkMemoryHeapsArray x) [1 .. VK_MAX_MEMORY_HEAPS])
                                      . showChar ']' . showChar '}'

data VkMemoryAllocateInfo = VkMemoryAllocateInfo## ByteArray##

instance Eq VkMemoryAllocateInfo where
        (VkMemoryAllocateInfo## a) == (VkMemoryAllocateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkMemoryAllocateInfo where
        (VkMemoryAllocateInfo## a) `compare` (VkMemoryAllocateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkMemoryAllocateInfo where
        sizeOf ~_ = #{size VkMemoryAllocateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkMemoryAllocateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkMemoryAllocateInfo),
            I## a <- alignment (undefined :: VkMemoryAllocateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkMemoryAllocateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkMemoryAllocateInfo## ba)
          | I## n <- sizeOf (undefined :: VkMemoryAllocateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkMemoryAllocateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkMemoryAllocateInfo),
            I## a <- alignment (undefined :: VkMemoryAllocateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkMemoryAllocateInfo## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkMemoryAllocateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkMemoryAllocateInfo## ba)
          | I## n <- sizeOf (undefined :: VkMemoryAllocateInfo),
            I## a <- alignment (undefined :: VkMemoryAllocateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkMemoryAllocateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkMemoryAllocateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkMemoryAllocateInfo where
        type VkSTypeMType VkMemoryAllocateInfo = VkStructureType
        vkSType (VkMemoryAllocateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkMemoryAllocateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkMemoryAllocateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkMemoryAllocateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkMemoryAllocateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkMemoryAllocateInfo where
        type VkPNextMType VkMemoryAllocateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkMemoryAllocateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkMemoryAllocateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkMemoryAllocateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkMemoryAllocateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkMemoryAllocateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

class HasVkAllocationSize a where
        type VkAllocationSizeMType a :: *

        vkAllocationSize :: a -> VkAllocationSizeMType a

        vkAllocationSizeByteOffset :: a -> Int

        readVkAllocationSize :: Mutable a -> IO (VkAllocationSizeMType a)

        writeVkAllocationSize ::
                              Mutable a -> VkAllocationSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'allocationSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAllocationSize a

instance {-# OVERLAPPING #-}
         HasVkAllocationSize VkMemoryAllocateInfo where
        type VkAllocationSizeMType VkMemoryAllocateInfo = VkDeviceSize
        vkAllocationSize (VkMemoryAllocateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkAllocationSizeByteOffset
                      (undefined :: VkMemoryAllocateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAllocationSize #-}
        vkAllocationSizeByteOffset ~_
          = #{offset VkMemoryAllocateInfo, allocationSize}

        {-# INLINE vkAllocationSizeByteOffset #-}
        readVkAllocationSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkAllocationSizeByteOffset
                      (undefined :: VkMemoryAllocateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAllocationSize #-}
        writeVkAllocationSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAllocationSizeByteOffset
                      (undefined :: VkMemoryAllocateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAllocationSize #-}

class HasVkMemoryTypeIndex a where
        type VkMemoryTypeIndexMType a :: *

        vkMemoryTypeIndex :: a -> VkMemoryTypeIndexMType a

        vkMemoryTypeIndexByteOffset :: a -> Int

        readVkMemoryTypeIndex :: Mutable a -> IO (VkMemoryTypeIndexMType a)

        writeVkMemoryTypeIndex ::
                               Mutable a -> VkMemoryTypeIndexMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memoryTypeIndex'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemoryTypeIndex a

instance {-# OVERLAPPING #-}
         HasVkMemoryTypeIndex VkMemoryAllocateInfo where
        type VkMemoryTypeIndexMType VkMemoryAllocateInfo = Data.Word.Word32
        vkMemoryTypeIndex (VkMemoryAllocateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMemoryTypeIndexByteOffset
                      (undefined :: VkMemoryAllocateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMemoryTypeIndex #-}
        vkMemoryTypeIndexByteOffset ~_
          = #{offset VkMemoryAllocateInfo, memoryTypeIndex}

        {-# INLINE vkMemoryTypeIndexByteOffset #-}
        readVkMemoryTypeIndex (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMemoryTypeIndexByteOffset
                      (undefined :: VkMemoryAllocateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMemoryTypeIndex #-}
        writeVkMemoryTypeIndex (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMemoryTypeIndexByteOffset
                      (undefined :: VkMemoryAllocateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMemoryTypeIndex #-}

instance Show VkMemoryAllocateInfo where
        showsPrec d x
          = showString "VkMemoryAllocateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkAllocationSize = " .
                            showsPrec d (vkAllocationSize x) .
                              showString ", " .
                                showString "vkMemoryTypeIndex = " .
                                  showsPrec d (vkMemoryTypeIndex x) . showChar '}'

data VkMemoryRequirements = VkMemoryRequirements## ByteArray##

instance Eq VkMemoryRequirements where
        (VkMemoryRequirements## a) == (VkMemoryRequirements## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkMemoryRequirements where
        (VkMemoryRequirements## a) `compare` (VkMemoryRequirements## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkMemoryRequirements where
        sizeOf ~_ = #{size VkMemoryRequirements}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkMemoryRequirements}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkMemoryRequirements),
            I## a <- alignment (undefined :: VkMemoryRequirements) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkMemoryRequirements## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkMemoryRequirements## ba)
          | I## n <- sizeOf (undefined :: VkMemoryRequirements) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkMemoryRequirements where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkMemoryRequirements),
            I## a <- alignment (undefined :: VkMemoryRequirements) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkMemoryRequirements## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkMemoryRequirements## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkMemoryRequirements## ba)
          | I## n <- sizeOf (undefined :: VkMemoryRequirements),
            I## a <- alignment (undefined :: VkMemoryRequirements) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkMemoryRequirements## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkMemoryRequirements## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkSize a where
        type VkSizeMType a :: *

        vkSize :: a -> VkSizeMType a

        vkSizeByteOffset :: a -> Int

        readVkSize :: Mutable a -> IO (VkSizeMType a)

        writeVkSize :: Mutable a -> VkSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'size'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSize a

instance {-# OVERLAPPING #-} HasVkSize VkMemoryRequirements where
        type VkSizeMType VkMemoryRequirements = VkDeviceSize
        vkSize (VkMemoryRequirements## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSizeByteOffset (undefined :: VkMemoryRequirements) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSize #-}
        vkSizeByteOffset ~_ = #{offset VkMemoryRequirements, size}

        {-# INLINE vkSizeByteOffset #-}
        readVkSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSizeByteOffset (undefined :: VkMemoryRequirements) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSize #-}
        writeVkSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSizeByteOffset (undefined :: VkMemoryRequirements) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSize #-}

class HasVkAlignment a where
        type VkAlignmentMType a :: *

        vkAlignment :: a -> VkAlignmentMType a

        vkAlignmentByteOffset :: a -> Int

        readVkAlignment :: Mutable a -> IO (VkAlignmentMType a)

        writeVkAlignment :: Mutable a -> VkAlignmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'alignment'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAlignment a

instance {-# OVERLAPPING #-} HasVkAlignment VkMemoryRequirements
         where
        type VkAlignmentMType VkMemoryRequirements = VkDeviceSize
        vkAlignment (VkMemoryRequirements## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkAlignmentByteOffset (undefined :: VkMemoryRequirements) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAlignment #-}
        vkAlignmentByteOffset ~_
          = #{offset VkMemoryRequirements, alignment}

        {-# INLINE vkAlignmentByteOffset #-}
        readVkAlignment (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkAlignmentByteOffset (undefined :: VkMemoryRequirements) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAlignment #-}
        writeVkAlignment (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAlignmentByteOffset (undefined :: VkMemoryRequirements) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAlignment #-}

class HasVkMemoryTypeBits a where
        type VkMemoryTypeBitsMType a :: *

        vkMemoryTypeBits :: a -> VkMemoryTypeBitsMType a

        vkMemoryTypeBitsByteOffset :: a -> Int

        readVkMemoryTypeBits :: Mutable a -> IO (VkMemoryTypeBitsMType a)

        writeVkMemoryTypeBits ::
                              Mutable a -> VkMemoryTypeBitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memoryTypeBits'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemoryTypeBits a

instance {-# OVERLAPPING #-}
         HasVkMemoryTypeBits VkMemoryRequirements where
        type VkMemoryTypeBitsMType VkMemoryRequirements = Data.Word.Word32
        vkMemoryTypeBits (VkMemoryRequirements## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMemoryTypeBitsByteOffset
                      (undefined :: VkMemoryRequirements)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMemoryTypeBits #-}
        vkMemoryTypeBitsByteOffset ~_
          = #{offset VkMemoryRequirements, memoryTypeBits}

        {-# INLINE vkMemoryTypeBitsByteOffset #-}
        readVkMemoryTypeBits (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMemoryTypeBitsByteOffset
                      (undefined :: VkMemoryRequirements)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMemoryTypeBits #-}
        writeVkMemoryTypeBits (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMemoryTypeBitsByteOffset
                      (undefined :: VkMemoryRequirements)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMemoryTypeBits #-}

instance Show VkMemoryRequirements where
        showsPrec d x
          = showString "VkMemoryRequirements {" .
              showString "vkSize = " .
                showsPrec d (vkSize x) .
                  showString ", " .
                    showString "vkAlignment = " .
                      showsPrec d (vkAlignment x) .
                        showString ", " .
                          showString "vkMemoryTypeBits = " .
                            showsPrec d (vkMemoryTypeBits x) . showChar '}'

data VkSparseImageFormatProperties = VkSparseImageFormatProperties## ByteArray##

instance Eq VkSparseImageFormatProperties where
        (VkSparseImageFormatProperties## a) ==
          (VkSparseImageFormatProperties## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSparseImageFormatProperties where
        (VkSparseImageFormatProperties## a) `compare`
          (VkSparseImageFormatProperties## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSparseImageFormatProperties where
        sizeOf ~_ = #{size VkSparseImageFormatProperties}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSparseImageFormatProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSparseImageFormatProperties),
            I## a <- alignment (undefined :: VkSparseImageFormatProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSparseImageFormatProperties##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSparseImageFormatProperties## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageFormatProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSparseImageFormatProperties where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSparseImageFormatProperties),
            I## a <- alignment (undefined :: VkSparseImageFormatProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSparseImageFormatProperties##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSparseImageFormatProperties## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSparseImageFormatProperties## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageFormatProperties),
            I## a <- alignment (undefined :: VkSparseImageFormatProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSparseImageFormatProperties## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSparseImageFormatProperties## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkAspectMask a where
        type VkAspectMaskMType a :: *

        vkAspectMask :: a -> VkAspectMaskMType a

        vkAspectMaskByteOffset :: a -> Int

        readVkAspectMask :: Mutable a -> IO (VkAspectMaskMType a)

        writeVkAspectMask :: Mutable a -> VkAspectMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'aspectMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAspectMask a

instance {-# OVERLAPPING #-}
         HasVkAspectMask VkSparseImageFormatProperties where
        type VkAspectMaskMType VkSparseImageFormatProperties =
             VkImageAspectFlags
        vkAspectMask (VkSparseImageFormatProperties## ba)
          | I## _n <- sizeOf (undefined :: VkImageAspectFlags),
            I## o <- vkAspectMaskByteOffset
                      (undefined :: VkSparseImageFormatProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAspectMask #-}
        vkAspectMaskByteOffset ~_
          = #{offset VkSparseImageFormatProperties, aspectMask}

        {-# INLINE vkAspectMaskByteOffset #-}
        readVkAspectMask (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageAspectFlags),
            I## o <- vkAspectMaskByteOffset
                      (undefined :: VkSparseImageFormatProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAspectMask #-}
        writeVkAspectMask (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAspectMaskByteOffset
                      (undefined :: VkSparseImageFormatProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAspectMask #-}

class HasVkImageGranularity a where
        type VkImageGranularityMType a :: *

        vkImageGranularity :: a -> VkImageGranularityMType a

        vkImageGranularityByteOffset :: a -> Int

        readVkImageGranularity ::
                               Mutable a -> IO (VkImageGranularityMType a)

        writeVkImageGranularity ::
                                Mutable a -> VkImageGranularityMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageGranularity'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageGranularity a

instance {-# OVERLAPPING #-}
         HasVkImageGranularity VkSparseImageFormatProperties where
        type VkImageGranularityMType VkSparseImageFormatProperties =
             VkExtent3D
        vkImageGranularity (VkSparseImageFormatProperties## ba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkImageGranularityByteOffset
                      (undefined :: VkSparseImageFormatProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageGranularity #-}
        vkImageGranularityByteOffset ~_
          = #{offset VkSparseImageFormatProperties, imageGranularity}

        {-# INLINE vkImageGranularityByteOffset #-}
        readVkImageGranularity (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkImageGranularityByteOffset
                      (undefined :: VkSparseImageFormatProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageGranularity #-}
        writeVkImageGranularity (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageGranularityByteOffset
                      (undefined :: VkSparseImageFormatProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageGranularity #-}

instance {-# OVERLAPPING #-}
         HasVkFlags VkSparseImageFormatProperties where
        type VkFlagsMType VkSparseImageFormatProperties =
             VkSparseImageFormatFlags
        vkFlags (VkSparseImageFormatProperties## ba)
          | I## _n <- sizeOf (undefined :: VkSparseImageFormatFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkSparseImageFormatProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkSparseImageFormatProperties, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSparseImageFormatFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkSparseImageFormatProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset
                      (undefined :: VkSparseImageFormatProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

instance Show VkSparseImageFormatProperties where
        showsPrec d x
          = showString "VkSparseImageFormatProperties {" .
              showString "vkAspectMask = " .
                showsPrec d (vkAspectMask x) .
                  showString ", " .
                    showString "vkImageGranularity = " .
                      showsPrec d (vkImageGranularity x) .
                        showString ", " .
                          showString "vkFlags = " . showsPrec d (vkFlags x) . showChar '}'

data VkSparseImageMemoryRequirements = VkSparseImageMemoryRequirements## ByteArray##

instance Eq VkSparseImageMemoryRequirements where
        (VkSparseImageMemoryRequirements## a) ==
          (VkSparseImageMemoryRequirements## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSparseImageMemoryRequirements where
        (VkSparseImageMemoryRequirements## a) `compare`
          (VkSparseImageMemoryRequirements## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSparseImageMemoryRequirements where
        sizeOf ~_ = #{size VkSparseImageMemoryRequirements}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSparseImageMemoryRequirements}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryRequirements),
            I## a <- alignment (undefined :: VkSparseImageMemoryRequirements) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSparseImageMemoryRequirements##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSparseImageMemoryRequirements## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryRequirements) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSparseImageMemoryRequirements where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryRequirements),
            I## a <- alignment (undefined :: VkSparseImageMemoryRequirements) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSparseImageMemoryRequirements##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSparseImageMemoryRequirements## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSparseImageMemoryRequirements## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryRequirements),
            I## a <- alignment (undefined :: VkSparseImageMemoryRequirements) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSparseImageMemoryRequirements## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSparseImageMemoryRequirements## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkFormatProperties a where
        type VkFormatPropertiesMType a :: *

        vkFormatProperties :: a -> VkFormatPropertiesMType a

        vkFormatPropertiesByteOffset :: a -> Int

        readVkFormatProperties ::
                               Mutable a -> IO (VkFormatPropertiesMType a)

        writeVkFormatProperties ::
                                Mutable a -> VkFormatPropertiesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'formatProperties'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFormatProperties a

instance {-# OVERLAPPING #-}
         HasVkFormatProperties VkSparseImageMemoryRequirements where
        type VkFormatPropertiesMType VkSparseImageMemoryRequirements =
             VkSparseImageFormatProperties
        vkFormatProperties (VkSparseImageMemoryRequirements## ba)
          | I## _n <- sizeOf (undefined :: VkSparseImageFormatProperties),
            I## o <- vkFormatPropertiesByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFormatProperties #-}
        vkFormatPropertiesByteOffset ~_
          = #{offset VkSparseImageMemoryRequirements, formatProperties}

        {-# INLINE vkFormatPropertiesByteOffset #-}
        readVkFormatProperties (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSparseImageFormatProperties),
            I## o <- vkFormatPropertiesByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFormatProperties #-}
        writeVkFormatProperties (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFormatPropertiesByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFormatProperties #-}

class HasVkImageMipTailFirstLod a where
        type VkImageMipTailFirstLodMType a :: *

        vkImageMipTailFirstLod :: a -> VkImageMipTailFirstLodMType a

        vkImageMipTailFirstLodByteOffset :: a -> Int

        readVkImageMipTailFirstLod ::
                                   Mutable a -> IO (VkImageMipTailFirstLodMType a)

        writeVkImageMipTailFirstLod ::
                                    Mutable a -> VkImageMipTailFirstLodMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageMipTailFirstLod'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageMipTailFirstLod a

instance {-# OVERLAPPING #-}
         HasVkImageMipTailFirstLod VkSparseImageMemoryRequirements where
        type VkImageMipTailFirstLodMType VkSparseImageMemoryRequirements =
             Data.Word.Word32
        vkImageMipTailFirstLod (VkSparseImageMemoryRequirements## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkImageMipTailFirstLodByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageMipTailFirstLod #-}
        vkImageMipTailFirstLodByteOffset ~_
          = #{offset VkSparseImageMemoryRequirements, imageMipTailFirstLod}

        {-# INLINE vkImageMipTailFirstLodByteOffset #-}
        readVkImageMipTailFirstLod (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkImageMipTailFirstLodByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageMipTailFirstLod #-}
        writeVkImageMipTailFirstLod (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageMipTailFirstLodByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageMipTailFirstLod #-}

class HasVkImageMipTailSize a where
        type VkImageMipTailSizeMType a :: *

        vkImageMipTailSize :: a -> VkImageMipTailSizeMType a

        vkImageMipTailSizeByteOffset :: a -> Int

        readVkImageMipTailSize ::
                               Mutable a -> IO (VkImageMipTailSizeMType a)

        writeVkImageMipTailSize ::
                                Mutable a -> VkImageMipTailSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageMipTailSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageMipTailSize a

instance {-# OVERLAPPING #-}
         HasVkImageMipTailSize VkSparseImageMemoryRequirements where
        type VkImageMipTailSizeMType VkSparseImageMemoryRequirements =
             VkDeviceSize
        vkImageMipTailSize (VkSparseImageMemoryRequirements## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkImageMipTailSizeByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageMipTailSize #-}
        vkImageMipTailSizeByteOffset ~_
          = #{offset VkSparseImageMemoryRequirements, imageMipTailSize}

        {-# INLINE vkImageMipTailSizeByteOffset #-}
        readVkImageMipTailSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkImageMipTailSizeByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageMipTailSize #-}
        writeVkImageMipTailSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageMipTailSizeByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageMipTailSize #-}

class HasVkImageMipTailOffset a where
        type VkImageMipTailOffsetMType a :: *

        vkImageMipTailOffset :: a -> VkImageMipTailOffsetMType a

        vkImageMipTailOffsetByteOffset :: a -> Int

        readVkImageMipTailOffset ::
                                 Mutable a -> IO (VkImageMipTailOffsetMType a)

        writeVkImageMipTailOffset ::
                                  Mutable a -> VkImageMipTailOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageMipTailOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageMipTailOffset a

instance {-# OVERLAPPING #-}
         HasVkImageMipTailOffset VkSparseImageMemoryRequirements where
        type VkImageMipTailOffsetMType VkSparseImageMemoryRequirements =
             VkDeviceSize
        vkImageMipTailOffset (VkSparseImageMemoryRequirements## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkImageMipTailOffsetByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageMipTailOffset #-}
        vkImageMipTailOffsetByteOffset ~_
          = #{offset VkSparseImageMemoryRequirements, imageMipTailOffset}

        {-# INLINE vkImageMipTailOffsetByteOffset #-}
        readVkImageMipTailOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkImageMipTailOffsetByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageMipTailOffset #-}
        writeVkImageMipTailOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageMipTailOffsetByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageMipTailOffset #-}

class HasVkImageMipTailStride a where
        type VkImageMipTailStrideMType a :: *

        vkImageMipTailStride :: a -> VkImageMipTailStrideMType a

        vkImageMipTailStrideByteOffset :: a -> Int

        readVkImageMipTailStride ::
                                 Mutable a -> IO (VkImageMipTailStrideMType a)

        writeVkImageMipTailStride ::
                                  Mutable a -> VkImageMipTailStrideMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageMipTailStride'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageMipTailStride a

instance {-# OVERLAPPING #-}
         HasVkImageMipTailStride VkSparseImageMemoryRequirements where
        type VkImageMipTailStrideMType VkSparseImageMemoryRequirements =
             VkDeviceSize
        vkImageMipTailStride (VkSparseImageMemoryRequirements## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkImageMipTailStrideByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageMipTailStride #-}
        vkImageMipTailStrideByteOffset ~_
          = #{offset VkSparseImageMemoryRequirements, imageMipTailStride}

        {-# INLINE vkImageMipTailStrideByteOffset #-}
        readVkImageMipTailStride (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkImageMipTailStrideByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageMipTailStride #-}
        writeVkImageMipTailStride (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageMipTailStrideByteOffset
                      (undefined :: VkSparseImageMemoryRequirements)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageMipTailStride #-}

instance Show VkSparseImageMemoryRequirements where
        showsPrec d x
          = showString "VkSparseImageMemoryRequirements {" .
              showString "vkFormatProperties = " .
                showsPrec d (vkFormatProperties x) .
                  showString ", " .
                    showString "vkImageMipTailFirstLod = " .
                      showsPrec d (vkImageMipTailFirstLod x) .
                        showString ", " .
                          showString "vkImageMipTailSize = " .
                            showsPrec d (vkImageMipTailSize x) .
                              showString ", " .
                                showString "vkImageMipTailOffset = " .
                                  showsPrec d (vkImageMipTailOffset x) .
                                    showString ", " .
                                      showString "vkImageMipTailStride = " .
                                        showsPrec d (vkImageMipTailStride x) . showChar '}'

data VkMemoryType = VkMemoryType## ByteArray##

instance Eq VkMemoryType where
        (VkMemoryType## a) == (VkMemoryType## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkMemoryType where
        (VkMemoryType## a) `compare` (VkMemoryType## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkMemoryType where
        sizeOf ~_ = #{size VkMemoryType}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkMemoryType}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkMemoryType),
            I## a <- alignment (undefined :: VkMemoryType) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkMemoryType## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkMemoryType## ba)
          | I## n <- sizeOf (undefined :: VkMemoryType) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkMemoryType where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkMemoryType),
            I## a <- alignment (undefined :: VkMemoryType) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkMemoryType## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkMemoryType## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkMemoryType## ba)
          | I## n <- sizeOf (undefined :: VkMemoryType),
            I## a <- alignment (undefined :: VkMemoryType) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkMemoryType## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkMemoryType## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkPropertyFlags a where
        type VkPropertyFlagsMType a :: *

        vkPropertyFlags :: a -> VkPropertyFlagsMType a

        vkPropertyFlagsByteOffset :: a -> Int

        readVkPropertyFlags :: Mutable a -> IO (VkPropertyFlagsMType a)

        writeVkPropertyFlags ::
                             Mutable a -> VkPropertyFlagsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'propertyFlags'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPropertyFlags a

instance {-# OVERLAPPING #-} HasVkPropertyFlags VkMemoryType where
        type VkPropertyFlagsMType VkMemoryType = VkMemoryPropertyFlags
        vkPropertyFlags (VkMemoryType## ba)
          | I## _n <- sizeOf (undefined :: VkMemoryPropertyFlags),
            I## o <- vkPropertyFlagsByteOffset (undefined :: VkMemoryType) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPropertyFlags #-}
        vkPropertyFlagsByteOffset ~_
          = #{offset VkMemoryType, propertyFlags}

        {-# INLINE vkPropertyFlagsByteOffset #-}
        readVkPropertyFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkMemoryPropertyFlags),
            I## o <- vkPropertyFlagsByteOffset (undefined :: VkMemoryType) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPropertyFlags #-}
        writeVkPropertyFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPropertyFlagsByteOffset (undefined :: VkMemoryType) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPropertyFlags #-}

class HasVkHeapIndex a where
        type VkHeapIndexMType a :: *

        vkHeapIndex :: a -> VkHeapIndexMType a

        vkHeapIndexByteOffset :: a -> Int

        readVkHeapIndex :: Mutable a -> IO (VkHeapIndexMType a)

        writeVkHeapIndex :: Mutable a -> VkHeapIndexMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'heapIndex'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkHeapIndex a

instance {-# OVERLAPPING #-} HasVkHeapIndex VkMemoryType where
        type VkHeapIndexMType VkMemoryType = Data.Word.Word32
        vkHeapIndex (VkMemoryType## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkHeapIndexByteOffset (undefined :: VkMemoryType) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkHeapIndex #-}
        vkHeapIndexByteOffset ~_
          = #{offset VkMemoryType, heapIndex}

        {-# INLINE vkHeapIndexByteOffset #-}
        readVkHeapIndex (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkHeapIndexByteOffset (undefined :: VkMemoryType) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkHeapIndex #-}
        writeVkHeapIndex (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkHeapIndexByteOffset (undefined :: VkMemoryType) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkHeapIndex #-}

instance Show VkMemoryType where
        showsPrec d x
          = showString "VkMemoryType {" .
              showString "vkPropertyFlags = " .
                showsPrec d (vkPropertyFlags x) .
                  showString ", " .
                    showString "vkHeapIndex = " .
                      showsPrec d (vkHeapIndex x) . showChar '}'

data VkMemoryHeap = VkMemoryHeap## ByteArray##

instance Eq VkMemoryHeap where
        (VkMemoryHeap## a) == (VkMemoryHeap## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkMemoryHeap where
        (VkMemoryHeap## a) `compare` (VkMemoryHeap## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkMemoryHeap where
        sizeOf ~_ = #{size VkMemoryHeap}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkMemoryHeap}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkMemoryHeap),
            I## a <- alignment (undefined :: VkMemoryHeap) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkMemoryHeap## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkMemoryHeap## ba)
          | I## n <- sizeOf (undefined :: VkMemoryHeap) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkMemoryHeap where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkMemoryHeap),
            I## a <- alignment (undefined :: VkMemoryHeap) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkMemoryHeap## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkMemoryHeap## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkMemoryHeap## ba)
          | I## n <- sizeOf (undefined :: VkMemoryHeap),
            I## a <- alignment (undefined :: VkMemoryHeap) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkMemoryHeap## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkMemoryHeap## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSize VkMemoryHeap where
        type VkSizeMType VkMemoryHeap = VkDeviceSize
        vkSize (VkMemoryHeap## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSizeByteOffset (undefined :: VkMemoryHeap) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSize #-}
        vkSizeByteOffset ~_ = #{offset VkMemoryHeap, size}

        {-# INLINE vkSizeByteOffset #-}
        readVkSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSizeByteOffset (undefined :: VkMemoryHeap) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSize #-}
        writeVkSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSizeByteOffset (undefined :: VkMemoryHeap) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSize #-}

instance {-# OVERLAPPING #-} HasVkFlags VkMemoryHeap where
        type VkFlagsMType VkMemoryHeap = VkMemoryHeapFlags
        vkFlags (VkMemoryHeap## ba)
          | I## _n <- sizeOf (undefined :: VkMemoryHeapFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkMemoryHeap) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_ = #{offset VkMemoryHeap, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkMemoryHeapFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkMemoryHeap) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkMemoryHeap) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

instance Show VkMemoryHeap where
        showsPrec d x
          = showString "VkMemoryHeap {" .
              showString "vkSize = " .
                showsPrec d (vkSize x) .
                  showString ", " .
                    showString "vkFlags = " . showsPrec d (vkFlags x) . showChar '}'

data VkMappedMemoryRange = VkMappedMemoryRange## ByteArray##

instance Eq VkMappedMemoryRange where
        (VkMappedMemoryRange## a) == (VkMappedMemoryRange## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkMappedMemoryRange where
        (VkMappedMemoryRange## a) `compare` (VkMappedMemoryRange## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkMappedMemoryRange where
        sizeOf ~_ = #{size VkMappedMemoryRange}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkMappedMemoryRange}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkMappedMemoryRange),
            I## a <- alignment (undefined :: VkMappedMemoryRange) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkMappedMemoryRange## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkMappedMemoryRange## ba)
          | I## n <- sizeOf (undefined :: VkMappedMemoryRange) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkMappedMemoryRange where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkMappedMemoryRange),
            I## a <- alignment (undefined :: VkMappedMemoryRange) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkMappedMemoryRange## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkMappedMemoryRange## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkMappedMemoryRange## ba)
          | I## n <- sizeOf (undefined :: VkMappedMemoryRange),
            I## a <- alignment (undefined :: VkMappedMemoryRange) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkMappedMemoryRange## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkMappedMemoryRange## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkMappedMemoryRange where
        type VkSTypeMType VkMappedMemoryRange = VkStructureType
        vkSType (VkMappedMemoryRange## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkMappedMemoryRange) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkMappedMemoryRange, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkMappedMemoryRange) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkMappedMemoryRange) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkMappedMemoryRange where
        type VkPNextMType VkMappedMemoryRange =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkMappedMemoryRange## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkMappedMemoryRange) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkMappedMemoryRange, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkMappedMemoryRange) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkMappedMemoryRange) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

class HasVkMemory a where
        type VkMemoryMType a :: *

        vkMemory :: a -> VkMemoryMType a

        vkMemoryByteOffset :: a -> Int

        readVkMemory :: Mutable a -> IO (VkMemoryMType a)

        writeVkMemory :: Mutable a -> VkMemoryMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memory'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemory a

instance {-# OVERLAPPING #-} HasVkMemory VkMappedMemoryRange where
        type VkMemoryMType VkMappedMemoryRange = VkDeviceMemory
        vkMemory (VkMappedMemoryRange## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceMemory),
            I## o <- vkMemoryByteOffset (undefined :: VkMappedMemoryRange) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMemory #-}
        vkMemoryByteOffset ~_
          = #{offset VkMappedMemoryRange, memory}

        {-# INLINE vkMemoryByteOffset #-}
        readVkMemory (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceMemory),
            I## o <- vkMemoryByteOffset (undefined :: VkMappedMemoryRange) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMemory #-}
        writeVkMemory (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMemoryByteOffset (undefined :: VkMappedMemoryRange) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMemory #-}

instance {-# OVERLAPPING #-} HasVkOffset VkMappedMemoryRange where
        type VkOffsetMType VkMappedMemoryRange = VkDeviceSize
        vkOffset (VkMappedMemoryRange## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkOffsetByteOffset (undefined :: VkMappedMemoryRange) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkMappedMemoryRange, offset}

        {-# INLINE vkOffsetByteOffset #-}
        readVkOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkOffsetByteOffset (undefined :: VkMappedMemoryRange) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOffset #-}
        writeVkOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOffsetByteOffset (undefined :: VkMappedMemoryRange) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOffset #-}

instance {-# OVERLAPPING #-} HasVkSize VkMappedMemoryRange where
        type VkSizeMType VkMappedMemoryRange = VkDeviceSize
        vkSize (VkMappedMemoryRange## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSizeByteOffset (undefined :: VkMappedMemoryRange) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSize #-}
        vkSizeByteOffset ~_ = #{offset VkMappedMemoryRange, size}

        {-# INLINE vkSizeByteOffset #-}
        readVkSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSizeByteOffset (undefined :: VkMappedMemoryRange) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSize #-}
        writeVkSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSizeByteOffset (undefined :: VkMappedMemoryRange) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSize #-}

instance Show VkMappedMemoryRange where
        showsPrec d x
          = showString "VkMappedMemoryRange {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkMemory = " .
                            showsPrec d (vkMemory x) .
                              showString ", " .
                                showString "vkOffset = " .
                                  showsPrec d (vkOffset x) .
                                    showString ", " .
                                      showString "vkSize = " . showsPrec d (vkSize x) . showChar '}'

data VkFormatProperties = VkFormatProperties## ByteArray##

instance Eq VkFormatProperties where
        (VkFormatProperties## a) == (VkFormatProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkFormatProperties where
        (VkFormatProperties## a) `compare` (VkFormatProperties## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkFormatProperties where
        sizeOf ~_ = #{size VkFormatProperties}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkFormatProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkFormatProperties),
            I## a <- alignment (undefined :: VkFormatProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkFormatProperties## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkFormatProperties## ba)
          | I## n <- sizeOf (undefined :: VkFormatProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkFormatProperties where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkFormatProperties),
            I## a <- alignment (undefined :: VkFormatProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkFormatProperties## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkFormatProperties## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkFormatProperties## ba)
          | I## n <- sizeOf (undefined :: VkFormatProperties),
            I## a <- alignment (undefined :: VkFormatProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkFormatProperties## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkFormatProperties## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkLinearTilingFeatures a where
        type VkLinearTilingFeaturesMType a :: *

        vkLinearTilingFeatures :: a -> VkLinearTilingFeaturesMType a

        vkLinearTilingFeaturesByteOffset :: a -> Int

        readVkLinearTilingFeatures ::
                                   Mutable a -> IO (VkLinearTilingFeaturesMType a)

        writeVkLinearTilingFeatures ::
                                    Mutable a -> VkLinearTilingFeaturesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'linearTilingFeatures'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLinearTilingFeatures a

instance {-# OVERLAPPING #-}
         HasVkLinearTilingFeatures VkFormatProperties where
        type VkLinearTilingFeaturesMType VkFormatProperties =
             VkFormatFeatureFlags
        vkLinearTilingFeatures (VkFormatProperties## ba)
          | I## _n <- sizeOf (undefined :: VkFormatFeatureFlags),
            I## o <- vkLinearTilingFeaturesByteOffset
                      (undefined :: VkFormatProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLinearTilingFeatures #-}
        vkLinearTilingFeaturesByteOffset ~_
          = #{offset VkFormatProperties, linearTilingFeatures}

        {-# INLINE vkLinearTilingFeaturesByteOffset #-}
        readVkLinearTilingFeatures (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFormatFeatureFlags),
            I## o <- vkLinearTilingFeaturesByteOffset
                      (undefined :: VkFormatProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLinearTilingFeatures #-}
        writeVkLinearTilingFeatures (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLinearTilingFeaturesByteOffset
                      (undefined :: VkFormatProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLinearTilingFeatures #-}

class HasVkOptimalTilingFeatures a where
        type VkOptimalTilingFeaturesMType a :: *

        vkOptimalTilingFeatures :: a -> VkOptimalTilingFeaturesMType a

        vkOptimalTilingFeaturesByteOffset :: a -> Int

        readVkOptimalTilingFeatures ::
                                    Mutable a -> IO (VkOptimalTilingFeaturesMType a)

        writeVkOptimalTilingFeatures ::
                                     Mutable a -> VkOptimalTilingFeaturesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'optimalTilingFeatures'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkOptimalTilingFeatures a

instance {-# OVERLAPPING #-}
         HasVkOptimalTilingFeatures VkFormatProperties where
        type VkOptimalTilingFeaturesMType VkFormatProperties =
             VkFormatFeatureFlags
        vkOptimalTilingFeatures (VkFormatProperties## ba)
          | I## _n <- sizeOf (undefined :: VkFormatFeatureFlags),
            I## o <- vkOptimalTilingFeaturesByteOffset
                      (undefined :: VkFormatProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOptimalTilingFeatures #-}
        vkOptimalTilingFeaturesByteOffset ~_
          = #{offset VkFormatProperties, optimalTilingFeatures}

        {-# INLINE vkOptimalTilingFeaturesByteOffset #-}
        readVkOptimalTilingFeatures (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFormatFeatureFlags),
            I## o <- vkOptimalTilingFeaturesByteOffset
                      (undefined :: VkFormatProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOptimalTilingFeatures #-}
        writeVkOptimalTilingFeatures (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOptimalTilingFeaturesByteOffset
                      (undefined :: VkFormatProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOptimalTilingFeatures #-}

class HasVkBufferFeatures a where
        type VkBufferFeaturesMType a :: *

        vkBufferFeatures :: a -> VkBufferFeaturesMType a

        vkBufferFeaturesByteOffset :: a -> Int

        readVkBufferFeatures :: Mutable a -> IO (VkBufferFeaturesMType a)

        writeVkBufferFeatures ::
                              Mutable a -> VkBufferFeaturesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bufferFeatures'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBufferFeatures a

instance {-# OVERLAPPING #-} HasVkBufferFeatures VkFormatProperties
         where
        type VkBufferFeaturesMType VkFormatProperties =
             VkFormatFeatureFlags
        vkBufferFeatures (VkFormatProperties## ba)
          | I## _n <- sizeOf (undefined :: VkFormatFeatureFlags),
            I## o <- vkBufferFeaturesByteOffset
                      (undefined :: VkFormatProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBufferFeatures #-}
        vkBufferFeaturesByteOffset ~_
          = #{offset VkFormatProperties, bufferFeatures}

        {-# INLINE vkBufferFeaturesByteOffset #-}
        readVkBufferFeatures (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFormatFeatureFlags),
            I## o <- vkBufferFeaturesByteOffset
                      (undefined :: VkFormatProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBufferFeatures #-}
        writeVkBufferFeatures (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBufferFeaturesByteOffset
                      (undefined :: VkFormatProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBufferFeatures #-}

instance Show VkFormatProperties where
        showsPrec d x
          = showString "VkFormatProperties {" .
              showString "vkLinearTilingFeatures = " .
                showsPrec d (vkLinearTilingFeatures x) .
                  showString ", " .
                    showString "vkOptimalTilingFeatures = " .
                      showsPrec d (vkOptimalTilingFeatures x) .
                        showString ", " .
                          showString "vkBufferFeatures = " .
                            showsPrec d (vkBufferFeatures x) . showChar '}'

data VkImageFormatProperties = VkImageFormatProperties## ByteArray##

instance Eq VkImageFormatProperties where
        (VkImageFormatProperties## a) == (VkImageFormatProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageFormatProperties where
        (VkImageFormatProperties## a) `compare` (VkImageFormatProperties## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageFormatProperties where
        sizeOf ~_ = #{size VkImageFormatProperties}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageFormatProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageFormatProperties),
            I## a <- alignment (undefined :: VkImageFormatProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkImageFormatProperties##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageFormatProperties## ba)
          | I## n <- sizeOf (undefined :: VkImageFormatProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageFormatProperties where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkImageFormatProperties),
            I## a <- alignment (undefined :: VkImageFormatProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkImageFormatProperties##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkImageFormatProperties## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkImageFormatProperties## ba)
          | I## n <- sizeOf (undefined :: VkImageFormatProperties),
            I## a <- alignment (undefined :: VkImageFormatProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkImageFormatProperties## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkImageFormatProperties## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkMaxExtent a where
        type VkMaxExtentMType a :: *

        vkMaxExtent :: a -> VkMaxExtentMType a

        vkMaxExtentByteOffset :: a -> Int

        readVkMaxExtent :: Mutable a -> IO (VkMaxExtentMType a)

        writeVkMaxExtent :: Mutable a -> VkMaxExtentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxExtent'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxExtent a

instance {-# OVERLAPPING #-} HasVkMaxExtent VkImageFormatProperties
         where
        type VkMaxExtentMType VkImageFormatProperties = VkExtent3D
        vkMaxExtent (VkImageFormatProperties## ba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkMaxExtentByteOffset
                      (undefined :: VkImageFormatProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxExtent #-}
        vkMaxExtentByteOffset ~_
          = #{offset VkImageFormatProperties, maxExtent}

        {-# INLINE vkMaxExtentByteOffset #-}
        readVkMaxExtent (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkMaxExtentByteOffset
                      (undefined :: VkImageFormatProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxExtent #-}
        writeVkMaxExtent (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxExtentByteOffset
                      (undefined :: VkImageFormatProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxExtent #-}

class HasVkMaxMipLevels a where
        type VkMaxMipLevelsMType a :: *

        vkMaxMipLevels :: a -> VkMaxMipLevelsMType a

        vkMaxMipLevelsByteOffset :: a -> Int

        readVkMaxMipLevels :: Mutable a -> IO (VkMaxMipLevelsMType a)

        writeVkMaxMipLevels :: Mutable a -> VkMaxMipLevelsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxMipLevels'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxMipLevels a

instance {-# OVERLAPPING #-}
         HasVkMaxMipLevels VkImageFormatProperties where
        type VkMaxMipLevelsMType VkImageFormatProperties = Data.Word.Word32
        vkMaxMipLevels (VkImageFormatProperties## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxMipLevelsByteOffset
                      (undefined :: VkImageFormatProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxMipLevels #-}
        vkMaxMipLevelsByteOffset ~_
          = #{offset VkImageFormatProperties, maxMipLevels}

        {-# INLINE vkMaxMipLevelsByteOffset #-}
        readVkMaxMipLevels (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxMipLevelsByteOffset
                      (undefined :: VkImageFormatProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxMipLevels #-}
        writeVkMaxMipLevels (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxMipLevelsByteOffset
                      (undefined :: VkImageFormatProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxMipLevels #-}

class HasVkMaxArrayLayers a where
        type VkMaxArrayLayersMType a :: *

        vkMaxArrayLayers :: a -> VkMaxArrayLayersMType a

        vkMaxArrayLayersByteOffset :: a -> Int

        readVkMaxArrayLayers :: Mutable a -> IO (VkMaxArrayLayersMType a)

        writeVkMaxArrayLayers ::
                              Mutable a -> VkMaxArrayLayersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxArrayLayers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxArrayLayers a

instance {-# OVERLAPPING #-}
         HasVkMaxArrayLayers VkImageFormatProperties where
        type VkMaxArrayLayersMType VkImageFormatProperties =
             Data.Word.Word32
        vkMaxArrayLayers (VkImageFormatProperties## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxArrayLayersByteOffset
                      (undefined :: VkImageFormatProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxArrayLayers #-}
        vkMaxArrayLayersByteOffset ~_
          = #{offset VkImageFormatProperties, maxArrayLayers}

        {-# INLINE vkMaxArrayLayersByteOffset #-}
        readVkMaxArrayLayers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxArrayLayersByteOffset
                      (undefined :: VkImageFormatProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxArrayLayers #-}
        writeVkMaxArrayLayers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxArrayLayersByteOffset
                      (undefined :: VkImageFormatProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxArrayLayers #-}

class HasVkSampleCounts a where
        type VkSampleCountsMType a :: *

        vkSampleCounts :: a -> VkSampleCountsMType a

        vkSampleCountsByteOffset :: a -> Int

        readVkSampleCounts :: Mutable a -> IO (VkSampleCountsMType a)

        writeVkSampleCounts :: Mutable a -> VkSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sampleCounts'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkSampleCounts VkImageFormatProperties where
        type VkSampleCountsMType VkImageFormatProperties =
             VkSampleCountFlags
        vkSampleCounts (VkImageFormatProperties## ba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkSampleCountsByteOffset
                      (undefined :: VkImageFormatProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSampleCounts #-}
        vkSampleCountsByteOffset ~_
          = #{offset VkImageFormatProperties, sampleCounts}

        {-# INLINE vkSampleCountsByteOffset #-}
        readVkSampleCounts (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkSampleCountsByteOffset
                      (undefined :: VkImageFormatProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSampleCounts #-}
        writeVkSampleCounts (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSampleCountsByteOffset
                      (undefined :: VkImageFormatProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSampleCounts #-}

class HasVkMaxResourceSize a where
        type VkMaxResourceSizeMType a :: *

        vkMaxResourceSize :: a -> VkMaxResourceSizeMType a

        vkMaxResourceSizeByteOffset :: a -> Int

        readVkMaxResourceSize :: Mutable a -> IO (VkMaxResourceSizeMType a)

        writeVkMaxResourceSize ::
                               Mutable a -> VkMaxResourceSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxResourceSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxResourceSize a

instance {-# OVERLAPPING #-}
         HasVkMaxResourceSize VkImageFormatProperties where
        type VkMaxResourceSizeMType VkImageFormatProperties = VkDeviceSize
        vkMaxResourceSize (VkImageFormatProperties## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkMaxResourceSizeByteOffset
                      (undefined :: VkImageFormatProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxResourceSize #-}
        vkMaxResourceSizeByteOffset ~_
          = #{offset VkImageFormatProperties, maxResourceSize}

        {-# INLINE vkMaxResourceSizeByteOffset #-}
        readVkMaxResourceSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkMaxResourceSizeByteOffset
                      (undefined :: VkImageFormatProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxResourceSize #-}
        writeVkMaxResourceSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxResourceSizeByteOffset
                      (undefined :: VkImageFormatProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxResourceSize #-}

instance Show VkImageFormatProperties where
        showsPrec d x
          = showString "VkImageFormatProperties {" .
              showString "vkMaxExtent = " .
                showsPrec d (vkMaxExtent x) .
                  showString ", " .
                    showString "vkMaxMipLevels = " .
                      showsPrec d (vkMaxMipLevels x) .
                        showString ", " .
                          showString "vkMaxArrayLayers = " .
                            showsPrec d (vkMaxArrayLayers x) .
                              showString ", " .
                                showString "vkSampleCounts = " .
                                  showsPrec d (vkSampleCounts x) .
                                    showString ", " .
                                      showString "vkMaxResourceSize = " .
                                        showsPrec d (vkMaxResourceSize x) . showChar '}'

data VkDescriptorBufferInfo = VkDescriptorBufferInfo## ByteArray##

instance Eq VkDescriptorBufferInfo where
        (VkDescriptorBufferInfo## a) == (VkDescriptorBufferInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDescriptorBufferInfo where
        (VkDescriptorBufferInfo## a) `compare` (VkDescriptorBufferInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDescriptorBufferInfo where
        sizeOf ~_ = #{size VkDescriptorBufferInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDescriptorBufferInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDescriptorBufferInfo),
            I## a <- alignment (undefined :: VkDescriptorBufferInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDescriptorBufferInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDescriptorBufferInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorBufferInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDescriptorBufferInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkDescriptorBufferInfo),
            I## a <- alignment (undefined :: VkDescriptorBufferInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkDescriptorBufferInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkDescriptorBufferInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkDescriptorBufferInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorBufferInfo),
            I## a <- alignment (undefined :: VkDescriptorBufferInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkDescriptorBufferInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkDescriptorBufferInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkBuffer a where
        type VkBufferMType a :: *

        vkBuffer :: a -> VkBufferMType a

        vkBufferByteOffset :: a -> Int

        readVkBuffer :: Mutable a -> IO (VkBufferMType a)

        writeVkBuffer :: Mutable a -> VkBufferMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'buffer'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBuffer a

instance {-# OVERLAPPING #-} HasVkBuffer VkDescriptorBufferInfo
         where
        type VkBufferMType VkDescriptorBufferInfo = VkBuffer
        vkBuffer (VkDescriptorBufferInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBuffer),
            I## o <- vkBufferByteOffset (undefined :: VkDescriptorBufferInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBuffer #-}
        vkBufferByteOffset ~_
          = #{offset VkDescriptorBufferInfo, buffer}

        {-# INLINE vkBufferByteOffset #-}
        readVkBuffer (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBuffer),
            I## o <- vkBufferByteOffset (undefined :: VkDescriptorBufferInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBuffer #-}
        writeVkBuffer (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBufferByteOffset (undefined :: VkDescriptorBufferInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBuffer #-}

instance {-# OVERLAPPING #-} HasVkOffset VkDescriptorBufferInfo
         where
        type VkOffsetMType VkDescriptorBufferInfo = VkDeviceSize
        vkOffset (VkDescriptorBufferInfo## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkOffsetByteOffset (undefined :: VkDescriptorBufferInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkDescriptorBufferInfo, offset}

        {-# INLINE vkOffsetByteOffset #-}
        readVkOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkOffsetByteOffset (undefined :: VkDescriptorBufferInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOffset #-}
        writeVkOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOffsetByteOffset (undefined :: VkDescriptorBufferInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOffset #-}

class HasVkRange a where
        type VkRangeMType a :: *

        vkRange :: a -> VkRangeMType a

        vkRangeByteOffset :: a -> Int

        readVkRange :: Mutable a -> IO (VkRangeMType a)

        writeVkRange :: Mutable a -> VkRangeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'range'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRange a

instance {-# OVERLAPPING #-} HasVkRange VkDescriptorBufferInfo
         where
        type VkRangeMType VkDescriptorBufferInfo = VkDeviceSize
        vkRange (VkDescriptorBufferInfo## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkRangeByteOffset (undefined :: VkDescriptorBufferInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkRange #-}
        vkRangeByteOffset ~_
          = #{offset VkDescriptorBufferInfo, range}

        {-# INLINE vkRangeByteOffset #-}
        readVkRange (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkRangeByteOffset (undefined :: VkDescriptorBufferInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkRange #-}
        writeVkRange (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkRangeByteOffset (undefined :: VkDescriptorBufferInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkRange #-}

instance Show VkDescriptorBufferInfo where
        showsPrec d x
          = showString "VkDescriptorBufferInfo {" .
              showString "vkBuffer = " .
                showsPrec d (vkBuffer x) .
                  showString ", " .
                    showString "vkOffset = " .
                      showsPrec d (vkOffset x) .
                        showString ", " .
                          showString "vkRange = " . showsPrec d (vkRange x) . showChar '}'

data VkDescriptorImageInfo = VkDescriptorImageInfo## ByteArray##

instance Eq VkDescriptorImageInfo where
        (VkDescriptorImageInfo## a) == (VkDescriptorImageInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDescriptorImageInfo where
        (VkDescriptorImageInfo## a) `compare` (VkDescriptorImageInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDescriptorImageInfo where
        sizeOf ~_ = #{size VkDescriptorImageInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDescriptorImageInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDescriptorImageInfo),
            I## a <- alignment (undefined :: VkDescriptorImageInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDescriptorImageInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDescriptorImageInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorImageInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDescriptorImageInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkDescriptorImageInfo),
            I## a <- alignment (undefined :: VkDescriptorImageInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkDescriptorImageInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkDescriptorImageInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkDescriptorImageInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorImageInfo),
            I## a <- alignment (undefined :: VkDescriptorImageInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkDescriptorImageInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkDescriptorImageInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkSampler a where
        type VkSamplerMType a :: *

        vkSampler :: a -> VkSamplerMType a

        vkSamplerByteOffset :: a -> Int

        readVkSampler :: Mutable a -> IO (VkSamplerMType a)

        writeVkSampler :: Mutable a -> VkSamplerMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sampler'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampler a

instance {-# OVERLAPPING #-} HasVkSampler VkDescriptorImageInfo
         where
        type VkSamplerMType VkDescriptorImageInfo = VkSampler
        vkSampler (VkDescriptorImageInfo## ba)
          | I## _n <- sizeOf (undefined :: VkSampler),
            I## o <- vkSamplerByteOffset (undefined :: VkDescriptorImageInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSampler #-}
        vkSamplerByteOffset ~_
          = #{offset VkDescriptorImageInfo, sampler}

        {-# INLINE vkSamplerByteOffset #-}
        readVkSampler (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSampler),
            I## o <- vkSamplerByteOffset (undefined :: VkDescriptorImageInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSampler #-}
        writeVkSampler (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSamplerByteOffset (undefined :: VkDescriptorImageInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSampler #-}

class HasVkImageView a where
        type VkImageViewMType a :: *

        vkImageView :: a -> VkImageViewMType a

        vkImageViewByteOffset :: a -> Int

        readVkImageView :: Mutable a -> IO (VkImageViewMType a)

        writeVkImageView :: Mutable a -> VkImageViewMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageView'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageView a

instance {-# OVERLAPPING #-} HasVkImageView VkDescriptorImageInfo
         where
        type VkImageViewMType VkDescriptorImageInfo = VkImageView
        vkImageView (VkDescriptorImageInfo## ba)
          | I## _n <- sizeOf (undefined :: VkImageView),
            I## o <- vkImageViewByteOffset (undefined :: VkDescriptorImageInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageView #-}
        vkImageViewByteOffset ~_
          = #{offset VkDescriptorImageInfo, imageView}

        {-# INLINE vkImageViewByteOffset #-}
        readVkImageView (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageView),
            I## o <- vkImageViewByteOffset (undefined :: VkDescriptorImageInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageView #-}
        writeVkImageView (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageViewByteOffset (undefined :: VkDescriptorImageInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageView #-}

class HasVkImageLayout a where
        type VkImageLayoutMType a :: *

        vkImageLayout :: a -> VkImageLayoutMType a

        vkImageLayoutByteOffset :: a -> Int

        readVkImageLayout :: Mutable a -> IO (VkImageLayoutMType a)

        writeVkImageLayout :: Mutable a -> VkImageLayoutMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageLayout'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageLayout a

instance {-# OVERLAPPING #-} HasVkImageLayout VkDescriptorImageInfo
         where
        type VkImageLayoutMType VkDescriptorImageInfo = VkImageLayout
        vkImageLayout (VkDescriptorImageInfo## ba)
          | I## _n <- sizeOf (undefined :: VkImageLayout),
            I## o <- vkImageLayoutByteOffset
                      (undefined :: VkDescriptorImageInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageLayout #-}
        vkImageLayoutByteOffset ~_
          = #{offset VkDescriptorImageInfo, imageLayout}

        {-# INLINE vkImageLayoutByteOffset #-}
        readVkImageLayout (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageLayout),
            I## o <- vkImageLayoutByteOffset
                      (undefined :: VkDescriptorImageInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageLayout #-}
        writeVkImageLayout (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageLayoutByteOffset
                      (undefined :: VkDescriptorImageInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageLayout #-}

instance Show VkDescriptorImageInfo where
        showsPrec d x
          = showString "VkDescriptorImageInfo {" .
              showString "vkSampler = " .
                showsPrec d (vkSampler x) .
                  showString ", " .
                    showString "vkImageView = " .
                      showsPrec d (vkImageView x) .
                        showString ", " .
                          showString "vkImageLayout = " .
                            showsPrec d (vkImageLayout x) . showChar '}'

data VkWriteDescriptorSet = VkWriteDescriptorSet## ByteArray##

instance Eq VkWriteDescriptorSet where
        (VkWriteDescriptorSet## a) == (VkWriteDescriptorSet## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkWriteDescriptorSet where
        (VkWriteDescriptorSet## a) `compare` (VkWriteDescriptorSet## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkWriteDescriptorSet where
        sizeOf ~_ = #{size VkWriteDescriptorSet}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkWriteDescriptorSet}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkWriteDescriptorSet),
            I## a <- alignment (undefined :: VkWriteDescriptorSet) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkWriteDescriptorSet## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkWriteDescriptorSet## ba)
          | I## n <- sizeOf (undefined :: VkWriteDescriptorSet) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkWriteDescriptorSet where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkWriteDescriptorSet),
            I## a <- alignment (undefined :: VkWriteDescriptorSet) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkWriteDescriptorSet## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkWriteDescriptorSet## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkWriteDescriptorSet## ba)
          | I## n <- sizeOf (undefined :: VkWriteDescriptorSet),
            I## a <- alignment (undefined :: VkWriteDescriptorSet) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkWriteDescriptorSet## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkWriteDescriptorSet## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkWriteDescriptorSet where
        type VkSTypeMType VkWriteDescriptorSet = VkStructureType
        vkSType (VkWriteDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkWriteDescriptorSet) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkWriteDescriptorSet, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkWriteDescriptorSet) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkWriteDescriptorSet) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkWriteDescriptorSet where
        type VkPNextMType VkWriteDescriptorSet =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkWriteDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkWriteDescriptorSet) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkWriteDescriptorSet, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkWriteDescriptorSet) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkWriteDescriptorSet) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

class HasVkDstSet a where
        type VkDstSetMType a :: *

        vkDstSet :: a -> VkDstSetMType a

        vkDstSetByteOffset :: a -> Int

        readVkDstSet :: Mutable a -> IO (VkDstSetMType a)

        writeVkDstSet :: Mutable a -> VkDstSetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstSet'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstSet a

instance {-# OVERLAPPING #-} HasVkDstSet VkWriteDescriptorSet where
        type VkDstSetMType VkWriteDescriptorSet = VkDescriptorSet
        vkDstSet (VkWriteDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: VkDescriptorSet),
            I## o <- vkDstSetByteOffset (undefined :: VkWriteDescriptorSet) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstSet #-}
        vkDstSetByteOffset ~_
          = #{offset VkWriteDescriptorSet, dstSet}

        {-# INLINE vkDstSetByteOffset #-}
        readVkDstSet (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDescriptorSet),
            I## o <- vkDstSetByteOffset (undefined :: VkWriteDescriptorSet) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstSet #-}
        writeVkDstSet (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstSetByteOffset (undefined :: VkWriteDescriptorSet) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstSet #-}

class HasVkDstBinding a where
        type VkDstBindingMType a :: *

        vkDstBinding :: a -> VkDstBindingMType a

        vkDstBindingByteOffset :: a -> Int

        readVkDstBinding :: Mutable a -> IO (VkDstBindingMType a)

        writeVkDstBinding :: Mutable a -> VkDstBindingMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstBinding'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstBinding a

instance {-# OVERLAPPING #-} HasVkDstBinding VkWriteDescriptorSet
         where
        type VkDstBindingMType VkWriteDescriptorSet = Data.Word.Word32
        vkDstBinding (VkWriteDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDstBindingByteOffset (undefined :: VkWriteDescriptorSet)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstBinding #-}
        vkDstBindingByteOffset ~_
          = #{offset VkWriteDescriptorSet, dstBinding}

        {-# INLINE vkDstBindingByteOffset #-}
        readVkDstBinding (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDstBindingByteOffset (undefined :: VkWriteDescriptorSet)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstBinding #-}
        writeVkDstBinding (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstBindingByteOffset (undefined :: VkWriteDescriptorSet)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstBinding #-}

class HasVkDstArrayElement a where
        type VkDstArrayElementMType a :: *

        vkDstArrayElement :: a -> VkDstArrayElementMType a

        vkDstArrayElementByteOffset :: a -> Int

        readVkDstArrayElement :: Mutable a -> IO (VkDstArrayElementMType a)

        writeVkDstArrayElement ::
                               Mutable a -> VkDstArrayElementMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstArrayElement'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstArrayElement a

instance {-# OVERLAPPING #-}
         HasVkDstArrayElement VkWriteDescriptorSet where
        type VkDstArrayElementMType VkWriteDescriptorSet = Data.Word.Word32
        vkDstArrayElement (VkWriteDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDstArrayElementByteOffset
                      (undefined :: VkWriteDescriptorSet)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstArrayElement #-}
        vkDstArrayElementByteOffset ~_
          = #{offset VkWriteDescriptorSet, dstArrayElement}

        {-# INLINE vkDstArrayElementByteOffset #-}
        readVkDstArrayElement (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDstArrayElementByteOffset
                      (undefined :: VkWriteDescriptorSet)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstArrayElement #-}
        writeVkDstArrayElement (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstArrayElementByteOffset
                      (undefined :: VkWriteDescriptorSet)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstArrayElement #-}

class HasVkDescriptorCount a where
        type VkDescriptorCountMType a :: *

        vkDescriptorCount :: a -> VkDescriptorCountMType a

        vkDescriptorCountByteOffset :: a -> Int

        readVkDescriptorCount :: Mutable a -> IO (VkDescriptorCountMType a)

        writeVkDescriptorCount ::
                               Mutable a -> VkDescriptorCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'descriptorCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDescriptorCount a

instance {-# OVERLAPPING #-}
         HasVkDescriptorCount VkWriteDescriptorSet where
        type VkDescriptorCountMType VkWriteDescriptorSet = Data.Word.Word32
        vkDescriptorCount (VkWriteDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDescriptorCountByteOffset
                      (undefined :: VkWriteDescriptorSet)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDescriptorCount #-}
        vkDescriptorCountByteOffset ~_
          = #{offset VkWriteDescriptorSet, descriptorCount}

        {-# INLINE vkDescriptorCountByteOffset #-}
        readVkDescriptorCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDescriptorCountByteOffset
                      (undefined :: VkWriteDescriptorSet)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDescriptorCount #-}
        writeVkDescriptorCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDescriptorCountByteOffset
                      (undefined :: VkWriteDescriptorSet)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDescriptorCount #-}

class HasVkDescriptorType a where
        type VkDescriptorTypeMType a :: *

        vkDescriptorType :: a -> VkDescriptorTypeMType a

        vkDescriptorTypeByteOffset :: a -> Int

        readVkDescriptorType :: Mutable a -> IO (VkDescriptorTypeMType a)

        writeVkDescriptorType ::
                              Mutable a -> VkDescriptorTypeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'descriptorType'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDescriptorType a

instance {-# OVERLAPPING #-}
         HasVkDescriptorType VkWriteDescriptorSet where
        type VkDescriptorTypeMType VkWriteDescriptorSet = VkDescriptorType
        vkDescriptorType (VkWriteDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: VkDescriptorType),
            I## o <- vkDescriptorTypeByteOffset
                      (undefined :: VkWriteDescriptorSet)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDescriptorType #-}
        vkDescriptorTypeByteOffset ~_
          = #{offset VkWriteDescriptorSet, descriptorType}

        {-# INLINE vkDescriptorTypeByteOffset #-}
        readVkDescriptorType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDescriptorType),
            I## o <- vkDescriptorTypeByteOffset
                      (undefined :: VkWriteDescriptorSet)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDescriptorType #-}
        writeVkDescriptorType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDescriptorTypeByteOffset
                      (undefined :: VkWriteDescriptorSet)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDescriptorType #-}

class HasVkPImageInfo a where
        type VkPImageInfoMType a :: *

        vkPImageInfo :: a -> VkPImageInfoMType a

        vkPImageInfoByteOffset :: a -> Int

        readVkPImageInfo :: Mutable a -> IO (VkPImageInfoMType a)

        writeVkPImageInfo :: Mutable a -> VkPImageInfoMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pImageInfo'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPImageInfo a

instance {-# OVERLAPPING #-} HasVkPImageInfo VkWriteDescriptorSet
         where
        type VkPImageInfoMType VkWriteDescriptorSet =
             Foreign.Ptr.Ptr VkDescriptorImageInfo
        vkPImageInfo (VkWriteDescriptorSet## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkDescriptorImageInfo),
            I## o <- vkPImageInfoByteOffset (undefined :: VkWriteDescriptorSet)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPImageInfo #-}
        vkPImageInfoByteOffset ~_
          = #{offset VkWriteDescriptorSet, pImageInfo}

        {-# INLINE vkPImageInfoByteOffset #-}
        readVkPImageInfo (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkDescriptorImageInfo),
            I## o <- vkPImageInfoByteOffset (undefined :: VkWriteDescriptorSet)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPImageInfo #-}
        writeVkPImageInfo (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPImageInfoByteOffset (undefined :: VkWriteDescriptorSet)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPImageInfo #-}

class HasVkPBufferInfo a where
        type VkPBufferInfoMType a :: *

        vkPBufferInfo :: a -> VkPBufferInfoMType a

        vkPBufferInfoByteOffset :: a -> Int

        readVkPBufferInfo :: Mutable a -> IO (VkPBufferInfoMType a)

        writeVkPBufferInfo :: Mutable a -> VkPBufferInfoMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pBufferInfo'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPBufferInfo a

instance {-# OVERLAPPING #-} HasVkPBufferInfo VkWriteDescriptorSet
         where
        type VkPBufferInfoMType VkWriteDescriptorSet =
             Foreign.Ptr.Ptr VkDescriptorBufferInfo
        vkPBufferInfo (VkWriteDescriptorSet## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkDescriptorBufferInfo),
            I## o <- vkPBufferInfoByteOffset (undefined :: VkWriteDescriptorSet)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPBufferInfo #-}
        vkPBufferInfoByteOffset ~_
          = #{offset VkWriteDescriptorSet, pBufferInfo}

        {-# INLINE vkPBufferInfoByteOffset #-}
        readVkPBufferInfo (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkDescriptorBufferInfo),
            I## o <- vkPBufferInfoByteOffset (undefined :: VkWriteDescriptorSet)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPBufferInfo #-}
        writeVkPBufferInfo (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPBufferInfoByteOffset (undefined :: VkWriteDescriptorSet)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPBufferInfo #-}

class HasVkPTexelBufferView a where
        type VkPTexelBufferViewMType a :: *

        vkPTexelBufferView :: a -> VkPTexelBufferViewMType a

        vkPTexelBufferViewByteOffset :: a -> Int

        readVkPTexelBufferView ::
                               Mutable a -> IO (VkPTexelBufferViewMType a)

        writeVkPTexelBufferView ::
                                Mutable a -> VkPTexelBufferViewMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pTexelBufferView'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPTexelBufferView a

instance {-# OVERLAPPING #-}
         HasVkPTexelBufferView VkWriteDescriptorSet where
        type VkPTexelBufferViewMType VkWriteDescriptorSet =
             Foreign.Ptr.Ptr VkBufferView
        vkPTexelBufferView (VkWriteDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkBufferView),
            I## o <- vkPTexelBufferViewByteOffset
                      (undefined :: VkWriteDescriptorSet)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPTexelBufferView #-}
        vkPTexelBufferViewByteOffset ~_
          = #{offset VkWriteDescriptorSet, pTexelBufferView}

        {-# INLINE vkPTexelBufferViewByteOffset #-}
        readVkPTexelBufferView (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkBufferView),
            I## o <- vkPTexelBufferViewByteOffset
                      (undefined :: VkWriteDescriptorSet)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPTexelBufferView #-}
        writeVkPTexelBufferView (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPTexelBufferViewByteOffset
                      (undefined :: VkWriteDescriptorSet)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPTexelBufferView #-}

instance Show VkWriteDescriptorSet where
        showsPrec d x
          = showString "VkWriteDescriptorSet {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkDstSet = " .
                            showsPrec d (vkDstSet x) .
                              showString ", " .
                                showString "vkDstBinding = " .
                                  showsPrec d (vkDstBinding x) .
                                    showString ", " .
                                      showString "vkDstArrayElement = " .
                                        showsPrec d (vkDstArrayElement x) .
                                          showString ", " .
                                            showString "vkDescriptorCount = " .
                                              showsPrec d (vkDescriptorCount x) .
                                                showString ", " .
                                                  showString "vkDescriptorType = " .
                                                    showsPrec d (vkDescriptorType x) .
                                                      showString ", " .
                                                        showString "vkPImageInfo = " .
                                                          showsPrec d (vkPImageInfo x) .
                                                            showString ", " .
                                                              showString "vkPBufferInfo = " .
                                                                showsPrec d (vkPBufferInfo x) .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkPTexelBufferView = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkPTexelBufferView x)
                                                                        . showChar '}'

data VkCopyDescriptorSet = VkCopyDescriptorSet## ByteArray##

instance Eq VkCopyDescriptorSet where
        (VkCopyDescriptorSet## a) == (VkCopyDescriptorSet## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkCopyDescriptorSet where
        (VkCopyDescriptorSet## a) `compare` (VkCopyDescriptorSet## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkCopyDescriptorSet where
        sizeOf ~_ = #{size VkCopyDescriptorSet}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkCopyDescriptorSet}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkCopyDescriptorSet),
            I## a <- alignment (undefined :: VkCopyDescriptorSet) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkCopyDescriptorSet## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkCopyDescriptorSet## ba)
          | I## n <- sizeOf (undefined :: VkCopyDescriptorSet) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkCopyDescriptorSet where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkCopyDescriptorSet),
            I## a <- alignment (undefined :: VkCopyDescriptorSet) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkCopyDescriptorSet## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkCopyDescriptorSet## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkCopyDescriptorSet## ba)
          | I## n <- sizeOf (undefined :: VkCopyDescriptorSet),
            I## a <- alignment (undefined :: VkCopyDescriptorSet) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkCopyDescriptorSet## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkCopyDescriptorSet## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkCopyDescriptorSet where
        type VkSTypeMType VkCopyDescriptorSet = VkStructureType
        vkSType (VkCopyDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkCopyDescriptorSet) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkCopyDescriptorSet, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkCopyDescriptorSet) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkCopyDescriptorSet) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkCopyDescriptorSet where
        type VkPNextMType VkCopyDescriptorSet =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkCopyDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkCopyDescriptorSet) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkCopyDescriptorSet, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkCopyDescriptorSet) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkCopyDescriptorSet) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

class HasVkSrcSet a where
        type VkSrcSetMType a :: *

        vkSrcSet :: a -> VkSrcSetMType a

        vkSrcSetByteOffset :: a -> Int

        readVkSrcSet :: Mutable a -> IO (VkSrcSetMType a)

        writeVkSrcSet :: Mutable a -> VkSrcSetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcSet'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcSet a

instance {-# OVERLAPPING #-} HasVkSrcSet VkCopyDescriptorSet where
        type VkSrcSetMType VkCopyDescriptorSet = VkDescriptorSet
        vkSrcSet (VkCopyDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: VkDescriptorSet),
            I## o <- vkSrcSetByteOffset (undefined :: VkCopyDescriptorSet) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSrcSet #-}
        vkSrcSetByteOffset ~_
          = #{offset VkCopyDescriptorSet, srcSet}

        {-# INLINE vkSrcSetByteOffset #-}
        readVkSrcSet (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDescriptorSet),
            I## o <- vkSrcSetByteOffset (undefined :: VkCopyDescriptorSet) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSrcSet #-}
        writeVkSrcSet (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcSetByteOffset (undefined :: VkCopyDescriptorSet) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSrcSet #-}

class HasVkSrcBinding a where
        type VkSrcBindingMType a :: *

        vkSrcBinding :: a -> VkSrcBindingMType a

        vkSrcBindingByteOffset :: a -> Int

        readVkSrcBinding :: Mutable a -> IO (VkSrcBindingMType a)

        writeVkSrcBinding :: Mutable a -> VkSrcBindingMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcBinding'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcBinding a

instance {-# OVERLAPPING #-} HasVkSrcBinding VkCopyDescriptorSet
         where
        type VkSrcBindingMType VkCopyDescriptorSet = Data.Word.Word32
        vkSrcBinding (VkCopyDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSrcBindingByteOffset (undefined :: VkCopyDescriptorSet) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSrcBinding #-}
        vkSrcBindingByteOffset ~_
          = #{offset VkCopyDescriptorSet, srcBinding}

        {-# INLINE vkSrcBindingByteOffset #-}
        readVkSrcBinding (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSrcBindingByteOffset (undefined :: VkCopyDescriptorSet) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSrcBinding #-}
        writeVkSrcBinding (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcBindingByteOffset (undefined :: VkCopyDescriptorSet) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSrcBinding #-}

class HasVkSrcArrayElement a where
        type VkSrcArrayElementMType a :: *

        vkSrcArrayElement :: a -> VkSrcArrayElementMType a

        vkSrcArrayElementByteOffset :: a -> Int

        readVkSrcArrayElement :: Mutable a -> IO (VkSrcArrayElementMType a)

        writeVkSrcArrayElement ::
                               Mutable a -> VkSrcArrayElementMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcArrayElement'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcArrayElement a

instance {-# OVERLAPPING #-}
         HasVkSrcArrayElement VkCopyDescriptorSet where
        type VkSrcArrayElementMType VkCopyDescriptorSet = Data.Word.Word32
        vkSrcArrayElement (VkCopyDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSrcArrayElementByteOffset
                      (undefined :: VkCopyDescriptorSet)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSrcArrayElement #-}
        vkSrcArrayElementByteOffset ~_
          = #{offset VkCopyDescriptorSet, srcArrayElement}

        {-# INLINE vkSrcArrayElementByteOffset #-}
        readVkSrcArrayElement (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSrcArrayElementByteOffset
                      (undefined :: VkCopyDescriptorSet)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSrcArrayElement #-}
        writeVkSrcArrayElement (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcArrayElementByteOffset
                      (undefined :: VkCopyDescriptorSet)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSrcArrayElement #-}

instance {-# OVERLAPPING #-} HasVkDstSet VkCopyDescriptorSet where
        type VkDstSetMType VkCopyDescriptorSet = VkDescriptorSet
        vkDstSet (VkCopyDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: VkDescriptorSet),
            I## o <- vkDstSetByteOffset (undefined :: VkCopyDescriptorSet) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstSet #-}
        vkDstSetByteOffset ~_
          = #{offset VkCopyDescriptorSet, dstSet}

        {-# INLINE vkDstSetByteOffset #-}
        readVkDstSet (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDescriptorSet),
            I## o <- vkDstSetByteOffset (undefined :: VkCopyDescriptorSet) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstSet #-}
        writeVkDstSet (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstSetByteOffset (undefined :: VkCopyDescriptorSet) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstSet #-}

instance {-# OVERLAPPING #-} HasVkDstBinding VkCopyDescriptorSet
         where
        type VkDstBindingMType VkCopyDescriptorSet = Data.Word.Word32
        vkDstBinding (VkCopyDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDstBindingByteOffset (undefined :: VkCopyDescriptorSet) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstBinding #-}
        vkDstBindingByteOffset ~_
          = #{offset VkCopyDescriptorSet, dstBinding}

        {-# INLINE vkDstBindingByteOffset #-}
        readVkDstBinding (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDstBindingByteOffset (undefined :: VkCopyDescriptorSet) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstBinding #-}
        writeVkDstBinding (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstBindingByteOffset (undefined :: VkCopyDescriptorSet) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstBinding #-}

instance {-# OVERLAPPING #-}
         HasVkDstArrayElement VkCopyDescriptorSet where
        type VkDstArrayElementMType VkCopyDescriptorSet = Data.Word.Word32
        vkDstArrayElement (VkCopyDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDstArrayElementByteOffset
                      (undefined :: VkCopyDescriptorSet)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstArrayElement #-}
        vkDstArrayElementByteOffset ~_
          = #{offset VkCopyDescriptorSet, dstArrayElement}

        {-# INLINE vkDstArrayElementByteOffset #-}
        readVkDstArrayElement (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDstArrayElementByteOffset
                      (undefined :: VkCopyDescriptorSet)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstArrayElement #-}
        writeVkDstArrayElement (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstArrayElementByteOffset
                      (undefined :: VkCopyDescriptorSet)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstArrayElement #-}

instance {-# OVERLAPPING #-}
         HasVkDescriptorCount VkCopyDescriptorSet where
        type VkDescriptorCountMType VkCopyDescriptorSet = Data.Word.Word32
        vkDescriptorCount (VkCopyDescriptorSet## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDescriptorCountByteOffset
                      (undefined :: VkCopyDescriptorSet)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDescriptorCount #-}
        vkDescriptorCountByteOffset ~_
          = #{offset VkCopyDescriptorSet, descriptorCount}

        {-# INLINE vkDescriptorCountByteOffset #-}
        readVkDescriptorCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDescriptorCountByteOffset
                      (undefined :: VkCopyDescriptorSet)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDescriptorCount #-}
        writeVkDescriptorCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDescriptorCountByteOffset
                      (undefined :: VkCopyDescriptorSet)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDescriptorCount #-}

instance Show VkCopyDescriptorSet where
        showsPrec d x
          = showString "VkCopyDescriptorSet {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkSrcSet = " .
                            showsPrec d (vkSrcSet x) .
                              showString ", " .
                                showString "vkSrcBinding = " .
                                  showsPrec d (vkSrcBinding x) .
                                    showString ", " .
                                      showString "vkSrcArrayElement = " .
                                        showsPrec d (vkSrcArrayElement x) .
                                          showString ", " .
                                            showString "vkDstSet = " .
                                              showsPrec d (vkDstSet x) .
                                                showString ", " .
                                                  showString "vkDstBinding = " .
                                                    showsPrec d (vkDstBinding x) .
                                                      showString ", " .
                                                        showString "vkDstArrayElement = " .
                                                          showsPrec d (vkDstArrayElement x) .
                                                            showString ", " .
                                                              showString "vkDescriptorCount = " .
                                                                showsPrec d (vkDescriptorCount x) .
                                                                  showChar '}'

data VkBufferCreateInfo = VkBufferCreateInfo## ByteArray##

instance Eq VkBufferCreateInfo where
        (VkBufferCreateInfo## a) == (VkBufferCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkBufferCreateInfo where
        (VkBufferCreateInfo## a) `compare` (VkBufferCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkBufferCreateInfo where
        sizeOf ~_ = #{size VkBufferCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkBufferCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkBufferCreateInfo),
            I## a <- alignment (undefined :: VkBufferCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkBufferCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkBufferCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkBufferCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkBufferCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkBufferCreateInfo),
            I## a <- alignment (undefined :: VkBufferCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkBufferCreateInfo## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkBufferCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkBufferCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkBufferCreateInfo),
            I## a <- alignment (undefined :: VkBufferCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkBufferCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkBufferCreateInfo## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkBufferCreateInfo where
        type VkSTypeMType VkBufferCreateInfo = VkStructureType
        vkSType (VkBufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkBufferCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_ = #{offset VkBufferCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkBufferCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkBufferCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkBufferCreateInfo where
        type VkPNextMType VkBufferCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkBufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkBufferCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_ = #{offset VkBufferCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkBufferCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkBufferCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkBufferCreateInfo where
        type VkFlagsMType VkBufferCreateInfo = VkBufferCreateFlags
        vkFlags (VkBufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBufferCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkBufferCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_ = #{offset VkBufferCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBufferCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkBufferCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkBufferCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

instance {-# OVERLAPPING #-} HasVkSize VkBufferCreateInfo where
        type VkSizeMType VkBufferCreateInfo = VkDeviceSize
        vkSize (VkBufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSizeByteOffset (undefined :: VkBufferCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSize #-}
        vkSizeByteOffset ~_ = #{offset VkBufferCreateInfo, size}

        {-# INLINE vkSizeByteOffset #-}
        readVkSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSizeByteOffset (undefined :: VkBufferCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSize #-}
        writeVkSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSizeByteOffset (undefined :: VkBufferCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSize #-}

class HasVkUsage a where
        type VkUsageMType a :: *

        vkUsage :: a -> VkUsageMType a

        vkUsageByteOffset :: a -> Int

        readVkUsage :: Mutable a -> IO (VkUsageMType a)

        writeVkUsage :: Mutable a -> VkUsageMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'usage'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkUsage a

instance {-# OVERLAPPING #-} HasVkUsage VkBufferCreateInfo where
        type VkUsageMType VkBufferCreateInfo = VkBufferUsageFlags
        vkUsage (VkBufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBufferUsageFlags),
            I## o <- vkUsageByteOffset (undefined :: VkBufferCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkUsage #-}
        vkUsageByteOffset ~_ = #{offset VkBufferCreateInfo, usage}

        {-# INLINE vkUsageByteOffset #-}
        readVkUsage (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBufferUsageFlags),
            I## o <- vkUsageByteOffset (undefined :: VkBufferCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkUsage #-}
        writeVkUsage (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkUsageByteOffset (undefined :: VkBufferCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkUsage #-}

class HasVkSharingMode a where
        type VkSharingModeMType a :: *

        vkSharingMode :: a -> VkSharingModeMType a

        vkSharingModeByteOffset :: a -> Int

        readVkSharingMode :: Mutable a -> IO (VkSharingModeMType a)

        writeVkSharingMode :: Mutable a -> VkSharingModeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sharingMode'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSharingMode a

instance {-# OVERLAPPING #-} HasVkSharingMode VkBufferCreateInfo
         where
        type VkSharingModeMType VkBufferCreateInfo = VkSharingMode
        vkSharingMode (VkBufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkSharingMode),
            I## o <- vkSharingModeByteOffset (undefined :: VkBufferCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSharingMode #-}
        vkSharingModeByteOffset ~_
          = #{offset VkBufferCreateInfo, sharingMode}

        {-# INLINE vkSharingModeByteOffset #-}
        readVkSharingMode (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSharingMode),
            I## o <- vkSharingModeByteOffset (undefined :: VkBufferCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSharingMode #-}
        writeVkSharingMode (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSharingModeByteOffset (undefined :: VkBufferCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSharingMode #-}

class HasVkQueueFamilyIndexCount a where
        type VkQueueFamilyIndexCountMType a :: *

        vkQueueFamilyIndexCount :: a -> VkQueueFamilyIndexCountMType a

        vkQueueFamilyIndexCountByteOffset :: a -> Int

        readVkQueueFamilyIndexCount ::
                                    Mutable a -> IO (VkQueueFamilyIndexCountMType a)

        writeVkQueueFamilyIndexCount ::
                                     Mutable a -> VkQueueFamilyIndexCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queueFamilyIndexCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueueFamilyIndexCount a

instance {-# OVERLAPPING #-}
         HasVkQueueFamilyIndexCount VkBufferCreateInfo where
        type VkQueueFamilyIndexCountMType VkBufferCreateInfo =
             Data.Word.Word32
        vkQueueFamilyIndexCount (VkBufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueFamilyIndexCountByteOffset
                      (undefined :: VkBufferCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkQueueFamilyIndexCount #-}
        vkQueueFamilyIndexCountByteOffset ~_
          = #{offset VkBufferCreateInfo, queueFamilyIndexCount}

        {-# INLINE vkQueueFamilyIndexCountByteOffset #-}
        readVkQueueFamilyIndexCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueFamilyIndexCountByteOffset
                      (undefined :: VkBufferCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkQueueFamilyIndexCount #-}
        writeVkQueueFamilyIndexCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkQueueFamilyIndexCountByteOffset
                      (undefined :: VkBufferCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkQueueFamilyIndexCount #-}

class HasVkPQueueFamilyIndices a where
        type VkPQueueFamilyIndicesMType a :: *

        vkPQueueFamilyIndices :: a -> VkPQueueFamilyIndicesMType a

        vkPQueueFamilyIndicesByteOffset :: a -> Int

        readVkPQueueFamilyIndices ::
                                  Mutable a -> IO (VkPQueueFamilyIndicesMType a)

        writeVkPQueueFamilyIndices ::
                                   Mutable a -> VkPQueueFamilyIndicesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pQueueFamilyIndices'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPQueueFamilyIndices a

instance {-# OVERLAPPING #-}
         HasVkPQueueFamilyIndices VkBufferCreateInfo where
        type VkPQueueFamilyIndicesMType VkBufferCreateInfo =
             Foreign.Ptr.Ptr Data.Word.Word32
        vkPQueueFamilyIndices (VkBufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Word.Word32),
            I## o <- vkPQueueFamilyIndicesByteOffset
                      (undefined :: VkBufferCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPQueueFamilyIndices #-}
        vkPQueueFamilyIndicesByteOffset ~_
          = #{offset VkBufferCreateInfo, pQueueFamilyIndices}

        {-# INLINE vkPQueueFamilyIndicesByteOffset #-}
        readVkPQueueFamilyIndices (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Word.Word32),
            I## o <- vkPQueueFamilyIndicesByteOffset
                      (undefined :: VkBufferCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPQueueFamilyIndices #-}
        writeVkPQueueFamilyIndices (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPQueueFamilyIndicesByteOffset
                      (undefined :: VkBufferCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPQueueFamilyIndices #-}

instance Show VkBufferCreateInfo where
        showsPrec d x
          = showString "VkBufferCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkSize = " .
                                  showsPrec d (vkSize x) .
                                    showString ", " .
                                      showString "vkUsage = " .
                                        showsPrec d (vkUsage x) .
                                          showString ", " .
                                            showString "vkSharingMode = " .
                                              showsPrec d (vkSharingMode x) .
                                                showString ", " .
                                                  showString "vkQueueFamilyIndexCount = " .
                                                    showsPrec d (vkQueueFamilyIndexCount x) .
                                                      showString ", " .
                                                        showString "vkPQueueFamilyIndices = " .
                                                          showsPrec d (vkPQueueFamilyIndices x) .
                                                            showChar '}'

data VkBufferViewCreateInfo = VkBufferViewCreateInfo## ByteArray##

instance Eq VkBufferViewCreateInfo where
        (VkBufferViewCreateInfo## a) == (VkBufferViewCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkBufferViewCreateInfo where
        (VkBufferViewCreateInfo## a) `compare` (VkBufferViewCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkBufferViewCreateInfo where
        sizeOf ~_ = #{size VkBufferViewCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkBufferViewCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkBufferViewCreateInfo),
            I## a <- alignment (undefined :: VkBufferViewCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkBufferViewCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkBufferViewCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkBufferViewCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkBufferViewCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkBufferViewCreateInfo),
            I## a <- alignment (undefined :: VkBufferViewCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkBufferViewCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkBufferViewCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkBufferViewCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkBufferViewCreateInfo),
            I## a <- alignment (undefined :: VkBufferViewCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkBufferViewCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkBufferViewCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkBufferViewCreateInfo
         where
        type VkSTypeMType VkBufferViewCreateInfo = VkStructureType
        vkSType (VkBufferViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkBufferViewCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkBufferViewCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkBufferViewCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkBufferViewCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkBufferViewCreateInfo
         where
        type VkPNextMType VkBufferViewCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkBufferViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkBufferViewCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkBufferViewCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkBufferViewCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkBufferViewCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkBufferViewCreateInfo
         where
        type VkFlagsMType VkBufferViewCreateInfo = VkBufferViewCreateFlags
        vkFlags (VkBufferViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBufferViewCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkBufferViewCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkBufferViewCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBufferViewCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkBufferViewCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkBufferViewCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

instance {-# OVERLAPPING #-} HasVkBuffer VkBufferViewCreateInfo
         where
        type VkBufferMType VkBufferViewCreateInfo = VkBuffer
        vkBuffer (VkBufferViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBuffer),
            I## o <- vkBufferByteOffset (undefined :: VkBufferViewCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBuffer #-}
        vkBufferByteOffset ~_
          = #{offset VkBufferViewCreateInfo, buffer}

        {-# INLINE vkBufferByteOffset #-}
        readVkBuffer (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBuffer),
            I## o <- vkBufferByteOffset (undefined :: VkBufferViewCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBuffer #-}
        writeVkBuffer (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBufferByteOffset (undefined :: VkBufferViewCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBuffer #-}

class HasVkFormat a where
        type VkFormatMType a :: *

        vkFormat :: a -> VkFormatMType a

        vkFormatByteOffset :: a -> Int

        readVkFormat :: Mutable a -> IO (VkFormatMType a)

        writeVkFormat :: Mutable a -> VkFormatMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'format'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFormat a

instance {-# OVERLAPPING #-} HasVkFormat VkBufferViewCreateInfo
         where
        type VkFormatMType VkBufferViewCreateInfo = VkFormat
        vkFormat (VkBufferViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkFormat),
            I## o <- vkFormatByteOffset (undefined :: VkBufferViewCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFormat #-}
        vkFormatByteOffset ~_
          = #{offset VkBufferViewCreateInfo, format}

        {-# INLINE vkFormatByteOffset #-}
        readVkFormat (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFormat),
            I## o <- vkFormatByteOffset (undefined :: VkBufferViewCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFormat #-}
        writeVkFormat (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFormatByteOffset (undefined :: VkBufferViewCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFormat #-}

instance {-# OVERLAPPING #-} HasVkOffset VkBufferViewCreateInfo
         where
        type VkOffsetMType VkBufferViewCreateInfo = VkDeviceSize
        vkOffset (VkBufferViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkOffsetByteOffset (undefined :: VkBufferViewCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkBufferViewCreateInfo, offset}

        {-# INLINE vkOffsetByteOffset #-}
        readVkOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkOffsetByteOffset (undefined :: VkBufferViewCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOffset #-}
        writeVkOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOffsetByteOffset (undefined :: VkBufferViewCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOffset #-}

instance {-# OVERLAPPING #-} HasVkRange VkBufferViewCreateInfo
         where
        type VkRangeMType VkBufferViewCreateInfo = VkDeviceSize
        vkRange (VkBufferViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkRangeByteOffset (undefined :: VkBufferViewCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkRange #-}
        vkRangeByteOffset ~_
          = #{offset VkBufferViewCreateInfo, range}

        {-# INLINE vkRangeByteOffset #-}
        readVkRange (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkRangeByteOffset (undefined :: VkBufferViewCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkRange #-}
        writeVkRange (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkRangeByteOffset (undefined :: VkBufferViewCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkRange #-}

instance Show VkBufferViewCreateInfo where
        showsPrec d x
          = showString "VkBufferViewCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkBuffer = " .
                                  showsPrec d (vkBuffer x) .
                                    showString ", " .
                                      showString "vkFormat = " .
                                        showsPrec d (vkFormat x) .
                                          showString ", " .
                                            showString "vkOffset = " .
                                              showsPrec d (vkOffset x) .
                                                showString ", " .
                                                  showString "vkRange = " .
                                                    showsPrec d (vkRange x) . showChar '}'

data VkImageSubresource = VkImageSubresource## ByteArray##

instance Eq VkImageSubresource where
        (VkImageSubresource## a) == (VkImageSubresource## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageSubresource where
        (VkImageSubresource## a) `compare` (VkImageSubresource## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageSubresource where
        sizeOf ~_ = #{size VkImageSubresource}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageSubresource}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageSubresource),
            I## a <- alignment (undefined :: VkImageSubresource) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkImageSubresource## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageSubresource## ba)
          | I## n <- sizeOf (undefined :: VkImageSubresource) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageSubresource where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkImageSubresource),
            I## a <- alignment (undefined :: VkImageSubresource) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkImageSubresource## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkImageSubresource## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkImageSubresource## ba)
          | I## n <- sizeOf (undefined :: VkImageSubresource),
            I## a <- alignment (undefined :: VkImageSubresource) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkImageSubresource## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkImageSubresource## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkAspectMask VkImageSubresource
         where
        type VkAspectMaskMType VkImageSubresource = VkImageAspectFlags
        vkAspectMask (VkImageSubresource## ba)
          | I## _n <- sizeOf (undefined :: VkImageAspectFlags),
            I## o <- vkAspectMaskByteOffset (undefined :: VkImageSubresource) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAspectMask #-}
        vkAspectMaskByteOffset ~_
          = #{offset VkImageSubresource, aspectMask}

        {-# INLINE vkAspectMaskByteOffset #-}
        readVkAspectMask (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageAspectFlags),
            I## o <- vkAspectMaskByteOffset (undefined :: VkImageSubresource) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAspectMask #-}
        writeVkAspectMask (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAspectMaskByteOffset (undefined :: VkImageSubresource) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAspectMask #-}

class HasVkMipLevel a where
        type VkMipLevelMType a :: *

        vkMipLevel :: a -> VkMipLevelMType a

        vkMipLevelByteOffset :: a -> Int

        readVkMipLevel :: Mutable a -> IO (VkMipLevelMType a)

        writeVkMipLevel :: Mutable a -> VkMipLevelMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'mipLevel'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMipLevel a

instance {-# OVERLAPPING #-} HasVkMipLevel VkImageSubresource where
        type VkMipLevelMType VkImageSubresource = Data.Word.Word32
        vkMipLevel (VkImageSubresource## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMipLevelByteOffset (undefined :: VkImageSubresource) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMipLevel #-}
        vkMipLevelByteOffset ~_
          = #{offset VkImageSubresource, mipLevel}

        {-# INLINE vkMipLevelByteOffset #-}
        readVkMipLevel (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMipLevelByteOffset (undefined :: VkImageSubresource) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMipLevel #-}
        writeVkMipLevel (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMipLevelByteOffset (undefined :: VkImageSubresource) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMipLevel #-}

class HasVkArrayLayer a where
        type VkArrayLayerMType a :: *

        vkArrayLayer :: a -> VkArrayLayerMType a

        vkArrayLayerByteOffset :: a -> Int

        readVkArrayLayer :: Mutable a -> IO (VkArrayLayerMType a)

        writeVkArrayLayer :: Mutable a -> VkArrayLayerMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'arrayLayer'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkArrayLayer a

instance {-# OVERLAPPING #-} HasVkArrayLayer VkImageSubresource
         where
        type VkArrayLayerMType VkImageSubresource = Data.Word.Word32
        vkArrayLayer (VkImageSubresource## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkArrayLayerByteOffset (undefined :: VkImageSubresource) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkArrayLayer #-}
        vkArrayLayerByteOffset ~_
          = #{offset VkImageSubresource, arrayLayer}

        {-# INLINE vkArrayLayerByteOffset #-}
        readVkArrayLayer (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkArrayLayerByteOffset (undefined :: VkImageSubresource) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkArrayLayer #-}
        writeVkArrayLayer (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkArrayLayerByteOffset (undefined :: VkImageSubresource) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkArrayLayer #-}

instance Show VkImageSubresource where
        showsPrec d x
          = showString "VkImageSubresource {" .
              showString "vkAspectMask = " .
                showsPrec d (vkAspectMask x) .
                  showString ", " .
                    showString "vkMipLevel = " .
                      showsPrec d (vkMipLevel x) .
                        showString ", " .
                          showString "vkArrayLayer = " .
                            showsPrec d (vkArrayLayer x) . showChar '}'

data VkImageSubresourceLayers = VkImageSubresourceLayers## ByteArray##

instance Eq VkImageSubresourceLayers where
        (VkImageSubresourceLayers## a) == (VkImageSubresourceLayers## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageSubresourceLayers where
        (VkImageSubresourceLayers## a) `compare`
          (VkImageSubresourceLayers## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageSubresourceLayers where
        sizeOf ~_ = #{size VkImageSubresourceLayers}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageSubresourceLayers}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## a <- alignment (undefined :: VkImageSubresourceLayers) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkImageSubresourceLayers##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageSubresourceLayers## ba)
          | I## n <- sizeOf (undefined :: VkImageSubresourceLayers) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageSubresourceLayers where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## a <- alignment (undefined :: VkImageSubresourceLayers) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkImageSubresourceLayers##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkImageSubresourceLayers## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkImageSubresourceLayers## ba)
          | I## n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## a <- alignment (undefined :: VkImageSubresourceLayers) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkImageSubresourceLayers## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkImageSubresourceLayers## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkAspectMask VkImageSubresourceLayers where
        type VkAspectMaskMType VkImageSubresourceLayers =
             VkImageAspectFlags
        vkAspectMask (VkImageSubresourceLayers## ba)
          | I## _n <- sizeOf (undefined :: VkImageAspectFlags),
            I## o <- vkAspectMaskByteOffset
                      (undefined :: VkImageSubresourceLayers)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAspectMask #-}
        vkAspectMaskByteOffset ~_
          = #{offset VkImageSubresourceLayers, aspectMask}

        {-# INLINE vkAspectMaskByteOffset #-}
        readVkAspectMask (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageAspectFlags),
            I## o <- vkAspectMaskByteOffset
                      (undefined :: VkImageSubresourceLayers)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAspectMask #-}
        writeVkAspectMask (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAspectMaskByteOffset
                      (undefined :: VkImageSubresourceLayers)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAspectMask #-}

instance {-# OVERLAPPING #-} HasVkMipLevel VkImageSubresourceLayers
         where
        type VkMipLevelMType VkImageSubresourceLayers = Data.Word.Word32
        vkMipLevel (VkImageSubresourceLayers## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMipLevelByteOffset
                      (undefined :: VkImageSubresourceLayers)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMipLevel #-}
        vkMipLevelByteOffset ~_
          = #{offset VkImageSubresourceLayers, mipLevel}

        {-# INLINE vkMipLevelByteOffset #-}
        readVkMipLevel (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMipLevelByteOffset
                      (undefined :: VkImageSubresourceLayers)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMipLevel #-}
        writeVkMipLevel (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMipLevelByteOffset
                      (undefined :: VkImageSubresourceLayers)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMipLevel #-}

instance {-# OVERLAPPING #-}
         HasVkBaseArrayLayer VkImageSubresourceLayers where
        type VkBaseArrayLayerMType VkImageSubresourceLayers =
             Data.Word.Word32
        vkBaseArrayLayer (VkImageSubresourceLayers## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBaseArrayLayerByteOffset
                      (undefined :: VkImageSubresourceLayers)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBaseArrayLayer #-}
        vkBaseArrayLayerByteOffset ~_
          = #{offset VkImageSubresourceLayers, baseArrayLayer}

        {-# INLINE vkBaseArrayLayerByteOffset #-}
        readVkBaseArrayLayer (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBaseArrayLayerByteOffset
                      (undefined :: VkImageSubresourceLayers)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBaseArrayLayer #-}
        writeVkBaseArrayLayer (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBaseArrayLayerByteOffset
                      (undefined :: VkImageSubresourceLayers)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBaseArrayLayer #-}

instance {-# OVERLAPPING #-}
         HasVkLayerCount VkImageSubresourceLayers where
        type VkLayerCountMType VkImageSubresourceLayers = Data.Word.Word32
        vkLayerCount (VkImageSubresourceLayers## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkLayerCountByteOffset
                      (undefined :: VkImageSubresourceLayers)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLayerCount #-}
        vkLayerCountByteOffset ~_
          = #{offset VkImageSubresourceLayers, layerCount}

        {-# INLINE vkLayerCountByteOffset #-}
        readVkLayerCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkLayerCountByteOffset
                      (undefined :: VkImageSubresourceLayers)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLayerCount #-}
        writeVkLayerCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLayerCountByteOffset
                      (undefined :: VkImageSubresourceLayers)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLayerCount #-}

instance Show VkImageSubresourceLayers where
        showsPrec d x
          = showString "VkImageSubresourceLayers {" .
              showString "vkAspectMask = " .
                showsPrec d (vkAspectMask x) .
                  showString ", " .
                    showString "vkMipLevel = " .
                      showsPrec d (vkMipLevel x) .
                        showString ", " .
                          showString "vkBaseArrayLayer = " .
                            showsPrec d (vkBaseArrayLayer x) .
                              showString ", " .
                                showString "vkLayerCount = " .
                                  showsPrec d (vkLayerCount x) . showChar '}'

data VkImageSubresourceRange = VkImageSubresourceRange## ByteArray##

instance Eq VkImageSubresourceRange where
        (VkImageSubresourceRange## a) == (VkImageSubresourceRange## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageSubresourceRange where
        (VkImageSubresourceRange## a) `compare` (VkImageSubresourceRange## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageSubresourceRange where
        sizeOf ~_ = #{size VkImageSubresourceRange}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageSubresourceRange}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageSubresourceRange),
            I## a <- alignment (undefined :: VkImageSubresourceRange) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkImageSubresourceRange##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageSubresourceRange## ba)
          | I## n <- sizeOf (undefined :: VkImageSubresourceRange) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageSubresourceRange where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkImageSubresourceRange),
            I## a <- alignment (undefined :: VkImageSubresourceRange) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkImageSubresourceRange##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkImageSubresourceRange## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkImageSubresourceRange## ba)
          | I## n <- sizeOf (undefined :: VkImageSubresourceRange),
            I## a <- alignment (undefined :: VkImageSubresourceRange) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkImageSubresourceRange## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkImageSubresourceRange## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkAspectMask VkImageSubresourceRange where
        type VkAspectMaskMType VkImageSubresourceRange = VkImageAspectFlags
        vkAspectMask (VkImageSubresourceRange## ba)
          | I## _n <- sizeOf (undefined :: VkImageAspectFlags),
            I## o <- vkAspectMaskByteOffset
                      (undefined :: VkImageSubresourceRange)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAspectMask #-}
        vkAspectMaskByteOffset ~_
          = #{offset VkImageSubresourceRange, aspectMask}

        {-# INLINE vkAspectMaskByteOffset #-}
        readVkAspectMask (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageAspectFlags),
            I## o <- vkAspectMaskByteOffset
                      (undefined :: VkImageSubresourceRange)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAspectMask #-}
        writeVkAspectMask (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAspectMaskByteOffset
                      (undefined :: VkImageSubresourceRange)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAspectMask #-}

class HasVkBaseMipLevel a where
        type VkBaseMipLevelMType a :: *

        vkBaseMipLevel :: a -> VkBaseMipLevelMType a

        vkBaseMipLevelByteOffset :: a -> Int

        readVkBaseMipLevel :: Mutable a -> IO (VkBaseMipLevelMType a)

        writeVkBaseMipLevel :: Mutable a -> VkBaseMipLevelMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'baseMipLevel'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBaseMipLevel a

instance {-# OVERLAPPING #-}
         HasVkBaseMipLevel VkImageSubresourceRange where
        type VkBaseMipLevelMType VkImageSubresourceRange = Data.Word.Word32
        vkBaseMipLevel (VkImageSubresourceRange## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBaseMipLevelByteOffset
                      (undefined :: VkImageSubresourceRange)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBaseMipLevel #-}
        vkBaseMipLevelByteOffset ~_
          = #{offset VkImageSubresourceRange, baseMipLevel}

        {-# INLINE vkBaseMipLevelByteOffset #-}
        readVkBaseMipLevel (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBaseMipLevelByteOffset
                      (undefined :: VkImageSubresourceRange)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBaseMipLevel #-}
        writeVkBaseMipLevel (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBaseMipLevelByteOffset
                      (undefined :: VkImageSubresourceRange)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBaseMipLevel #-}

class HasVkLevelCount a where
        type VkLevelCountMType a :: *

        vkLevelCount :: a -> VkLevelCountMType a

        vkLevelCountByteOffset :: a -> Int

        readVkLevelCount :: Mutable a -> IO (VkLevelCountMType a)

        writeVkLevelCount :: Mutable a -> VkLevelCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'levelCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLevelCount a

instance {-# OVERLAPPING #-}
         HasVkLevelCount VkImageSubresourceRange where
        type VkLevelCountMType VkImageSubresourceRange = Data.Word.Word32
        vkLevelCount (VkImageSubresourceRange## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkLevelCountByteOffset
                      (undefined :: VkImageSubresourceRange)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLevelCount #-}
        vkLevelCountByteOffset ~_
          = #{offset VkImageSubresourceRange, levelCount}

        {-# INLINE vkLevelCountByteOffset #-}
        readVkLevelCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkLevelCountByteOffset
                      (undefined :: VkImageSubresourceRange)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLevelCount #-}
        writeVkLevelCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLevelCountByteOffset
                      (undefined :: VkImageSubresourceRange)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLevelCount #-}

instance {-# OVERLAPPING #-}
         HasVkBaseArrayLayer VkImageSubresourceRange where
        type VkBaseArrayLayerMType VkImageSubresourceRange =
             Data.Word.Word32
        vkBaseArrayLayer (VkImageSubresourceRange## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBaseArrayLayerByteOffset
                      (undefined :: VkImageSubresourceRange)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBaseArrayLayer #-}
        vkBaseArrayLayerByteOffset ~_
          = #{offset VkImageSubresourceRange, baseArrayLayer}

        {-# INLINE vkBaseArrayLayerByteOffset #-}
        readVkBaseArrayLayer (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBaseArrayLayerByteOffset
                      (undefined :: VkImageSubresourceRange)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBaseArrayLayer #-}
        writeVkBaseArrayLayer (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBaseArrayLayerByteOffset
                      (undefined :: VkImageSubresourceRange)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBaseArrayLayer #-}

instance {-# OVERLAPPING #-}
         HasVkLayerCount VkImageSubresourceRange where
        type VkLayerCountMType VkImageSubresourceRange = Data.Word.Word32
        vkLayerCount (VkImageSubresourceRange## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkLayerCountByteOffset
                      (undefined :: VkImageSubresourceRange)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLayerCount #-}
        vkLayerCountByteOffset ~_
          = #{offset VkImageSubresourceRange, layerCount}

        {-# INLINE vkLayerCountByteOffset #-}
        readVkLayerCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkLayerCountByteOffset
                      (undefined :: VkImageSubresourceRange)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLayerCount #-}
        writeVkLayerCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLayerCountByteOffset
                      (undefined :: VkImageSubresourceRange)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLayerCount #-}

instance Show VkImageSubresourceRange where
        showsPrec d x
          = showString "VkImageSubresourceRange {" .
              showString "vkAspectMask = " .
                showsPrec d (vkAspectMask x) .
                  showString ", " .
                    showString "vkBaseMipLevel = " .
                      showsPrec d (vkBaseMipLevel x) .
                        showString ", " .
                          showString "vkLevelCount = " .
                            showsPrec d (vkLevelCount x) .
                              showString ", " .
                                showString "vkBaseArrayLayer = " .
                                  showsPrec d (vkBaseArrayLayer x) .
                                    showString ", " .
                                      showString "vkLayerCount = " .
                                        showsPrec d (vkLayerCount x) . showChar '}'

data VkImageCreateInfo = VkImageCreateInfo## ByteArray##

instance Eq VkImageCreateInfo where
        (VkImageCreateInfo## a) == (VkImageCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageCreateInfo where
        (VkImageCreateInfo## a) `compare` (VkImageCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageCreateInfo where
        sizeOf ~_ = #{size VkImageCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageCreateInfo),
            I## a <- alignment (undefined :: VkImageCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkImageCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkImageCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkImageCreateInfo),
            I## a <- alignment (undefined :: VkImageCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkImageCreateInfo## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkImageCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkImageCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkImageCreateInfo),
            I## a <- alignment (undefined :: VkImageCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkImageCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkImageCreateInfo## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkImageCreateInfo where
        type VkSTypeMType VkImageCreateInfo = VkStructureType
        vkSType (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkImageCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_ = #{offset VkImageCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkImageCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkImageCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkImageCreateInfo where
        type VkPNextMType VkImageCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkImageCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_ = #{offset VkImageCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkImageCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkImageCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkImageCreateInfo where
        type VkFlagsMType VkImageCreateInfo = VkImageCreateFlags
        vkFlags (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkImageCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkImageCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_ = #{offset VkImageCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkImageCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkImageCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkImageType a where
        type VkImageTypeMType a :: *

        vkImageType :: a -> VkImageTypeMType a

        vkImageTypeByteOffset :: a -> Int

        readVkImageType :: Mutable a -> IO (VkImageTypeMType a)

        writeVkImageType :: Mutable a -> VkImageTypeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageType'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageType a

instance {-# OVERLAPPING #-} HasVkImageType VkImageCreateInfo where
        type VkImageTypeMType VkImageCreateInfo = VkImageType
        vkImageType (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkImageType),
            I## o <- vkImageTypeByteOffset (undefined :: VkImageCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageType #-}
        vkImageTypeByteOffset ~_
          = #{offset VkImageCreateInfo, imageType}

        {-# INLINE vkImageTypeByteOffset #-}
        readVkImageType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageType),
            I## o <- vkImageTypeByteOffset (undefined :: VkImageCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageType #-}
        writeVkImageType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageTypeByteOffset (undefined :: VkImageCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageType #-}

instance {-# OVERLAPPING #-} HasVkFormat VkImageCreateInfo where
        type VkFormatMType VkImageCreateInfo = VkFormat
        vkFormat (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkFormat),
            I## o <- vkFormatByteOffset (undefined :: VkImageCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFormat #-}
        vkFormatByteOffset ~_
          = #{offset VkImageCreateInfo, format}

        {-# INLINE vkFormatByteOffset #-}
        readVkFormat (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFormat),
            I## o <- vkFormatByteOffset (undefined :: VkImageCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFormat #-}
        writeVkFormat (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFormatByteOffset (undefined :: VkImageCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFormat #-}

instance {-# OVERLAPPING #-} HasVkExtent VkImageCreateInfo where
        type VkExtentMType VkImageCreateInfo = VkExtent3D
        vkExtent (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkExtentByteOffset (undefined :: VkImageCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkExtent #-}
        vkExtentByteOffset ~_
          = #{offset VkImageCreateInfo, extent}

        {-# INLINE vkExtentByteOffset #-}
        readVkExtent (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkExtentByteOffset (undefined :: VkImageCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkExtent #-}
        writeVkExtent (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkExtentByteOffset (undefined :: VkImageCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkExtent #-}

class HasVkMipLevels a where
        type VkMipLevelsMType a :: *

        vkMipLevels :: a -> VkMipLevelsMType a

        vkMipLevelsByteOffset :: a -> Int

        readVkMipLevels :: Mutable a -> IO (VkMipLevelsMType a)

        writeVkMipLevels :: Mutable a -> VkMipLevelsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'mipLevels'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMipLevels a

instance {-# OVERLAPPING #-} HasVkMipLevels VkImageCreateInfo where
        type VkMipLevelsMType VkImageCreateInfo = Data.Word.Word32
        vkMipLevels (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMipLevelsByteOffset (undefined :: VkImageCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMipLevels #-}
        vkMipLevelsByteOffset ~_
          = #{offset VkImageCreateInfo, mipLevels}

        {-# INLINE vkMipLevelsByteOffset #-}
        readVkMipLevels (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMipLevelsByteOffset (undefined :: VkImageCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMipLevels #-}
        writeVkMipLevels (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMipLevelsByteOffset (undefined :: VkImageCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMipLevels #-}

class HasVkArrayLayers a where
        type VkArrayLayersMType a :: *

        vkArrayLayers :: a -> VkArrayLayersMType a

        vkArrayLayersByteOffset :: a -> Int

        readVkArrayLayers :: Mutable a -> IO (VkArrayLayersMType a)

        writeVkArrayLayers :: Mutable a -> VkArrayLayersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'arrayLayers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkArrayLayers a

instance {-# OVERLAPPING #-} HasVkArrayLayers VkImageCreateInfo
         where
        type VkArrayLayersMType VkImageCreateInfo = Data.Word.Word32
        vkArrayLayers (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkArrayLayersByteOffset (undefined :: VkImageCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkArrayLayers #-}
        vkArrayLayersByteOffset ~_
          = #{offset VkImageCreateInfo, arrayLayers}

        {-# INLINE vkArrayLayersByteOffset #-}
        readVkArrayLayers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkArrayLayersByteOffset (undefined :: VkImageCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkArrayLayers #-}
        writeVkArrayLayers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkArrayLayersByteOffset (undefined :: VkImageCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkArrayLayers #-}

class HasVkSamples a where
        type VkSamplesMType a :: *

        vkSamples :: a -> VkSamplesMType a

        vkSamplesByteOffset :: a -> Int

        readVkSamples :: Mutable a -> IO (VkSamplesMType a)

        writeVkSamples :: Mutable a -> VkSamplesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'samples'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSamples a

instance {-# OVERLAPPING #-} HasVkSamples VkImageCreateInfo where
        type VkSamplesMType VkImageCreateInfo = VkSampleCountFlagBits
        vkSamples (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlagBits),
            I## o <- vkSamplesByteOffset (undefined :: VkImageCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSamples #-}
        vkSamplesByteOffset ~_
          = #{offset VkImageCreateInfo, samples}

        {-# INLINE vkSamplesByteOffset #-}
        readVkSamples (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlagBits),
            I## o <- vkSamplesByteOffset (undefined :: VkImageCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSamples #-}
        writeVkSamples (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSamplesByteOffset (undefined :: VkImageCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSamples #-}

class HasVkTiling a where
        type VkTilingMType a :: *

        vkTiling :: a -> VkTilingMType a

        vkTilingByteOffset :: a -> Int

        readVkTiling :: Mutable a -> IO (VkTilingMType a)

        writeVkTiling :: Mutable a -> VkTilingMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'tiling'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTiling a

instance {-# OVERLAPPING #-} HasVkTiling VkImageCreateInfo where
        type VkTilingMType VkImageCreateInfo = VkImageTiling
        vkTiling (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkImageTiling),
            I## o <- vkTilingByteOffset (undefined :: VkImageCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkTiling #-}
        vkTilingByteOffset ~_
          = #{offset VkImageCreateInfo, tiling}

        {-# INLINE vkTilingByteOffset #-}
        readVkTiling (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageTiling),
            I## o <- vkTilingByteOffset (undefined :: VkImageCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkTiling #-}
        writeVkTiling (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkTilingByteOffset (undefined :: VkImageCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkTiling #-}

instance {-# OVERLAPPING #-} HasVkUsage VkImageCreateInfo where
        type VkUsageMType VkImageCreateInfo = VkImageUsageFlags
        vkUsage (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkImageUsageFlags),
            I## o <- vkUsageByteOffset (undefined :: VkImageCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkUsage #-}
        vkUsageByteOffset ~_ = #{offset VkImageCreateInfo, usage}

        {-# INLINE vkUsageByteOffset #-}
        readVkUsage (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageUsageFlags),
            I## o <- vkUsageByteOffset (undefined :: VkImageCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkUsage #-}
        writeVkUsage (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkUsageByteOffset (undefined :: VkImageCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkUsage #-}

instance {-# OVERLAPPING #-} HasVkSharingMode VkImageCreateInfo
         where
        type VkSharingModeMType VkImageCreateInfo = VkSharingMode
        vkSharingMode (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkSharingMode),
            I## o <- vkSharingModeByteOffset (undefined :: VkImageCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSharingMode #-}
        vkSharingModeByteOffset ~_
          = #{offset VkImageCreateInfo, sharingMode}

        {-# INLINE vkSharingModeByteOffset #-}
        readVkSharingMode (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSharingMode),
            I## o <- vkSharingModeByteOffset (undefined :: VkImageCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSharingMode #-}
        writeVkSharingMode (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSharingModeByteOffset (undefined :: VkImageCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSharingMode #-}

instance {-# OVERLAPPING #-}
         HasVkQueueFamilyIndexCount VkImageCreateInfo where
        type VkQueueFamilyIndexCountMType VkImageCreateInfo =
             Data.Word.Word32
        vkQueueFamilyIndexCount (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueFamilyIndexCountByteOffset
                      (undefined :: VkImageCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkQueueFamilyIndexCount #-}
        vkQueueFamilyIndexCountByteOffset ~_
          = #{offset VkImageCreateInfo, queueFamilyIndexCount}

        {-# INLINE vkQueueFamilyIndexCountByteOffset #-}
        readVkQueueFamilyIndexCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueFamilyIndexCountByteOffset
                      (undefined :: VkImageCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkQueueFamilyIndexCount #-}
        writeVkQueueFamilyIndexCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkQueueFamilyIndexCountByteOffset
                      (undefined :: VkImageCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkQueueFamilyIndexCount #-}

instance {-# OVERLAPPING #-}
         HasVkPQueueFamilyIndices VkImageCreateInfo where
        type VkPQueueFamilyIndicesMType VkImageCreateInfo =
             Foreign.Ptr.Ptr Data.Word.Word32
        vkPQueueFamilyIndices (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Word.Word32),
            I## o <- vkPQueueFamilyIndicesByteOffset
                      (undefined :: VkImageCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPQueueFamilyIndices #-}
        vkPQueueFamilyIndicesByteOffset ~_
          = #{offset VkImageCreateInfo, pQueueFamilyIndices}

        {-# INLINE vkPQueueFamilyIndicesByteOffset #-}
        readVkPQueueFamilyIndices (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Word.Word32),
            I## o <- vkPQueueFamilyIndicesByteOffset
                      (undefined :: VkImageCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPQueueFamilyIndices #-}
        writeVkPQueueFamilyIndices (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPQueueFamilyIndicesByteOffset
                      (undefined :: VkImageCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPQueueFamilyIndices #-}

class HasVkInitialLayout a where
        type VkInitialLayoutMType a :: *

        vkInitialLayout :: a -> VkInitialLayoutMType a

        vkInitialLayoutByteOffset :: a -> Int

        readVkInitialLayout :: Mutable a -> IO (VkInitialLayoutMType a)

        writeVkInitialLayout ::
                             Mutable a -> VkInitialLayoutMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'initialLayout'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkInitialLayout a

instance {-# OVERLAPPING #-} HasVkInitialLayout VkImageCreateInfo
         where
        type VkInitialLayoutMType VkImageCreateInfo = VkImageLayout
        vkInitialLayout (VkImageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkImageLayout),
            I## o <- vkInitialLayoutByteOffset (undefined :: VkImageCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkInitialLayout #-}
        vkInitialLayoutByteOffset ~_
          = #{offset VkImageCreateInfo, initialLayout}

        {-# INLINE vkInitialLayoutByteOffset #-}
        readVkInitialLayout (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageLayout),
            I## o <- vkInitialLayoutByteOffset (undefined :: VkImageCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkInitialLayout #-}
        writeVkInitialLayout (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkInitialLayoutByteOffset (undefined :: VkImageCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkInitialLayout #-}

instance Show VkImageCreateInfo where
        showsPrec d x
          = showString "VkImageCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkImageType = " .
                                  showsPrec d (vkImageType x) .
                                    showString ", " .
                                      showString "vkFormat = " .
                                        showsPrec d (vkFormat x) .
                                          showString ", " .
                                            showString "vkExtent = " .
                                              showsPrec d (vkExtent x) .
                                                showString ", " .
                                                  showString "vkMipLevels = " .
                                                    showsPrec d (vkMipLevels x) .
                                                      showString ", " .
                                                        showString "vkArrayLayers = " .
                                                          showsPrec d (vkArrayLayers x) .
                                                            showString ", " .
                                                              showString "vkSamples = " .
                                                                showsPrec d (vkSamples x) .
                                                                  showString ", " .
                                                                    showString "vkTiling = " .
                                                                      showsPrec d (vkTiling x) .
                                                                        showString ", " .
                                                                          showString "vkUsage = " .
                                                                            showsPrec d (vkUsage x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkSharingMode = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkSharingMode
                                                                                       x)
                                                                                    .
                                                                                    showString ", "
                                                                                      .
                                                                                      showString
                                                                                        "vkQueueFamilyIndexCount = "
                                                                                        .
                                                                                        showsPrec d
                                                                                          (vkQueueFamilyIndexCount
                                                                                             x)
                                                                                          .
                                                                                          showString
                                                                                            ", "
                                                                                            .
                                                                                            showString
                                                                                              "vkPQueueFamilyIndices = "
                                                                                              .
                                                                                              showsPrec
                                                                                                d
                                                                                                (vkPQueueFamilyIndices
                                                                                                   x)
                                                                                                .
                                                                                                showString
                                                                                                  ", "
                                                                                                  .
                                                                                                  showString
                                                                                                    "vkInitialLayout = "
                                                                                                    .
                                                                                                    showsPrec
                                                                                                      d
                                                                                                      (vkInitialLayout
                                                                                                         x)
                                                                                                      .
                                                                                                      showChar
                                                                                                        '}'

data VkSubresourceLayout = VkSubresourceLayout## ByteArray##

instance Eq VkSubresourceLayout where
        (VkSubresourceLayout## a) == (VkSubresourceLayout## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSubresourceLayout where
        (VkSubresourceLayout## a) `compare` (VkSubresourceLayout## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSubresourceLayout where
        sizeOf ~_ = #{size VkSubresourceLayout}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSubresourceLayout}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSubresourceLayout),
            I## a <- alignment (undefined :: VkSubresourceLayout) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSubresourceLayout## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSubresourceLayout## ba)
          | I## n <- sizeOf (undefined :: VkSubresourceLayout) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSubresourceLayout where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSubresourceLayout),
            I## a <- alignment (undefined :: VkSubresourceLayout) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSubresourceLayout## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSubresourceLayout## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSubresourceLayout## ba)
          | I## n <- sizeOf (undefined :: VkSubresourceLayout),
            I## a <- alignment (undefined :: VkSubresourceLayout) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSubresourceLayout## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSubresourceLayout## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkOffset VkSubresourceLayout where
        type VkOffsetMType VkSubresourceLayout = VkDeviceSize
        vkOffset (VkSubresourceLayout## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkOffsetByteOffset (undefined :: VkSubresourceLayout) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkSubresourceLayout, offset}

        {-# INLINE vkOffsetByteOffset #-}
        readVkOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkOffsetByteOffset (undefined :: VkSubresourceLayout) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOffset #-}
        writeVkOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOffsetByteOffset (undefined :: VkSubresourceLayout) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOffset #-}

instance {-# OVERLAPPING #-} HasVkSize VkSubresourceLayout where
        type VkSizeMType VkSubresourceLayout = VkDeviceSize
        vkSize (VkSubresourceLayout## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSizeByteOffset (undefined :: VkSubresourceLayout) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSize #-}
        vkSizeByteOffset ~_ = #{offset VkSubresourceLayout, size}

        {-# INLINE vkSizeByteOffset #-}
        readVkSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSizeByteOffset (undefined :: VkSubresourceLayout) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSize #-}
        writeVkSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSizeByteOffset (undefined :: VkSubresourceLayout) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSize #-}

class HasVkRowPitch a where
        type VkRowPitchMType a :: *

        vkRowPitch :: a -> VkRowPitchMType a

        vkRowPitchByteOffset :: a -> Int

        readVkRowPitch :: Mutable a -> IO (VkRowPitchMType a)

        writeVkRowPitch :: Mutable a -> VkRowPitchMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'rowPitch'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRowPitch a

instance {-# OVERLAPPING #-} HasVkRowPitch VkSubresourceLayout
         where
        type VkRowPitchMType VkSubresourceLayout = VkDeviceSize
        vkRowPitch (VkSubresourceLayout## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkRowPitchByteOffset (undefined :: VkSubresourceLayout) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkRowPitch #-}
        vkRowPitchByteOffset ~_
          = #{offset VkSubresourceLayout, rowPitch}

        {-# INLINE vkRowPitchByteOffset #-}
        readVkRowPitch (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkRowPitchByteOffset (undefined :: VkSubresourceLayout) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkRowPitch #-}
        writeVkRowPitch (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkRowPitchByteOffset (undefined :: VkSubresourceLayout) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkRowPitch #-}

class HasVkArrayPitch a where
        type VkArrayPitchMType a :: *

        vkArrayPitch :: a -> VkArrayPitchMType a

        vkArrayPitchByteOffset :: a -> Int

        readVkArrayPitch :: Mutable a -> IO (VkArrayPitchMType a)

        writeVkArrayPitch :: Mutable a -> VkArrayPitchMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'arrayPitch'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkArrayPitch a

instance {-# OVERLAPPING #-} HasVkArrayPitch VkSubresourceLayout
         where
        type VkArrayPitchMType VkSubresourceLayout = VkDeviceSize
        vkArrayPitch (VkSubresourceLayout## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkArrayPitchByteOffset (undefined :: VkSubresourceLayout) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkArrayPitch #-}
        vkArrayPitchByteOffset ~_
          = #{offset VkSubresourceLayout, arrayPitch}

        {-# INLINE vkArrayPitchByteOffset #-}
        readVkArrayPitch (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkArrayPitchByteOffset (undefined :: VkSubresourceLayout) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkArrayPitch #-}
        writeVkArrayPitch (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkArrayPitchByteOffset (undefined :: VkSubresourceLayout) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkArrayPitch #-}

class HasVkDepthPitch a where
        type VkDepthPitchMType a :: *

        vkDepthPitch :: a -> VkDepthPitchMType a

        vkDepthPitchByteOffset :: a -> Int

        readVkDepthPitch :: Mutable a -> IO (VkDepthPitchMType a)

        writeVkDepthPitch :: Mutable a -> VkDepthPitchMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthPitch'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthPitch a

instance {-# OVERLAPPING #-} HasVkDepthPitch VkSubresourceLayout
         where
        type VkDepthPitchMType VkSubresourceLayout = VkDeviceSize
        vkDepthPitch (VkSubresourceLayout## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkDepthPitchByteOffset (undefined :: VkSubresourceLayout) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthPitch #-}
        vkDepthPitchByteOffset ~_
          = #{offset VkSubresourceLayout, depthPitch}

        {-# INLINE vkDepthPitchByteOffset #-}
        readVkDepthPitch (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkDepthPitchByteOffset (undefined :: VkSubresourceLayout) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthPitch #-}
        writeVkDepthPitch (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthPitchByteOffset (undefined :: VkSubresourceLayout) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthPitch #-}

instance Show VkSubresourceLayout where
        showsPrec d x
          = showString "VkSubresourceLayout {" .
              showString "vkOffset = " .
                showsPrec d (vkOffset x) .
                  showString ", " .
                    showString "vkSize = " .
                      showsPrec d (vkSize x) .
                        showString ", " .
                          showString "vkRowPitch = " .
                            showsPrec d (vkRowPitch x) .
                              showString ", " .
                                showString "vkArrayPitch = " .
                                  showsPrec d (vkArrayPitch x) .
                                    showString ", " .
                                      showString "vkDepthPitch = " .
                                        showsPrec d (vkDepthPitch x) . showChar '}'

data VkImageViewCreateInfo = VkImageViewCreateInfo## ByteArray##

instance Eq VkImageViewCreateInfo where
        (VkImageViewCreateInfo## a) == (VkImageViewCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageViewCreateInfo where
        (VkImageViewCreateInfo## a) `compare` (VkImageViewCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageViewCreateInfo where
        sizeOf ~_ = #{size VkImageViewCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageViewCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageViewCreateInfo),
            I## a <- alignment (undefined :: VkImageViewCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkImageViewCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageViewCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkImageViewCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageViewCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkImageViewCreateInfo),
            I## a <- alignment (undefined :: VkImageViewCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkImageViewCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkImageViewCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkImageViewCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkImageViewCreateInfo),
            I## a <- alignment (undefined :: VkImageViewCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkImageViewCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkImageViewCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkImageViewCreateInfo where
        type VkSTypeMType VkImageViewCreateInfo = VkStructureType
        vkSType (VkImageViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkImageViewCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkImageViewCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkImageViewCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkImageViewCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkImageViewCreateInfo where
        type VkPNextMType VkImageViewCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkImageViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkImageViewCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkImageViewCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkImageViewCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkImageViewCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkImageViewCreateInfo where
        type VkFlagsMType VkImageViewCreateInfo = VkImageViewCreateFlags
        vkFlags (VkImageViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkImageViewCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkImageViewCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkImageViewCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageViewCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkImageViewCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkImageViewCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkImage a where
        type VkImageMType a :: *

        vkImage :: a -> VkImageMType a

        vkImageByteOffset :: a -> Int

        readVkImage :: Mutable a -> IO (VkImageMType a)

        writeVkImage :: Mutable a -> VkImageMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'image'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImage a

instance {-# OVERLAPPING #-} HasVkImage VkImageViewCreateInfo where
        type VkImageMType VkImageViewCreateInfo = VkImage
        vkImage (VkImageViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkImage),
            I## o <- vkImageByteOffset (undefined :: VkImageViewCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImage #-}
        vkImageByteOffset ~_
          = #{offset VkImageViewCreateInfo, image}

        {-# INLINE vkImageByteOffset #-}
        readVkImage (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImage),
            I## o <- vkImageByteOffset (undefined :: VkImageViewCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImage #-}
        writeVkImage (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageByteOffset (undefined :: VkImageViewCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImage #-}

class HasVkViewType a where
        type VkViewTypeMType a :: *

        vkViewType :: a -> VkViewTypeMType a

        vkViewTypeByteOffset :: a -> Int

        readVkViewType :: Mutable a -> IO (VkViewTypeMType a)

        writeVkViewType :: Mutable a -> VkViewTypeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'viewType'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkViewType a

instance {-# OVERLAPPING #-} HasVkViewType VkImageViewCreateInfo
         where
        type VkViewTypeMType VkImageViewCreateInfo = VkImageViewType
        vkViewType (VkImageViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkImageViewType),
            I## o <- vkViewTypeByteOffset (undefined :: VkImageViewCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkViewType #-}
        vkViewTypeByteOffset ~_
          = #{offset VkImageViewCreateInfo, viewType}

        {-# INLINE vkViewTypeByteOffset #-}
        readVkViewType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageViewType),
            I## o <- vkViewTypeByteOffset (undefined :: VkImageViewCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkViewType #-}
        writeVkViewType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkViewTypeByteOffset (undefined :: VkImageViewCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkViewType #-}

instance {-# OVERLAPPING #-} HasVkFormat VkImageViewCreateInfo
         where
        type VkFormatMType VkImageViewCreateInfo = VkFormat
        vkFormat (VkImageViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkFormat),
            I## o <- vkFormatByteOffset (undefined :: VkImageViewCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFormat #-}
        vkFormatByteOffset ~_
          = #{offset VkImageViewCreateInfo, format}

        {-# INLINE vkFormatByteOffset #-}
        readVkFormat (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFormat),
            I## o <- vkFormatByteOffset (undefined :: VkImageViewCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFormat #-}
        writeVkFormat (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFormatByteOffset (undefined :: VkImageViewCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFormat #-}

class HasVkComponents a where
        type VkComponentsMType a :: *

        vkComponents :: a -> VkComponentsMType a

        vkComponentsByteOffset :: a -> Int

        readVkComponents :: Mutable a -> IO (VkComponentsMType a)

        writeVkComponents :: Mutable a -> VkComponentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'components'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkComponents a

instance {-# OVERLAPPING #-} HasVkComponents VkImageViewCreateInfo
         where
        type VkComponentsMType VkImageViewCreateInfo = VkComponentMapping
        vkComponents (VkImageViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkComponentMapping),
            I## o <- vkComponentsByteOffset (undefined :: VkImageViewCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkComponents #-}
        vkComponentsByteOffset ~_
          = #{offset VkImageViewCreateInfo, components}

        {-# INLINE vkComponentsByteOffset #-}
        readVkComponents (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkComponentMapping),
            I## o <- vkComponentsByteOffset (undefined :: VkImageViewCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkComponents #-}
        writeVkComponents (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkComponentsByteOffset (undefined :: VkImageViewCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkComponents #-}

class HasVkSubresourceRange a where
        type VkSubresourceRangeMType a :: *

        vkSubresourceRange :: a -> VkSubresourceRangeMType a

        vkSubresourceRangeByteOffset :: a -> Int

        readVkSubresourceRange ::
                               Mutable a -> IO (VkSubresourceRangeMType a)

        writeVkSubresourceRange ::
                                Mutable a -> VkSubresourceRangeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'subresourceRange'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSubresourceRange a

instance {-# OVERLAPPING #-}
         HasVkSubresourceRange VkImageViewCreateInfo where
        type VkSubresourceRangeMType VkImageViewCreateInfo =
             VkImageSubresourceRange
        vkSubresourceRange (VkImageViewCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceRange),
            I## o <- vkSubresourceRangeByteOffset
                      (undefined :: VkImageViewCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSubresourceRange #-}
        vkSubresourceRangeByteOffset ~_
          = #{offset VkImageViewCreateInfo, subresourceRange}

        {-# INLINE vkSubresourceRangeByteOffset #-}
        readVkSubresourceRange (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceRange),
            I## o <- vkSubresourceRangeByteOffset
                      (undefined :: VkImageViewCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSubresourceRange #-}
        writeVkSubresourceRange (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSubresourceRangeByteOffset
                      (undefined :: VkImageViewCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSubresourceRange #-}

instance Show VkImageViewCreateInfo where
        showsPrec d x
          = showString "VkImageViewCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkImage = " .
                                  showsPrec d (vkImage x) .
                                    showString ", " .
                                      showString "vkViewType = " .
                                        showsPrec d (vkViewType x) .
                                          showString ", " .
                                            showString "vkFormat = " .
                                              showsPrec d (vkFormat x) .
                                                showString ", " .
                                                  showString "vkComponents = " .
                                                    showsPrec d (vkComponents x) .
                                                      showString ", " .
                                                        showString "vkSubresourceRange = " .
                                                          showsPrec d (vkSubresourceRange x) .
                                                            showChar '}'

data VkBufferCopy = VkBufferCopy## ByteArray##

instance Eq VkBufferCopy where
        (VkBufferCopy## a) == (VkBufferCopy## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkBufferCopy where
        (VkBufferCopy## a) `compare` (VkBufferCopy## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkBufferCopy where
        sizeOf ~_ = #{size VkBufferCopy}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkBufferCopy}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkBufferCopy),
            I## a <- alignment (undefined :: VkBufferCopy) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkBufferCopy## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkBufferCopy## ba)
          | I## n <- sizeOf (undefined :: VkBufferCopy) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkBufferCopy where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkBufferCopy),
            I## a <- alignment (undefined :: VkBufferCopy) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkBufferCopy## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkBufferCopy## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkBufferCopy## ba)
          | I## n <- sizeOf (undefined :: VkBufferCopy),
            I## a <- alignment (undefined :: VkBufferCopy) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkBufferCopy## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkBufferCopy## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkSrcOffset a where
        type VkSrcOffsetMType a :: *

        vkSrcOffset :: a -> VkSrcOffsetMType a

        vkSrcOffsetByteOffset :: a -> Int

        readVkSrcOffset :: Mutable a -> IO (VkSrcOffsetMType a)

        writeVkSrcOffset :: Mutable a -> VkSrcOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcOffset a

instance {-# OVERLAPPING #-} HasVkSrcOffset VkBufferCopy where
        type VkSrcOffsetMType VkBufferCopy = VkDeviceSize
        vkSrcOffset (VkBufferCopy## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSrcOffsetByteOffset (undefined :: VkBufferCopy) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSrcOffset #-}
        vkSrcOffsetByteOffset ~_
          = #{offset VkBufferCopy, srcOffset}

        {-# INLINE vkSrcOffsetByteOffset #-}
        readVkSrcOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSrcOffsetByteOffset (undefined :: VkBufferCopy) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSrcOffset #-}
        writeVkSrcOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcOffsetByteOffset (undefined :: VkBufferCopy) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSrcOffset #-}

class HasVkDstOffset a where
        type VkDstOffsetMType a :: *

        vkDstOffset :: a -> VkDstOffsetMType a

        vkDstOffsetByteOffset :: a -> Int

        readVkDstOffset :: Mutable a -> IO (VkDstOffsetMType a)

        writeVkDstOffset :: Mutable a -> VkDstOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstOffset a

instance {-# OVERLAPPING #-} HasVkDstOffset VkBufferCopy where
        type VkDstOffsetMType VkBufferCopy = VkDeviceSize
        vkDstOffset (VkBufferCopy## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkDstOffsetByteOffset (undefined :: VkBufferCopy) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstOffset #-}
        vkDstOffsetByteOffset ~_
          = #{offset VkBufferCopy, dstOffset}

        {-# INLINE vkDstOffsetByteOffset #-}
        readVkDstOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkDstOffsetByteOffset (undefined :: VkBufferCopy) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstOffset #-}
        writeVkDstOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstOffsetByteOffset (undefined :: VkBufferCopy) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstOffset #-}

instance {-# OVERLAPPING #-} HasVkSize VkBufferCopy where
        type VkSizeMType VkBufferCopy = VkDeviceSize
        vkSize (VkBufferCopy## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSizeByteOffset (undefined :: VkBufferCopy) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSize #-}
        vkSizeByteOffset ~_ = #{offset VkBufferCopy, size}

        {-# INLINE vkSizeByteOffset #-}
        readVkSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSizeByteOffset (undefined :: VkBufferCopy) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSize #-}
        writeVkSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSizeByteOffset (undefined :: VkBufferCopy) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSize #-}

instance Show VkBufferCopy where
        showsPrec d x
          = showString "VkBufferCopy {" .
              showString "vkSrcOffset = " .
                showsPrec d (vkSrcOffset x) .
                  showString ", " .
                    showString "vkDstOffset = " .
                      showsPrec d (vkDstOffset x) .
                        showString ", " .
                          showString "vkSize = " . showsPrec d (vkSize x) . showChar '}'

data VkSparseMemoryBind = VkSparseMemoryBind## ByteArray##

instance Eq VkSparseMemoryBind where
        (VkSparseMemoryBind## a) == (VkSparseMemoryBind## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSparseMemoryBind where
        (VkSparseMemoryBind## a) `compare` (VkSparseMemoryBind## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSparseMemoryBind where
        sizeOf ~_ = #{size VkSparseMemoryBind}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSparseMemoryBind}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSparseMemoryBind),
            I## a <- alignment (undefined :: VkSparseMemoryBind) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSparseMemoryBind## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSparseMemoryBind## ba)
          | I## n <- sizeOf (undefined :: VkSparseMemoryBind) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSparseMemoryBind where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSparseMemoryBind),
            I## a <- alignment (undefined :: VkSparseMemoryBind) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSparseMemoryBind## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSparseMemoryBind## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSparseMemoryBind## ba)
          | I## n <- sizeOf (undefined :: VkSparseMemoryBind),
            I## a <- alignment (undefined :: VkSparseMemoryBind) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSparseMemoryBind## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSparseMemoryBind## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkResourceOffset a where
        type VkResourceOffsetMType a :: *

        vkResourceOffset :: a -> VkResourceOffsetMType a

        vkResourceOffsetByteOffset :: a -> Int

        readVkResourceOffset :: Mutable a -> IO (VkResourceOffsetMType a)

        writeVkResourceOffset ::
                              Mutable a -> VkResourceOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'resourceOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkResourceOffset a

instance {-# OVERLAPPING #-} HasVkResourceOffset VkSparseMemoryBind
         where
        type VkResourceOffsetMType VkSparseMemoryBind = VkDeviceSize
        vkResourceOffset (VkSparseMemoryBind## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkResourceOffsetByteOffset
                      (undefined :: VkSparseMemoryBind)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkResourceOffset #-}
        vkResourceOffsetByteOffset ~_
          = #{offset VkSparseMemoryBind, resourceOffset}

        {-# INLINE vkResourceOffsetByteOffset #-}
        readVkResourceOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkResourceOffsetByteOffset
                      (undefined :: VkSparseMemoryBind)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkResourceOffset #-}
        writeVkResourceOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkResourceOffsetByteOffset
                      (undefined :: VkSparseMemoryBind)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkResourceOffset #-}

instance {-# OVERLAPPING #-} HasVkSize VkSparseMemoryBind where
        type VkSizeMType VkSparseMemoryBind = VkDeviceSize
        vkSize (VkSparseMemoryBind## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSizeByteOffset (undefined :: VkSparseMemoryBind) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSize #-}
        vkSizeByteOffset ~_ = #{offset VkSparseMemoryBind, size}

        {-# INLINE vkSizeByteOffset #-}
        readVkSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSizeByteOffset (undefined :: VkSparseMemoryBind) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSize #-}
        writeVkSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSizeByteOffset (undefined :: VkSparseMemoryBind) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSize #-}

instance {-# OVERLAPPING #-} HasVkMemory VkSparseMemoryBind where
        type VkMemoryMType VkSparseMemoryBind = VkDeviceMemory
        vkMemory (VkSparseMemoryBind## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceMemory),
            I## o <- vkMemoryByteOffset (undefined :: VkSparseMemoryBind) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMemory #-}
        vkMemoryByteOffset ~_
          = #{offset VkSparseMemoryBind, memory}

        {-# INLINE vkMemoryByteOffset #-}
        readVkMemory (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceMemory),
            I## o <- vkMemoryByteOffset (undefined :: VkSparseMemoryBind) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMemory #-}
        writeVkMemory (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMemoryByteOffset (undefined :: VkSparseMemoryBind) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMemory #-}

class HasVkMemoryOffset a where
        type VkMemoryOffsetMType a :: *

        vkMemoryOffset :: a -> VkMemoryOffsetMType a

        vkMemoryOffsetByteOffset :: a -> Int

        readVkMemoryOffset :: Mutable a -> IO (VkMemoryOffsetMType a)

        writeVkMemoryOffset :: Mutable a -> VkMemoryOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'memoryOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMemoryOffset a

instance {-# OVERLAPPING #-} HasVkMemoryOffset VkSparseMemoryBind
         where
        type VkMemoryOffsetMType VkSparseMemoryBind = VkDeviceSize
        vkMemoryOffset (VkSparseMemoryBind## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkMemoryOffsetByteOffset (undefined :: VkSparseMemoryBind)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMemoryOffset #-}
        vkMemoryOffsetByteOffset ~_
          = #{offset VkSparseMemoryBind, memoryOffset}

        {-# INLINE vkMemoryOffsetByteOffset #-}
        readVkMemoryOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkMemoryOffsetByteOffset (undefined :: VkSparseMemoryBind)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMemoryOffset #-}
        writeVkMemoryOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMemoryOffsetByteOffset (undefined :: VkSparseMemoryBind)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMemoryOffset #-}

instance {-# OVERLAPPING #-} HasVkFlags VkSparseMemoryBind where
        type VkFlagsMType VkSparseMemoryBind = VkSparseMemoryBindFlags
        vkFlags (VkSparseMemoryBind## ba)
          | I## _n <- sizeOf (undefined :: VkSparseMemoryBindFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkSparseMemoryBind) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_ = #{offset VkSparseMemoryBind, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSparseMemoryBindFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkSparseMemoryBind) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkSparseMemoryBind) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

instance Show VkSparseMemoryBind where
        showsPrec d x
          = showString "VkSparseMemoryBind {" .
              showString "vkResourceOffset = " .
                showsPrec d (vkResourceOffset x) .
                  showString ", " .
                    showString "vkSize = " .
                      showsPrec d (vkSize x) .
                        showString ", " .
                          showString "vkMemory = " .
                            showsPrec d (vkMemory x) .
                              showString ", " .
                                showString "vkMemoryOffset = " .
                                  showsPrec d (vkMemoryOffset x) .
                                    showString ", " .
                                      showString "vkFlags = " .
                                        showsPrec d (vkFlags x) . showChar '}'

data VkSparseImageMemoryBind = VkSparseImageMemoryBind## ByteArray##

instance Eq VkSparseImageMemoryBind where
        (VkSparseImageMemoryBind## a) == (VkSparseImageMemoryBind## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSparseImageMemoryBind where
        (VkSparseImageMemoryBind## a) `compare` (VkSparseImageMemoryBind## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSparseImageMemoryBind where
        sizeOf ~_ = #{size VkSparseImageMemoryBind}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSparseImageMemoryBind}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryBind),
            I## a <- alignment (undefined :: VkSparseImageMemoryBind) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSparseImageMemoryBind##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSparseImageMemoryBind## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryBind) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSparseImageMemoryBind where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryBind),
            I## a <- alignment (undefined :: VkSparseImageMemoryBind) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSparseImageMemoryBind##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSparseImageMemoryBind## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSparseImageMemoryBind## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryBind),
            I## a <- alignment (undefined :: VkSparseImageMemoryBind) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSparseImageMemoryBind## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSparseImageMemoryBind## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkSubresource a where
        type VkSubresourceMType a :: *

        vkSubresource :: a -> VkSubresourceMType a

        vkSubresourceByteOffset :: a -> Int

        readVkSubresource :: Mutable a -> IO (VkSubresourceMType a)

        writeVkSubresource :: Mutable a -> VkSubresourceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'subresource'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSubresource a

instance {-# OVERLAPPING #-}
         HasVkSubresource VkSparseImageMemoryBind where
        type VkSubresourceMType VkSparseImageMemoryBind =
             VkImageSubresource
        vkSubresource (VkSparseImageMemoryBind## ba)
          | I## _n <- sizeOf (undefined :: VkImageSubresource),
            I## o <- vkSubresourceByteOffset
                      (undefined :: VkSparseImageMemoryBind)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSubresource #-}
        vkSubresourceByteOffset ~_
          = #{offset VkSparseImageMemoryBind, subresource}

        {-# INLINE vkSubresourceByteOffset #-}
        readVkSubresource (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageSubresource),
            I## o <- vkSubresourceByteOffset
                      (undefined :: VkSparseImageMemoryBind)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSubresource #-}
        writeVkSubresource (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSubresourceByteOffset
                      (undefined :: VkSparseImageMemoryBind)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSubresource #-}

instance {-# OVERLAPPING #-} HasVkOffset VkSparseImageMemoryBind
         where
        type VkOffsetMType VkSparseImageMemoryBind = VkOffset3D
        vkOffset (VkSparseImageMemoryBind## ba)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkOffsetByteOffset (undefined :: VkSparseImageMemoryBind) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkSparseImageMemoryBind, offset}

        {-# INLINE vkOffsetByteOffset #-}
        readVkOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkOffsetByteOffset (undefined :: VkSparseImageMemoryBind) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOffset #-}
        writeVkOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOffsetByteOffset (undefined :: VkSparseImageMemoryBind) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOffset #-}

instance {-# OVERLAPPING #-} HasVkExtent VkSparseImageMemoryBind
         where
        type VkExtentMType VkSparseImageMemoryBind = VkExtent3D
        vkExtent (VkSparseImageMemoryBind## ba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkExtentByteOffset (undefined :: VkSparseImageMemoryBind) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkExtent #-}
        vkExtentByteOffset ~_
          = #{offset VkSparseImageMemoryBind, extent}

        {-# INLINE vkExtentByteOffset #-}
        readVkExtent (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkExtentByteOffset (undefined :: VkSparseImageMemoryBind) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkExtent #-}
        writeVkExtent (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkExtentByteOffset (undefined :: VkSparseImageMemoryBind) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkExtent #-}

instance {-# OVERLAPPING #-} HasVkMemory VkSparseImageMemoryBind
         where
        type VkMemoryMType VkSparseImageMemoryBind = VkDeviceMemory
        vkMemory (VkSparseImageMemoryBind## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceMemory),
            I## o <- vkMemoryByteOffset (undefined :: VkSparseImageMemoryBind) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMemory #-}
        vkMemoryByteOffset ~_
          = #{offset VkSparseImageMemoryBind, memory}

        {-# INLINE vkMemoryByteOffset #-}
        readVkMemory (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceMemory),
            I## o <- vkMemoryByteOffset (undefined :: VkSparseImageMemoryBind) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMemory #-}
        writeVkMemory (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMemoryByteOffset (undefined :: VkSparseImageMemoryBind) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMemory #-}

instance {-# OVERLAPPING #-}
         HasVkMemoryOffset VkSparseImageMemoryBind where
        type VkMemoryOffsetMType VkSparseImageMemoryBind = VkDeviceSize
        vkMemoryOffset (VkSparseImageMemoryBind## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkMemoryOffsetByteOffset
                      (undefined :: VkSparseImageMemoryBind)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMemoryOffset #-}
        vkMemoryOffsetByteOffset ~_
          = #{offset VkSparseImageMemoryBind, memoryOffset}

        {-# INLINE vkMemoryOffsetByteOffset #-}
        readVkMemoryOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkMemoryOffsetByteOffset
                      (undefined :: VkSparseImageMemoryBind)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMemoryOffset #-}
        writeVkMemoryOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMemoryOffsetByteOffset
                      (undefined :: VkSparseImageMemoryBind)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMemoryOffset #-}

instance {-# OVERLAPPING #-} HasVkFlags VkSparseImageMemoryBind
         where
        type VkFlagsMType VkSparseImageMemoryBind = VkSparseMemoryBindFlags
        vkFlags (VkSparseImageMemoryBind## ba)
          | I## _n <- sizeOf (undefined :: VkSparseMemoryBindFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkSparseImageMemoryBind) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkSparseImageMemoryBind, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSparseMemoryBindFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkSparseImageMemoryBind) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkSparseImageMemoryBind) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

instance Show VkSparseImageMemoryBind where
        showsPrec d x
          = showString "VkSparseImageMemoryBind {" .
              showString "vkSubresource = " .
                showsPrec d (vkSubresource x) .
                  showString ", " .
                    showString "vkOffset = " .
                      showsPrec d (vkOffset x) .
                        showString ", " .
                          showString "vkExtent = " .
                            showsPrec d (vkExtent x) .
                              showString ", " .
                                showString "vkMemory = " .
                                  showsPrec d (vkMemory x) .
                                    showString ", " .
                                      showString "vkMemoryOffset = " .
                                        showsPrec d (vkMemoryOffset x) .
                                          showString ", " .
                                            showString "vkFlags = " .
                                              showsPrec d (vkFlags x) . showChar '}'

data VkSparseBufferMemoryBindInfo = VkSparseBufferMemoryBindInfo## ByteArray##

instance Eq VkSparseBufferMemoryBindInfo where
        (VkSparseBufferMemoryBindInfo## a) ==
          (VkSparseBufferMemoryBindInfo## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSparseBufferMemoryBindInfo where
        (VkSparseBufferMemoryBindInfo## a) `compare`
          (VkSparseBufferMemoryBindInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSparseBufferMemoryBindInfo where
        sizeOf ~_ = #{size VkSparseBufferMemoryBindInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSparseBufferMemoryBindInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSparseBufferMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseBufferMemoryBindInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSparseBufferMemoryBindInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSparseBufferMemoryBindInfo## ba)
          | I## n <- sizeOf (undefined :: VkSparseBufferMemoryBindInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSparseBufferMemoryBindInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSparseBufferMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseBufferMemoryBindInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSparseBufferMemoryBindInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSparseBufferMemoryBindInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSparseBufferMemoryBindInfo## ba)
          | I## n <- sizeOf (undefined :: VkSparseBufferMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseBufferMemoryBindInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSparseBufferMemoryBindInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSparseBufferMemoryBindInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkBuffer VkSparseBufferMemoryBindInfo where
        type VkBufferMType VkSparseBufferMemoryBindInfo = VkBuffer
        vkBuffer (VkSparseBufferMemoryBindInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBuffer),
            I## o <- vkBufferByteOffset
                      (undefined :: VkSparseBufferMemoryBindInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBuffer #-}
        vkBufferByteOffset ~_
          = #{offset VkSparseBufferMemoryBindInfo, buffer}

        {-# INLINE vkBufferByteOffset #-}
        readVkBuffer (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBuffer),
            I## o <- vkBufferByteOffset
                      (undefined :: VkSparseBufferMemoryBindInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBuffer #-}
        writeVkBuffer (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBufferByteOffset
                      (undefined :: VkSparseBufferMemoryBindInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBuffer #-}

class HasVkBindCount a where
        type VkBindCountMType a :: *

        vkBindCount :: a -> VkBindCountMType a

        vkBindCountByteOffset :: a -> Int

        readVkBindCount :: Mutable a -> IO (VkBindCountMType a)

        writeVkBindCount :: Mutable a -> VkBindCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bindCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBindCount a

instance {-# OVERLAPPING #-}
         HasVkBindCount VkSparseBufferMemoryBindInfo where
        type VkBindCountMType VkSparseBufferMemoryBindInfo =
             Data.Word.Word32
        vkBindCount (VkSparseBufferMemoryBindInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBindCountByteOffset
                      (undefined :: VkSparseBufferMemoryBindInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBindCount #-}
        vkBindCountByteOffset ~_
          = #{offset VkSparseBufferMemoryBindInfo, bindCount}

        {-# INLINE vkBindCountByteOffset #-}
        readVkBindCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBindCountByteOffset
                      (undefined :: VkSparseBufferMemoryBindInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBindCount #-}
        writeVkBindCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBindCountByteOffset
                      (undefined :: VkSparseBufferMemoryBindInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBindCount #-}

class HasVkPBinds a where
        type VkPBindsMType a :: *

        vkPBinds :: a -> VkPBindsMType a

        vkPBindsByteOffset :: a -> Int

        readVkPBinds :: Mutable a -> IO (VkPBindsMType a)

        writeVkPBinds :: Mutable a -> VkPBindsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pBinds'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPBinds a

instance {-# OVERLAPPING #-}
         HasVkPBinds VkSparseBufferMemoryBindInfo where
        type VkPBindsMType VkSparseBufferMemoryBindInfo =
             Foreign.Ptr.Ptr VkSparseMemoryBind
        vkPBinds (VkSparseBufferMemoryBindInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSparseMemoryBind),
            I## o <- vkPBindsByteOffset
                      (undefined :: VkSparseBufferMemoryBindInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPBinds #-}
        vkPBindsByteOffset ~_
          = #{offset VkSparseBufferMemoryBindInfo, pBinds}

        {-# INLINE vkPBindsByteOffset #-}
        readVkPBinds (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSparseMemoryBind),
            I## o <- vkPBindsByteOffset
                      (undefined :: VkSparseBufferMemoryBindInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPBinds #-}
        writeVkPBinds (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPBindsByteOffset
                      (undefined :: VkSparseBufferMemoryBindInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPBinds #-}

instance Show VkSparseBufferMemoryBindInfo where
        showsPrec d x
          = showString "VkSparseBufferMemoryBindInfo {" .
              showString "vkBuffer = " .
                showsPrec d (vkBuffer x) .
                  showString ", " .
                    showString "vkBindCount = " .
                      showsPrec d (vkBindCount x) .
                        showString ", " .
                          showString "vkPBinds = " . showsPrec d (vkPBinds x) . showChar '}'

data VkSparseImageOpaqueMemoryBindInfo = VkSparseImageOpaqueMemoryBindInfo## ByteArray##

instance Eq VkSparseImageOpaqueMemoryBindInfo where
        (VkSparseImageOpaqueMemoryBindInfo## a) ==
          (VkSparseImageOpaqueMemoryBindInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSparseImageOpaqueMemoryBindInfo where
        (VkSparseImageOpaqueMemoryBindInfo## a) `compare`
          (VkSparseImageOpaqueMemoryBindInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSparseImageOpaqueMemoryBindInfo where
        sizeOf ~_ = #{size VkSparseImageOpaqueMemoryBindInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkSparseImageOpaqueMemoryBindInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSparseImageOpaqueMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseImageOpaqueMemoryBindInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSparseImageOpaqueMemoryBindInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSparseImageOpaqueMemoryBindInfo## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageOpaqueMemoryBindInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSparseImageOpaqueMemoryBindInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSparseImageOpaqueMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseImageOpaqueMemoryBindInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSparseImageOpaqueMemoryBindInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSparseImageOpaqueMemoryBindInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSparseImageOpaqueMemoryBindInfo## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageOpaqueMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseImageOpaqueMemoryBindInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSparseImageOpaqueMemoryBindInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSparseImageOpaqueMemoryBindInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkImage VkSparseImageOpaqueMemoryBindInfo where
        type VkImageMType VkSparseImageOpaqueMemoryBindInfo = VkImage
        vkImage (VkSparseImageOpaqueMemoryBindInfo## ba)
          | I## _n <- sizeOf (undefined :: VkImage),
            I## o <- vkImageByteOffset
                      (undefined :: VkSparseImageOpaqueMemoryBindInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImage #-}
        vkImageByteOffset ~_
          = #{offset VkSparseImageOpaqueMemoryBindInfo, image}

        {-# INLINE vkImageByteOffset #-}
        readVkImage (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImage),
            I## o <- vkImageByteOffset
                      (undefined :: VkSparseImageOpaqueMemoryBindInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImage #-}
        writeVkImage (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageByteOffset
                      (undefined :: VkSparseImageOpaqueMemoryBindInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImage #-}

instance {-# OVERLAPPING #-}
         HasVkBindCount VkSparseImageOpaqueMemoryBindInfo where
        type VkBindCountMType VkSparseImageOpaqueMemoryBindInfo =
             Data.Word.Word32
        vkBindCount (VkSparseImageOpaqueMemoryBindInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBindCountByteOffset
                      (undefined :: VkSparseImageOpaqueMemoryBindInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBindCount #-}
        vkBindCountByteOffset ~_
          = #{offset VkSparseImageOpaqueMemoryBindInfo, bindCount}

        {-# INLINE vkBindCountByteOffset #-}
        readVkBindCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBindCountByteOffset
                      (undefined :: VkSparseImageOpaqueMemoryBindInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBindCount #-}
        writeVkBindCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBindCountByteOffset
                      (undefined :: VkSparseImageOpaqueMemoryBindInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBindCount #-}

instance {-# OVERLAPPING #-}
         HasVkPBinds VkSparseImageOpaqueMemoryBindInfo where
        type VkPBindsMType VkSparseImageOpaqueMemoryBindInfo =
             Foreign.Ptr.Ptr VkSparseMemoryBind
        vkPBinds (VkSparseImageOpaqueMemoryBindInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSparseMemoryBind),
            I## o <- vkPBindsByteOffset
                      (undefined :: VkSparseImageOpaqueMemoryBindInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPBinds #-}
        vkPBindsByteOffset ~_
          = #{offset VkSparseImageOpaqueMemoryBindInfo, pBinds}

        {-# INLINE vkPBindsByteOffset #-}
        readVkPBinds (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSparseMemoryBind),
            I## o <- vkPBindsByteOffset
                      (undefined :: VkSparseImageOpaqueMemoryBindInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPBinds #-}
        writeVkPBinds (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPBindsByteOffset
                      (undefined :: VkSparseImageOpaqueMemoryBindInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPBinds #-}

instance Show VkSparseImageOpaqueMemoryBindInfo where
        showsPrec d x
          = showString "VkSparseImageOpaqueMemoryBindInfo {" .
              showString "vkImage = " .
                showsPrec d (vkImage x) .
                  showString ", " .
                    showString "vkBindCount = " .
                      showsPrec d (vkBindCount x) .
                        showString ", " .
                          showString "vkPBinds = " . showsPrec d (vkPBinds x) . showChar '}'

data VkSparseImageMemoryBindInfo = VkSparseImageMemoryBindInfo## ByteArray##

instance Eq VkSparseImageMemoryBindInfo where
        (VkSparseImageMemoryBindInfo## a) ==
          (VkSparseImageMemoryBindInfo## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSparseImageMemoryBindInfo where
        (VkSparseImageMemoryBindInfo## a) `compare`
          (VkSparseImageMemoryBindInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSparseImageMemoryBindInfo where
        sizeOf ~_ = #{size VkSparseImageMemoryBindInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSparseImageMemoryBindInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseImageMemoryBindInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSparseImageMemoryBindInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSparseImageMemoryBindInfo## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryBindInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSparseImageMemoryBindInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseImageMemoryBindInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSparseImageMemoryBindInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSparseImageMemoryBindInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSparseImageMemoryBindInfo## ba)
          | I## n <- sizeOf (undefined :: VkSparseImageMemoryBindInfo),
            I## a <- alignment (undefined :: VkSparseImageMemoryBindInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSparseImageMemoryBindInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSparseImageMemoryBindInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkImage VkSparseImageMemoryBindInfo
         where
        type VkImageMType VkSparseImageMemoryBindInfo = VkImage
        vkImage (VkSparseImageMemoryBindInfo## ba)
          | I## _n <- sizeOf (undefined :: VkImage),
            I## o <- vkImageByteOffset
                      (undefined :: VkSparseImageMemoryBindInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImage #-}
        vkImageByteOffset ~_
          = #{offset VkSparseImageMemoryBindInfo, image}

        {-# INLINE vkImageByteOffset #-}
        readVkImage (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImage),
            I## o <- vkImageByteOffset
                      (undefined :: VkSparseImageMemoryBindInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImage #-}
        writeVkImage (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageByteOffset
                      (undefined :: VkSparseImageMemoryBindInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImage #-}

instance {-# OVERLAPPING #-}
         HasVkBindCount VkSparseImageMemoryBindInfo where
        type VkBindCountMType VkSparseImageMemoryBindInfo =
             Data.Word.Word32
        vkBindCount (VkSparseImageMemoryBindInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBindCountByteOffset
                      (undefined :: VkSparseImageMemoryBindInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBindCount #-}
        vkBindCountByteOffset ~_
          = #{offset VkSparseImageMemoryBindInfo, bindCount}

        {-# INLINE vkBindCountByteOffset #-}
        readVkBindCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBindCountByteOffset
                      (undefined :: VkSparseImageMemoryBindInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBindCount #-}
        writeVkBindCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBindCountByteOffset
                      (undefined :: VkSparseImageMemoryBindInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBindCount #-}

instance {-# OVERLAPPING #-}
         HasVkPBinds VkSparseImageMemoryBindInfo where
        type VkPBindsMType VkSparseImageMemoryBindInfo =
             Foreign.Ptr.Ptr VkSparseImageMemoryBind
        vkPBinds (VkSparseImageMemoryBindInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSparseImageMemoryBind),
            I## o <- vkPBindsByteOffset
                      (undefined :: VkSparseImageMemoryBindInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPBinds #-}
        vkPBindsByteOffset ~_
          = #{offset VkSparseImageMemoryBindInfo, pBinds}

        {-# INLINE vkPBindsByteOffset #-}
        readVkPBinds (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSparseImageMemoryBind),
            I## o <- vkPBindsByteOffset
                      (undefined :: VkSparseImageMemoryBindInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPBinds #-}
        writeVkPBinds (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPBindsByteOffset
                      (undefined :: VkSparseImageMemoryBindInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPBinds #-}

instance Show VkSparseImageMemoryBindInfo where
        showsPrec d x
          = showString "VkSparseImageMemoryBindInfo {" .
              showString "vkImage = " .
                showsPrec d (vkImage x) .
                  showString ", " .
                    showString "vkBindCount = " .
                      showsPrec d (vkBindCount x) .
                        showString ", " .
                          showString "vkPBinds = " . showsPrec d (vkPBinds x) . showChar '}'

data VkBindSparseInfo = VkBindSparseInfo## ByteArray##

instance Eq VkBindSparseInfo where
        (VkBindSparseInfo## a) == (VkBindSparseInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkBindSparseInfo where
        (VkBindSparseInfo## a) `compare` (VkBindSparseInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkBindSparseInfo where
        sizeOf ~_ = #{size VkBindSparseInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkBindSparseInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkBindSparseInfo),
            I## a <- alignment (undefined :: VkBindSparseInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkBindSparseInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkBindSparseInfo## ba)
          | I## n <- sizeOf (undefined :: VkBindSparseInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkBindSparseInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkBindSparseInfo),
            I## a <- alignment (undefined :: VkBindSparseInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkBindSparseInfo## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkBindSparseInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkBindSparseInfo## ba)
          | I## n <- sizeOf (undefined :: VkBindSparseInfo),
            I## a <- alignment (undefined :: VkBindSparseInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkBindSparseInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkBindSparseInfo## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkBindSparseInfo where
        type VkSTypeMType VkBindSparseInfo = VkStructureType
        vkSType (VkBindSparseInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkBindSparseInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_ = #{offset VkBindSparseInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkBindSparseInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkBindSparseInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkBindSparseInfo where
        type VkPNextMType VkBindSparseInfo = Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkBindSparseInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkBindSparseInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_ = #{offset VkBindSparseInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkBindSparseInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkBindSparseInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

class HasVkWaitSemaphoreCount a where
        type VkWaitSemaphoreCountMType a :: *

        vkWaitSemaphoreCount :: a -> VkWaitSemaphoreCountMType a

        vkWaitSemaphoreCountByteOffset :: a -> Int

        readVkWaitSemaphoreCount ::
                                 Mutable a -> IO (VkWaitSemaphoreCountMType a)

        writeVkWaitSemaphoreCount ::
                                  Mutable a -> VkWaitSemaphoreCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'waitSemaphoreCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkWaitSemaphoreCount a

instance {-# OVERLAPPING #-}
         HasVkWaitSemaphoreCount VkBindSparseInfo where
        type VkWaitSemaphoreCountMType VkBindSparseInfo = Data.Word.Word32
        vkWaitSemaphoreCount (VkBindSparseInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkWaitSemaphoreCountByteOffset
                      (undefined :: VkBindSparseInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkWaitSemaphoreCount #-}
        vkWaitSemaphoreCountByteOffset ~_
          = #{offset VkBindSparseInfo, waitSemaphoreCount}

        {-# INLINE vkWaitSemaphoreCountByteOffset #-}
        readVkWaitSemaphoreCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkWaitSemaphoreCountByteOffset
                      (undefined :: VkBindSparseInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkWaitSemaphoreCount #-}
        writeVkWaitSemaphoreCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkWaitSemaphoreCountByteOffset
                      (undefined :: VkBindSparseInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkWaitSemaphoreCount #-}

class HasVkPWaitSemaphores a where
        type VkPWaitSemaphoresMType a :: *

        vkPWaitSemaphores :: a -> VkPWaitSemaphoresMType a

        vkPWaitSemaphoresByteOffset :: a -> Int

        readVkPWaitSemaphores :: Mutable a -> IO (VkPWaitSemaphoresMType a)

        writeVkPWaitSemaphores ::
                               Mutable a -> VkPWaitSemaphoresMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pWaitSemaphores'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPWaitSemaphores a

instance {-# OVERLAPPING #-} HasVkPWaitSemaphores VkBindSparseInfo
         where
        type VkPWaitSemaphoresMType VkBindSparseInfo =
             Foreign.Ptr.Ptr VkSemaphore
        vkPWaitSemaphores (VkBindSparseInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSemaphore),
            I## o <- vkPWaitSemaphoresByteOffset (undefined :: VkBindSparseInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPWaitSemaphores #-}
        vkPWaitSemaphoresByteOffset ~_
          = #{offset VkBindSparseInfo, pWaitSemaphores}

        {-# INLINE vkPWaitSemaphoresByteOffset #-}
        readVkPWaitSemaphores (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSemaphore),
            I## o <- vkPWaitSemaphoresByteOffset (undefined :: VkBindSparseInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPWaitSemaphores #-}
        writeVkPWaitSemaphores (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPWaitSemaphoresByteOffset (undefined :: VkBindSparseInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPWaitSemaphores #-}

class HasVkBufferBindCount a where
        type VkBufferBindCountMType a :: *

        vkBufferBindCount :: a -> VkBufferBindCountMType a

        vkBufferBindCountByteOffset :: a -> Int

        readVkBufferBindCount :: Mutable a -> IO (VkBufferBindCountMType a)

        writeVkBufferBindCount ::
                               Mutable a -> VkBufferBindCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bufferBindCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBufferBindCount a

instance {-# OVERLAPPING #-} HasVkBufferBindCount VkBindSparseInfo
         where
        type VkBufferBindCountMType VkBindSparseInfo = Data.Word.Word32
        vkBufferBindCount (VkBindSparseInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBufferBindCountByteOffset (undefined :: VkBindSparseInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBufferBindCount #-}
        vkBufferBindCountByteOffset ~_
          = #{offset VkBindSparseInfo, bufferBindCount}

        {-# INLINE vkBufferBindCountByteOffset #-}
        readVkBufferBindCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBufferBindCountByteOffset (undefined :: VkBindSparseInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBufferBindCount #-}
        writeVkBufferBindCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBufferBindCountByteOffset (undefined :: VkBindSparseInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBufferBindCount #-}

class HasVkPBufferBinds a where
        type VkPBufferBindsMType a :: *

        vkPBufferBinds :: a -> VkPBufferBindsMType a

        vkPBufferBindsByteOffset :: a -> Int

        readVkPBufferBinds :: Mutable a -> IO (VkPBufferBindsMType a)

        writeVkPBufferBinds :: Mutable a -> VkPBufferBindsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pBufferBinds'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPBufferBinds a

instance {-# OVERLAPPING #-} HasVkPBufferBinds VkBindSparseInfo
         where
        type VkPBufferBindsMType VkBindSparseInfo =
             Foreign.Ptr.Ptr VkSparseBufferMemoryBindInfo
        vkPBufferBinds (VkBindSparseInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSparseBufferMemoryBindInfo),
            I## o <- vkPBufferBindsByteOffset (undefined :: VkBindSparseInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPBufferBinds #-}
        vkPBufferBindsByteOffset ~_
          = #{offset VkBindSparseInfo, pBufferBinds}

        {-# INLINE vkPBufferBindsByteOffset #-}
        readVkPBufferBinds (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSparseBufferMemoryBindInfo),
            I## o <- vkPBufferBindsByteOffset (undefined :: VkBindSparseInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPBufferBinds #-}
        writeVkPBufferBinds (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPBufferBindsByteOffset (undefined :: VkBindSparseInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPBufferBinds #-}

class HasVkImageOpaqueBindCount a where
        type VkImageOpaqueBindCountMType a :: *

        vkImageOpaqueBindCount :: a -> VkImageOpaqueBindCountMType a

        vkImageOpaqueBindCountByteOffset :: a -> Int

        readVkImageOpaqueBindCount ::
                                   Mutable a -> IO (VkImageOpaqueBindCountMType a)

        writeVkImageOpaqueBindCount ::
                                    Mutable a -> VkImageOpaqueBindCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageOpaqueBindCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageOpaqueBindCount a

instance {-# OVERLAPPING #-}
         HasVkImageOpaqueBindCount VkBindSparseInfo where
        type VkImageOpaqueBindCountMType VkBindSparseInfo =
             Data.Word.Word32
        vkImageOpaqueBindCount (VkBindSparseInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkImageOpaqueBindCountByteOffset
                      (undefined :: VkBindSparseInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageOpaqueBindCount #-}
        vkImageOpaqueBindCountByteOffset ~_
          = #{offset VkBindSparseInfo, imageOpaqueBindCount}

        {-# INLINE vkImageOpaqueBindCountByteOffset #-}
        readVkImageOpaqueBindCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkImageOpaqueBindCountByteOffset
                      (undefined :: VkBindSparseInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageOpaqueBindCount #-}
        writeVkImageOpaqueBindCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageOpaqueBindCountByteOffset
                      (undefined :: VkBindSparseInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageOpaqueBindCount #-}

class HasVkPImageOpaqueBinds a where
        type VkPImageOpaqueBindsMType a :: *

        vkPImageOpaqueBinds :: a -> VkPImageOpaqueBindsMType a

        vkPImageOpaqueBindsByteOffset :: a -> Int

        readVkPImageOpaqueBinds ::
                                Mutable a -> IO (VkPImageOpaqueBindsMType a)

        writeVkPImageOpaqueBinds ::
                                 Mutable a -> VkPImageOpaqueBindsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pImageOpaqueBinds'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPImageOpaqueBinds a

instance {-# OVERLAPPING #-}
         HasVkPImageOpaqueBinds VkBindSparseInfo where
        type VkPImageOpaqueBindsMType VkBindSparseInfo =
             Foreign.Ptr.Ptr VkSparseImageOpaqueMemoryBindInfo
        vkPImageOpaqueBinds (VkBindSparseInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSparseImageOpaqueMemoryBindInfo),
            I## o <- vkPImageOpaqueBindsByteOffset
                      (undefined :: VkBindSparseInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPImageOpaqueBinds #-}
        vkPImageOpaqueBindsByteOffset ~_
          = #{offset VkBindSparseInfo, pImageOpaqueBinds}

        {-# INLINE vkPImageOpaqueBindsByteOffset #-}
        readVkPImageOpaqueBinds (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSparseImageOpaqueMemoryBindInfo),
            I## o <- vkPImageOpaqueBindsByteOffset
                      (undefined :: VkBindSparseInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPImageOpaqueBinds #-}
        writeVkPImageOpaqueBinds (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPImageOpaqueBindsByteOffset
                      (undefined :: VkBindSparseInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPImageOpaqueBinds #-}

class HasVkImageBindCount a where
        type VkImageBindCountMType a :: *

        vkImageBindCount :: a -> VkImageBindCountMType a

        vkImageBindCountByteOffset :: a -> Int

        readVkImageBindCount :: Mutable a -> IO (VkImageBindCountMType a)

        writeVkImageBindCount ::
                              Mutable a -> VkImageBindCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageBindCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageBindCount a

instance {-# OVERLAPPING #-} HasVkImageBindCount VkBindSparseInfo
         where
        type VkImageBindCountMType VkBindSparseInfo = Data.Word.Word32
        vkImageBindCount (VkBindSparseInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkImageBindCountByteOffset (undefined :: VkBindSparseInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageBindCount #-}
        vkImageBindCountByteOffset ~_
          = #{offset VkBindSparseInfo, imageBindCount}

        {-# INLINE vkImageBindCountByteOffset #-}
        readVkImageBindCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkImageBindCountByteOffset (undefined :: VkBindSparseInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageBindCount #-}
        writeVkImageBindCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageBindCountByteOffset (undefined :: VkBindSparseInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageBindCount #-}

class HasVkPImageBinds a where
        type VkPImageBindsMType a :: *

        vkPImageBinds :: a -> VkPImageBindsMType a

        vkPImageBindsByteOffset :: a -> Int

        readVkPImageBinds :: Mutable a -> IO (VkPImageBindsMType a)

        writeVkPImageBinds :: Mutable a -> VkPImageBindsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pImageBinds'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPImageBinds a

instance {-# OVERLAPPING #-} HasVkPImageBinds VkBindSparseInfo
         where
        type VkPImageBindsMType VkBindSparseInfo =
             Foreign.Ptr.Ptr VkSparseImageMemoryBindInfo
        vkPImageBinds (VkBindSparseInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSparseImageMemoryBindInfo),
            I## o <- vkPImageBindsByteOffset (undefined :: VkBindSparseInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPImageBinds #-}
        vkPImageBindsByteOffset ~_
          = #{offset VkBindSparseInfo, pImageBinds}

        {-# INLINE vkPImageBindsByteOffset #-}
        readVkPImageBinds (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSparseImageMemoryBindInfo),
            I## o <- vkPImageBindsByteOffset (undefined :: VkBindSparseInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPImageBinds #-}
        writeVkPImageBinds (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPImageBindsByteOffset (undefined :: VkBindSparseInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPImageBinds #-}

class HasVkSignalSemaphoreCount a where
        type VkSignalSemaphoreCountMType a :: *

        vkSignalSemaphoreCount :: a -> VkSignalSemaphoreCountMType a

        vkSignalSemaphoreCountByteOffset :: a -> Int

        readVkSignalSemaphoreCount ::
                                   Mutable a -> IO (VkSignalSemaphoreCountMType a)

        writeVkSignalSemaphoreCount ::
                                    Mutable a -> VkSignalSemaphoreCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'signalSemaphoreCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSignalSemaphoreCount a

instance {-# OVERLAPPING #-}
         HasVkSignalSemaphoreCount VkBindSparseInfo where
        type VkSignalSemaphoreCountMType VkBindSparseInfo =
             Data.Word.Word32
        vkSignalSemaphoreCount (VkBindSparseInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSignalSemaphoreCountByteOffset
                      (undefined :: VkBindSparseInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSignalSemaphoreCount #-}
        vkSignalSemaphoreCountByteOffset ~_
          = #{offset VkBindSparseInfo, signalSemaphoreCount}

        {-# INLINE vkSignalSemaphoreCountByteOffset #-}
        readVkSignalSemaphoreCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSignalSemaphoreCountByteOffset
                      (undefined :: VkBindSparseInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSignalSemaphoreCount #-}
        writeVkSignalSemaphoreCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSignalSemaphoreCountByteOffset
                      (undefined :: VkBindSparseInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSignalSemaphoreCount #-}

class HasVkPSignalSemaphores a where
        type VkPSignalSemaphoresMType a :: *

        vkPSignalSemaphores :: a -> VkPSignalSemaphoresMType a

        vkPSignalSemaphoresByteOffset :: a -> Int

        readVkPSignalSemaphores ::
                                Mutable a -> IO (VkPSignalSemaphoresMType a)

        writeVkPSignalSemaphores ::
                                 Mutable a -> VkPSignalSemaphoresMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pSignalSemaphores'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPSignalSemaphores a

instance {-# OVERLAPPING #-}
         HasVkPSignalSemaphores VkBindSparseInfo where
        type VkPSignalSemaphoresMType VkBindSparseInfo =
             Foreign.Ptr.Ptr VkSemaphore
        vkPSignalSemaphores (VkBindSparseInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSemaphore),
            I## o <- vkPSignalSemaphoresByteOffset
                      (undefined :: VkBindSparseInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPSignalSemaphores #-}
        vkPSignalSemaphoresByteOffset ~_
          = #{offset VkBindSparseInfo, pSignalSemaphores}

        {-# INLINE vkPSignalSemaphoresByteOffset #-}
        readVkPSignalSemaphores (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSemaphore),
            I## o <- vkPSignalSemaphoresByteOffset
                      (undefined :: VkBindSparseInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPSignalSemaphores #-}
        writeVkPSignalSemaphores (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPSignalSemaphoresByteOffset
                      (undefined :: VkBindSparseInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPSignalSemaphores #-}

instance Show VkBindSparseInfo where
        showsPrec d x
          = showString "VkBindSparseInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkWaitSemaphoreCount = " .
                            showsPrec d (vkWaitSemaphoreCount x) .
                              showString ", " .
                                showString "vkPWaitSemaphores = " .
                                  showsPrec d (vkPWaitSemaphores x) .
                                    showString ", " .
                                      showString "vkBufferBindCount = " .
                                        showsPrec d (vkBufferBindCount x) .
                                          showString ", " .
                                            showString "vkPBufferBinds = " .
                                              showsPrec d (vkPBufferBinds x) .
                                                showString ", " .
                                                  showString "vkImageOpaqueBindCount = " .
                                                    showsPrec d (vkImageOpaqueBindCount x) .
                                                      showString ", " .
                                                        showString "vkPImageOpaqueBinds = " .
                                                          showsPrec d (vkPImageOpaqueBinds x) .
                                                            showString ", " .
                                                              showString "vkImageBindCount = " .
                                                                showsPrec d (vkImageBindCount x) .
                                                                  showString ", " .
                                                                    showString "vkPImageBinds = " .
                                                                      showsPrec d (vkPImageBinds x)
                                                                        .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkSignalSemaphoreCount = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkSignalSemaphoreCount
                                                                                 x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkPSignalSemaphores = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkPSignalSemaphores
                                                                                       x)
                                                                                    . showChar '}'

data VkImageCopy = VkImageCopy## ByteArray##

instance Eq VkImageCopy where
        (VkImageCopy## a) == (VkImageCopy## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageCopy where
        (VkImageCopy## a) `compare` (VkImageCopy## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageCopy where
        sizeOf ~_ = #{size VkImageCopy}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageCopy}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageCopy),
            I## a <- alignment (undefined :: VkImageCopy) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkImageCopy## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageCopy## ba)
          | I## n <- sizeOf (undefined :: VkImageCopy) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageCopy where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkImageCopy),
            I## a <- alignment (undefined :: VkImageCopy) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkImageCopy## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkImageCopy## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkImageCopy## ba)
          | I## n <- sizeOf (undefined :: VkImageCopy),
            I## a <- alignment (undefined :: VkImageCopy) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkImageCopy## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkImageCopy## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkSrcSubresource a where
        type VkSrcSubresourceMType a :: *

        vkSrcSubresource :: a -> VkSrcSubresourceMType a

        vkSrcSubresourceByteOffset :: a -> Int

        readVkSrcSubresource :: Mutable a -> IO (VkSrcSubresourceMType a)

        writeVkSrcSubresource ::
                              Mutable a -> VkSrcSubresourceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcSubresource'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcSubresource a

instance {-# OVERLAPPING #-} HasVkSrcSubresource VkImageCopy where
        type VkSrcSubresourceMType VkImageCopy = VkImageSubresourceLayers
        vkSrcSubresource (VkImageCopy## ba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## o <- vkSrcSubresourceByteOffset (undefined :: VkImageCopy) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSrcSubresource #-}
        vkSrcSubresourceByteOffset ~_
          = #{offset VkImageCopy, srcSubresource}

        {-# INLINE vkSrcSubresourceByteOffset #-}
        readVkSrcSubresource (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## o <- vkSrcSubresourceByteOffset (undefined :: VkImageCopy) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSrcSubresource #-}
        writeVkSrcSubresource (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcSubresourceByteOffset (undefined :: VkImageCopy) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSrcSubresource #-}

instance {-# OVERLAPPING #-} HasVkSrcOffset VkImageCopy where
        type VkSrcOffsetMType VkImageCopy = VkOffset3D
        vkSrcOffset (VkImageCopy## ba)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkSrcOffsetByteOffset (undefined :: VkImageCopy) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSrcOffset #-}
        vkSrcOffsetByteOffset ~_
          = #{offset VkImageCopy, srcOffset}

        {-# INLINE vkSrcOffsetByteOffset #-}
        readVkSrcOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkSrcOffsetByteOffset (undefined :: VkImageCopy) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSrcOffset #-}
        writeVkSrcOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcOffsetByteOffset (undefined :: VkImageCopy) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSrcOffset #-}

class HasVkDstSubresource a where
        type VkDstSubresourceMType a :: *

        vkDstSubresource :: a -> VkDstSubresourceMType a

        vkDstSubresourceByteOffset :: a -> Int

        readVkDstSubresource :: Mutable a -> IO (VkDstSubresourceMType a)

        writeVkDstSubresource ::
                              Mutable a -> VkDstSubresourceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstSubresource'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstSubresource a

instance {-# OVERLAPPING #-} HasVkDstSubresource VkImageCopy where
        type VkDstSubresourceMType VkImageCopy = VkImageSubresourceLayers
        vkDstSubresource (VkImageCopy## ba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## o <- vkDstSubresourceByteOffset (undefined :: VkImageCopy) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstSubresource #-}
        vkDstSubresourceByteOffset ~_
          = #{offset VkImageCopy, dstSubresource}

        {-# INLINE vkDstSubresourceByteOffset #-}
        readVkDstSubresource (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## o <- vkDstSubresourceByteOffset (undefined :: VkImageCopy) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstSubresource #-}
        writeVkDstSubresource (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstSubresourceByteOffset (undefined :: VkImageCopy) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstSubresource #-}

instance {-# OVERLAPPING #-} HasVkDstOffset VkImageCopy where
        type VkDstOffsetMType VkImageCopy = VkOffset3D
        vkDstOffset (VkImageCopy## ba)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkDstOffsetByteOffset (undefined :: VkImageCopy) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstOffset #-}
        vkDstOffsetByteOffset ~_
          = #{offset VkImageCopy, dstOffset}

        {-# INLINE vkDstOffsetByteOffset #-}
        readVkDstOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkDstOffsetByteOffset (undefined :: VkImageCopy) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstOffset #-}
        writeVkDstOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstOffsetByteOffset (undefined :: VkImageCopy) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstOffset #-}

instance {-# OVERLAPPING #-} HasVkExtent VkImageCopy where
        type VkExtentMType VkImageCopy = VkExtent3D
        vkExtent (VkImageCopy## ba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkExtentByteOffset (undefined :: VkImageCopy) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkExtent #-}
        vkExtentByteOffset ~_ = #{offset VkImageCopy, extent}

        {-# INLINE vkExtentByteOffset #-}
        readVkExtent (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkExtentByteOffset (undefined :: VkImageCopy) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkExtent #-}
        writeVkExtent (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkExtentByteOffset (undefined :: VkImageCopy) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkExtent #-}

instance Show VkImageCopy where
        showsPrec d x
          = showString "VkImageCopy {" .
              showString "vkSrcSubresource = " .
                showsPrec d (vkSrcSubresource x) .
                  showString ", " .
                    showString "vkSrcOffset = " .
                      showsPrec d (vkSrcOffset x) .
                        showString ", " .
                          showString "vkDstSubresource = " .
                            showsPrec d (vkDstSubresource x) .
                              showString ", " .
                                showString "vkDstOffset = " .
                                  showsPrec d (vkDstOffset x) .
                                    showString ", " .
                                      showString "vkExtent = " .
                                        showsPrec d (vkExtent x) . showChar '}'

data VkImageBlit = VkImageBlit## ByteArray##

instance Eq VkImageBlit where
        (VkImageBlit## a) == (VkImageBlit## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageBlit where
        (VkImageBlit## a) `compare` (VkImageBlit## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageBlit where
        sizeOf ~_ = #{size VkImageBlit}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageBlit}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageBlit),
            I## a <- alignment (undefined :: VkImageBlit) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkImageBlit## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageBlit## ba)
          | I## n <- sizeOf (undefined :: VkImageBlit) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageBlit where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkImageBlit),
            I## a <- alignment (undefined :: VkImageBlit) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkImageBlit## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkImageBlit## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkImageBlit## ba)
          | I## n <- sizeOf (undefined :: VkImageBlit),
            I## a <- alignment (undefined :: VkImageBlit) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkImageBlit## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkImageBlit## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSrcSubresource VkImageBlit where
        type VkSrcSubresourceMType VkImageBlit = VkImageSubresourceLayers
        vkSrcSubresource (VkImageBlit## ba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## o <- vkSrcSubresourceByteOffset (undefined :: VkImageBlit) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSrcSubresource #-}
        vkSrcSubresourceByteOffset ~_
          = #{offset VkImageBlit, srcSubresource}

        {-# INLINE vkSrcSubresourceByteOffset #-}
        readVkSrcSubresource (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## o <- vkSrcSubresourceByteOffset (undefined :: VkImageBlit) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSrcSubresource #-}
        writeVkSrcSubresource (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcSubresourceByteOffset (undefined :: VkImageBlit) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSrcSubresource #-}

class HasVkSrcOffsetsArray a where
        type VkSrcOffsetsArrayMType a :: *

        vkSrcOffsetsArray :: a -> Int -> VkSrcOffsetsArrayMType a

        vkSrcOffsetsArrayByteOffset :: a -> Int

        readVkSrcOffsetsArray ::
                              Mutable a -> Int -> IO (VkSrcOffsetsArrayMType a)

        writeVkSrcOffsetsArray ::
                               Mutable a -> Int -> VkSrcOffsetsArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcOffsets'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcOffsetsArray a

instance {-# OVERLAPPING #-} HasVkSrcOffsetsArray VkImageBlit where
        type VkSrcOffsetsArrayMType VkImageBlit = VkOffset3D
        vkSrcOffsetsArray (VkImageBlit## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkSrcOffsetsArrayByteOffset (undefined :: VkImageBlit) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkSrcOffsetsArray #-}
        vkSrcOffsetsArrayByteOffset ~_
          = #{offset VkImageBlit, srcOffsets}

        {-# INLINE vkSrcOffsetsArrayByteOffset #-}
        readVkSrcOffsetsArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkSrcOffsetsArrayByteOffset (undefined :: VkImageBlit) =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkSrcOffsetsArray #-}
        writeVkSrcOffsetsArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcOffsetsArrayByteOffset (undefined :: VkImageBlit) =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkSrcOffsetsArray #-}

instance {-# OVERLAPPING #-} HasVkDstSubresource VkImageBlit where
        type VkDstSubresourceMType VkImageBlit = VkImageSubresourceLayers
        vkDstSubresource (VkImageBlit## ba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## o <- vkDstSubresourceByteOffset (undefined :: VkImageBlit) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstSubresource #-}
        vkDstSubresourceByteOffset ~_
          = #{offset VkImageBlit, dstSubresource}

        {-# INLINE vkDstSubresourceByteOffset #-}
        readVkDstSubresource (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## o <- vkDstSubresourceByteOffset (undefined :: VkImageBlit) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstSubresource #-}
        writeVkDstSubresource (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstSubresourceByteOffset (undefined :: VkImageBlit) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstSubresource #-}

class HasVkDstOffsetsArray a where
        type VkDstOffsetsArrayMType a :: *

        vkDstOffsetsArray :: a -> Int -> VkDstOffsetsArrayMType a

        vkDstOffsetsArrayByteOffset :: a -> Int

        readVkDstOffsetsArray ::
                              Mutable a -> Int -> IO (VkDstOffsetsArrayMType a)

        writeVkDstOffsetsArray ::
                               Mutable a -> Int -> VkDstOffsetsArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstOffsets'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstOffsetsArray a

instance {-# OVERLAPPING #-} HasVkDstOffsetsArray VkImageBlit where
        type VkDstOffsetsArrayMType VkImageBlit = VkOffset3D
        vkDstOffsetsArray (VkImageBlit## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkDstOffsetsArrayByteOffset (undefined :: VkImageBlit) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkDstOffsetsArray #-}
        vkDstOffsetsArrayByteOffset ~_
          = #{offset VkImageBlit, dstOffsets}

        {-# INLINE vkDstOffsetsArrayByteOffset #-}
        readVkDstOffsetsArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkDstOffsetsArrayByteOffset (undefined :: VkImageBlit) =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkDstOffsetsArray #-}
        writeVkDstOffsetsArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkDstOffsetsArrayByteOffset (undefined :: VkImageBlit) =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkDstOffsetsArray #-}

instance Show VkImageBlit where
        showsPrec d x
          = showString "VkImageBlit {" .
              showString "vkSrcSubresource = " .
                showsPrec d (vkSrcSubresource x) .
                  showString ", " .
                    showString "vkSrcOffsetsArray = [" .
                      showsPrec d (map (vkSrcOffsetsArray x) [1 .. 2]) .
                        showChar ']' .
                          showString ", " .
                            showString "vkDstSubresource = " .
                              showsPrec d (vkDstSubresource x) .
                                showString ", " .
                                  showString "vkDstOffsetsArray = [" .
                                    showsPrec d (map (vkDstOffsetsArray x) [1 .. 2]) .
                                      showChar ']' . showChar '}'

data VkBufferImageCopy = VkBufferImageCopy## ByteArray##

instance Eq VkBufferImageCopy where
        (VkBufferImageCopy## a) == (VkBufferImageCopy## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkBufferImageCopy where
        (VkBufferImageCopy## a) `compare` (VkBufferImageCopy## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkBufferImageCopy where
        sizeOf ~_ = #{size VkBufferImageCopy}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkBufferImageCopy}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkBufferImageCopy),
            I## a <- alignment (undefined :: VkBufferImageCopy) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkBufferImageCopy## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkBufferImageCopy## ba)
          | I## n <- sizeOf (undefined :: VkBufferImageCopy) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkBufferImageCopy where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkBufferImageCopy),
            I## a <- alignment (undefined :: VkBufferImageCopy) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkBufferImageCopy## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkBufferImageCopy## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkBufferImageCopy## ba)
          | I## n <- sizeOf (undefined :: VkBufferImageCopy),
            I## a <- alignment (undefined :: VkBufferImageCopy) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkBufferImageCopy## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkBufferImageCopy## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkBufferOffset a where
        type VkBufferOffsetMType a :: *

        vkBufferOffset :: a -> VkBufferOffsetMType a

        vkBufferOffsetByteOffset :: a -> Int

        readVkBufferOffset :: Mutable a -> IO (VkBufferOffsetMType a)

        writeVkBufferOffset :: Mutable a -> VkBufferOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bufferOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBufferOffset a

instance {-# OVERLAPPING #-} HasVkBufferOffset VkBufferImageCopy
         where
        type VkBufferOffsetMType VkBufferImageCopy = VkDeviceSize
        vkBufferOffset (VkBufferImageCopy## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkBufferOffsetByteOffset (undefined :: VkBufferImageCopy) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBufferOffset #-}
        vkBufferOffsetByteOffset ~_
          = #{offset VkBufferImageCopy, bufferOffset}

        {-# INLINE vkBufferOffsetByteOffset #-}
        readVkBufferOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkBufferOffsetByteOffset (undefined :: VkBufferImageCopy) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBufferOffset #-}
        writeVkBufferOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBufferOffsetByteOffset (undefined :: VkBufferImageCopy) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBufferOffset #-}

class HasVkBufferRowLength a where
        type VkBufferRowLengthMType a :: *

        vkBufferRowLength :: a -> VkBufferRowLengthMType a

        vkBufferRowLengthByteOffset :: a -> Int

        readVkBufferRowLength :: Mutable a -> IO (VkBufferRowLengthMType a)

        writeVkBufferRowLength ::
                               Mutable a -> VkBufferRowLengthMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bufferRowLength'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBufferRowLength a

instance {-# OVERLAPPING #-} HasVkBufferRowLength VkBufferImageCopy
         where
        type VkBufferRowLengthMType VkBufferImageCopy = Data.Word.Word32
        vkBufferRowLength (VkBufferImageCopy## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBufferRowLengthByteOffset
                      (undefined :: VkBufferImageCopy)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBufferRowLength #-}
        vkBufferRowLengthByteOffset ~_
          = #{offset VkBufferImageCopy, bufferRowLength}

        {-# INLINE vkBufferRowLengthByteOffset #-}
        readVkBufferRowLength (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBufferRowLengthByteOffset
                      (undefined :: VkBufferImageCopy)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBufferRowLength #-}
        writeVkBufferRowLength (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBufferRowLengthByteOffset
                      (undefined :: VkBufferImageCopy)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBufferRowLength #-}

class HasVkBufferImageHeight a where
        type VkBufferImageHeightMType a :: *

        vkBufferImageHeight :: a -> VkBufferImageHeightMType a

        vkBufferImageHeightByteOffset :: a -> Int

        readVkBufferImageHeight ::
                                Mutable a -> IO (VkBufferImageHeightMType a)

        writeVkBufferImageHeight ::
                                 Mutable a -> VkBufferImageHeightMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bufferImageHeight'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBufferImageHeight a

instance {-# OVERLAPPING #-}
         HasVkBufferImageHeight VkBufferImageCopy where
        type VkBufferImageHeightMType VkBufferImageCopy = Data.Word.Word32
        vkBufferImageHeight (VkBufferImageCopy## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBufferImageHeightByteOffset
                      (undefined :: VkBufferImageCopy)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBufferImageHeight #-}
        vkBufferImageHeightByteOffset ~_
          = #{offset VkBufferImageCopy, bufferImageHeight}

        {-# INLINE vkBufferImageHeightByteOffset #-}
        readVkBufferImageHeight (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBufferImageHeightByteOffset
                      (undefined :: VkBufferImageCopy)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBufferImageHeight #-}
        writeVkBufferImageHeight (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBufferImageHeightByteOffset
                      (undefined :: VkBufferImageCopy)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBufferImageHeight #-}

class HasVkImageSubresource a where
        type VkImageSubresourceMType a :: *

        vkImageSubresource :: a -> VkImageSubresourceMType a

        vkImageSubresourceByteOffset :: a -> Int

        readVkImageSubresource ::
                               Mutable a -> IO (VkImageSubresourceMType a)

        writeVkImageSubresource ::
                                Mutable a -> VkImageSubresourceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageSubresource'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageSubresource a

instance {-# OVERLAPPING #-}
         HasVkImageSubresource VkBufferImageCopy where
        type VkImageSubresourceMType VkBufferImageCopy =
             VkImageSubresourceLayers
        vkImageSubresource (VkBufferImageCopy## ba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## o <- vkImageSubresourceByteOffset
                      (undefined :: VkBufferImageCopy)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageSubresource #-}
        vkImageSubresourceByteOffset ~_
          = #{offset VkBufferImageCopy, imageSubresource}

        {-# INLINE vkImageSubresourceByteOffset #-}
        readVkImageSubresource (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## o <- vkImageSubresourceByteOffset
                      (undefined :: VkBufferImageCopy)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageSubresource #-}
        writeVkImageSubresource (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageSubresourceByteOffset
                      (undefined :: VkBufferImageCopy)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageSubresource #-}

class HasVkImageOffset a where
        type VkImageOffsetMType a :: *

        vkImageOffset :: a -> VkImageOffsetMType a

        vkImageOffsetByteOffset :: a -> Int

        readVkImageOffset :: Mutable a -> IO (VkImageOffsetMType a)

        writeVkImageOffset :: Mutable a -> VkImageOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageOffset a

instance {-# OVERLAPPING #-} HasVkImageOffset VkBufferImageCopy
         where
        type VkImageOffsetMType VkBufferImageCopy = VkOffset3D
        vkImageOffset (VkBufferImageCopy## ba)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkImageOffsetByteOffset (undefined :: VkBufferImageCopy) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageOffset #-}
        vkImageOffsetByteOffset ~_
          = #{offset VkBufferImageCopy, imageOffset}

        {-# INLINE vkImageOffsetByteOffset #-}
        readVkImageOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkImageOffsetByteOffset (undefined :: VkBufferImageCopy) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageOffset #-}
        writeVkImageOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageOffsetByteOffset (undefined :: VkBufferImageCopy) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageOffset #-}

class HasVkImageExtent a where
        type VkImageExtentMType a :: *

        vkImageExtent :: a -> VkImageExtentMType a

        vkImageExtentByteOffset :: a -> Int

        readVkImageExtent :: Mutable a -> IO (VkImageExtentMType a)

        writeVkImageExtent :: Mutable a -> VkImageExtentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageExtent'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageExtent a

instance {-# OVERLAPPING #-} HasVkImageExtent VkBufferImageCopy
         where
        type VkImageExtentMType VkBufferImageCopy = VkExtent3D
        vkImageExtent (VkBufferImageCopy## ba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkImageExtentByteOffset (undefined :: VkBufferImageCopy) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageExtent #-}
        vkImageExtentByteOffset ~_
          = #{offset VkBufferImageCopy, imageExtent}

        {-# INLINE vkImageExtentByteOffset #-}
        readVkImageExtent (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkImageExtentByteOffset (undefined :: VkBufferImageCopy) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageExtent #-}
        writeVkImageExtent (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageExtentByteOffset (undefined :: VkBufferImageCopy) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageExtent #-}

instance Show VkBufferImageCopy where
        showsPrec d x
          = showString "VkBufferImageCopy {" .
              showString "vkBufferOffset = " .
                showsPrec d (vkBufferOffset x) .
                  showString ", " .
                    showString "vkBufferRowLength = " .
                      showsPrec d (vkBufferRowLength x) .
                        showString ", " .
                          showString "vkBufferImageHeight = " .
                            showsPrec d (vkBufferImageHeight x) .
                              showString ", " .
                                showString "vkImageSubresource = " .
                                  showsPrec d (vkImageSubresource x) .
                                    showString ", " .
                                      showString "vkImageOffset = " .
                                        showsPrec d (vkImageOffset x) .
                                          showString ", " .
                                            showString "vkImageExtent = " .
                                              showsPrec d (vkImageExtent x) . showChar '}'

data VkImageResolve = VkImageResolve## ByteArray##

instance Eq VkImageResolve where
        (VkImageResolve## a) == (VkImageResolve## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkImageResolve where
        (VkImageResolve## a) `compare` (VkImageResolve## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkImageResolve where
        sizeOf ~_ = #{size VkImageResolve}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkImageResolve}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkImageResolve),
            I## a <- alignment (undefined :: VkImageResolve) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkImageResolve## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkImageResolve## ba)
          | I## n <- sizeOf (undefined :: VkImageResolve) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkImageResolve where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkImageResolve),
            I## a <- alignment (undefined :: VkImageResolve) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkImageResolve## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkImageResolve## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkImageResolve## ba)
          | I## n <- sizeOf (undefined :: VkImageResolve),
            I## a <- alignment (undefined :: VkImageResolve) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkImageResolve## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkImageResolve## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSrcSubresource VkImageResolve
         where
        type VkSrcSubresourceMType VkImageResolve =
             VkImageSubresourceLayers
        vkSrcSubresource (VkImageResolve## ba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## o <- vkSrcSubresourceByteOffset (undefined :: VkImageResolve) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSrcSubresource #-}
        vkSrcSubresourceByteOffset ~_
          = #{offset VkImageResolve, srcSubresource}

        {-# INLINE vkSrcSubresourceByteOffset #-}
        readVkSrcSubresource (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## o <- vkSrcSubresourceByteOffset (undefined :: VkImageResolve) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSrcSubresource #-}
        writeVkSrcSubresource (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcSubresourceByteOffset (undefined :: VkImageResolve) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSrcSubresource #-}

instance {-# OVERLAPPING #-} HasVkSrcOffset VkImageResolve where
        type VkSrcOffsetMType VkImageResolve = VkOffset3D
        vkSrcOffset (VkImageResolve## ba)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkSrcOffsetByteOffset (undefined :: VkImageResolve) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSrcOffset #-}
        vkSrcOffsetByteOffset ~_
          = #{offset VkImageResolve, srcOffset}

        {-# INLINE vkSrcOffsetByteOffset #-}
        readVkSrcOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkSrcOffsetByteOffset (undefined :: VkImageResolve) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSrcOffset #-}
        writeVkSrcOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcOffsetByteOffset (undefined :: VkImageResolve) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSrcOffset #-}

instance {-# OVERLAPPING #-} HasVkDstSubresource VkImageResolve
         where
        type VkDstSubresourceMType VkImageResolve =
             VkImageSubresourceLayers
        vkDstSubresource (VkImageResolve## ba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## o <- vkDstSubresourceByteOffset (undefined :: VkImageResolve) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstSubresource #-}
        vkDstSubresourceByteOffset ~_
          = #{offset VkImageResolve, dstSubresource}

        {-# INLINE vkDstSubresourceByteOffset #-}
        readVkDstSubresource (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageSubresourceLayers),
            I## o <- vkDstSubresourceByteOffset (undefined :: VkImageResolve) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstSubresource #-}
        writeVkDstSubresource (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstSubresourceByteOffset (undefined :: VkImageResolve) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstSubresource #-}

instance {-# OVERLAPPING #-} HasVkDstOffset VkImageResolve where
        type VkDstOffsetMType VkImageResolve = VkOffset3D
        vkDstOffset (VkImageResolve## ba)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkDstOffsetByteOffset (undefined :: VkImageResolve) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstOffset #-}
        vkDstOffsetByteOffset ~_
          = #{offset VkImageResolve, dstOffset}

        {-# INLINE vkDstOffsetByteOffset #-}
        readVkDstOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkOffset3D),
            I## o <- vkDstOffsetByteOffset (undefined :: VkImageResolve) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstOffset #-}
        writeVkDstOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstOffsetByteOffset (undefined :: VkImageResolve) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstOffset #-}

instance {-# OVERLAPPING #-} HasVkExtent VkImageResolve where
        type VkExtentMType VkImageResolve = VkExtent3D
        vkExtent (VkImageResolve## ba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkExtentByteOffset (undefined :: VkImageResolve) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkExtent #-}
        vkExtentByteOffset ~_ = #{offset VkImageResolve, extent}

        {-# INLINE vkExtentByteOffset #-}
        readVkExtent (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkExtent3D),
            I## o <- vkExtentByteOffset (undefined :: VkImageResolve) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkExtent #-}
        writeVkExtent (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkExtentByteOffset (undefined :: VkImageResolve) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkExtent #-}

instance Show VkImageResolve where
        showsPrec d x
          = showString "VkImageResolve {" .
              showString "vkSrcSubresource = " .
                showsPrec d (vkSrcSubresource x) .
                  showString ", " .
                    showString "vkSrcOffset = " .
                      showsPrec d (vkSrcOffset x) .
                        showString ", " .
                          showString "vkDstSubresource = " .
                            showsPrec d (vkDstSubresource x) .
                              showString ", " .
                                showString "vkDstOffset = " .
                                  showsPrec d (vkDstOffset x) .
                                    showString ", " .
                                      showString "vkExtent = " .
                                        showsPrec d (vkExtent x) . showChar '}'

data VkShaderModuleCreateInfo = VkShaderModuleCreateInfo## ByteArray##

instance Eq VkShaderModuleCreateInfo where
        (VkShaderModuleCreateInfo## a) == (VkShaderModuleCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkShaderModuleCreateInfo where
        (VkShaderModuleCreateInfo## a) `compare`
          (VkShaderModuleCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkShaderModuleCreateInfo where
        sizeOf ~_ = #{size VkShaderModuleCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkShaderModuleCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkShaderModuleCreateInfo),
            I## a <- alignment (undefined :: VkShaderModuleCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkShaderModuleCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkShaderModuleCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkShaderModuleCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkShaderModuleCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkShaderModuleCreateInfo),
            I## a <- alignment (undefined :: VkShaderModuleCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkShaderModuleCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkShaderModuleCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkShaderModuleCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkShaderModuleCreateInfo),
            I## a <- alignment (undefined :: VkShaderModuleCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkShaderModuleCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkShaderModuleCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkShaderModuleCreateInfo
         where
        type VkSTypeMType VkShaderModuleCreateInfo = VkStructureType
        vkSType (VkShaderModuleCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkShaderModuleCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkShaderModuleCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkShaderModuleCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkShaderModuleCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkShaderModuleCreateInfo
         where
        type VkPNextMType VkShaderModuleCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkShaderModuleCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkShaderModuleCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkShaderModuleCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkShaderModuleCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkShaderModuleCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkShaderModuleCreateInfo
         where
        type VkFlagsMType VkShaderModuleCreateInfo =
             VkShaderModuleCreateFlags
        vkFlags (VkShaderModuleCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkShaderModuleCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkShaderModuleCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkShaderModuleCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkShaderModuleCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkShaderModuleCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkShaderModuleCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkCodeSize a where
        type VkCodeSizeMType a :: *

        vkCodeSize :: a -> VkCodeSizeMType a

        vkCodeSizeByteOffset :: a -> Int

        readVkCodeSize :: Mutable a -> IO (VkCodeSizeMType a)

        writeVkCodeSize :: Mutable a -> VkCodeSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'codeSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCodeSize a

instance {-# OVERLAPPING #-} HasVkCodeSize VkShaderModuleCreateInfo
         where
        type VkCodeSizeMType VkShaderModuleCreateInfo =
             Foreign.C.Types.CSize
        vkCodeSize (VkShaderModuleCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CSize),
            I## o <- vkCodeSizeByteOffset
                      (undefined :: VkShaderModuleCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkCodeSize #-}
        vkCodeSizeByteOffset ~_
          = #{offset VkShaderModuleCreateInfo, codeSize}

        {-# INLINE vkCodeSizeByteOffset #-}
        readVkCodeSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CSize),
            I## o <- vkCodeSizeByteOffset
                      (undefined :: VkShaderModuleCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkCodeSize #-}
        writeVkCodeSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkCodeSizeByteOffset
                      (undefined :: VkShaderModuleCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkCodeSize #-}

class HasVkPCode a where
        type VkPCodeMType a :: *

        vkPCode :: a -> VkPCodeMType a

        vkPCodeByteOffset :: a -> Int

        readVkPCode :: Mutable a -> IO (VkPCodeMType a)

        writeVkPCode :: Mutable a -> VkPCodeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pCode'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPCode a

instance {-# OVERLAPPING #-} HasVkPCode VkShaderModuleCreateInfo
         where
        type VkPCodeMType VkShaderModuleCreateInfo =
             Foreign.Ptr.Ptr Data.Word.Word32
        vkPCode (VkShaderModuleCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Word.Word32),
            I## o <- vkPCodeByteOffset (undefined :: VkShaderModuleCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPCode #-}
        vkPCodeByteOffset ~_
          = #{offset VkShaderModuleCreateInfo, pCode}

        {-# INLINE vkPCodeByteOffset #-}
        readVkPCode (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Word.Word32),
            I## o <- vkPCodeByteOffset (undefined :: VkShaderModuleCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPCode #-}
        writeVkPCode (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPCodeByteOffset (undefined :: VkShaderModuleCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPCode #-}

instance Show VkShaderModuleCreateInfo where
        showsPrec d x
          = showString "VkShaderModuleCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkCodeSize = " .
                                  showsPrec d (vkCodeSize x) .
                                    showString ", " .
                                      showString "vkPCode = " .
                                        showsPrec d (vkPCode x) . showChar '}'

data VkDescriptorSetLayoutBinding = VkDescriptorSetLayoutBinding## ByteArray##

instance Eq VkDescriptorSetLayoutBinding where
        (VkDescriptorSetLayoutBinding## a) ==
          (VkDescriptorSetLayoutBinding## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDescriptorSetLayoutBinding where
        (VkDescriptorSetLayoutBinding## a) `compare`
          (VkDescriptorSetLayoutBinding## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDescriptorSetLayoutBinding where
        sizeOf ~_ = #{size VkDescriptorSetLayoutBinding}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDescriptorSetLayoutBinding}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDescriptorSetLayoutBinding),
            I## a <- alignment (undefined :: VkDescriptorSetLayoutBinding) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDescriptorSetLayoutBinding##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDescriptorSetLayoutBinding## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorSetLayoutBinding) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDescriptorSetLayoutBinding where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkDescriptorSetLayoutBinding),
            I## a <- alignment (undefined :: VkDescriptorSetLayoutBinding) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkDescriptorSetLayoutBinding##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkDescriptorSetLayoutBinding## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkDescriptorSetLayoutBinding## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorSetLayoutBinding),
            I## a <- alignment (undefined :: VkDescriptorSetLayoutBinding) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkDescriptorSetLayoutBinding## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkDescriptorSetLayoutBinding## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkBinding a where
        type VkBindingMType a :: *

        vkBinding :: a -> VkBindingMType a

        vkBindingByteOffset :: a -> Int

        readVkBinding :: Mutable a -> IO (VkBindingMType a)

        writeVkBinding :: Mutable a -> VkBindingMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'binding'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBinding a

instance {-# OVERLAPPING #-}
         HasVkBinding VkDescriptorSetLayoutBinding where
        type VkBindingMType VkDescriptorSetLayoutBinding = Data.Word.Word32
        vkBinding (VkDescriptorSetLayoutBinding## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBindingByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBinding #-}
        vkBindingByteOffset ~_
          = #{offset VkDescriptorSetLayoutBinding, binding}

        {-# INLINE vkBindingByteOffset #-}
        readVkBinding (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBindingByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBinding #-}
        writeVkBinding (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBindingByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBinding #-}

instance {-# OVERLAPPING #-}
         HasVkDescriptorType VkDescriptorSetLayoutBinding where
        type VkDescriptorTypeMType VkDescriptorSetLayoutBinding =
             VkDescriptorType
        vkDescriptorType (VkDescriptorSetLayoutBinding## ba)
          | I## _n <- sizeOf (undefined :: VkDescriptorType),
            I## o <- vkDescriptorTypeByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDescriptorType #-}
        vkDescriptorTypeByteOffset ~_
          = #{offset VkDescriptorSetLayoutBinding, descriptorType}

        {-# INLINE vkDescriptorTypeByteOffset #-}
        readVkDescriptorType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDescriptorType),
            I## o <- vkDescriptorTypeByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDescriptorType #-}
        writeVkDescriptorType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDescriptorTypeByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDescriptorType #-}

instance {-# OVERLAPPING #-}
         HasVkDescriptorCount VkDescriptorSetLayoutBinding where
        type VkDescriptorCountMType VkDescriptorSetLayoutBinding =
             Data.Word.Word32
        vkDescriptorCount (VkDescriptorSetLayoutBinding## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDescriptorCountByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDescriptorCount #-}
        vkDescriptorCountByteOffset ~_
          = #{offset VkDescriptorSetLayoutBinding, descriptorCount}

        {-# INLINE vkDescriptorCountByteOffset #-}
        readVkDescriptorCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDescriptorCountByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDescriptorCount #-}
        writeVkDescriptorCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDescriptorCountByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDescriptorCount #-}

class HasVkStageFlags a where
        type VkStageFlagsMType a :: *

        vkStageFlags :: a -> VkStageFlagsMType a

        vkStageFlagsByteOffset :: a -> Int

        readVkStageFlags :: Mutable a -> IO (VkStageFlagsMType a)

        writeVkStageFlags :: Mutable a -> VkStageFlagsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stageFlags'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStageFlags a

instance {-# OVERLAPPING #-}
         HasVkStageFlags VkDescriptorSetLayoutBinding where
        type VkStageFlagsMType VkDescriptorSetLayoutBinding =
             VkShaderStageFlags
        vkStageFlags (VkDescriptorSetLayoutBinding## ba)
          | I## _n <- sizeOf (undefined :: VkShaderStageFlags),
            I## o <- vkStageFlagsByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkStageFlags #-}
        vkStageFlagsByteOffset ~_
          = #{offset VkDescriptorSetLayoutBinding, stageFlags}

        {-# INLINE vkStageFlagsByteOffset #-}
        readVkStageFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkShaderStageFlags),
            I## o <- vkStageFlagsByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkStageFlags #-}
        writeVkStageFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkStageFlagsByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkStageFlags #-}

class HasVkPImmutableSamplers a where
        type VkPImmutableSamplersMType a :: *

        vkPImmutableSamplers :: a -> VkPImmutableSamplersMType a

        vkPImmutableSamplersByteOffset :: a -> Int

        readVkPImmutableSamplers ::
                                 Mutable a -> IO (VkPImmutableSamplersMType a)

        writeVkPImmutableSamplers ::
                                  Mutable a -> VkPImmutableSamplersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pImmutableSamplers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPImmutableSamplers a

instance {-# OVERLAPPING #-}
         HasVkPImmutableSamplers VkDescriptorSetLayoutBinding where
        type VkPImmutableSamplersMType VkDescriptorSetLayoutBinding =
             Foreign.Ptr.Ptr VkSampler
        vkPImmutableSamplers (VkDescriptorSetLayoutBinding## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSampler),
            I## o <- vkPImmutableSamplersByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPImmutableSamplers #-}
        vkPImmutableSamplersByteOffset ~_
          = #{offset VkDescriptorSetLayoutBinding, pImmutableSamplers}

        {-# INLINE vkPImmutableSamplersByteOffset #-}
        readVkPImmutableSamplers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSampler),
            I## o <- vkPImmutableSamplersByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPImmutableSamplers #-}
        writeVkPImmutableSamplers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPImmutableSamplersByteOffset
                      (undefined :: VkDescriptorSetLayoutBinding)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPImmutableSamplers #-}

instance Show VkDescriptorSetLayoutBinding where
        showsPrec d x
          = showString "VkDescriptorSetLayoutBinding {" .
              showString "vkBinding = " .
                showsPrec d (vkBinding x) .
                  showString ", " .
                    showString "vkDescriptorType = " .
                      showsPrec d (vkDescriptorType x) .
                        showString ", " .
                          showString "vkDescriptorCount = " .
                            showsPrec d (vkDescriptorCount x) .
                              showString ", " .
                                showString "vkStageFlags = " .
                                  showsPrec d (vkStageFlags x) .
                                    showString ", " .
                                      showString "vkPImmutableSamplers = " .
                                        showsPrec d (vkPImmutableSamplers x) . showChar '}'

data VkDescriptorSetLayoutCreateInfo = VkDescriptorSetLayoutCreateInfo## ByteArray##

instance Eq VkDescriptorSetLayoutCreateInfo where
        (VkDescriptorSetLayoutCreateInfo## a) ==
          (VkDescriptorSetLayoutCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDescriptorSetLayoutCreateInfo where
        (VkDescriptorSetLayoutCreateInfo## a) `compare`
          (VkDescriptorSetLayoutCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDescriptorSetLayoutCreateInfo where
        sizeOf ~_ = #{size VkDescriptorSetLayoutCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDescriptorSetLayoutCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDescriptorSetLayoutCreateInfo),
            I## a <- alignment (undefined :: VkDescriptorSetLayoutCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDescriptorSetLayoutCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDescriptorSetLayoutCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorSetLayoutCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDescriptorSetLayoutCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkDescriptorSetLayoutCreateInfo),
            I## a <- alignment (undefined :: VkDescriptorSetLayoutCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkDescriptorSetLayoutCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkDescriptorSetLayoutCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkDescriptorSetLayoutCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorSetLayoutCreateInfo),
            I## a <- alignment (undefined :: VkDescriptorSetLayoutCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkDescriptorSetLayoutCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkDescriptorSetLayoutCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkSType VkDescriptorSetLayoutCreateInfo where
        type VkSTypeMType VkDescriptorSetLayoutCreateInfo = VkStructureType
        vkSType (VkDescriptorSetLayoutCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkDescriptorSetLayoutCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-}
         HasVkPNext VkDescriptorSetLayoutCreateInfo where
        type VkPNextMType VkDescriptorSetLayoutCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkDescriptorSetLayoutCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkDescriptorSetLayoutCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-}
         HasVkFlags VkDescriptorSetLayoutCreateInfo where
        type VkFlagsMType VkDescriptorSetLayoutCreateInfo =
             VkDescriptorSetLayoutCreateFlags
        vkFlags (VkDescriptorSetLayoutCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkDescriptorSetLayoutCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkDescriptorSetLayoutCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDescriptorSetLayoutCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkBindingCount a where
        type VkBindingCountMType a :: *

        vkBindingCount :: a -> VkBindingCountMType a

        vkBindingCountByteOffset :: a -> Int

        readVkBindingCount :: Mutable a -> IO (VkBindingCountMType a)

        writeVkBindingCount :: Mutable a -> VkBindingCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bindingCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBindingCount a

instance {-# OVERLAPPING #-}
         HasVkBindingCount VkDescriptorSetLayoutCreateInfo where
        type VkBindingCountMType VkDescriptorSetLayoutCreateInfo =
             Data.Word.Word32
        vkBindingCount (VkDescriptorSetLayoutCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBindingCountByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBindingCount #-}
        vkBindingCountByteOffset ~_
          = #{offset VkDescriptorSetLayoutCreateInfo, bindingCount}

        {-# INLINE vkBindingCountByteOffset #-}
        readVkBindingCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBindingCountByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBindingCount #-}
        writeVkBindingCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBindingCountByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBindingCount #-}

class HasVkPBindings a where
        type VkPBindingsMType a :: *

        vkPBindings :: a -> VkPBindingsMType a

        vkPBindingsByteOffset :: a -> Int

        readVkPBindings :: Mutable a -> IO (VkPBindingsMType a)

        writeVkPBindings :: Mutable a -> VkPBindingsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pBindings'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPBindings a

instance {-# OVERLAPPING #-}
         HasVkPBindings VkDescriptorSetLayoutCreateInfo where
        type VkPBindingsMType VkDescriptorSetLayoutCreateInfo =
             Foreign.Ptr.Ptr VkDescriptorSetLayoutBinding
        vkPBindings (VkDescriptorSetLayoutCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkDescriptorSetLayoutBinding),
            I## o <- vkPBindingsByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPBindings #-}
        vkPBindingsByteOffset ~_
          = #{offset VkDescriptorSetLayoutCreateInfo, pBindings}

        {-# INLINE vkPBindingsByteOffset #-}
        readVkPBindings (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkDescriptorSetLayoutBinding),
            I## o <- vkPBindingsByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPBindings #-}
        writeVkPBindings (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPBindingsByteOffset
                      (undefined :: VkDescriptorSetLayoutCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPBindings #-}

instance Show VkDescriptorSetLayoutCreateInfo where
        showsPrec d x
          = showString "VkDescriptorSetLayoutCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkBindingCount = " .
                                  showsPrec d (vkBindingCount x) .
                                    showString ", " .
                                      showString "vkPBindings = " .
                                        showsPrec d (vkPBindings x) . showChar '}'

data VkDescriptorPoolSize = VkDescriptorPoolSize## ByteArray##

instance Eq VkDescriptorPoolSize where
        (VkDescriptorPoolSize## a) == (VkDescriptorPoolSize## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDescriptorPoolSize where
        (VkDescriptorPoolSize## a) `compare` (VkDescriptorPoolSize## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDescriptorPoolSize where
        sizeOf ~_ = #{size VkDescriptorPoolSize}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDescriptorPoolSize}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDescriptorPoolSize),
            I## a <- alignment (undefined :: VkDescriptorPoolSize) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDescriptorPoolSize## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDescriptorPoolSize## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorPoolSize) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDescriptorPoolSize where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkDescriptorPoolSize),
            I## a <- alignment (undefined :: VkDescriptorPoolSize) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkDescriptorPoolSize## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkDescriptorPoolSize## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkDescriptorPoolSize## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorPoolSize),
            I## a <- alignment (undefined :: VkDescriptorPoolSize) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkDescriptorPoolSize## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkDescriptorPoolSize## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkType a where
        type VkTypeMType a :: *

        vkType :: a -> VkTypeMType a

        vkTypeByteOffset :: a -> Int

        readVkType :: Mutable a -> IO (VkTypeMType a)

        writeVkType :: Mutable a -> VkTypeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'type'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkType a

instance {-# OVERLAPPING #-} HasVkType VkDescriptorPoolSize where
        type VkTypeMType VkDescriptorPoolSize = VkDescriptorType
        vkType (VkDescriptorPoolSize## ba)
          | I## _n <- sizeOf (undefined :: VkDescriptorType),
            I## o <- vkTypeByteOffset (undefined :: VkDescriptorPoolSize) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkType #-}
        vkTypeByteOffset ~_ = #{offset VkDescriptorPoolSize, type}

        {-# INLINE vkTypeByteOffset #-}
        readVkType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDescriptorType),
            I## o <- vkTypeByteOffset (undefined :: VkDescriptorPoolSize) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkType #-}
        writeVkType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkTypeByteOffset (undefined :: VkDescriptorPoolSize) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkType #-}

instance {-# OVERLAPPING #-}
         HasVkDescriptorCount VkDescriptorPoolSize where
        type VkDescriptorCountMType VkDescriptorPoolSize = Data.Word.Word32
        vkDescriptorCount (VkDescriptorPoolSize## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDescriptorCountByteOffset
                      (undefined :: VkDescriptorPoolSize)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDescriptorCount #-}
        vkDescriptorCountByteOffset ~_
          = #{offset VkDescriptorPoolSize, descriptorCount}

        {-# INLINE vkDescriptorCountByteOffset #-}
        readVkDescriptorCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDescriptorCountByteOffset
                      (undefined :: VkDescriptorPoolSize)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDescriptorCount #-}
        writeVkDescriptorCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDescriptorCountByteOffset
                      (undefined :: VkDescriptorPoolSize)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDescriptorCount #-}

instance Show VkDescriptorPoolSize where
        showsPrec d x
          = showString "VkDescriptorPoolSize {" .
              showString "vkType = " .
                showsPrec d (vkType x) .
                  showString ", " .
                    showString "vkDescriptorCount = " .
                      showsPrec d (vkDescriptorCount x) . showChar '}'

data VkDescriptorPoolCreateInfo = VkDescriptorPoolCreateInfo## ByteArray##

instance Eq VkDescriptorPoolCreateInfo where
        (VkDescriptorPoolCreateInfo## a) == (VkDescriptorPoolCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDescriptorPoolCreateInfo where
        (VkDescriptorPoolCreateInfo## a) `compare`
          (VkDescriptorPoolCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDescriptorPoolCreateInfo where
        sizeOf ~_ = #{size VkDescriptorPoolCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDescriptorPoolCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDescriptorPoolCreateInfo),
            I## a <- alignment (undefined :: VkDescriptorPoolCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDescriptorPoolCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDescriptorPoolCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorPoolCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDescriptorPoolCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkDescriptorPoolCreateInfo),
            I## a <- alignment (undefined :: VkDescriptorPoolCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkDescriptorPoolCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkDescriptorPoolCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkDescriptorPoolCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorPoolCreateInfo),
            I## a <- alignment (undefined :: VkDescriptorPoolCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkDescriptorPoolCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkDescriptorPoolCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkDescriptorPoolCreateInfo
         where
        type VkSTypeMType VkDescriptorPoolCreateInfo = VkStructureType
        vkSType (VkDescriptorPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkDescriptorPoolCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkDescriptorPoolCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkDescriptorPoolCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkDescriptorPoolCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkDescriptorPoolCreateInfo
         where
        type VkPNextMType VkDescriptorPoolCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkDescriptorPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkDescriptorPoolCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkDescriptorPoolCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkDescriptorPoolCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkDescriptorPoolCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkDescriptorPoolCreateInfo
         where
        type VkFlagsMType VkDescriptorPoolCreateInfo =
             VkDescriptorPoolCreateFlags
        vkFlags (VkDescriptorPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkDescriptorPoolCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkDescriptorPoolCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkDescriptorPoolCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDescriptorPoolCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkDescriptorPoolCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkDescriptorPoolCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkMaxSets a where
        type VkMaxSetsMType a :: *

        vkMaxSets :: a -> VkMaxSetsMType a

        vkMaxSetsByteOffset :: a -> Int

        readVkMaxSets :: Mutable a -> IO (VkMaxSetsMType a)

        writeVkMaxSets :: Mutable a -> VkMaxSetsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxSets'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxSets a

instance {-# OVERLAPPING #-}
         HasVkMaxSets VkDescriptorPoolCreateInfo where
        type VkMaxSetsMType VkDescriptorPoolCreateInfo = Data.Word.Word32
        vkMaxSets (VkDescriptorPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxSetsByteOffset
                      (undefined :: VkDescriptorPoolCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxSets #-}
        vkMaxSetsByteOffset ~_
          = #{offset VkDescriptorPoolCreateInfo, maxSets}

        {-# INLINE vkMaxSetsByteOffset #-}
        readVkMaxSets (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxSetsByteOffset
                      (undefined :: VkDescriptorPoolCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxSets #-}
        writeVkMaxSets (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxSetsByteOffset
                      (undefined :: VkDescriptorPoolCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxSets #-}

class HasVkPoolSizeCount a where
        type VkPoolSizeCountMType a :: *

        vkPoolSizeCount :: a -> VkPoolSizeCountMType a

        vkPoolSizeCountByteOffset :: a -> Int

        readVkPoolSizeCount :: Mutable a -> IO (VkPoolSizeCountMType a)

        writeVkPoolSizeCount ::
                             Mutable a -> VkPoolSizeCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'poolSizeCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPoolSizeCount a

instance {-# OVERLAPPING #-}
         HasVkPoolSizeCount VkDescriptorPoolCreateInfo where
        type VkPoolSizeCountMType VkDescriptorPoolCreateInfo =
             Data.Word.Word32
        vkPoolSizeCount (VkDescriptorPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkPoolSizeCountByteOffset
                      (undefined :: VkDescriptorPoolCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPoolSizeCount #-}
        vkPoolSizeCountByteOffset ~_
          = #{offset VkDescriptorPoolCreateInfo, poolSizeCount}

        {-# INLINE vkPoolSizeCountByteOffset #-}
        readVkPoolSizeCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkPoolSizeCountByteOffset
                      (undefined :: VkDescriptorPoolCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPoolSizeCount #-}
        writeVkPoolSizeCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPoolSizeCountByteOffset
                      (undefined :: VkDescriptorPoolCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPoolSizeCount #-}

class HasVkPPoolSizes a where
        type VkPPoolSizesMType a :: *

        vkPPoolSizes :: a -> VkPPoolSizesMType a

        vkPPoolSizesByteOffset :: a -> Int

        readVkPPoolSizes :: Mutable a -> IO (VkPPoolSizesMType a)

        writeVkPPoolSizes :: Mutable a -> VkPPoolSizesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pPoolSizes'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPPoolSizes a

instance {-# OVERLAPPING #-}
         HasVkPPoolSizes VkDescriptorPoolCreateInfo where
        type VkPPoolSizesMType VkDescriptorPoolCreateInfo =
             Foreign.Ptr.Ptr VkDescriptorPoolSize
        vkPPoolSizes (VkDescriptorPoolCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkDescriptorPoolSize),
            I## o <- vkPPoolSizesByteOffset
                      (undefined :: VkDescriptorPoolCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPPoolSizes #-}
        vkPPoolSizesByteOffset ~_
          = #{offset VkDescriptorPoolCreateInfo, pPoolSizes}

        {-# INLINE vkPPoolSizesByteOffset #-}
        readVkPPoolSizes (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkDescriptorPoolSize),
            I## o <- vkPPoolSizesByteOffset
                      (undefined :: VkDescriptorPoolCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPPoolSizes #-}
        writeVkPPoolSizes (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPPoolSizesByteOffset
                      (undefined :: VkDescriptorPoolCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPPoolSizes #-}

instance Show VkDescriptorPoolCreateInfo where
        showsPrec d x
          = showString "VkDescriptorPoolCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkMaxSets = " .
                                  showsPrec d (vkMaxSets x) .
                                    showString ", " .
                                      showString "vkPoolSizeCount = " .
                                        showsPrec d (vkPoolSizeCount x) .
                                          showString ", " .
                                            showString "vkPPoolSizes = " .
                                              showsPrec d (vkPPoolSizes x) . showChar '}'

data VkDescriptorSetAllocateInfo = VkDescriptorSetAllocateInfo## ByteArray##

instance Eq VkDescriptorSetAllocateInfo where
        (VkDescriptorSetAllocateInfo## a) ==
          (VkDescriptorSetAllocateInfo## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkDescriptorSetAllocateInfo where
        (VkDescriptorSetAllocateInfo## a) `compare`
          (VkDescriptorSetAllocateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkDescriptorSetAllocateInfo where
        sizeOf ~_ = #{size VkDescriptorSetAllocateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkDescriptorSetAllocateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkDescriptorSetAllocateInfo),
            I## a <- alignment (undefined :: VkDescriptorSetAllocateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkDescriptorSetAllocateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkDescriptorSetAllocateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorSetAllocateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkDescriptorSetAllocateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkDescriptorSetAllocateInfo),
            I## a <- alignment (undefined :: VkDescriptorSetAllocateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkDescriptorSetAllocateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkDescriptorSetAllocateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkDescriptorSetAllocateInfo## ba)
          | I## n <- sizeOf (undefined :: VkDescriptorSetAllocateInfo),
            I## a <- alignment (undefined :: VkDescriptorSetAllocateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkDescriptorSetAllocateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkDescriptorSetAllocateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkDescriptorSetAllocateInfo
         where
        type VkSTypeMType VkDescriptorSetAllocateInfo = VkStructureType
        vkSType (VkDescriptorSetAllocateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkDescriptorSetAllocateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkDescriptorSetAllocateInfo
         where
        type VkPNextMType VkDescriptorSetAllocateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkDescriptorSetAllocateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkDescriptorSetAllocateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

class HasVkDescriptorPool a where
        type VkDescriptorPoolMType a :: *

        vkDescriptorPool :: a -> VkDescriptorPoolMType a

        vkDescriptorPoolByteOffset :: a -> Int

        readVkDescriptorPool :: Mutable a -> IO (VkDescriptorPoolMType a)

        writeVkDescriptorPool ::
                              Mutable a -> VkDescriptorPoolMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'descriptorPool'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDescriptorPool a

instance {-# OVERLAPPING #-}
         HasVkDescriptorPool VkDescriptorSetAllocateInfo where
        type VkDescriptorPoolMType VkDescriptorSetAllocateInfo =
             VkDescriptorPool
        vkDescriptorPool (VkDescriptorSetAllocateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkDescriptorPool),
            I## o <- vkDescriptorPoolByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDescriptorPool #-}
        vkDescriptorPoolByteOffset ~_
          = #{offset VkDescriptorSetAllocateInfo, descriptorPool}

        {-# INLINE vkDescriptorPoolByteOffset #-}
        readVkDescriptorPool (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDescriptorPool),
            I## o <- vkDescriptorPoolByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDescriptorPool #-}
        writeVkDescriptorPool (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDescriptorPoolByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDescriptorPool #-}

class HasVkDescriptorSetCount a where
        type VkDescriptorSetCountMType a :: *

        vkDescriptorSetCount :: a -> VkDescriptorSetCountMType a

        vkDescriptorSetCountByteOffset :: a -> Int

        readVkDescriptorSetCount ::
                                 Mutable a -> IO (VkDescriptorSetCountMType a)

        writeVkDescriptorSetCount ::
                                  Mutable a -> VkDescriptorSetCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'descriptorSetCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDescriptorSetCount a

instance {-# OVERLAPPING #-}
         HasVkDescriptorSetCount VkDescriptorSetAllocateInfo where
        type VkDescriptorSetCountMType VkDescriptorSetAllocateInfo =
             Data.Word.Word32
        vkDescriptorSetCount (VkDescriptorSetAllocateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDescriptorSetCountByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDescriptorSetCount #-}
        vkDescriptorSetCountByteOffset ~_
          = #{offset VkDescriptorSetAllocateInfo, descriptorSetCount}

        {-# INLINE vkDescriptorSetCountByteOffset #-}
        readVkDescriptorSetCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDescriptorSetCountByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDescriptorSetCount #-}
        writeVkDescriptorSetCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDescriptorSetCountByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDescriptorSetCount #-}

class HasVkPSetLayouts a where
        type VkPSetLayoutsMType a :: *

        vkPSetLayouts :: a -> VkPSetLayoutsMType a

        vkPSetLayoutsByteOffset :: a -> Int

        readVkPSetLayouts :: Mutable a -> IO (VkPSetLayoutsMType a)

        writeVkPSetLayouts :: Mutable a -> VkPSetLayoutsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pSetLayouts'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPSetLayouts a

instance {-# OVERLAPPING #-}
         HasVkPSetLayouts VkDescriptorSetAllocateInfo where
        type VkPSetLayoutsMType VkDescriptorSetAllocateInfo =
             Foreign.Ptr.Ptr VkDescriptorSetLayout
        vkPSetLayouts (VkDescriptorSetAllocateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkDescriptorSetLayout),
            I## o <- vkPSetLayoutsByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPSetLayouts #-}
        vkPSetLayoutsByteOffset ~_
          = #{offset VkDescriptorSetAllocateInfo, pSetLayouts}

        {-# INLINE vkPSetLayoutsByteOffset #-}
        readVkPSetLayouts (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkDescriptorSetLayout),
            I## o <- vkPSetLayoutsByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPSetLayouts #-}
        writeVkPSetLayouts (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPSetLayoutsByteOffset
                      (undefined :: VkDescriptorSetAllocateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPSetLayouts #-}

instance Show VkDescriptorSetAllocateInfo where
        showsPrec d x
          = showString "VkDescriptorSetAllocateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkDescriptorPool = " .
                            showsPrec d (vkDescriptorPool x) .
                              showString ", " .
                                showString "vkDescriptorSetCount = " .
                                  showsPrec d (vkDescriptorSetCount x) .
                                    showString ", " .
                                      showString "vkPSetLayouts = " .
                                        showsPrec d (vkPSetLayouts x) . showChar '}'

data VkSpecializationMapEntry = VkSpecializationMapEntry## ByteArray##

instance Eq VkSpecializationMapEntry where
        (VkSpecializationMapEntry## a) == (VkSpecializationMapEntry## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSpecializationMapEntry where
        (VkSpecializationMapEntry## a) `compare`
          (VkSpecializationMapEntry## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSpecializationMapEntry where
        sizeOf ~_ = #{size VkSpecializationMapEntry}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSpecializationMapEntry}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSpecializationMapEntry),
            I## a <- alignment (undefined :: VkSpecializationMapEntry) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSpecializationMapEntry##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSpecializationMapEntry## ba)
          | I## n <- sizeOf (undefined :: VkSpecializationMapEntry) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSpecializationMapEntry where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSpecializationMapEntry),
            I## a <- alignment (undefined :: VkSpecializationMapEntry) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSpecializationMapEntry##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSpecializationMapEntry## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSpecializationMapEntry## ba)
          | I## n <- sizeOf (undefined :: VkSpecializationMapEntry),
            I## a <- alignment (undefined :: VkSpecializationMapEntry) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSpecializationMapEntry## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSpecializationMapEntry## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkConstantID a where
        type VkConstantIDMType a :: *

        vkConstantID :: a -> VkConstantIDMType a

        vkConstantIDByteOffset :: a -> Int

        readVkConstantID :: Mutable a -> IO (VkConstantIDMType a)

        writeVkConstantID :: Mutable a -> VkConstantIDMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'constantID'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkConstantID a

instance {-# OVERLAPPING #-}
         HasVkConstantID VkSpecializationMapEntry where
        type VkConstantIDMType VkSpecializationMapEntry = Data.Word.Word32
        vkConstantID (VkSpecializationMapEntry## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkConstantIDByteOffset
                      (undefined :: VkSpecializationMapEntry)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkConstantID #-}
        vkConstantIDByteOffset ~_
          = #{offset VkSpecializationMapEntry, constantID}

        {-# INLINE vkConstantIDByteOffset #-}
        readVkConstantID (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkConstantIDByteOffset
                      (undefined :: VkSpecializationMapEntry)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkConstantID #-}
        writeVkConstantID (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkConstantIDByteOffset
                      (undefined :: VkSpecializationMapEntry)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkConstantID #-}

instance {-# OVERLAPPING #-} HasVkOffset VkSpecializationMapEntry
         where
        type VkOffsetMType VkSpecializationMapEntry = Data.Word.Word32
        vkOffset (VkSpecializationMapEntry## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkOffsetByteOffset (undefined :: VkSpecializationMapEntry)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkSpecializationMapEntry, offset}

        {-# INLINE vkOffsetByteOffset #-}
        readVkOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkOffsetByteOffset (undefined :: VkSpecializationMapEntry)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOffset #-}
        writeVkOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOffsetByteOffset (undefined :: VkSpecializationMapEntry)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOffset #-}

instance {-# OVERLAPPING #-} HasVkSize VkSpecializationMapEntry
         where
        type VkSizeMType VkSpecializationMapEntry = Foreign.C.Types.CSize
        vkSize (VkSpecializationMapEntry## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CSize),
            I## o <- vkSizeByteOffset (undefined :: VkSpecializationMapEntry) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSize #-}
        vkSizeByteOffset ~_
          = #{offset VkSpecializationMapEntry, size}

        {-# INLINE vkSizeByteOffset #-}
        readVkSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CSize),
            I## o <- vkSizeByteOffset (undefined :: VkSpecializationMapEntry) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSize #-}
        writeVkSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSizeByteOffset (undefined :: VkSpecializationMapEntry) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSize #-}

instance Show VkSpecializationMapEntry where
        showsPrec d x
          = showString "VkSpecializationMapEntry {" .
              showString "vkConstantID = " .
                showsPrec d (vkConstantID x) .
                  showString ", " .
                    showString "vkOffset = " .
                      showsPrec d (vkOffset x) .
                        showString ", " .
                          showString "vkSize = " . showsPrec d (vkSize x) . showChar '}'

data VkSpecializationInfo = VkSpecializationInfo## ByteArray##

instance Eq VkSpecializationInfo where
        (VkSpecializationInfo## a) == (VkSpecializationInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSpecializationInfo where
        (VkSpecializationInfo## a) `compare` (VkSpecializationInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSpecializationInfo where
        sizeOf ~_ = #{size VkSpecializationInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSpecializationInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSpecializationInfo),
            I## a <- alignment (undefined :: VkSpecializationInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSpecializationInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSpecializationInfo## ba)
          | I## n <- sizeOf (undefined :: VkSpecializationInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSpecializationInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSpecializationInfo),
            I## a <- alignment (undefined :: VkSpecializationInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSpecializationInfo## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSpecializationInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSpecializationInfo## ba)
          | I## n <- sizeOf (undefined :: VkSpecializationInfo),
            I## a <- alignment (undefined :: VkSpecializationInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSpecializationInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSpecializationInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkMapEntryCount a where
        type VkMapEntryCountMType a :: *

        vkMapEntryCount :: a -> VkMapEntryCountMType a

        vkMapEntryCountByteOffset :: a -> Int

        readVkMapEntryCount :: Mutable a -> IO (VkMapEntryCountMType a)

        writeVkMapEntryCount ::
                             Mutable a -> VkMapEntryCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'mapEntryCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMapEntryCount a

instance {-# OVERLAPPING #-}
         HasVkMapEntryCount VkSpecializationInfo where
        type VkMapEntryCountMType VkSpecializationInfo = Data.Word.Word32
        vkMapEntryCount (VkSpecializationInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMapEntryCountByteOffset
                      (undefined :: VkSpecializationInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMapEntryCount #-}
        vkMapEntryCountByteOffset ~_
          = #{offset VkSpecializationInfo, mapEntryCount}

        {-# INLINE vkMapEntryCountByteOffset #-}
        readVkMapEntryCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMapEntryCountByteOffset
                      (undefined :: VkSpecializationInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMapEntryCount #-}
        writeVkMapEntryCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMapEntryCountByteOffset
                      (undefined :: VkSpecializationInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMapEntryCount #-}

class HasVkPMapEntries a where
        type VkPMapEntriesMType a :: *

        vkPMapEntries :: a -> VkPMapEntriesMType a

        vkPMapEntriesByteOffset :: a -> Int

        readVkPMapEntries :: Mutable a -> IO (VkPMapEntriesMType a)

        writeVkPMapEntries :: Mutable a -> VkPMapEntriesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pMapEntries'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPMapEntries a

instance {-# OVERLAPPING #-} HasVkPMapEntries VkSpecializationInfo
         where
        type VkPMapEntriesMType VkSpecializationInfo =
             Foreign.Ptr.Ptr VkSpecializationMapEntry
        vkPMapEntries (VkSpecializationInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSpecializationMapEntry),
            I## o <- vkPMapEntriesByteOffset (undefined :: VkSpecializationInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPMapEntries #-}
        vkPMapEntriesByteOffset ~_
          = #{offset VkSpecializationInfo, pMapEntries}

        {-# INLINE vkPMapEntriesByteOffset #-}
        readVkPMapEntries (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSpecializationMapEntry),
            I## o <- vkPMapEntriesByteOffset (undefined :: VkSpecializationInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPMapEntries #-}
        writeVkPMapEntries (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPMapEntriesByteOffset (undefined :: VkSpecializationInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPMapEntries #-}

class HasVkDataSize a where
        type VkDataSizeMType a :: *

        vkDataSize :: a -> VkDataSizeMType a

        vkDataSizeByteOffset :: a -> Int

        readVkDataSize :: Mutable a -> IO (VkDataSizeMType a)

        writeVkDataSize :: Mutable a -> VkDataSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dataSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDataSize a

instance {-# OVERLAPPING #-} HasVkDataSize VkSpecializationInfo
         where
        type VkDataSizeMType VkSpecializationInfo = Foreign.C.Types.CSize
        vkDataSize (VkSpecializationInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CSize),
            I## o <- vkDataSizeByteOffset (undefined :: VkSpecializationInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDataSize #-}
        vkDataSizeByteOffset ~_
          = #{offset VkSpecializationInfo, dataSize}

        {-# INLINE vkDataSizeByteOffset #-}
        readVkDataSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CSize),
            I## o <- vkDataSizeByteOffset (undefined :: VkSpecializationInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDataSize #-}
        writeVkDataSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDataSizeByteOffset (undefined :: VkSpecializationInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDataSize #-}

class HasVkPData a where
        type VkPDataMType a :: *

        vkPData :: a -> VkPDataMType a

        vkPDataByteOffset :: a -> Int

        readVkPData :: Mutable a -> IO (VkPDataMType a)

        writeVkPData :: Mutable a -> VkPDataMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pData'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPData a

instance {-# OVERLAPPING #-} HasVkPData VkSpecializationInfo where
        type VkPDataMType VkSpecializationInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPData (VkSpecializationInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPDataByteOffset (undefined :: VkSpecializationInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPData #-}
        vkPDataByteOffset ~_
          = #{offset VkSpecializationInfo, pData}

        {-# INLINE vkPDataByteOffset #-}
        readVkPData (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPDataByteOffset (undefined :: VkSpecializationInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPData #-}
        writeVkPData (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPDataByteOffset (undefined :: VkSpecializationInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPData #-}

instance Show VkSpecializationInfo where
        showsPrec d x
          = showString "VkSpecializationInfo {" .
              showString "vkMapEntryCount = " .
                showsPrec d (vkMapEntryCount x) .
                  showString ", " .
                    showString "vkPMapEntries = " .
                      showsPrec d (vkPMapEntries x) .
                        showString ", " .
                          showString "vkDataSize = " .
                            showsPrec d (vkDataSize x) .
                              showString ", " .
                                showString "vkPData = " . showsPrec d (vkPData x) . showChar '}'

data VkPipelineShaderStageCreateInfo = VkPipelineShaderStageCreateInfo## ByteArray##

instance Eq VkPipelineShaderStageCreateInfo where
        (VkPipelineShaderStageCreateInfo## a) ==
          (VkPipelineShaderStageCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineShaderStageCreateInfo where
        (VkPipelineShaderStageCreateInfo## a) `compare`
          (VkPipelineShaderStageCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineShaderStageCreateInfo where
        sizeOf ~_ = #{size VkPipelineShaderStageCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPipelineShaderStageCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPipelineShaderStageCreateInfo),
            I## a <- alignment (undefined :: VkPipelineShaderStageCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineShaderStageCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineShaderStageCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineShaderStageCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineShaderStageCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkPipelineShaderStageCreateInfo),
            I## a <- alignment (undefined :: VkPipelineShaderStageCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPipelineShaderStageCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPipelineShaderStageCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPipelineShaderStageCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineShaderStageCreateInfo),
            I## a <- alignment (undefined :: VkPipelineShaderStageCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPipelineShaderStageCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPipelineShaderStageCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineShaderStageCreateInfo where
        type VkSTypeMType VkPipelineShaderStageCreateInfo = VkStructureType
        vkSType (VkPipelineShaderStageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineShaderStageCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineShaderStageCreateInfo where
        type VkPNextMType VkPipelineShaderStageCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkPipelineShaderStageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineShaderStageCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineShaderStageCreateInfo where
        type VkFlagsMType VkPipelineShaderStageCreateInfo =
             VkPipelineShaderStageCreateFlags
        vkFlags (VkPipelineShaderStageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkPipelineShaderStageCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineShaderStageCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPipelineShaderStageCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkStage a where
        type VkStageMType a :: *

        vkStage :: a -> VkStageMType a

        vkStageByteOffset :: a -> Int

        readVkStage :: Mutable a -> IO (VkStageMType a)

        writeVkStage :: Mutable a -> VkStageMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stage'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStage a

instance {-# OVERLAPPING #-}
         HasVkStage VkPipelineShaderStageCreateInfo where
        type VkStageMType VkPipelineShaderStageCreateInfo =
             VkShaderStageFlagBits
        vkStage (VkPipelineShaderStageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkShaderStageFlagBits),
            I## o <- vkStageByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkStage #-}
        vkStageByteOffset ~_
          = #{offset VkPipelineShaderStageCreateInfo, stage}

        {-# INLINE vkStageByteOffset #-}
        readVkStage (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkShaderStageFlagBits),
            I## o <- vkStageByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkStage #-}
        writeVkStage (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkStageByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkStage #-}

class HasVkModule a where
        type VkModuleMType a :: *

        vkModule :: a -> VkModuleMType a

        vkModuleByteOffset :: a -> Int

        readVkModule :: Mutable a -> IO (VkModuleMType a)

        writeVkModule :: Mutable a -> VkModuleMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'module'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkModule a

instance {-# OVERLAPPING #-}
         HasVkModule VkPipelineShaderStageCreateInfo where
        type VkModuleMType VkPipelineShaderStageCreateInfo = VkShaderModule
        vkModule (VkPipelineShaderStageCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkShaderModule),
            I## o <- vkModuleByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkModule #-}
        vkModuleByteOffset ~_
          = #{offset VkPipelineShaderStageCreateInfo, module}

        {-# INLINE vkModuleByteOffset #-}
        readVkModule (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkShaderModule),
            I## o <- vkModuleByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkModule #-}
        writeVkModule (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkModuleByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkModule #-}

class HasVkPName a where
        type VkPNameMType a :: *

        vkPName :: a -> VkPNameMType a

        vkPNameByteOffset :: a -> Int

        readVkPName :: Mutable a -> IO (VkPNameMType a)

        writeVkPName :: Mutable a -> VkPNameMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pName'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPName a

instance {-# OVERLAPPING #-}
         HasVkPName VkPipelineShaderStageCreateInfo where
        type VkPNameMType VkPipelineShaderStageCreateInfo =
             Foreign.Ptr.Ptr Foreign.C.Types.CChar
        vkPName (VkPipelineShaderStageCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr Foreign.C.Types.CChar),
            I## o <- vkPNameByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPName #-}
        vkPNameByteOffset ~_
          = #{offset VkPipelineShaderStageCreateInfo, pName}

        {-# INLINE vkPNameByteOffset #-}
        readVkPName (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr Foreign.C.Types.CChar),
            I## o <- vkPNameByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPName #-}
        writeVkPName (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNameByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPName #-}

class HasVkPSpecializationInfo a where
        type VkPSpecializationInfoMType a :: *

        vkPSpecializationInfo :: a -> VkPSpecializationInfoMType a

        vkPSpecializationInfoByteOffset :: a -> Int

        readVkPSpecializationInfo ::
                                  Mutable a -> IO (VkPSpecializationInfoMType a)

        writeVkPSpecializationInfo ::
                                   Mutable a -> VkPSpecializationInfoMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pSpecializationInfo'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPSpecializationInfo a

instance {-# OVERLAPPING #-}
         HasVkPSpecializationInfo VkPipelineShaderStageCreateInfo where
        type VkPSpecializationInfoMType VkPipelineShaderStageCreateInfo =
             Foreign.Ptr.Ptr VkSpecializationInfo
        vkPSpecializationInfo (VkPipelineShaderStageCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSpecializationInfo),
            I## o <- vkPSpecializationInfoByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPSpecializationInfo #-}
        vkPSpecializationInfoByteOffset ~_
          = #{offset VkPipelineShaderStageCreateInfo, pSpecializationInfo}

        {-# INLINE vkPSpecializationInfoByteOffset #-}
        readVkPSpecializationInfo (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSpecializationInfo),
            I## o <- vkPSpecializationInfoByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPSpecializationInfo #-}
        writeVkPSpecializationInfo (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPSpecializationInfoByteOffset
                      (undefined :: VkPipelineShaderStageCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPSpecializationInfo #-}

instance Show VkPipelineShaderStageCreateInfo where
        showsPrec d x
          = showString "VkPipelineShaderStageCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkStage = " .
                                  showsPrec d (vkStage x) .
                                    showString ", " .
                                      showString "vkModule = " .
                                        showsPrec d (vkModule x) .
                                          showString ", " .
                                            showString "vkPName = " .
                                              showsPrec d (vkPName x) .
                                                showString ", " .
                                                  showString "vkPSpecializationInfo = " .
                                                    showsPrec d (vkPSpecializationInfo x) .
                                                      showChar '}'

data VkComputePipelineCreateInfo = VkComputePipelineCreateInfo## ByteArray##

instance Eq VkComputePipelineCreateInfo where
        (VkComputePipelineCreateInfo## a) ==
          (VkComputePipelineCreateInfo## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkComputePipelineCreateInfo where
        (VkComputePipelineCreateInfo## a) `compare`
          (VkComputePipelineCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkComputePipelineCreateInfo where
        sizeOf ~_ = #{size VkComputePipelineCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkComputePipelineCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkComputePipelineCreateInfo),
            I## a <- alignment (undefined :: VkComputePipelineCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkComputePipelineCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkComputePipelineCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkComputePipelineCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkComputePipelineCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkComputePipelineCreateInfo),
            I## a <- alignment (undefined :: VkComputePipelineCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkComputePipelineCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkComputePipelineCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkComputePipelineCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkComputePipelineCreateInfo),
            I## a <- alignment (undefined :: VkComputePipelineCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkComputePipelineCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkComputePipelineCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkComputePipelineCreateInfo
         where
        type VkSTypeMType VkComputePipelineCreateInfo = VkStructureType
        vkSType (VkComputePipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkComputePipelineCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkComputePipelineCreateInfo
         where
        type VkPNextMType VkComputePipelineCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkComputePipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkComputePipelineCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkComputePipelineCreateInfo
         where
        type VkFlagsMType VkComputePipelineCreateInfo =
             VkPipelineCreateFlags
        vkFlags (VkComputePipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkPipelineCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkComputePipelineCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPipelineCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

instance {-# OVERLAPPING #-} HasVkStage VkComputePipelineCreateInfo
         where
        type VkStageMType VkComputePipelineCreateInfo =
             VkPipelineShaderStageCreateInfo
        vkStage (VkComputePipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkPipelineShaderStageCreateInfo),
            I## o <- vkStageByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkStage #-}
        vkStageByteOffset ~_
          = #{offset VkComputePipelineCreateInfo, stage}

        {-# INLINE vkStageByteOffset #-}
        readVkStage (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPipelineShaderStageCreateInfo),
            I## o <- vkStageByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkStage #-}
        writeVkStage (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkStageByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkStage #-}

class HasVkLayout a where
        type VkLayoutMType a :: *

        vkLayout :: a -> VkLayoutMType a

        vkLayoutByteOffset :: a -> Int

        readVkLayout :: Mutable a -> IO (VkLayoutMType a)

        writeVkLayout :: Mutable a -> VkLayoutMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'layout'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLayout a

instance {-# OVERLAPPING #-}
         HasVkLayout VkComputePipelineCreateInfo where
        type VkLayoutMType VkComputePipelineCreateInfo = VkPipelineLayout
        vkLayout (VkComputePipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkPipelineLayout),
            I## o <- vkLayoutByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLayout #-}
        vkLayoutByteOffset ~_
          = #{offset VkComputePipelineCreateInfo, layout}

        {-# INLINE vkLayoutByteOffset #-}
        readVkLayout (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPipelineLayout),
            I## o <- vkLayoutByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLayout #-}
        writeVkLayout (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLayoutByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLayout #-}

class HasVkBasePipelineHandle a where
        type VkBasePipelineHandleMType a :: *

        vkBasePipelineHandle :: a -> VkBasePipelineHandleMType a

        vkBasePipelineHandleByteOffset :: a -> Int

        readVkBasePipelineHandle ::
                                 Mutable a -> IO (VkBasePipelineHandleMType a)

        writeVkBasePipelineHandle ::
                                  Mutable a -> VkBasePipelineHandleMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'basePipelineHandle'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBasePipelineHandle a

instance {-# OVERLAPPING #-}
         HasVkBasePipelineHandle VkComputePipelineCreateInfo where
        type VkBasePipelineHandleMType VkComputePipelineCreateInfo =
             VkPipeline
        vkBasePipelineHandle (VkComputePipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkPipeline),
            I## o <- vkBasePipelineHandleByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBasePipelineHandle #-}
        vkBasePipelineHandleByteOffset ~_
          = #{offset VkComputePipelineCreateInfo, basePipelineHandle}

        {-# INLINE vkBasePipelineHandleByteOffset #-}
        readVkBasePipelineHandle (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPipeline),
            I## o <- vkBasePipelineHandleByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBasePipelineHandle #-}
        writeVkBasePipelineHandle (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBasePipelineHandleByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBasePipelineHandle #-}

class HasVkBasePipelineIndex a where
        type VkBasePipelineIndexMType a :: *

        vkBasePipelineIndex :: a -> VkBasePipelineIndexMType a

        vkBasePipelineIndexByteOffset :: a -> Int

        readVkBasePipelineIndex ::
                                Mutable a -> IO (VkBasePipelineIndexMType a)

        writeVkBasePipelineIndex ::
                                 Mutable a -> VkBasePipelineIndexMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'basePipelineIndex'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBasePipelineIndex a

instance {-# OVERLAPPING #-}
         HasVkBasePipelineIndex VkComputePipelineCreateInfo where
        type VkBasePipelineIndexMType VkComputePipelineCreateInfo =
             Data.Int.Int32
        vkBasePipelineIndex (VkComputePipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkBasePipelineIndexByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBasePipelineIndex #-}
        vkBasePipelineIndexByteOffset ~_
          = #{offset VkComputePipelineCreateInfo, basePipelineIndex}

        {-# INLINE vkBasePipelineIndexByteOffset #-}
        readVkBasePipelineIndex (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkBasePipelineIndexByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBasePipelineIndex #-}
        writeVkBasePipelineIndex (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBasePipelineIndexByteOffset
                      (undefined :: VkComputePipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBasePipelineIndex #-}

instance Show VkComputePipelineCreateInfo where
        showsPrec d x
          = showString "VkComputePipelineCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkStage = " .
                                  showsPrec d (vkStage x) .
                                    showString ", " .
                                      showString "vkLayout = " .
                                        showsPrec d (vkLayout x) .
                                          showString ", " .
                                            showString "vkBasePipelineHandle = " .
                                              showsPrec d (vkBasePipelineHandle x) .
                                                showString ", " .
                                                  showString "vkBasePipelineIndex = " .
                                                    showsPrec d (vkBasePipelineIndex x) .
                                                      showChar '}'

data VkVertexInputBindingDescription = VkVertexInputBindingDescription## ByteArray##

instance Eq VkVertexInputBindingDescription where
        (VkVertexInputBindingDescription## a) ==
          (VkVertexInputBindingDescription## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkVertexInputBindingDescription where
        (VkVertexInputBindingDescription## a) `compare`
          (VkVertexInputBindingDescription## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkVertexInputBindingDescription where
        sizeOf ~_ = #{size VkVertexInputBindingDescription}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkVertexInputBindingDescription}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkVertexInputBindingDescription),
            I## a <- alignment (undefined :: VkVertexInputBindingDescription) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkVertexInputBindingDescription##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkVertexInputBindingDescription## ba)
          | I## n <- sizeOf (undefined :: VkVertexInputBindingDescription) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkVertexInputBindingDescription where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkVertexInputBindingDescription),
            I## a <- alignment (undefined :: VkVertexInputBindingDescription) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkVertexInputBindingDescription##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkVertexInputBindingDescription## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkVertexInputBindingDescription## ba)
          | I## n <- sizeOf (undefined :: VkVertexInputBindingDescription),
            I## a <- alignment (undefined :: VkVertexInputBindingDescription) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkVertexInputBindingDescription## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkVertexInputBindingDescription## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkBinding VkVertexInputBindingDescription where
        type VkBindingMType VkVertexInputBindingDescription =
             Data.Word.Word32
        vkBinding (VkVertexInputBindingDescription## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBindingByteOffset
                      (undefined :: VkVertexInputBindingDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBinding #-}
        vkBindingByteOffset ~_
          = #{offset VkVertexInputBindingDescription, binding}

        {-# INLINE vkBindingByteOffset #-}
        readVkBinding (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBindingByteOffset
                      (undefined :: VkVertexInputBindingDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBinding #-}
        writeVkBinding (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBindingByteOffset
                      (undefined :: VkVertexInputBindingDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBinding #-}

class HasVkStride a where
        type VkStrideMType a :: *

        vkStride :: a -> VkStrideMType a

        vkStrideByteOffset :: a -> Int

        readVkStride :: Mutable a -> IO (VkStrideMType a)

        writeVkStride :: Mutable a -> VkStrideMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stride'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStride a

instance {-# OVERLAPPING #-}
         HasVkStride VkVertexInputBindingDescription where
        type VkStrideMType VkVertexInputBindingDescription =
             Data.Word.Word32
        vkStride (VkVertexInputBindingDescription## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkStrideByteOffset
                      (undefined :: VkVertexInputBindingDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkStride #-}
        vkStrideByteOffset ~_
          = #{offset VkVertexInputBindingDescription, stride}

        {-# INLINE vkStrideByteOffset #-}
        readVkStride (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkStrideByteOffset
                      (undefined :: VkVertexInputBindingDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkStride #-}
        writeVkStride (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkStrideByteOffset
                      (undefined :: VkVertexInputBindingDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkStride #-}

class HasVkInputRate a where
        type VkInputRateMType a :: *

        vkInputRate :: a -> VkInputRateMType a

        vkInputRateByteOffset :: a -> Int

        readVkInputRate :: Mutable a -> IO (VkInputRateMType a)

        writeVkInputRate :: Mutable a -> VkInputRateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'inputRate'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkInputRate a

instance {-# OVERLAPPING #-}
         HasVkInputRate VkVertexInputBindingDescription where
        type VkInputRateMType VkVertexInputBindingDescription =
             VkVertexInputRate
        vkInputRate (VkVertexInputBindingDescription## ba)
          | I## _n <- sizeOf (undefined :: VkVertexInputRate),
            I## o <- vkInputRateByteOffset
                      (undefined :: VkVertexInputBindingDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkInputRate #-}
        vkInputRateByteOffset ~_
          = #{offset VkVertexInputBindingDescription, inputRate}

        {-# INLINE vkInputRateByteOffset #-}
        readVkInputRate (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkVertexInputRate),
            I## o <- vkInputRateByteOffset
                      (undefined :: VkVertexInputBindingDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkInputRate #-}
        writeVkInputRate (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkInputRateByteOffset
                      (undefined :: VkVertexInputBindingDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkInputRate #-}

instance Show VkVertexInputBindingDescription where
        showsPrec d x
          = showString "VkVertexInputBindingDescription {" .
              showString "vkBinding = " .
                showsPrec d (vkBinding x) .
                  showString ", " .
                    showString "vkStride = " .
                      showsPrec d (vkStride x) .
                        showString ", " .
                          showString "vkInputRate = " .
                            showsPrec d (vkInputRate x) . showChar '}'

data VkVertexInputAttributeDescription = VkVertexInputAttributeDescription## ByteArray##

instance Eq VkVertexInputAttributeDescription where
        (VkVertexInputAttributeDescription## a) ==
          (VkVertexInputAttributeDescription## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkVertexInputAttributeDescription where
        (VkVertexInputAttributeDescription## a) `compare`
          (VkVertexInputAttributeDescription## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkVertexInputAttributeDescription where
        sizeOf ~_ = #{size VkVertexInputAttributeDescription}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkVertexInputAttributeDescription}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkVertexInputAttributeDescription),
            I## a <- alignment (undefined :: VkVertexInputAttributeDescription)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkVertexInputAttributeDescription##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkVertexInputAttributeDescription## ba)
          | I## n <- sizeOf (undefined :: VkVertexInputAttributeDescription) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkVertexInputAttributeDescription where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkVertexInputAttributeDescription),
            I## a <- alignment (undefined :: VkVertexInputAttributeDescription)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkVertexInputAttributeDescription##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkVertexInputAttributeDescription## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkVertexInputAttributeDescription## ba)
          | I## n <- sizeOf (undefined :: VkVertexInputAttributeDescription),
            I## a <- alignment (undefined :: VkVertexInputAttributeDescription)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkVertexInputAttributeDescription## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkVertexInputAttributeDescription## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkLocation a where
        type VkLocationMType a :: *

        vkLocation :: a -> VkLocationMType a

        vkLocationByteOffset :: a -> Int

        readVkLocation :: Mutable a -> IO (VkLocationMType a)

        writeVkLocation :: Mutable a -> VkLocationMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'location'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLocation a

instance {-# OVERLAPPING #-}
         HasVkLocation VkVertexInputAttributeDescription where
        type VkLocationMType VkVertexInputAttributeDescription =
             Data.Word.Word32
        vkLocation (VkVertexInputAttributeDescription## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkLocationByteOffset
                      (undefined :: VkVertexInputAttributeDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLocation #-}
        vkLocationByteOffset ~_
          = #{offset VkVertexInputAttributeDescription, location}

        {-# INLINE vkLocationByteOffset #-}
        readVkLocation (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkLocationByteOffset
                      (undefined :: VkVertexInputAttributeDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLocation #-}
        writeVkLocation (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLocationByteOffset
                      (undefined :: VkVertexInputAttributeDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLocation #-}

instance {-# OVERLAPPING #-}
         HasVkBinding VkVertexInputAttributeDescription where
        type VkBindingMType VkVertexInputAttributeDescription =
             Data.Word.Word32
        vkBinding (VkVertexInputAttributeDescription## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBindingByteOffset
                      (undefined :: VkVertexInputAttributeDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBinding #-}
        vkBindingByteOffset ~_
          = #{offset VkVertexInputAttributeDescription, binding}

        {-# INLINE vkBindingByteOffset #-}
        readVkBinding (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkBindingByteOffset
                      (undefined :: VkVertexInputAttributeDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBinding #-}
        writeVkBinding (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBindingByteOffset
                      (undefined :: VkVertexInputAttributeDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBinding #-}

instance {-# OVERLAPPING #-}
         HasVkFormat VkVertexInputAttributeDescription where
        type VkFormatMType VkVertexInputAttributeDescription = VkFormat
        vkFormat (VkVertexInputAttributeDescription## ba)
          | I## _n <- sizeOf (undefined :: VkFormat),
            I## o <- vkFormatByteOffset
                      (undefined :: VkVertexInputAttributeDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFormat #-}
        vkFormatByteOffset ~_
          = #{offset VkVertexInputAttributeDescription, format}

        {-# INLINE vkFormatByteOffset #-}
        readVkFormat (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFormat),
            I## o <- vkFormatByteOffset
                      (undefined :: VkVertexInputAttributeDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFormat #-}
        writeVkFormat (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFormatByteOffset
                      (undefined :: VkVertexInputAttributeDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFormat #-}

instance {-# OVERLAPPING #-}
         HasVkOffset VkVertexInputAttributeDescription where
        type VkOffsetMType VkVertexInputAttributeDescription =
             Data.Word.Word32
        vkOffset (VkVertexInputAttributeDescription## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkOffsetByteOffset
                      (undefined :: VkVertexInputAttributeDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkVertexInputAttributeDescription, offset}

        {-# INLINE vkOffsetByteOffset #-}
        readVkOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkOffsetByteOffset
                      (undefined :: VkVertexInputAttributeDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOffset #-}
        writeVkOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOffsetByteOffset
                      (undefined :: VkVertexInputAttributeDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOffset #-}

instance Show VkVertexInputAttributeDescription where
        showsPrec d x
          = showString "VkVertexInputAttributeDescription {" .
              showString "vkLocation = " .
                showsPrec d (vkLocation x) .
                  showString ", " .
                    showString "vkBinding = " .
                      showsPrec d (vkBinding x) .
                        showString ", " .
                          showString "vkFormat = " .
                            showsPrec d (vkFormat x) .
                              showString ", " .
                                showString "vkOffset = " . showsPrec d (vkOffset x) . showChar '}'

data VkPipelineVertexInputStateCreateInfo = VkPipelineVertexInputStateCreateInfo## ByteArray##

instance Eq VkPipelineVertexInputStateCreateInfo where
        (VkPipelineVertexInputStateCreateInfo## a) ==
          (VkPipelineVertexInputStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineVertexInputStateCreateInfo where
        (VkPipelineVertexInputStateCreateInfo## a) `compare`
          (VkPipelineVertexInputStateCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineVertexInputStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineVertexInputStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineVertexInputStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineVertexInputStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineVertexInputStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineVertexInputStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineVertexInputStateCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineVertexInputStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPipelineVertexInputStateCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPipelineVertexInputStateCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPipelineVertexInputStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineVertexInputStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPipelineVertexInputStateCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPipelineVertexInputStateCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineVertexInputStateCreateInfo where
        type VkSTypeMType VkPipelineVertexInputStateCreateInfo =
             VkStructureType
        vkSType (VkPipelineVertexInputStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineVertexInputStateCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineVertexInputStateCreateInfo where
        type VkPNextMType VkPipelineVertexInputStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkPipelineVertexInputStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineVertexInputStateCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineVertexInputStateCreateInfo where
        type VkFlagsMType VkPipelineVertexInputStateCreateInfo =
             VkPipelineVertexInputStateCreateFlags
        vkFlags (VkPipelineVertexInputStateCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineVertexInputStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineVertexInputStateCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineVertexInputStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkVertexBindingDescriptionCount a where
        type VkVertexBindingDescriptionCountMType a :: *

        vkVertexBindingDescriptionCount ::
                                        a -> VkVertexBindingDescriptionCountMType a

        vkVertexBindingDescriptionCountByteOffset :: a -> Int

        readVkVertexBindingDescriptionCount ::
                                            Mutable a -> IO (VkVertexBindingDescriptionCountMType a)

        writeVkVertexBindingDescriptionCount ::
                                             Mutable a ->
                                               VkVertexBindingDescriptionCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'vertexBindingDescriptionCount'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkVertexBindingDescriptionCount a

instance {-# OVERLAPPING #-}
         HasVkVertexBindingDescriptionCount
           VkPipelineVertexInputStateCreateInfo
         where
        type VkVertexBindingDescriptionCountMType
               VkPipelineVertexInputStateCreateInfo
             = Data.Word.Word32
        vkVertexBindingDescriptionCount
          (VkPipelineVertexInputStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkVertexBindingDescriptionCountByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkVertexBindingDescriptionCount #-}
        vkVertexBindingDescriptionCountByteOffset ~_
          = #{offset VkPipelineVertexInputStateCreateInfo, vertexBindingDescriptionCount}

        {-# INLINE vkVertexBindingDescriptionCountByteOffset #-}
        readVkVertexBindingDescriptionCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkVertexBindingDescriptionCountByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkVertexBindingDescriptionCount #-}
        writeVkVertexBindingDescriptionCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkVertexBindingDescriptionCountByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkVertexBindingDescriptionCount #-}

class HasVkPVertexBindingDescriptions a where
        type VkPVertexBindingDescriptionsMType a :: *

        vkPVertexBindingDescriptions ::
                                     a -> VkPVertexBindingDescriptionsMType a

        vkPVertexBindingDescriptionsByteOffset :: a -> Int

        readVkPVertexBindingDescriptions ::
                                         Mutable a -> IO (VkPVertexBindingDescriptionsMType a)

        writeVkPVertexBindingDescriptions ::
                                          Mutable a -> VkPVertexBindingDescriptionsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pVertexBindingDescriptions'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPVertexBindingDescriptions a

instance {-# OVERLAPPING #-}
         HasVkPVertexBindingDescriptions
           VkPipelineVertexInputStateCreateInfo
         where
        type VkPVertexBindingDescriptionsMType
               VkPipelineVertexInputStateCreateInfo
             = Foreign.Ptr.Ptr VkVertexInputBindingDescription
        vkPVertexBindingDescriptions
          (VkPipelineVertexInputStateCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkVertexInputBindingDescription),
            I## o <- vkPVertexBindingDescriptionsByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPVertexBindingDescriptions #-}
        vkPVertexBindingDescriptionsByteOffset ~_
          = #{offset VkPipelineVertexInputStateCreateInfo, pVertexBindingDescriptions}

        {-# INLINE vkPVertexBindingDescriptionsByteOffset #-}
        readVkPVertexBindingDescriptions (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkVertexInputBindingDescription),
            I## o <- vkPVertexBindingDescriptionsByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPVertexBindingDescriptions #-}
        writeVkPVertexBindingDescriptions (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPVertexBindingDescriptionsByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPVertexBindingDescriptions #-}

class HasVkVertexAttributeDescriptionCount a where
        type VkVertexAttributeDescriptionCountMType a :: *

        vkVertexAttributeDescriptionCount ::
                                          a -> VkVertexAttributeDescriptionCountMType a

        vkVertexAttributeDescriptionCountByteOffset :: a -> Int

        readVkVertexAttributeDescriptionCount ::
                                              Mutable a ->
                                                IO (VkVertexAttributeDescriptionCountMType a)

        writeVkVertexAttributeDescriptionCount ::
                                               Mutable a ->
                                                 VkVertexAttributeDescriptionCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'vertexAttributeDescriptionCount'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkVertexAttributeDescriptionCount a

instance {-# OVERLAPPING #-}
         HasVkVertexAttributeDescriptionCount
           VkPipelineVertexInputStateCreateInfo
         where
        type VkVertexAttributeDescriptionCountMType
               VkPipelineVertexInputStateCreateInfo
             = Data.Word.Word32
        vkVertexAttributeDescriptionCount
          (VkPipelineVertexInputStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkVertexAttributeDescriptionCountByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkVertexAttributeDescriptionCount #-}
        vkVertexAttributeDescriptionCountByteOffset ~_
          = #{offset VkPipelineVertexInputStateCreateInfo, vertexAttributeDescriptionCount}

        {-# INLINE vkVertexAttributeDescriptionCountByteOffset #-}
        readVkVertexAttributeDescriptionCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkVertexAttributeDescriptionCountByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkVertexAttributeDescriptionCount #-}
        writeVkVertexAttributeDescriptionCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkVertexAttributeDescriptionCountByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkVertexAttributeDescriptionCount #-}

class HasVkPVertexAttributeDescriptions a where
        type VkPVertexAttributeDescriptionsMType a :: *

        vkPVertexAttributeDescriptions ::
                                       a -> VkPVertexAttributeDescriptionsMType a

        vkPVertexAttributeDescriptionsByteOffset :: a -> Int

        readVkPVertexAttributeDescriptions ::
                                           Mutable a -> IO (VkPVertexAttributeDescriptionsMType a)

        writeVkPVertexAttributeDescriptions ::
                                            Mutable a ->
                                              VkPVertexAttributeDescriptionsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pVertexAttributeDescriptions'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPVertexAttributeDescriptions a

instance {-# OVERLAPPING #-}
         HasVkPVertexAttributeDescriptions
           VkPipelineVertexInputStateCreateInfo
         where
        type VkPVertexAttributeDescriptionsMType
               VkPipelineVertexInputStateCreateInfo
             = Foreign.Ptr.Ptr VkVertexInputAttributeDescription
        vkPVertexAttributeDescriptions
          (VkPipelineVertexInputStateCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkVertexInputAttributeDescription),
            I## o <- vkPVertexAttributeDescriptionsByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPVertexAttributeDescriptions #-}
        vkPVertexAttributeDescriptionsByteOffset ~_
          = #{offset VkPipelineVertexInputStateCreateInfo, pVertexAttributeDescriptions}

        {-# INLINE vkPVertexAttributeDescriptionsByteOffset #-}
        readVkPVertexAttributeDescriptions (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkVertexInputAttributeDescription),
            I## o <- vkPVertexAttributeDescriptionsByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPVertexAttributeDescriptions #-}
        writeVkPVertexAttributeDescriptions (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPVertexAttributeDescriptionsByteOffset
                      (undefined :: VkPipelineVertexInputStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPVertexAttributeDescriptions #-}

instance Show VkPipelineVertexInputStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineVertexInputStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkVertexBindingDescriptionCount = " .
                                  showsPrec d (vkVertexBindingDescriptionCount x) .
                                    showString ", " .
                                      showString "vkPVertexBindingDescriptions = " .
                                        showsPrec d (vkPVertexBindingDescriptions x) .
                                          showString ", " .
                                            showString "vkVertexAttributeDescriptionCount = " .
                                              showsPrec d (vkVertexAttributeDescriptionCount x) .
                                                showString ", " .
                                                  showString "vkPVertexAttributeDescriptions = " .
                                                    showsPrec d (vkPVertexAttributeDescriptions x) .
                                                      showChar '}'

data VkPipelineInputAssemblyStateCreateInfo = VkPipelineInputAssemblyStateCreateInfo## ByteArray##

instance Eq VkPipelineInputAssemblyStateCreateInfo where
        (VkPipelineInputAssemblyStateCreateInfo## a) ==
          (VkPipelineInputAssemblyStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineInputAssemblyStateCreateInfo where
        (VkPipelineInputAssemblyStateCreateInfo## a) `compare`
          (VkPipelineInputAssemblyStateCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineInputAssemblyStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineInputAssemblyStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineInputAssemblyStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineInputAssemblyStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineInputAssemblyStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineInputAssemblyStateCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPipelineInputAssemblyStateCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s',
                                        VkPipelineInputAssemblyStateCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPipelineInputAssemblyStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPipelineInputAssemblyStateCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPipelineInputAssemblyStateCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineInputAssemblyStateCreateInfo where
        type VkSTypeMType VkPipelineInputAssemblyStateCreateInfo =
             VkStructureType
        vkSType (VkPipelineInputAssemblyStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineInputAssemblyStateCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineInputAssemblyStateCreateInfo where
        type VkPNextMType VkPipelineInputAssemblyStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkPipelineInputAssemblyStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineInputAssemblyStateCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineInputAssemblyStateCreateInfo where
        type VkFlagsMType VkPipelineInputAssemblyStateCreateInfo =
             VkPipelineInputAssemblyStateCreateFlags
        vkFlags (VkPipelineInputAssemblyStateCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineInputAssemblyStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineInputAssemblyStateCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineInputAssemblyStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkTopology a where
        type VkTopologyMType a :: *

        vkTopology :: a -> VkTopologyMType a

        vkTopologyByteOffset :: a -> Int

        readVkTopology :: Mutable a -> IO (VkTopologyMType a)

        writeVkTopology :: Mutable a -> VkTopologyMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'topology'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTopology a

instance {-# OVERLAPPING #-}
         HasVkTopology VkPipelineInputAssemblyStateCreateInfo where
        type VkTopologyMType VkPipelineInputAssemblyStateCreateInfo =
             VkPrimitiveTopology
        vkTopology (VkPipelineInputAssemblyStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkPrimitiveTopology),
            I## o <- vkTopologyByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkTopology #-}
        vkTopologyByteOffset ~_
          = #{offset VkPipelineInputAssemblyStateCreateInfo, topology}

        {-# INLINE vkTopologyByteOffset #-}
        readVkTopology (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPrimitiveTopology),
            I## o <- vkTopologyByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkTopology #-}
        writeVkTopology (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkTopologyByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkTopology #-}

class HasVkPrimitiveRestartEnable a where
        type VkPrimitiveRestartEnableMType a :: *

        vkPrimitiveRestartEnable :: a -> VkPrimitiveRestartEnableMType a

        vkPrimitiveRestartEnableByteOffset :: a -> Int

        readVkPrimitiveRestartEnable ::
                                     Mutable a -> IO (VkPrimitiveRestartEnableMType a)

        writeVkPrimitiveRestartEnable ::
                                      Mutable a -> VkPrimitiveRestartEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'primitiveRestartEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPrimitiveRestartEnable a

instance {-# OVERLAPPING #-}
         HasVkPrimitiveRestartEnable VkPipelineInputAssemblyStateCreateInfo
         where
        type VkPrimitiveRestartEnableMType
               VkPipelineInputAssemblyStateCreateInfo
             = VkBool32
        vkPrimitiveRestartEnable
          (VkPipelineInputAssemblyStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkPrimitiveRestartEnableByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPrimitiveRestartEnable #-}
        vkPrimitiveRestartEnableByteOffset ~_
          = #{offset VkPipelineInputAssemblyStateCreateInfo, primitiveRestartEnable}

        {-# INLINE vkPrimitiveRestartEnableByteOffset #-}
        readVkPrimitiveRestartEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkPrimitiveRestartEnableByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPrimitiveRestartEnable #-}
        writeVkPrimitiveRestartEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPrimitiveRestartEnableByteOffset
                      (undefined :: VkPipelineInputAssemblyStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPrimitiveRestartEnable #-}

instance Show VkPipelineInputAssemblyStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineInputAssemblyStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkTopology = " .
                                  showsPrec d (vkTopology x) .
                                    showString ", " .
                                      showString "vkPrimitiveRestartEnable = " .
                                        showsPrec d (vkPrimitiveRestartEnable x) . showChar '}'

data VkPipelineTessellationStateCreateInfo = VkPipelineTessellationStateCreateInfo## ByteArray##

instance Eq VkPipelineTessellationStateCreateInfo where
        (VkPipelineTessellationStateCreateInfo## a) ==
          (VkPipelineTessellationStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineTessellationStateCreateInfo where
        (VkPipelineTessellationStateCreateInfo## a) `compare`
          (VkPipelineTessellationStateCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineTessellationStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineTessellationStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineTessellationStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineTessellationStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineTessellationStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineTessellationStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineTessellationStateCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineTessellationStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPipelineTessellationStateCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s',
                                        VkPipelineTessellationStateCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPipelineTessellationStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineTessellationStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPipelineTessellationStateCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPipelineTessellationStateCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineTessellationStateCreateInfo where
        type VkSTypeMType VkPipelineTessellationStateCreateInfo =
             VkStructureType
        vkSType (VkPipelineTessellationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineTessellationStateCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineTessellationStateCreateInfo where
        type VkPNextMType VkPipelineTessellationStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkPipelineTessellationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineTessellationStateCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineTessellationStateCreateInfo where
        type VkFlagsMType VkPipelineTessellationStateCreateInfo =
             VkPipelineTessellationStateCreateFlags
        vkFlags (VkPipelineTessellationStateCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineTessellationStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineTessellationStateCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineTessellationStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkPatchControlPoints a where
        type VkPatchControlPointsMType a :: *

        vkPatchControlPoints :: a -> VkPatchControlPointsMType a

        vkPatchControlPointsByteOffset :: a -> Int

        readVkPatchControlPoints ::
                                 Mutable a -> IO (VkPatchControlPointsMType a)

        writeVkPatchControlPoints ::
                                  Mutable a -> VkPatchControlPointsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'patchControlPoints'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPatchControlPoints a

instance {-# OVERLAPPING #-}
         HasVkPatchControlPoints VkPipelineTessellationStateCreateInfo where
        type VkPatchControlPointsMType
               VkPipelineTessellationStateCreateInfo
             = Data.Word.Word32
        vkPatchControlPoints (VkPipelineTessellationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkPatchControlPointsByteOffset
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPatchControlPoints #-}
        vkPatchControlPointsByteOffset ~_
          = #{offset VkPipelineTessellationStateCreateInfo, patchControlPoints}

        {-# INLINE vkPatchControlPointsByteOffset #-}
        readVkPatchControlPoints (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkPatchControlPointsByteOffset
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPatchControlPoints #-}
        writeVkPatchControlPoints (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPatchControlPointsByteOffset
                      (undefined :: VkPipelineTessellationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPatchControlPoints #-}

instance Show VkPipelineTessellationStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineTessellationStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkPatchControlPoints = " .
                                  showsPrec d (vkPatchControlPoints x) . showChar '}'

data VkPipelineViewportStateCreateInfo = VkPipelineViewportStateCreateInfo## ByteArray##

instance Eq VkPipelineViewportStateCreateInfo where
        (VkPipelineViewportStateCreateInfo## a) ==
          (VkPipelineViewportStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineViewportStateCreateInfo where
        (VkPipelineViewportStateCreateInfo## a) `compare`
          (VkPipelineViewportStateCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineViewportStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineViewportStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineViewportStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPipelineViewportStateCreateInfo),
            I## a <- alignment (undefined :: VkPipelineViewportStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineViewportStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineViewportStateCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineViewportStateCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineViewportStateCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkPipelineViewportStateCreateInfo),
            I## a <- alignment (undefined :: VkPipelineViewportStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPipelineViewportStateCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPipelineViewportStateCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPipelineViewportStateCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineViewportStateCreateInfo),
            I## a <- alignment (undefined :: VkPipelineViewportStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPipelineViewportStateCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPipelineViewportStateCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineViewportStateCreateInfo where
        type VkSTypeMType VkPipelineViewportStateCreateInfo =
             VkStructureType
        vkSType (VkPipelineViewportStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineViewportStateCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineViewportStateCreateInfo where
        type VkPNextMType VkPipelineViewportStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkPipelineViewportStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineViewportStateCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineViewportStateCreateInfo where
        type VkFlagsMType VkPipelineViewportStateCreateInfo =
             VkPipelineViewportStateCreateFlags
        vkFlags (VkPipelineViewportStateCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineViewportStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineViewportStateCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineViewportStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkViewportCount a where
        type VkViewportCountMType a :: *

        vkViewportCount :: a -> VkViewportCountMType a

        vkViewportCountByteOffset :: a -> Int

        readVkViewportCount :: Mutable a -> IO (VkViewportCountMType a)

        writeVkViewportCount ::
                             Mutable a -> VkViewportCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'viewportCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkViewportCount a

instance {-# OVERLAPPING #-}
         HasVkViewportCount VkPipelineViewportStateCreateInfo where
        type VkViewportCountMType VkPipelineViewportStateCreateInfo =
             Data.Word.Word32
        vkViewportCount (VkPipelineViewportStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkViewportCountByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkViewportCount #-}
        vkViewportCountByteOffset ~_
          = #{offset VkPipelineViewportStateCreateInfo, viewportCount}

        {-# INLINE vkViewportCountByteOffset #-}
        readVkViewportCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkViewportCountByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkViewportCount #-}
        writeVkViewportCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkViewportCountByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkViewportCount #-}

class HasVkPViewports a where
        type VkPViewportsMType a :: *

        vkPViewports :: a -> VkPViewportsMType a

        vkPViewportsByteOffset :: a -> Int

        readVkPViewports :: Mutable a -> IO (VkPViewportsMType a)

        writeVkPViewports :: Mutable a -> VkPViewportsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pViewports'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPViewports a

instance {-# OVERLAPPING #-}
         HasVkPViewports VkPipelineViewportStateCreateInfo where
        type VkPViewportsMType VkPipelineViewportStateCreateInfo =
             Foreign.Ptr.Ptr VkViewport
        vkPViewports (VkPipelineViewportStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkViewport),
            I## o <- vkPViewportsByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPViewports #-}
        vkPViewportsByteOffset ~_
          = #{offset VkPipelineViewportStateCreateInfo, pViewports}

        {-# INLINE vkPViewportsByteOffset #-}
        readVkPViewports (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkViewport),
            I## o <- vkPViewportsByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPViewports #-}
        writeVkPViewports (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPViewportsByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPViewports #-}

class HasVkScissorCount a where
        type VkScissorCountMType a :: *

        vkScissorCount :: a -> VkScissorCountMType a

        vkScissorCountByteOffset :: a -> Int

        readVkScissorCount :: Mutable a -> IO (VkScissorCountMType a)

        writeVkScissorCount :: Mutable a -> VkScissorCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'scissorCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkScissorCount a

instance {-# OVERLAPPING #-}
         HasVkScissorCount VkPipelineViewportStateCreateInfo where
        type VkScissorCountMType VkPipelineViewportStateCreateInfo =
             Data.Word.Word32
        vkScissorCount (VkPipelineViewportStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkScissorCountByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkScissorCount #-}
        vkScissorCountByteOffset ~_
          = #{offset VkPipelineViewportStateCreateInfo, scissorCount}

        {-# INLINE vkScissorCountByteOffset #-}
        readVkScissorCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkScissorCountByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkScissorCount #-}
        writeVkScissorCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkScissorCountByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkScissorCount #-}

class HasVkPScissors a where
        type VkPScissorsMType a :: *

        vkPScissors :: a -> VkPScissorsMType a

        vkPScissorsByteOffset :: a -> Int

        readVkPScissors :: Mutable a -> IO (VkPScissorsMType a)

        writeVkPScissors :: Mutable a -> VkPScissorsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pScissors'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPScissors a

instance {-# OVERLAPPING #-}
         HasVkPScissors VkPipelineViewportStateCreateInfo where
        type VkPScissorsMType VkPipelineViewportStateCreateInfo =
             Foreign.Ptr.Ptr VkRect2D
        vkPScissors (VkPipelineViewportStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkRect2D),
            I## o <- vkPScissorsByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPScissors #-}
        vkPScissorsByteOffset ~_
          = #{offset VkPipelineViewportStateCreateInfo, pScissors}

        {-# INLINE vkPScissorsByteOffset #-}
        readVkPScissors (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkRect2D),
            I## o <- vkPScissorsByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPScissors #-}
        writeVkPScissors (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPScissorsByteOffset
                      (undefined :: VkPipelineViewportStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPScissors #-}

instance Show VkPipelineViewportStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineViewportStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkViewportCount = " .
                                  showsPrec d (vkViewportCount x) .
                                    showString ", " .
                                      showString "vkPViewports = " .
                                        showsPrec d (vkPViewports x) .
                                          showString ", " .
                                            showString "vkScissorCount = " .
                                              showsPrec d (vkScissorCount x) .
                                                showString ", " .
                                                  showString "vkPScissors = " .
                                                    showsPrec d (vkPScissors x) . showChar '}'

data VkPipelineRasterizationStateCreateInfo = VkPipelineRasterizationStateCreateInfo## ByteArray##

instance Eq VkPipelineRasterizationStateCreateInfo where
        (VkPipelineRasterizationStateCreateInfo## a) ==
          (VkPipelineRasterizationStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineRasterizationStateCreateInfo where
        (VkPipelineRasterizationStateCreateInfo## a) `compare`
          (VkPipelineRasterizationStateCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineRasterizationStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineRasterizationStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineRasterizationStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineRasterizationStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineRasterizationStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineRasterizationStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineRasterizationStateCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineRasterizationStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPipelineRasterizationStateCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s',
                                        VkPipelineRasterizationStateCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPipelineRasterizationStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineRasterizationStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPipelineRasterizationStateCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPipelineRasterizationStateCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineRasterizationStateCreateInfo where
        type VkSTypeMType VkPipelineRasterizationStateCreateInfo =
             VkStructureType
        vkSType (VkPipelineRasterizationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineRasterizationStateCreateInfo where
        type VkPNextMType VkPipelineRasterizationStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkPipelineRasterizationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineRasterizationStateCreateInfo where
        type VkFlagsMType VkPipelineRasterizationStateCreateInfo =
             VkPipelineRasterizationStateCreateFlags
        vkFlags (VkPipelineRasterizationStateCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineRasterizationStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineRasterizationStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkDepthClampEnable a where
        type VkDepthClampEnableMType a :: *

        vkDepthClampEnable :: a -> VkDepthClampEnableMType a

        vkDepthClampEnableByteOffset :: a -> Int

        readVkDepthClampEnable ::
                               Mutable a -> IO (VkDepthClampEnableMType a)

        writeVkDepthClampEnable ::
                                Mutable a -> VkDepthClampEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthClampEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthClampEnable a

instance {-# OVERLAPPING #-}
         HasVkDepthClampEnable VkPipelineRasterizationStateCreateInfo where
        type VkDepthClampEnableMType VkPipelineRasterizationStateCreateInfo
             = VkBool32
        vkDepthClampEnable (VkPipelineRasterizationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthClampEnableByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthClampEnable #-}
        vkDepthClampEnableByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, depthClampEnable}

        {-# INLINE vkDepthClampEnableByteOffset #-}
        readVkDepthClampEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthClampEnableByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthClampEnable #-}
        writeVkDepthClampEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthClampEnableByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthClampEnable #-}

class HasVkRasterizerDiscardEnable a where
        type VkRasterizerDiscardEnableMType a :: *

        vkRasterizerDiscardEnable :: a -> VkRasterizerDiscardEnableMType a

        vkRasterizerDiscardEnableByteOffset :: a -> Int

        readVkRasterizerDiscardEnable ::
                                      Mutable a -> IO (VkRasterizerDiscardEnableMType a)

        writeVkRasterizerDiscardEnable ::
                                       Mutable a -> VkRasterizerDiscardEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'rasterizerDiscardEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRasterizerDiscardEnable a

instance {-# OVERLAPPING #-}
         HasVkRasterizerDiscardEnable VkPipelineRasterizationStateCreateInfo
         where
        type VkRasterizerDiscardEnableMType
               VkPipelineRasterizationStateCreateInfo
             = VkBool32
        vkRasterizerDiscardEnable
          (VkPipelineRasterizationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkRasterizerDiscardEnableByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkRasterizerDiscardEnable #-}
        vkRasterizerDiscardEnableByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, rasterizerDiscardEnable}

        {-# INLINE vkRasterizerDiscardEnableByteOffset #-}
        readVkRasterizerDiscardEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkRasterizerDiscardEnableByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkRasterizerDiscardEnable #-}
        writeVkRasterizerDiscardEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkRasterizerDiscardEnableByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkRasterizerDiscardEnable #-}

class HasVkPolygonMode a where
        type VkPolygonModeMType a :: *

        vkPolygonMode :: a -> VkPolygonModeMType a

        vkPolygonModeByteOffset :: a -> Int

        readVkPolygonMode :: Mutable a -> IO (VkPolygonModeMType a)

        writeVkPolygonMode :: Mutable a -> VkPolygonModeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'polygonMode'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPolygonMode a

instance {-# OVERLAPPING #-}
         HasVkPolygonMode VkPipelineRasterizationStateCreateInfo where
        type VkPolygonModeMType VkPipelineRasterizationStateCreateInfo =
             VkPolygonMode
        vkPolygonMode (VkPipelineRasterizationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkPolygonMode),
            I## o <- vkPolygonModeByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPolygonMode #-}
        vkPolygonModeByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, polygonMode}

        {-# INLINE vkPolygonModeByteOffset #-}
        readVkPolygonMode (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPolygonMode),
            I## o <- vkPolygonModeByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPolygonMode #-}
        writeVkPolygonMode (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPolygonModeByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPolygonMode #-}

class HasVkCullMode a where
        type VkCullModeMType a :: *

        vkCullMode :: a -> VkCullModeMType a

        vkCullModeByteOffset :: a -> Int

        readVkCullMode :: Mutable a -> IO (VkCullModeMType a)

        writeVkCullMode :: Mutable a -> VkCullModeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'cullMode'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCullMode a

instance {-# OVERLAPPING #-}
         HasVkCullMode VkPipelineRasterizationStateCreateInfo where
        type VkCullModeMType VkPipelineRasterizationStateCreateInfo =
             VkCullModeFlags
        vkCullMode (VkPipelineRasterizationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkCullModeFlags),
            I## o <- vkCullModeByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkCullMode #-}
        vkCullModeByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, cullMode}

        {-# INLINE vkCullModeByteOffset #-}
        readVkCullMode (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkCullModeFlags),
            I## o <- vkCullModeByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkCullMode #-}
        writeVkCullMode (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkCullModeByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkCullMode #-}

class HasVkFrontFace a where
        type VkFrontFaceMType a :: *

        vkFrontFace :: a -> VkFrontFaceMType a

        vkFrontFaceByteOffset :: a -> Int

        readVkFrontFace :: Mutable a -> IO (VkFrontFaceMType a)

        writeVkFrontFace :: Mutable a -> VkFrontFaceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'frontFace'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFrontFace a

instance {-# OVERLAPPING #-}
         HasVkFrontFace VkPipelineRasterizationStateCreateInfo where
        type VkFrontFaceMType VkPipelineRasterizationStateCreateInfo =
             VkFrontFace
        vkFrontFace (VkPipelineRasterizationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkFrontFace),
            I## o <- vkFrontFaceByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFrontFace #-}
        vkFrontFaceByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, frontFace}

        {-# INLINE vkFrontFaceByteOffset #-}
        readVkFrontFace (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFrontFace),
            I## o <- vkFrontFaceByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFrontFace #-}
        writeVkFrontFace (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFrontFaceByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFrontFace #-}

class HasVkDepthBiasEnable a where
        type VkDepthBiasEnableMType a :: *

        vkDepthBiasEnable :: a -> VkDepthBiasEnableMType a

        vkDepthBiasEnableByteOffset :: a -> Int

        readVkDepthBiasEnable :: Mutable a -> IO (VkDepthBiasEnableMType a)

        writeVkDepthBiasEnable ::
                               Mutable a -> VkDepthBiasEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthBiasEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthBiasEnable a

instance {-# OVERLAPPING #-}
         HasVkDepthBiasEnable VkPipelineRasterizationStateCreateInfo where
        type VkDepthBiasEnableMType VkPipelineRasterizationStateCreateInfo
             = VkBool32
        vkDepthBiasEnable (VkPipelineRasterizationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthBiasEnableByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthBiasEnable #-}
        vkDepthBiasEnableByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, depthBiasEnable}

        {-# INLINE vkDepthBiasEnableByteOffset #-}
        readVkDepthBiasEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthBiasEnableByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthBiasEnable #-}
        writeVkDepthBiasEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthBiasEnableByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthBiasEnable #-}

class HasVkDepthBiasConstantFactor a where
        type VkDepthBiasConstantFactorMType a :: *

        vkDepthBiasConstantFactor :: a -> VkDepthBiasConstantFactorMType a

        vkDepthBiasConstantFactorByteOffset :: a -> Int

        readVkDepthBiasConstantFactor ::
                                      Mutable a -> IO (VkDepthBiasConstantFactorMType a)

        writeVkDepthBiasConstantFactor ::
                                       Mutable a -> VkDepthBiasConstantFactorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthBiasConstantFactor'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthBiasConstantFactor a

instance {-# OVERLAPPING #-}
         HasVkDepthBiasConstantFactor VkPipelineRasterizationStateCreateInfo
         where
        type VkDepthBiasConstantFactorMType
               VkPipelineRasterizationStateCreateInfo
             = Foreign.C.Types.CFloat
        vkDepthBiasConstantFactor
          (VkPipelineRasterizationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkDepthBiasConstantFactorByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthBiasConstantFactor #-}
        vkDepthBiasConstantFactorByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, depthBiasConstantFactor}

        {-# INLINE vkDepthBiasConstantFactorByteOffset #-}
        readVkDepthBiasConstantFactor (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkDepthBiasConstantFactorByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthBiasConstantFactor #-}
        writeVkDepthBiasConstantFactor (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthBiasConstantFactorByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthBiasConstantFactor #-}

class HasVkDepthBiasClamp a where
        type VkDepthBiasClampMType a :: *

        vkDepthBiasClamp :: a -> VkDepthBiasClampMType a

        vkDepthBiasClampByteOffset :: a -> Int

        readVkDepthBiasClamp :: Mutable a -> IO (VkDepthBiasClampMType a)

        writeVkDepthBiasClamp ::
                              Mutable a -> VkDepthBiasClampMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthBiasClamp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthBiasClamp a

instance {-# OVERLAPPING #-}
         HasVkDepthBiasClamp VkPipelineRasterizationStateCreateInfo where
        type VkDepthBiasClampMType VkPipelineRasterizationStateCreateInfo =
             Foreign.C.Types.CFloat
        vkDepthBiasClamp (VkPipelineRasterizationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkDepthBiasClampByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthBiasClamp #-}
        vkDepthBiasClampByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, depthBiasClamp}

        {-# INLINE vkDepthBiasClampByteOffset #-}
        readVkDepthBiasClamp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkDepthBiasClampByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthBiasClamp #-}
        writeVkDepthBiasClamp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthBiasClampByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthBiasClamp #-}

class HasVkDepthBiasSlopeFactor a where
        type VkDepthBiasSlopeFactorMType a :: *

        vkDepthBiasSlopeFactor :: a -> VkDepthBiasSlopeFactorMType a

        vkDepthBiasSlopeFactorByteOffset :: a -> Int

        readVkDepthBiasSlopeFactor ::
                                   Mutable a -> IO (VkDepthBiasSlopeFactorMType a)

        writeVkDepthBiasSlopeFactor ::
                                    Mutable a -> VkDepthBiasSlopeFactorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthBiasSlopeFactor'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthBiasSlopeFactor a

instance {-# OVERLAPPING #-}
         HasVkDepthBiasSlopeFactor VkPipelineRasterizationStateCreateInfo
         where
        type VkDepthBiasSlopeFactorMType
               VkPipelineRasterizationStateCreateInfo
             = Foreign.C.Types.CFloat
        vkDepthBiasSlopeFactor (VkPipelineRasterizationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkDepthBiasSlopeFactorByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthBiasSlopeFactor #-}
        vkDepthBiasSlopeFactorByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, depthBiasSlopeFactor}

        {-# INLINE vkDepthBiasSlopeFactorByteOffset #-}
        readVkDepthBiasSlopeFactor (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkDepthBiasSlopeFactorByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthBiasSlopeFactor #-}
        writeVkDepthBiasSlopeFactor (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthBiasSlopeFactorByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthBiasSlopeFactor #-}

class HasVkLineWidth a where
        type VkLineWidthMType a :: *

        vkLineWidth :: a -> VkLineWidthMType a

        vkLineWidthByteOffset :: a -> Int

        readVkLineWidth :: Mutable a -> IO (VkLineWidthMType a)

        writeVkLineWidth :: Mutable a -> VkLineWidthMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'lineWidth'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLineWidth a

instance {-# OVERLAPPING #-}
         HasVkLineWidth VkPipelineRasterizationStateCreateInfo where
        type VkLineWidthMType VkPipelineRasterizationStateCreateInfo =
             Foreign.C.Types.CFloat
        vkLineWidth (VkPipelineRasterizationStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkLineWidthByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLineWidth #-}
        vkLineWidthByteOffset ~_
          = #{offset VkPipelineRasterizationStateCreateInfo, lineWidth}

        {-# INLINE vkLineWidthByteOffset #-}
        readVkLineWidth (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkLineWidthByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLineWidth #-}
        writeVkLineWidth (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLineWidthByteOffset
                      (undefined :: VkPipelineRasterizationStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLineWidth #-}

instance Show VkPipelineRasterizationStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineRasterizationStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkDepthClampEnable = " .
                                  showsPrec d (vkDepthClampEnable x) .
                                    showString ", " .
                                      showString "vkRasterizerDiscardEnable = " .
                                        showsPrec d (vkRasterizerDiscardEnable x) .
                                          showString ", " .
                                            showString "vkPolygonMode = " .
                                              showsPrec d (vkPolygonMode x) .
                                                showString ", " .
                                                  showString "vkCullMode = " .
                                                    showsPrec d (vkCullMode x) .
                                                      showString ", " .
                                                        showString "vkFrontFace = " .
                                                          showsPrec d (vkFrontFace x) .
                                                            showString ", " .
                                                              showString "vkDepthBiasEnable = " .
                                                                showsPrec d (vkDepthBiasEnable x) .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkDepthBiasConstantFactor = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkDepthBiasConstantFactor
                                                                           x)
                                                                        .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkDepthBiasClamp = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkDepthBiasClamp x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkDepthBiasSlopeFactor = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkDepthBiasSlopeFactor
                                                                                       x)
                                                                                    .
                                                                                    showString ", "
                                                                                      .
                                                                                      showString
                                                                                        "vkLineWidth = "
                                                                                        .
                                                                                        showsPrec d
                                                                                          (vkLineWidth
                                                                                             x)
                                                                                          .
                                                                                          showChar
                                                                                            '}'

data VkPipelineMultisampleStateCreateInfo = VkPipelineMultisampleStateCreateInfo## ByteArray##

instance Eq VkPipelineMultisampleStateCreateInfo where
        (VkPipelineMultisampleStateCreateInfo## a) ==
          (VkPipelineMultisampleStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineMultisampleStateCreateInfo where
        (VkPipelineMultisampleStateCreateInfo## a) `compare`
          (VkPipelineMultisampleStateCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineMultisampleStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineMultisampleStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineMultisampleStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineMultisampleStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineMultisampleStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineMultisampleStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineMultisampleStateCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineMultisampleStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPipelineMultisampleStateCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPipelineMultisampleStateCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPipelineMultisampleStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineMultisampleStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPipelineMultisampleStateCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPipelineMultisampleStateCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineMultisampleStateCreateInfo where
        type VkSTypeMType VkPipelineMultisampleStateCreateInfo =
             VkStructureType
        vkSType (VkPipelineMultisampleStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineMultisampleStateCreateInfo where
        type VkPNextMType VkPipelineMultisampleStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkPipelineMultisampleStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineMultisampleStateCreateInfo where
        type VkFlagsMType VkPipelineMultisampleStateCreateInfo =
             VkPipelineMultisampleStateCreateFlags
        vkFlags (VkPipelineMultisampleStateCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineMultisampleStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineMultisampleStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkRasterizationSamples a where
        type VkRasterizationSamplesMType a :: *

        vkRasterizationSamples :: a -> VkRasterizationSamplesMType a

        vkRasterizationSamplesByteOffset :: a -> Int

        readVkRasterizationSamples ::
                                   Mutable a -> IO (VkRasterizationSamplesMType a)

        writeVkRasterizationSamples ::
                                    Mutable a -> VkRasterizationSamplesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'rasterizationSamples'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRasterizationSamples a

instance {-# OVERLAPPING #-}
         HasVkRasterizationSamples VkPipelineMultisampleStateCreateInfo
         where
        type VkRasterizationSamplesMType
               VkPipelineMultisampleStateCreateInfo
             = VkSampleCountFlagBits
        vkRasterizationSamples (VkPipelineMultisampleStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlagBits),
            I## o <- vkRasterizationSamplesByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkRasterizationSamples #-}
        vkRasterizationSamplesByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, rasterizationSamples}

        {-# INLINE vkRasterizationSamplesByteOffset #-}
        readVkRasterizationSamples (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlagBits),
            I## o <- vkRasterizationSamplesByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkRasterizationSamples #-}
        writeVkRasterizationSamples (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkRasterizationSamplesByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkRasterizationSamples #-}

class HasVkSampleShadingEnable a where
        type VkSampleShadingEnableMType a :: *

        vkSampleShadingEnable :: a -> VkSampleShadingEnableMType a

        vkSampleShadingEnableByteOffset :: a -> Int

        readVkSampleShadingEnable ::
                                  Mutable a -> IO (VkSampleShadingEnableMType a)

        writeVkSampleShadingEnable ::
                                   Mutable a -> VkSampleShadingEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sampleShadingEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampleShadingEnable a

instance {-# OVERLAPPING #-}
         HasVkSampleShadingEnable VkPipelineMultisampleStateCreateInfo where
        type VkSampleShadingEnableMType
               VkPipelineMultisampleStateCreateInfo
             = VkBool32
        vkSampleShadingEnable (VkPipelineMultisampleStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSampleShadingEnableByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSampleShadingEnable #-}
        vkSampleShadingEnableByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, sampleShadingEnable}

        {-# INLINE vkSampleShadingEnableByteOffset #-}
        readVkSampleShadingEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSampleShadingEnableByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSampleShadingEnable #-}
        writeVkSampleShadingEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSampleShadingEnableByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSampleShadingEnable #-}

class HasVkMinSampleShading a where
        type VkMinSampleShadingMType a :: *

        vkMinSampleShading :: a -> VkMinSampleShadingMType a

        vkMinSampleShadingByteOffset :: a -> Int

        readVkMinSampleShading ::
                               Mutable a -> IO (VkMinSampleShadingMType a)

        writeVkMinSampleShading ::
                                Mutable a -> VkMinSampleShadingMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minSampleShading'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinSampleShading a

instance {-# OVERLAPPING #-}
         HasVkMinSampleShading VkPipelineMultisampleStateCreateInfo where
        type VkMinSampleShadingMType VkPipelineMultisampleStateCreateInfo =
             Foreign.C.Types.CFloat
        vkMinSampleShading (VkPipelineMultisampleStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMinSampleShadingByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinSampleShading #-}
        vkMinSampleShadingByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, minSampleShading}

        {-# INLINE vkMinSampleShadingByteOffset #-}
        readVkMinSampleShading (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMinSampleShadingByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinSampleShading #-}
        writeVkMinSampleShading (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinSampleShadingByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinSampleShading #-}

class HasVkPSampleMask a where
        type VkPSampleMaskMType a :: *

        vkPSampleMask :: a -> VkPSampleMaskMType a

        vkPSampleMaskByteOffset :: a -> Int

        readVkPSampleMask :: Mutable a -> IO (VkPSampleMaskMType a)

        writeVkPSampleMask :: Mutable a -> VkPSampleMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pSampleMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPSampleMask a

instance {-# OVERLAPPING #-}
         HasVkPSampleMask VkPipelineMultisampleStateCreateInfo where
        type VkPSampleMaskMType VkPipelineMultisampleStateCreateInfo =
             Foreign.Ptr.Ptr VkSampleMask
        vkPSampleMask (VkPipelineMultisampleStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSampleMask),
            I## o <- vkPSampleMaskByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPSampleMask #-}
        vkPSampleMaskByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, pSampleMask}

        {-# INLINE vkPSampleMaskByteOffset #-}
        readVkPSampleMask (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSampleMask),
            I## o <- vkPSampleMaskByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPSampleMask #-}
        writeVkPSampleMask (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPSampleMaskByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPSampleMask #-}

class HasVkAlphaToCoverageEnable a where
        type VkAlphaToCoverageEnableMType a :: *

        vkAlphaToCoverageEnable :: a -> VkAlphaToCoverageEnableMType a

        vkAlphaToCoverageEnableByteOffset :: a -> Int

        readVkAlphaToCoverageEnable ::
                                    Mutable a -> IO (VkAlphaToCoverageEnableMType a)

        writeVkAlphaToCoverageEnable ::
                                     Mutable a -> VkAlphaToCoverageEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'alphaToCoverageEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAlphaToCoverageEnable a

instance {-# OVERLAPPING #-}
         HasVkAlphaToCoverageEnable VkPipelineMultisampleStateCreateInfo
         where
        type VkAlphaToCoverageEnableMType
               VkPipelineMultisampleStateCreateInfo
             = VkBool32
        vkAlphaToCoverageEnable (VkPipelineMultisampleStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkAlphaToCoverageEnableByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAlphaToCoverageEnable #-}
        vkAlphaToCoverageEnableByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, alphaToCoverageEnable}

        {-# INLINE vkAlphaToCoverageEnableByteOffset #-}
        readVkAlphaToCoverageEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkAlphaToCoverageEnableByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAlphaToCoverageEnable #-}
        writeVkAlphaToCoverageEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAlphaToCoverageEnableByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAlphaToCoverageEnable #-}

class HasVkAlphaToOneEnable a where
        type VkAlphaToOneEnableMType a :: *

        vkAlphaToOneEnable :: a -> VkAlphaToOneEnableMType a

        vkAlphaToOneEnableByteOffset :: a -> Int

        readVkAlphaToOneEnable ::
                               Mutable a -> IO (VkAlphaToOneEnableMType a)

        writeVkAlphaToOneEnable ::
                                Mutable a -> VkAlphaToOneEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'alphaToOneEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAlphaToOneEnable a

instance {-# OVERLAPPING #-}
         HasVkAlphaToOneEnable VkPipelineMultisampleStateCreateInfo where
        type VkAlphaToOneEnableMType VkPipelineMultisampleStateCreateInfo =
             VkBool32
        vkAlphaToOneEnable (VkPipelineMultisampleStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkAlphaToOneEnableByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAlphaToOneEnable #-}
        vkAlphaToOneEnableByteOffset ~_
          = #{offset VkPipelineMultisampleStateCreateInfo, alphaToOneEnable}

        {-# INLINE vkAlphaToOneEnableByteOffset #-}
        readVkAlphaToOneEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkAlphaToOneEnableByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAlphaToOneEnable #-}
        writeVkAlphaToOneEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAlphaToOneEnableByteOffset
                      (undefined :: VkPipelineMultisampleStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAlphaToOneEnable #-}

instance Show VkPipelineMultisampleStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineMultisampleStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkRasterizationSamples = " .
                                  showsPrec d (vkRasterizationSamples x) .
                                    showString ", " .
                                      showString "vkSampleShadingEnable = " .
                                        showsPrec d (vkSampleShadingEnable x) .
                                          showString ", " .
                                            showString "vkMinSampleShading = " .
                                              showsPrec d (vkMinSampleShading x) .
                                                showString ", " .
                                                  showString "vkPSampleMask = " .
                                                    showsPrec d (vkPSampleMask x) .
                                                      showString ", " .
                                                        showString "vkAlphaToCoverageEnable = " .
                                                          showsPrec d (vkAlphaToCoverageEnable x) .
                                                            showString ", " .
                                                              showString "vkAlphaToOneEnable = " .
                                                                showsPrec d (vkAlphaToOneEnable x) .
                                                                  showChar '}'

data VkPipelineColorBlendAttachmentState = VkPipelineColorBlendAttachmentState## ByteArray##

instance Eq VkPipelineColorBlendAttachmentState where
        (VkPipelineColorBlendAttachmentState## a) ==
          (VkPipelineColorBlendAttachmentState## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineColorBlendAttachmentState where
        (VkPipelineColorBlendAttachmentState## a) `compare`
          (VkPipelineColorBlendAttachmentState## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineColorBlendAttachmentState where
        sizeOf ~_ = #{size VkPipelineColorBlendAttachmentState}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineColorBlendAttachmentState}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineColorBlendAttachmentState),
            I## a <- alignment
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineColorBlendAttachmentState##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineColorBlendAttachmentState## ba)
          | I## n <- sizeOf (undefined :: VkPipelineColorBlendAttachmentState)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineColorBlendAttachmentState where
        freeze (Mutable## mba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineColorBlendAttachmentState),
            I## a <- alignment
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPipelineColorBlendAttachmentState##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPipelineColorBlendAttachmentState## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPipelineColorBlendAttachmentState## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineColorBlendAttachmentState),
            I## a <- alignment
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPipelineColorBlendAttachmentState## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPipelineColorBlendAttachmentState## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkBlendEnable a where
        type VkBlendEnableMType a :: *

        vkBlendEnable :: a -> VkBlendEnableMType a

        vkBlendEnableByteOffset :: a -> Int

        readVkBlendEnable :: Mutable a -> IO (VkBlendEnableMType a)

        writeVkBlendEnable :: Mutable a -> VkBlendEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'blendEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBlendEnable a

instance {-# OVERLAPPING #-}
         HasVkBlendEnable VkPipelineColorBlendAttachmentState where
        type VkBlendEnableMType VkPipelineColorBlendAttachmentState =
             VkBool32
        vkBlendEnable (VkPipelineColorBlendAttachmentState## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkBlendEnableByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBlendEnable #-}
        vkBlendEnableByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, blendEnable}

        {-# INLINE vkBlendEnableByteOffset #-}
        readVkBlendEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkBlendEnableByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBlendEnable #-}
        writeVkBlendEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBlendEnableByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBlendEnable #-}

class HasVkSrcColorBlendFactor a where
        type VkSrcColorBlendFactorMType a :: *

        vkSrcColorBlendFactor :: a -> VkSrcColorBlendFactorMType a

        vkSrcColorBlendFactorByteOffset :: a -> Int

        readVkSrcColorBlendFactor ::
                                  Mutable a -> IO (VkSrcColorBlendFactorMType a)

        writeVkSrcColorBlendFactor ::
                                   Mutable a -> VkSrcColorBlendFactorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcColorBlendFactor'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcColorBlendFactor a

instance {-# OVERLAPPING #-}
         HasVkSrcColorBlendFactor VkPipelineColorBlendAttachmentState where
        type VkSrcColorBlendFactorMType VkPipelineColorBlendAttachmentState
             = VkBlendFactor
        vkSrcColorBlendFactor (VkPipelineColorBlendAttachmentState## ba)
          | I## _n <- sizeOf (undefined :: VkBlendFactor),
            I## o <- vkSrcColorBlendFactorByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSrcColorBlendFactor #-}
        vkSrcColorBlendFactorByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, srcColorBlendFactor}

        {-# INLINE vkSrcColorBlendFactorByteOffset #-}
        readVkSrcColorBlendFactor (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBlendFactor),
            I## o <- vkSrcColorBlendFactorByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSrcColorBlendFactor #-}
        writeVkSrcColorBlendFactor (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcColorBlendFactorByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSrcColorBlendFactor #-}

class HasVkDstColorBlendFactor a where
        type VkDstColorBlendFactorMType a :: *

        vkDstColorBlendFactor :: a -> VkDstColorBlendFactorMType a

        vkDstColorBlendFactorByteOffset :: a -> Int

        readVkDstColorBlendFactor ::
                                  Mutable a -> IO (VkDstColorBlendFactorMType a)

        writeVkDstColorBlendFactor ::
                                   Mutable a -> VkDstColorBlendFactorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstColorBlendFactor'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstColorBlendFactor a

instance {-# OVERLAPPING #-}
         HasVkDstColorBlendFactor VkPipelineColorBlendAttachmentState where
        type VkDstColorBlendFactorMType VkPipelineColorBlendAttachmentState
             = VkBlendFactor
        vkDstColorBlendFactor (VkPipelineColorBlendAttachmentState## ba)
          | I## _n <- sizeOf (undefined :: VkBlendFactor),
            I## o <- vkDstColorBlendFactorByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstColorBlendFactor #-}
        vkDstColorBlendFactorByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, dstColorBlendFactor}

        {-# INLINE vkDstColorBlendFactorByteOffset #-}
        readVkDstColorBlendFactor (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBlendFactor),
            I## o <- vkDstColorBlendFactorByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstColorBlendFactor #-}
        writeVkDstColorBlendFactor (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstColorBlendFactorByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstColorBlendFactor #-}

class HasVkColorBlendOp a where
        type VkColorBlendOpMType a :: *

        vkColorBlendOp :: a -> VkColorBlendOpMType a

        vkColorBlendOpByteOffset :: a -> Int

        readVkColorBlendOp :: Mutable a -> IO (VkColorBlendOpMType a)

        writeVkColorBlendOp :: Mutable a -> VkColorBlendOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'colorBlendOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkColorBlendOp a

instance {-# OVERLAPPING #-}
         HasVkColorBlendOp VkPipelineColorBlendAttachmentState where
        type VkColorBlendOpMType VkPipelineColorBlendAttachmentState =
             VkBlendOp
        vkColorBlendOp (VkPipelineColorBlendAttachmentState## ba)
          | I## _n <- sizeOf (undefined :: VkBlendOp),
            I## o <- vkColorBlendOpByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkColorBlendOp #-}
        vkColorBlendOpByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, colorBlendOp}

        {-# INLINE vkColorBlendOpByteOffset #-}
        readVkColorBlendOp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBlendOp),
            I## o <- vkColorBlendOpByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkColorBlendOp #-}
        writeVkColorBlendOp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkColorBlendOpByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkColorBlendOp #-}

class HasVkSrcAlphaBlendFactor a where
        type VkSrcAlphaBlendFactorMType a :: *

        vkSrcAlphaBlendFactor :: a -> VkSrcAlphaBlendFactorMType a

        vkSrcAlphaBlendFactorByteOffset :: a -> Int

        readVkSrcAlphaBlendFactor ::
                                  Mutable a -> IO (VkSrcAlphaBlendFactorMType a)

        writeVkSrcAlphaBlendFactor ::
                                   Mutable a -> VkSrcAlphaBlendFactorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcAlphaBlendFactor'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcAlphaBlendFactor a

instance {-# OVERLAPPING #-}
         HasVkSrcAlphaBlendFactor VkPipelineColorBlendAttachmentState where
        type VkSrcAlphaBlendFactorMType VkPipelineColorBlendAttachmentState
             = VkBlendFactor
        vkSrcAlphaBlendFactor (VkPipelineColorBlendAttachmentState## ba)
          | I## _n <- sizeOf (undefined :: VkBlendFactor),
            I## o <- vkSrcAlphaBlendFactorByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSrcAlphaBlendFactor #-}
        vkSrcAlphaBlendFactorByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, srcAlphaBlendFactor}

        {-# INLINE vkSrcAlphaBlendFactorByteOffset #-}
        readVkSrcAlphaBlendFactor (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBlendFactor),
            I## o <- vkSrcAlphaBlendFactorByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSrcAlphaBlendFactor #-}
        writeVkSrcAlphaBlendFactor (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcAlphaBlendFactorByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSrcAlphaBlendFactor #-}

class HasVkDstAlphaBlendFactor a where
        type VkDstAlphaBlendFactorMType a :: *

        vkDstAlphaBlendFactor :: a -> VkDstAlphaBlendFactorMType a

        vkDstAlphaBlendFactorByteOffset :: a -> Int

        readVkDstAlphaBlendFactor ::
                                  Mutable a -> IO (VkDstAlphaBlendFactorMType a)

        writeVkDstAlphaBlendFactor ::
                                   Mutable a -> VkDstAlphaBlendFactorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstAlphaBlendFactor'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstAlphaBlendFactor a

instance {-# OVERLAPPING #-}
         HasVkDstAlphaBlendFactor VkPipelineColorBlendAttachmentState where
        type VkDstAlphaBlendFactorMType VkPipelineColorBlendAttachmentState
             = VkBlendFactor
        vkDstAlphaBlendFactor (VkPipelineColorBlendAttachmentState## ba)
          | I## _n <- sizeOf (undefined :: VkBlendFactor),
            I## o <- vkDstAlphaBlendFactorByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstAlphaBlendFactor #-}
        vkDstAlphaBlendFactorByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, dstAlphaBlendFactor}

        {-# INLINE vkDstAlphaBlendFactorByteOffset #-}
        readVkDstAlphaBlendFactor (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBlendFactor),
            I## o <- vkDstAlphaBlendFactorByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstAlphaBlendFactor #-}
        writeVkDstAlphaBlendFactor (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstAlphaBlendFactorByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstAlphaBlendFactor #-}

class HasVkAlphaBlendOp a where
        type VkAlphaBlendOpMType a :: *

        vkAlphaBlendOp :: a -> VkAlphaBlendOpMType a

        vkAlphaBlendOpByteOffset :: a -> Int

        readVkAlphaBlendOp :: Mutable a -> IO (VkAlphaBlendOpMType a)

        writeVkAlphaBlendOp :: Mutable a -> VkAlphaBlendOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'alphaBlendOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAlphaBlendOp a

instance {-# OVERLAPPING #-}
         HasVkAlphaBlendOp VkPipelineColorBlendAttachmentState where
        type VkAlphaBlendOpMType VkPipelineColorBlendAttachmentState =
             VkBlendOp
        vkAlphaBlendOp (VkPipelineColorBlendAttachmentState## ba)
          | I## _n <- sizeOf (undefined :: VkBlendOp),
            I## o <- vkAlphaBlendOpByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAlphaBlendOp #-}
        vkAlphaBlendOpByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, alphaBlendOp}

        {-# INLINE vkAlphaBlendOpByteOffset #-}
        readVkAlphaBlendOp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBlendOp),
            I## o <- vkAlphaBlendOpByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAlphaBlendOp #-}
        writeVkAlphaBlendOp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAlphaBlendOpByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAlphaBlendOp #-}

class HasVkColorWriteMask a where
        type VkColorWriteMaskMType a :: *

        vkColorWriteMask :: a -> VkColorWriteMaskMType a

        vkColorWriteMaskByteOffset :: a -> Int

        readVkColorWriteMask :: Mutable a -> IO (VkColorWriteMaskMType a)

        writeVkColorWriteMask ::
                              Mutable a -> VkColorWriteMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'colorWriteMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkColorWriteMask a

instance {-# OVERLAPPING #-}
         HasVkColorWriteMask VkPipelineColorBlendAttachmentState where
        type VkColorWriteMaskMType VkPipelineColorBlendAttachmentState =
             VkColorComponentFlags
        vkColorWriteMask (VkPipelineColorBlendAttachmentState## ba)
          | I## _n <- sizeOf (undefined :: VkColorComponentFlags),
            I## o <- vkColorWriteMaskByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkColorWriteMask #-}
        vkColorWriteMaskByteOffset ~_
          = #{offset VkPipelineColorBlendAttachmentState, colorWriteMask}

        {-# INLINE vkColorWriteMaskByteOffset #-}
        readVkColorWriteMask (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkColorComponentFlags),
            I## o <- vkColorWriteMaskByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkColorWriteMask #-}
        writeVkColorWriteMask (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkColorWriteMaskByteOffset
                      (undefined :: VkPipelineColorBlendAttachmentState)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkColorWriteMask #-}

instance Show VkPipelineColorBlendAttachmentState where
        showsPrec d x
          = showString "VkPipelineColorBlendAttachmentState {" .
              showString "vkBlendEnable = " .
                showsPrec d (vkBlendEnable x) .
                  showString ", " .
                    showString "vkSrcColorBlendFactor = " .
                      showsPrec d (vkSrcColorBlendFactor x) .
                        showString ", " .
                          showString "vkDstColorBlendFactor = " .
                            showsPrec d (vkDstColorBlendFactor x) .
                              showString ", " .
                                showString "vkColorBlendOp = " .
                                  showsPrec d (vkColorBlendOp x) .
                                    showString ", " .
                                      showString "vkSrcAlphaBlendFactor = " .
                                        showsPrec d (vkSrcAlphaBlendFactor x) .
                                          showString ", " .
                                            showString "vkDstAlphaBlendFactor = " .
                                              showsPrec d (vkDstAlphaBlendFactor x) .
                                                showString ", " .
                                                  showString "vkAlphaBlendOp = " .
                                                    showsPrec d (vkAlphaBlendOp x) .
                                                      showString ", " .
                                                        showString "vkColorWriteMask = " .
                                                          showsPrec d (vkColorWriteMask x) .
                                                            showChar '}'

data VkPipelineColorBlendStateCreateInfo = VkPipelineColorBlendStateCreateInfo## ByteArray##

instance Eq VkPipelineColorBlendStateCreateInfo where
        (VkPipelineColorBlendStateCreateInfo## a) ==
          (VkPipelineColorBlendStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineColorBlendStateCreateInfo where
        (VkPipelineColorBlendStateCreateInfo## a) `compare`
          (VkPipelineColorBlendStateCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineColorBlendStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineColorBlendStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineColorBlendStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineColorBlendStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineColorBlendStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineColorBlendStateCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineColorBlendStateCreateInfo)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineColorBlendStateCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineColorBlendStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPipelineColorBlendStateCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPipelineColorBlendStateCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPipelineColorBlendStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineColorBlendStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPipelineColorBlendStateCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPipelineColorBlendStateCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineColorBlendStateCreateInfo where
        type VkSTypeMType VkPipelineColorBlendStateCreateInfo =
             VkStructureType
        vkSType (VkPipelineColorBlendStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineColorBlendStateCreateInfo where
        type VkPNextMType VkPipelineColorBlendStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkPipelineColorBlendStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineColorBlendStateCreateInfo where
        type VkFlagsMType VkPipelineColorBlendStateCreateInfo =
             VkPipelineColorBlendStateCreateFlags
        vkFlags (VkPipelineColorBlendStateCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineColorBlendStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineColorBlendStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkLogicOpEnable a where
        type VkLogicOpEnableMType a :: *

        vkLogicOpEnable :: a -> VkLogicOpEnableMType a

        vkLogicOpEnableByteOffset :: a -> Int

        readVkLogicOpEnable :: Mutable a -> IO (VkLogicOpEnableMType a)

        writeVkLogicOpEnable ::
                             Mutable a -> VkLogicOpEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'logicOpEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLogicOpEnable a

instance {-# OVERLAPPING #-}
         HasVkLogicOpEnable VkPipelineColorBlendStateCreateInfo where
        type VkLogicOpEnableMType VkPipelineColorBlendStateCreateInfo =
             VkBool32
        vkLogicOpEnable (VkPipelineColorBlendStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkLogicOpEnableByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLogicOpEnable #-}
        vkLogicOpEnableByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, logicOpEnable}

        {-# INLINE vkLogicOpEnableByteOffset #-}
        readVkLogicOpEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkLogicOpEnableByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLogicOpEnable #-}
        writeVkLogicOpEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLogicOpEnableByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLogicOpEnable #-}

class HasVkLogicOp a where
        type VkLogicOpMType a :: *

        vkLogicOp :: a -> VkLogicOpMType a

        vkLogicOpByteOffset :: a -> Int

        readVkLogicOp :: Mutable a -> IO (VkLogicOpMType a)

        writeVkLogicOp :: Mutable a -> VkLogicOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'logicOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLogicOp a

instance {-# OVERLAPPING #-}
         HasVkLogicOp VkPipelineColorBlendStateCreateInfo where
        type VkLogicOpMType VkPipelineColorBlendStateCreateInfo = VkLogicOp
        vkLogicOp (VkPipelineColorBlendStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkLogicOp),
            I## o <- vkLogicOpByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLogicOp #-}
        vkLogicOpByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, logicOp}

        {-# INLINE vkLogicOpByteOffset #-}
        readVkLogicOp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkLogicOp),
            I## o <- vkLogicOpByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLogicOp #-}
        writeVkLogicOp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLogicOpByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLogicOp #-}

class HasVkAttachmentCount a where
        type VkAttachmentCountMType a :: *

        vkAttachmentCount :: a -> VkAttachmentCountMType a

        vkAttachmentCountByteOffset :: a -> Int

        readVkAttachmentCount :: Mutable a -> IO (VkAttachmentCountMType a)

        writeVkAttachmentCount ::
                               Mutable a -> VkAttachmentCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'attachmentCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAttachmentCount a

instance {-# OVERLAPPING #-}
         HasVkAttachmentCount VkPipelineColorBlendStateCreateInfo where
        type VkAttachmentCountMType VkPipelineColorBlendStateCreateInfo =
             Data.Word.Word32
        vkAttachmentCount (VkPipelineColorBlendStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkAttachmentCountByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAttachmentCount #-}
        vkAttachmentCountByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, attachmentCount}

        {-# INLINE vkAttachmentCountByteOffset #-}
        readVkAttachmentCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkAttachmentCountByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAttachmentCount #-}
        writeVkAttachmentCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAttachmentCountByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAttachmentCount #-}

class HasVkPAttachments a where
        type VkPAttachmentsMType a :: *

        vkPAttachments :: a -> VkPAttachmentsMType a

        vkPAttachmentsByteOffset :: a -> Int

        readVkPAttachments :: Mutable a -> IO (VkPAttachmentsMType a)

        writeVkPAttachments :: Mutable a -> VkPAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pAttachments'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPAttachments a

instance {-# OVERLAPPING #-}
         HasVkPAttachments VkPipelineColorBlendStateCreateInfo where
        type VkPAttachmentsMType VkPipelineColorBlendStateCreateInfo =
             Foreign.Ptr.Ptr VkPipelineColorBlendAttachmentState
        vkPAttachments (VkPipelineColorBlendStateCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPipelineColorBlendAttachmentState),
            I## o <- vkPAttachmentsByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPAttachments #-}
        vkPAttachmentsByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, pAttachments}

        {-# INLINE vkPAttachmentsByteOffset #-}
        readVkPAttachments (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPipelineColorBlendAttachmentState),
            I## o <- vkPAttachmentsByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPAttachments #-}
        writeVkPAttachments (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPAttachmentsByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPAttachments #-}

class HasVkBlendConstantsArray a where
        type VkBlendConstantsArrayMType a :: *

        vkBlendConstantsArray :: a -> Int -> VkBlendConstantsArrayMType a

        vkBlendConstantsArrayByteOffset :: a -> Int

        readVkBlendConstantsArray ::
                                  Mutable a -> Int -> IO (VkBlendConstantsArrayMType a)

        writeVkBlendConstantsArray ::
                                   Mutable a -> Int -> VkBlendConstantsArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'blendConstants'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBlendConstantsArray a

instance {-# OVERLAPPING #-}
         HasVkBlendConstantsArray VkPipelineColorBlendStateCreateInfo where
        type VkBlendConstantsArrayMType VkPipelineColorBlendStateCreateInfo
             = Foreign.C.Types.CFloat
        vkBlendConstantsArray (VkPipelineColorBlendStateCreateInfo## ba)
          (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkBlendConstantsArrayByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkBlendConstantsArray #-}
        vkBlendConstantsArrayByteOffset ~_
          = #{offset VkPipelineColorBlendStateCreateInfo, blendConstants}

        {-# INLINE vkBlendConstantsArrayByteOffset #-}
        readVkBlendConstantsArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkBlendConstantsArrayByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkBlendConstantsArray #-}
        writeVkBlendConstantsArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkBlendConstantsArrayByteOffset
                      (undefined :: VkPipelineColorBlendStateCreateInfo)
            =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkBlendConstantsArray #-}

instance Show VkPipelineColorBlendStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineColorBlendStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkLogicOpEnable = " .
                                  showsPrec d (vkLogicOpEnable x) .
                                    showString ", " .
                                      showString "vkLogicOp = " .
                                        showsPrec d (vkLogicOp x) .
                                          showString ", " .
                                            showString "vkAttachmentCount = " .
                                              showsPrec d (vkAttachmentCount x) .
                                                showString ", " .
                                                  showString "vkPAttachments = " .
                                                    showsPrec d (vkPAttachments x) .
                                                      showString ", " .
                                                        showString "vkBlendConstantsArray = [" .
                                                          showsPrec d
                                                            (map (vkBlendConstantsArray x) [1 .. 4])
                                                            . showChar ']' . showChar '}'

data VkPipelineDynamicStateCreateInfo = VkPipelineDynamicStateCreateInfo## ByteArray##

instance Eq VkPipelineDynamicStateCreateInfo where
        (VkPipelineDynamicStateCreateInfo## a) ==
          (VkPipelineDynamicStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineDynamicStateCreateInfo where
        (VkPipelineDynamicStateCreateInfo## a) `compare`
          (VkPipelineDynamicStateCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineDynamicStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineDynamicStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineDynamicStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPipelineDynamicStateCreateInfo),
            I## a <- alignment (undefined :: VkPipelineDynamicStateCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineDynamicStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineDynamicStateCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineDynamicStateCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineDynamicStateCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkPipelineDynamicStateCreateInfo),
            I## a <- alignment (undefined :: VkPipelineDynamicStateCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPipelineDynamicStateCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPipelineDynamicStateCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPipelineDynamicStateCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineDynamicStateCreateInfo),
            I## a <- alignment (undefined :: VkPipelineDynamicStateCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPipelineDynamicStateCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPipelineDynamicStateCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineDynamicStateCreateInfo where
        type VkSTypeMType VkPipelineDynamicStateCreateInfo =
             VkStructureType
        vkSType (VkPipelineDynamicStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineDynamicStateCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineDynamicStateCreateInfo where
        type VkPNextMType VkPipelineDynamicStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkPipelineDynamicStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineDynamicStateCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineDynamicStateCreateInfo where
        type VkFlagsMType VkPipelineDynamicStateCreateInfo =
             VkPipelineDynamicStateCreateFlags
        vkFlags (VkPipelineDynamicStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkPipelineDynamicStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineDynamicStateCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPipelineDynamicStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkDynamicStateCount a where
        type VkDynamicStateCountMType a :: *

        vkDynamicStateCount :: a -> VkDynamicStateCountMType a

        vkDynamicStateCountByteOffset :: a -> Int

        readVkDynamicStateCount ::
                                Mutable a -> IO (VkDynamicStateCountMType a)

        writeVkDynamicStateCount ::
                                 Mutable a -> VkDynamicStateCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dynamicStateCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDynamicStateCount a

instance {-# OVERLAPPING #-}
         HasVkDynamicStateCount VkPipelineDynamicStateCreateInfo where
        type VkDynamicStateCountMType VkPipelineDynamicStateCreateInfo =
             Data.Word.Word32
        vkDynamicStateCount (VkPipelineDynamicStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDynamicStateCountByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDynamicStateCount #-}
        vkDynamicStateCountByteOffset ~_
          = #{offset VkPipelineDynamicStateCreateInfo, dynamicStateCount}

        {-# INLINE vkDynamicStateCountByteOffset #-}
        readVkDynamicStateCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDynamicStateCountByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDynamicStateCount #-}
        writeVkDynamicStateCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDynamicStateCountByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDynamicStateCount #-}

class HasVkPDynamicStates a where
        type VkPDynamicStatesMType a :: *

        vkPDynamicStates :: a -> VkPDynamicStatesMType a

        vkPDynamicStatesByteOffset :: a -> Int

        readVkPDynamicStates :: Mutable a -> IO (VkPDynamicStatesMType a)

        writeVkPDynamicStates ::
                              Mutable a -> VkPDynamicStatesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pDynamicStates'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPDynamicStates a

instance {-# OVERLAPPING #-}
         HasVkPDynamicStates VkPipelineDynamicStateCreateInfo where
        type VkPDynamicStatesMType VkPipelineDynamicStateCreateInfo =
             Foreign.Ptr.Ptr VkDynamicState
        vkPDynamicStates (VkPipelineDynamicStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkDynamicState),
            I## o <- vkPDynamicStatesByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPDynamicStates #-}
        vkPDynamicStatesByteOffset ~_
          = #{offset VkPipelineDynamicStateCreateInfo, pDynamicStates}

        {-# INLINE vkPDynamicStatesByteOffset #-}
        readVkPDynamicStates (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkDynamicState),
            I## o <- vkPDynamicStatesByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPDynamicStates #-}
        writeVkPDynamicStates (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPDynamicStatesByteOffset
                      (undefined :: VkPipelineDynamicStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPDynamicStates #-}

instance Show VkPipelineDynamicStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineDynamicStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkDynamicStateCount = " .
                                  showsPrec d (vkDynamicStateCount x) .
                                    showString ", " .
                                      showString "vkPDynamicStates = " .
                                        showsPrec d (vkPDynamicStates x) . showChar '}'

data VkStencilOpState = VkStencilOpState## ByteArray##

instance Eq VkStencilOpState where
        (VkStencilOpState## a) == (VkStencilOpState## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkStencilOpState where
        (VkStencilOpState## a) `compare` (VkStencilOpState## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkStencilOpState where
        sizeOf ~_ = #{size VkStencilOpState}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkStencilOpState}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkStencilOpState),
            I## a <- alignment (undefined :: VkStencilOpState) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkStencilOpState## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkStencilOpState## ba)
          | I## n <- sizeOf (undefined :: VkStencilOpState) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkStencilOpState where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkStencilOpState),
            I## a <- alignment (undefined :: VkStencilOpState) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkStencilOpState## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkStencilOpState## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkStencilOpState## ba)
          | I## n <- sizeOf (undefined :: VkStencilOpState),
            I## a <- alignment (undefined :: VkStencilOpState) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkStencilOpState## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkStencilOpState## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkFailOp a where
        type VkFailOpMType a :: *

        vkFailOp :: a -> VkFailOpMType a

        vkFailOpByteOffset :: a -> Int

        readVkFailOp :: Mutable a -> IO (VkFailOpMType a)

        writeVkFailOp :: Mutable a -> VkFailOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'failOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFailOp a

instance {-# OVERLAPPING #-} HasVkFailOp VkStencilOpState where
        type VkFailOpMType VkStencilOpState = VkStencilOp
        vkFailOp (VkStencilOpState## ba)
          | I## _n <- sizeOf (undefined :: VkStencilOp),
            I## o <- vkFailOpByteOffset (undefined :: VkStencilOpState) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFailOp #-}
        vkFailOpByteOffset ~_ = #{offset VkStencilOpState, failOp}

        {-# INLINE vkFailOpByteOffset #-}
        readVkFailOp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStencilOp),
            I## o <- vkFailOpByteOffset (undefined :: VkStencilOpState) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFailOp #-}
        writeVkFailOp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFailOpByteOffset (undefined :: VkStencilOpState) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFailOp #-}

class HasVkPassOp a where
        type VkPassOpMType a :: *

        vkPassOp :: a -> VkPassOpMType a

        vkPassOpByteOffset :: a -> Int

        readVkPassOp :: Mutable a -> IO (VkPassOpMType a)

        writeVkPassOp :: Mutable a -> VkPassOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'passOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPassOp a

instance {-# OVERLAPPING #-} HasVkPassOp VkStencilOpState where
        type VkPassOpMType VkStencilOpState = VkStencilOp
        vkPassOp (VkStencilOpState## ba)
          | I## _n <- sizeOf (undefined :: VkStencilOp),
            I## o <- vkPassOpByteOffset (undefined :: VkStencilOpState) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPassOp #-}
        vkPassOpByteOffset ~_ = #{offset VkStencilOpState, passOp}

        {-# INLINE vkPassOpByteOffset #-}
        readVkPassOp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStencilOp),
            I## o <- vkPassOpByteOffset (undefined :: VkStencilOpState) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPassOp #-}
        writeVkPassOp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPassOpByteOffset (undefined :: VkStencilOpState) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPassOp #-}

class HasVkDepthFailOp a where
        type VkDepthFailOpMType a :: *

        vkDepthFailOp :: a -> VkDepthFailOpMType a

        vkDepthFailOpByteOffset :: a -> Int

        readVkDepthFailOp :: Mutable a -> IO (VkDepthFailOpMType a)

        writeVkDepthFailOp :: Mutable a -> VkDepthFailOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthFailOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthFailOp a

instance {-# OVERLAPPING #-} HasVkDepthFailOp VkStencilOpState
         where
        type VkDepthFailOpMType VkStencilOpState = VkStencilOp
        vkDepthFailOp (VkStencilOpState## ba)
          | I## _n <- sizeOf (undefined :: VkStencilOp),
            I## o <- vkDepthFailOpByteOffset (undefined :: VkStencilOpState) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthFailOp #-}
        vkDepthFailOpByteOffset ~_
          = #{offset VkStencilOpState, depthFailOp}

        {-# INLINE vkDepthFailOpByteOffset #-}
        readVkDepthFailOp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStencilOp),
            I## o <- vkDepthFailOpByteOffset (undefined :: VkStencilOpState) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthFailOp #-}
        writeVkDepthFailOp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthFailOpByteOffset (undefined :: VkStencilOpState) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthFailOp #-}

class HasVkCompareOp a where
        type VkCompareOpMType a :: *

        vkCompareOp :: a -> VkCompareOpMType a

        vkCompareOpByteOffset :: a -> Int

        readVkCompareOp :: Mutable a -> IO (VkCompareOpMType a)

        writeVkCompareOp :: Mutable a -> VkCompareOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'compareOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCompareOp a

instance {-# OVERLAPPING #-} HasVkCompareOp VkStencilOpState where
        type VkCompareOpMType VkStencilOpState = VkCompareOp
        vkCompareOp (VkStencilOpState## ba)
          | I## _n <- sizeOf (undefined :: VkCompareOp),
            I## o <- vkCompareOpByteOffset (undefined :: VkStencilOpState) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkCompareOp #-}
        vkCompareOpByteOffset ~_
          = #{offset VkStencilOpState, compareOp}

        {-# INLINE vkCompareOpByteOffset #-}
        readVkCompareOp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkCompareOp),
            I## o <- vkCompareOpByteOffset (undefined :: VkStencilOpState) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkCompareOp #-}
        writeVkCompareOp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkCompareOpByteOffset (undefined :: VkStencilOpState) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkCompareOp #-}

class HasVkCompareMask a where
        type VkCompareMaskMType a :: *

        vkCompareMask :: a -> VkCompareMaskMType a

        vkCompareMaskByteOffset :: a -> Int

        readVkCompareMask :: Mutable a -> IO (VkCompareMaskMType a)

        writeVkCompareMask :: Mutable a -> VkCompareMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'compareMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCompareMask a

instance {-# OVERLAPPING #-} HasVkCompareMask VkStencilOpState
         where
        type VkCompareMaskMType VkStencilOpState = Data.Word.Word32
        vkCompareMask (VkStencilOpState## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkCompareMaskByteOffset (undefined :: VkStencilOpState) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkCompareMask #-}
        vkCompareMaskByteOffset ~_
          = #{offset VkStencilOpState, compareMask}

        {-# INLINE vkCompareMaskByteOffset #-}
        readVkCompareMask (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkCompareMaskByteOffset (undefined :: VkStencilOpState) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkCompareMask #-}
        writeVkCompareMask (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkCompareMaskByteOffset (undefined :: VkStencilOpState) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkCompareMask #-}

class HasVkWriteMask a where
        type VkWriteMaskMType a :: *

        vkWriteMask :: a -> VkWriteMaskMType a

        vkWriteMaskByteOffset :: a -> Int

        readVkWriteMask :: Mutable a -> IO (VkWriteMaskMType a)

        writeVkWriteMask :: Mutable a -> VkWriteMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'writeMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkWriteMask a

instance {-# OVERLAPPING #-} HasVkWriteMask VkStencilOpState where
        type VkWriteMaskMType VkStencilOpState = Data.Word.Word32
        vkWriteMask (VkStencilOpState## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkWriteMaskByteOffset (undefined :: VkStencilOpState) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkWriteMask #-}
        vkWriteMaskByteOffset ~_
          = #{offset VkStencilOpState, writeMask}

        {-# INLINE vkWriteMaskByteOffset #-}
        readVkWriteMask (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkWriteMaskByteOffset (undefined :: VkStencilOpState) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkWriteMask #-}
        writeVkWriteMask (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkWriteMaskByteOffset (undefined :: VkStencilOpState) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkWriteMask #-}

class HasVkReference a where
        type VkReferenceMType a :: *

        vkReference :: a -> VkReferenceMType a

        vkReferenceByteOffset :: a -> Int

        readVkReference :: Mutable a -> IO (VkReferenceMType a)

        writeVkReference :: Mutable a -> VkReferenceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'reference'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkReference a

instance {-# OVERLAPPING #-} HasVkReference VkStencilOpState where
        type VkReferenceMType VkStencilOpState = Data.Word.Word32
        vkReference (VkStencilOpState## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkReferenceByteOffset (undefined :: VkStencilOpState) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkReference #-}
        vkReferenceByteOffset ~_
          = #{offset VkStencilOpState, reference}

        {-# INLINE vkReferenceByteOffset #-}
        readVkReference (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkReferenceByteOffset (undefined :: VkStencilOpState) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkReference #-}
        writeVkReference (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkReferenceByteOffset (undefined :: VkStencilOpState) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkReference #-}

instance Show VkStencilOpState where
        showsPrec d x
          = showString "VkStencilOpState {" .
              showString "vkFailOp = " .
                showsPrec d (vkFailOp x) .
                  showString ", " .
                    showString "vkPassOp = " .
                      showsPrec d (vkPassOp x) .
                        showString ", " .
                          showString "vkDepthFailOp = " .
                            showsPrec d (vkDepthFailOp x) .
                              showString ", " .
                                showString "vkCompareOp = " .
                                  showsPrec d (vkCompareOp x) .
                                    showString ", " .
                                      showString "vkCompareMask = " .
                                        showsPrec d (vkCompareMask x) .
                                          showString ", " .
                                            showString "vkWriteMask = " .
                                              showsPrec d (vkWriteMask x) .
                                                showString ", " .
                                                  showString "vkReference = " .
                                                    showsPrec d (vkReference x) . showChar '}'

data VkPipelineDepthStencilStateCreateInfo = VkPipelineDepthStencilStateCreateInfo## ByteArray##

instance Eq VkPipelineDepthStencilStateCreateInfo where
        (VkPipelineDepthStencilStateCreateInfo## a) ==
          (VkPipelineDepthStencilStateCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineDepthStencilStateCreateInfo where
        (VkPipelineDepthStencilStateCreateInfo## a) `compare`
          (VkPipelineDepthStencilStateCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineDepthStencilStateCreateInfo where
        sizeOf ~_ = #{size VkPipelineDepthStencilStateCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPipelineDepthStencilStateCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf
                      (undefined :: VkPipelineDepthStencilStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineDepthStencilStateCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            = IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineDepthStencilStateCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineDepthStencilStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPipelineDepthStencilStateCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s',
                                        VkPipelineDepthStencilStateCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## n <- sizeOf
                      (undefined :: VkPipelineDepthStencilStateCreateInfo),
            I## a <- alignment
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPipelineDepthStencilStateCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPipelineDepthStencilStateCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkSType VkPipelineDepthStencilStateCreateInfo where
        type VkSTypeMType VkPipelineDepthStencilStateCreateInfo =
             VkStructureType
        vkSType (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-}
         HasVkPNext VkPipelineDepthStencilStateCreateInfo where
        type VkPNextMType VkPipelineDepthStencilStateCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-}
         HasVkFlags VkPipelineDepthStencilStateCreateInfo where
        type VkFlagsMType VkPipelineDepthStencilStateCreateInfo =
             VkPipelineDepthStencilStateCreateFlags
        vkFlags (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineDepthStencilStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: VkPipelineDepthStencilStateCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkDepthTestEnable a where
        type VkDepthTestEnableMType a :: *

        vkDepthTestEnable :: a -> VkDepthTestEnableMType a

        vkDepthTestEnableByteOffset :: a -> Int

        readVkDepthTestEnable :: Mutable a -> IO (VkDepthTestEnableMType a)

        writeVkDepthTestEnable ::
                               Mutable a -> VkDepthTestEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthTestEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthTestEnable a

instance {-# OVERLAPPING #-}
         HasVkDepthTestEnable VkPipelineDepthStencilStateCreateInfo where
        type VkDepthTestEnableMType VkPipelineDepthStencilStateCreateInfo =
             VkBool32
        vkDepthTestEnable (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthTestEnableByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthTestEnable #-}
        vkDepthTestEnableByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, depthTestEnable}

        {-# INLINE vkDepthTestEnableByteOffset #-}
        readVkDepthTestEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthTestEnableByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthTestEnable #-}
        writeVkDepthTestEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthTestEnableByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthTestEnable #-}

class HasVkDepthWriteEnable a where
        type VkDepthWriteEnableMType a :: *

        vkDepthWriteEnable :: a -> VkDepthWriteEnableMType a

        vkDepthWriteEnableByteOffset :: a -> Int

        readVkDepthWriteEnable ::
                               Mutable a -> IO (VkDepthWriteEnableMType a)

        writeVkDepthWriteEnable ::
                                Mutable a -> VkDepthWriteEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthWriteEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthWriteEnable a

instance {-# OVERLAPPING #-}
         HasVkDepthWriteEnable VkPipelineDepthStencilStateCreateInfo where
        type VkDepthWriteEnableMType VkPipelineDepthStencilStateCreateInfo
             = VkBool32
        vkDepthWriteEnable (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthWriteEnableByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthWriteEnable #-}
        vkDepthWriteEnableByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, depthWriteEnable}

        {-# INLINE vkDepthWriteEnableByteOffset #-}
        readVkDepthWriteEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthWriteEnableByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthWriteEnable #-}
        writeVkDepthWriteEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthWriteEnableByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthWriteEnable #-}

class HasVkDepthCompareOp a where
        type VkDepthCompareOpMType a :: *

        vkDepthCompareOp :: a -> VkDepthCompareOpMType a

        vkDepthCompareOpByteOffset :: a -> Int

        readVkDepthCompareOp :: Mutable a -> IO (VkDepthCompareOpMType a)

        writeVkDepthCompareOp ::
                              Mutable a -> VkDepthCompareOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthCompareOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthCompareOp a

instance {-# OVERLAPPING #-}
         HasVkDepthCompareOp VkPipelineDepthStencilStateCreateInfo where
        type VkDepthCompareOpMType VkPipelineDepthStencilStateCreateInfo =
             VkCompareOp
        vkDepthCompareOp (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkCompareOp),
            I## o <- vkDepthCompareOpByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthCompareOp #-}
        vkDepthCompareOpByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, depthCompareOp}

        {-# INLINE vkDepthCompareOpByteOffset #-}
        readVkDepthCompareOp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkCompareOp),
            I## o <- vkDepthCompareOpByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthCompareOp #-}
        writeVkDepthCompareOp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthCompareOpByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthCompareOp #-}

class HasVkDepthBoundsTestEnable a where
        type VkDepthBoundsTestEnableMType a :: *

        vkDepthBoundsTestEnable :: a -> VkDepthBoundsTestEnableMType a

        vkDepthBoundsTestEnableByteOffset :: a -> Int

        readVkDepthBoundsTestEnable ::
                                    Mutable a -> IO (VkDepthBoundsTestEnableMType a)

        writeVkDepthBoundsTestEnable ::
                                     Mutable a -> VkDepthBoundsTestEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthBoundsTestEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthBoundsTestEnable a

instance {-# OVERLAPPING #-}
         HasVkDepthBoundsTestEnable VkPipelineDepthStencilStateCreateInfo
         where
        type VkDepthBoundsTestEnableMType
               VkPipelineDepthStencilStateCreateInfo
             = VkBool32
        vkDepthBoundsTestEnable (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthBoundsTestEnableByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthBoundsTestEnable #-}
        vkDepthBoundsTestEnableByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, depthBoundsTestEnable}

        {-# INLINE vkDepthBoundsTestEnableByteOffset #-}
        readVkDepthBoundsTestEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthBoundsTestEnableByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthBoundsTestEnable #-}
        writeVkDepthBoundsTestEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthBoundsTestEnableByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthBoundsTestEnable #-}

class HasVkStencilTestEnable a where
        type VkStencilTestEnableMType a :: *

        vkStencilTestEnable :: a -> VkStencilTestEnableMType a

        vkStencilTestEnableByteOffset :: a -> Int

        readVkStencilTestEnable ::
                                Mutable a -> IO (VkStencilTestEnableMType a)

        writeVkStencilTestEnable ::
                                 Mutable a -> VkStencilTestEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stencilTestEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStencilTestEnable a

instance {-# OVERLAPPING #-}
         HasVkStencilTestEnable VkPipelineDepthStencilStateCreateInfo where
        type VkStencilTestEnableMType VkPipelineDepthStencilStateCreateInfo
             = VkBool32
        vkStencilTestEnable (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkStencilTestEnableByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkStencilTestEnable #-}
        vkStencilTestEnableByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, stencilTestEnable}

        {-# INLINE vkStencilTestEnableByteOffset #-}
        readVkStencilTestEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkStencilTestEnableByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkStencilTestEnable #-}
        writeVkStencilTestEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkStencilTestEnableByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkStencilTestEnable #-}

class HasVkFront a where
        type VkFrontMType a :: *

        vkFront :: a -> VkFrontMType a

        vkFrontByteOffset :: a -> Int

        readVkFront :: Mutable a -> IO (VkFrontMType a)

        writeVkFront :: Mutable a -> VkFrontMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'front'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFront a

instance {-# OVERLAPPING #-}
         HasVkFront VkPipelineDepthStencilStateCreateInfo where
        type VkFrontMType VkPipelineDepthStencilStateCreateInfo =
             VkStencilOpState
        vkFront (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStencilOpState),
            I## o <- vkFrontByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFront #-}
        vkFrontByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, front}

        {-# INLINE vkFrontByteOffset #-}
        readVkFront (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStencilOpState),
            I## o <- vkFrontByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFront #-}
        writeVkFront (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFrontByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFront #-}

class HasVkBack a where
        type VkBackMType a :: *

        vkBack :: a -> VkBackMType a

        vkBackByteOffset :: a -> Int

        readVkBack :: Mutable a -> IO (VkBackMType a)

        writeVkBack :: Mutable a -> VkBackMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'back'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBack a

instance {-# OVERLAPPING #-}
         HasVkBack VkPipelineDepthStencilStateCreateInfo where
        type VkBackMType VkPipelineDepthStencilStateCreateInfo =
             VkStencilOpState
        vkBack (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStencilOpState),
            I## o <- vkBackByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBack #-}
        vkBackByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, back}

        {-# INLINE vkBackByteOffset #-}
        readVkBack (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStencilOpState),
            I## o <- vkBackByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBack #-}
        writeVkBack (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBackByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBack #-}

class HasVkMinDepthBounds a where
        type VkMinDepthBoundsMType a :: *

        vkMinDepthBounds :: a -> VkMinDepthBoundsMType a

        vkMinDepthBoundsByteOffset :: a -> Int

        readVkMinDepthBounds :: Mutable a -> IO (VkMinDepthBoundsMType a)

        writeVkMinDepthBounds ::
                              Mutable a -> VkMinDepthBoundsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minDepthBounds'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinDepthBounds a

instance {-# OVERLAPPING #-}
         HasVkMinDepthBounds VkPipelineDepthStencilStateCreateInfo where
        type VkMinDepthBoundsMType VkPipelineDepthStencilStateCreateInfo =
             Foreign.C.Types.CFloat
        vkMinDepthBounds (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMinDepthBoundsByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinDepthBounds #-}
        vkMinDepthBoundsByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, minDepthBounds}

        {-# INLINE vkMinDepthBoundsByteOffset #-}
        readVkMinDepthBounds (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMinDepthBoundsByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinDepthBounds #-}
        writeVkMinDepthBounds (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinDepthBoundsByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinDepthBounds #-}

class HasVkMaxDepthBounds a where
        type VkMaxDepthBoundsMType a :: *

        vkMaxDepthBounds :: a -> VkMaxDepthBoundsMType a

        vkMaxDepthBoundsByteOffset :: a -> Int

        readVkMaxDepthBounds :: Mutable a -> IO (VkMaxDepthBoundsMType a)

        writeVkMaxDepthBounds ::
                              Mutable a -> VkMaxDepthBoundsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxDepthBounds'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDepthBounds a

instance {-# OVERLAPPING #-}
         HasVkMaxDepthBounds VkPipelineDepthStencilStateCreateInfo where
        type VkMaxDepthBoundsMType VkPipelineDepthStencilStateCreateInfo =
             Foreign.C.Types.CFloat
        vkMaxDepthBounds (VkPipelineDepthStencilStateCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMaxDepthBoundsByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxDepthBounds #-}
        vkMaxDepthBoundsByteOffset ~_
          = #{offset VkPipelineDepthStencilStateCreateInfo, maxDepthBounds}

        {-# INLINE vkMaxDepthBoundsByteOffset #-}
        readVkMaxDepthBounds (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMaxDepthBoundsByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxDepthBounds #-}
        writeVkMaxDepthBounds (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxDepthBoundsByteOffset
                      (undefined :: VkPipelineDepthStencilStateCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxDepthBounds #-}

instance Show VkPipelineDepthStencilStateCreateInfo where
        showsPrec d x
          = showString "VkPipelineDepthStencilStateCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkDepthTestEnable = " .
                                  showsPrec d (vkDepthTestEnable x) .
                                    showString ", " .
                                      showString "vkDepthWriteEnable = " .
                                        showsPrec d (vkDepthWriteEnable x) .
                                          showString ", " .
                                            showString "vkDepthCompareOp = " .
                                              showsPrec d (vkDepthCompareOp x) .
                                                showString ", " .
                                                  showString "vkDepthBoundsTestEnable = " .
                                                    showsPrec d (vkDepthBoundsTestEnable x) .
                                                      showString ", " .
                                                        showString "vkStencilTestEnable = " .
                                                          showsPrec d (vkStencilTestEnable x) .
                                                            showString ", " .
                                                              showString "vkFront = " .
                                                                showsPrec d (vkFront x) .
                                                                  showString ", " .
                                                                    showString "vkBack = " .
                                                                      showsPrec d (vkBack x) .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkMinDepthBounds = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkMinDepthBounds x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkMaxDepthBounds = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkMaxDepthBounds
                                                                                       x)
                                                                                    . showChar '}'

data VkGraphicsPipelineCreateInfo = VkGraphicsPipelineCreateInfo## ByteArray##

instance Eq VkGraphicsPipelineCreateInfo where
        (VkGraphicsPipelineCreateInfo## a) ==
          (VkGraphicsPipelineCreateInfo## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkGraphicsPipelineCreateInfo where
        (VkGraphicsPipelineCreateInfo## a) `compare`
          (VkGraphicsPipelineCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkGraphicsPipelineCreateInfo where
        sizeOf ~_ = #{size VkGraphicsPipelineCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkGraphicsPipelineCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkGraphicsPipelineCreateInfo),
            I## a <- alignment (undefined :: VkGraphicsPipelineCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkGraphicsPipelineCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkGraphicsPipelineCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkGraphicsPipelineCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkGraphicsPipelineCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkGraphicsPipelineCreateInfo),
            I## a <- alignment (undefined :: VkGraphicsPipelineCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkGraphicsPipelineCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkGraphicsPipelineCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkGraphicsPipelineCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkGraphicsPipelineCreateInfo),
            I## a <- alignment (undefined :: VkGraphicsPipelineCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkGraphicsPipelineCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkGraphicsPipelineCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkSType VkGraphicsPipelineCreateInfo where
        type VkSTypeMType VkGraphicsPipelineCreateInfo = VkStructureType
        vkSType (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-}
         HasVkPNext VkGraphicsPipelineCreateInfo where
        type VkPNextMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-}
         HasVkFlags VkGraphicsPipelineCreateInfo where
        type VkFlagsMType VkGraphicsPipelineCreateInfo =
             VkPipelineCreateFlags
        vkFlags (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkPipelineCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPipelineCreateFlags),
            I## o <- vkFlagsByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkStageCount a where
        type VkStageCountMType a :: *

        vkStageCount :: a -> VkStageCountMType a

        vkStageCountByteOffset :: a -> Int

        readVkStageCount :: Mutable a -> IO (VkStageCountMType a)

        writeVkStageCount :: Mutable a -> VkStageCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stageCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStageCount a

instance {-# OVERLAPPING #-}
         HasVkStageCount VkGraphicsPipelineCreateInfo where
        type VkStageCountMType VkGraphicsPipelineCreateInfo =
             Data.Word.Word32
        vkStageCount (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkStageCountByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkStageCount #-}
        vkStageCountByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, stageCount}

        {-# INLINE vkStageCountByteOffset #-}
        readVkStageCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkStageCountByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkStageCount #-}
        writeVkStageCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkStageCountByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkStageCount #-}

class HasVkPStages a where
        type VkPStagesMType a :: *

        vkPStages :: a -> VkPStagesMType a

        vkPStagesByteOffset :: a -> Int

        readVkPStages :: Mutable a -> IO (VkPStagesMType a)

        writeVkPStages :: Mutable a -> VkPStagesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pStages'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPStages a

instance {-# OVERLAPPING #-}
         HasVkPStages VkGraphicsPipelineCreateInfo where
        type VkPStagesMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineShaderStageCreateInfo
        vkPStages (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPipelineShaderStageCreateInfo),
            I## o <- vkPStagesByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPStages #-}
        vkPStagesByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pStages}

        {-# INLINE vkPStagesByteOffset #-}
        readVkPStages (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPipelineShaderStageCreateInfo),
            I## o <- vkPStagesByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPStages #-}
        writeVkPStages (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPStagesByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPStages #-}

class HasVkPVertexInputState a where
        type VkPVertexInputStateMType a :: *

        vkPVertexInputState :: a -> VkPVertexInputStateMType a

        vkPVertexInputStateByteOffset :: a -> Int

        readVkPVertexInputState ::
                                Mutable a -> IO (VkPVertexInputStateMType a)

        writeVkPVertexInputState ::
                                 Mutable a -> VkPVertexInputStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pVertexInputState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPVertexInputState a

instance {-# OVERLAPPING #-}
         HasVkPVertexInputState VkGraphicsPipelineCreateInfo where
        type VkPVertexInputStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineVertexInputStateCreateInfo
        vkPVertexInputState (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr VkPipelineVertexInputStateCreateInfo),
            I## o <- vkPVertexInputStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPVertexInputState #-}
        vkPVertexInputStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pVertexInputState}

        {-# INLINE vkPVertexInputStateByteOffset #-}
        readVkPVertexInputState (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr VkPipelineVertexInputStateCreateInfo),
            I## o <- vkPVertexInputStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPVertexInputState #-}
        writeVkPVertexInputState (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPVertexInputStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPVertexInputState #-}

class HasVkPInputAssemblyState a where
        type VkPInputAssemblyStateMType a :: *

        vkPInputAssemblyState :: a -> VkPInputAssemblyStateMType a

        vkPInputAssemblyStateByteOffset :: a -> Int

        readVkPInputAssemblyState ::
                                  Mutable a -> IO (VkPInputAssemblyStateMType a)

        writeVkPInputAssemblyState ::
                                   Mutable a -> VkPInputAssemblyStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pInputAssemblyState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPInputAssemblyState a

instance {-# OVERLAPPING #-}
         HasVkPInputAssemblyState VkGraphicsPipelineCreateInfo where
        type VkPInputAssemblyStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineInputAssemblyStateCreateInfo
        vkPInputAssemblyState (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr VkPipelineInputAssemblyStateCreateInfo),
            I## o <- vkPInputAssemblyStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPInputAssemblyState #-}
        vkPInputAssemblyStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pInputAssemblyState}

        {-# INLINE vkPInputAssemblyStateByteOffset #-}
        readVkPInputAssemblyState (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr VkPipelineInputAssemblyStateCreateInfo),
            I## o <- vkPInputAssemblyStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPInputAssemblyState #-}
        writeVkPInputAssemblyState (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPInputAssemblyStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPInputAssemblyState #-}

class HasVkPTessellationState a where
        type VkPTessellationStateMType a :: *

        vkPTessellationState :: a -> VkPTessellationStateMType a

        vkPTessellationStateByteOffset :: a -> Int

        readVkPTessellationState ::
                                 Mutable a -> IO (VkPTessellationStateMType a)

        writeVkPTessellationState ::
                                  Mutable a -> VkPTessellationStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pTessellationState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPTessellationState a

instance {-# OVERLAPPING #-}
         HasVkPTessellationState VkGraphicsPipelineCreateInfo where
        type VkPTessellationStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineTessellationStateCreateInfo
        vkPTessellationState (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr VkPipelineTessellationStateCreateInfo),
            I## o <- vkPTessellationStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPTessellationState #-}
        vkPTessellationStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pTessellationState}

        {-# INLINE vkPTessellationStateByteOffset #-}
        readVkPTessellationState (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr VkPipelineTessellationStateCreateInfo),
            I## o <- vkPTessellationStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPTessellationState #-}
        writeVkPTessellationState (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPTessellationStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPTessellationState #-}

class HasVkPViewportState a where
        type VkPViewportStateMType a :: *

        vkPViewportState :: a -> VkPViewportStateMType a

        vkPViewportStateByteOffset :: a -> Int

        readVkPViewportState :: Mutable a -> IO (VkPViewportStateMType a)

        writeVkPViewportState ::
                              Mutable a -> VkPViewportStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pViewportState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPViewportState a

instance {-# OVERLAPPING #-}
         HasVkPViewportState VkGraphicsPipelineCreateInfo where
        type VkPViewportStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineViewportStateCreateInfo
        vkPViewportState (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPipelineViewportStateCreateInfo),
            I## o <- vkPViewportStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPViewportState #-}
        vkPViewportStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pViewportState}

        {-# INLINE vkPViewportStateByteOffset #-}
        readVkPViewportState (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPipelineViewportStateCreateInfo),
            I## o <- vkPViewportStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPViewportState #-}
        writeVkPViewportState (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPViewportStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPViewportState #-}

class HasVkPRasterizationState a where
        type VkPRasterizationStateMType a :: *

        vkPRasterizationState :: a -> VkPRasterizationStateMType a

        vkPRasterizationStateByteOffset :: a -> Int

        readVkPRasterizationState ::
                                  Mutable a -> IO (VkPRasterizationStateMType a)

        writeVkPRasterizationState ::
                                   Mutable a -> VkPRasterizationStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pRasterizationState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPRasterizationState a

instance {-# OVERLAPPING #-}
         HasVkPRasterizationState VkGraphicsPipelineCreateInfo where
        type VkPRasterizationStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineRasterizationStateCreateInfo
        vkPRasterizationState (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr VkPipelineRasterizationStateCreateInfo),
            I## o <- vkPRasterizationStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPRasterizationState #-}
        vkPRasterizationStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pRasterizationState}

        {-# INLINE vkPRasterizationStateByteOffset #-}
        readVkPRasterizationState (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr VkPipelineRasterizationStateCreateInfo),
            I## o <- vkPRasterizationStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPRasterizationState #-}
        writeVkPRasterizationState (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPRasterizationStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPRasterizationState #-}

class HasVkPMultisampleState a where
        type VkPMultisampleStateMType a :: *

        vkPMultisampleState :: a -> VkPMultisampleStateMType a

        vkPMultisampleStateByteOffset :: a -> Int

        readVkPMultisampleState ::
                                Mutable a -> IO (VkPMultisampleStateMType a)

        writeVkPMultisampleState ::
                                 Mutable a -> VkPMultisampleStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pMultisampleState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPMultisampleState a

instance {-# OVERLAPPING #-}
         HasVkPMultisampleState VkGraphicsPipelineCreateInfo where
        type VkPMultisampleStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineMultisampleStateCreateInfo
        vkPMultisampleState (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr VkPipelineMultisampleStateCreateInfo),
            I## o <- vkPMultisampleStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPMultisampleState #-}
        vkPMultisampleStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pMultisampleState}

        {-# INLINE vkPMultisampleStateByteOffset #-}
        readVkPMultisampleState (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr VkPipelineMultisampleStateCreateInfo),
            I## o <- vkPMultisampleStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPMultisampleState #-}
        writeVkPMultisampleState (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPMultisampleStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPMultisampleState #-}

class HasVkPDepthStencilState a where
        type VkPDepthStencilStateMType a :: *

        vkPDepthStencilState :: a -> VkPDepthStencilStateMType a

        vkPDepthStencilStateByteOffset :: a -> Int

        readVkPDepthStencilState ::
                                 Mutable a -> IO (VkPDepthStencilStateMType a)

        writeVkPDepthStencilState ::
                                  Mutable a -> VkPDepthStencilStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pDepthStencilState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPDepthStencilState a

instance {-# OVERLAPPING #-}
         HasVkPDepthStencilState VkGraphicsPipelineCreateInfo where
        type VkPDepthStencilStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineDepthStencilStateCreateInfo
        vkPDepthStencilState (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr VkPipelineDepthStencilStateCreateInfo),
            I## o <- vkPDepthStencilStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPDepthStencilState #-}
        vkPDepthStencilStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pDepthStencilState}

        {-# INLINE vkPDepthStencilStateByteOffset #-}
        readVkPDepthStencilState (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined ::
                          Foreign.Ptr.Ptr VkPipelineDepthStencilStateCreateInfo),
            I## o <- vkPDepthStencilStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPDepthStencilState #-}
        writeVkPDepthStencilState (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPDepthStencilStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPDepthStencilState #-}

class HasVkPColorBlendState a where
        type VkPColorBlendStateMType a :: *

        vkPColorBlendState :: a -> VkPColorBlendStateMType a

        vkPColorBlendStateByteOffset :: a -> Int

        readVkPColorBlendState ::
                               Mutable a -> IO (VkPColorBlendStateMType a)

        writeVkPColorBlendState ::
                                Mutable a -> VkPColorBlendStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pColorBlendState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPColorBlendState a

instance {-# OVERLAPPING #-}
         HasVkPColorBlendState VkGraphicsPipelineCreateInfo where
        type VkPColorBlendStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineColorBlendStateCreateInfo
        vkPColorBlendState (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPipelineColorBlendStateCreateInfo),
            I## o <- vkPColorBlendStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPColorBlendState #-}
        vkPColorBlendStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pColorBlendState}

        {-# INLINE vkPColorBlendStateByteOffset #-}
        readVkPColorBlendState (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPipelineColorBlendStateCreateInfo),
            I## o <- vkPColorBlendStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPColorBlendState #-}
        writeVkPColorBlendState (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPColorBlendStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPColorBlendState #-}

class HasVkPDynamicState a where
        type VkPDynamicStateMType a :: *

        vkPDynamicState :: a -> VkPDynamicStateMType a

        vkPDynamicStateByteOffset :: a -> Int

        readVkPDynamicState :: Mutable a -> IO (VkPDynamicStateMType a)

        writeVkPDynamicState ::
                             Mutable a -> VkPDynamicStateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pDynamicState'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPDynamicState a

instance {-# OVERLAPPING #-}
         HasVkPDynamicState VkGraphicsPipelineCreateInfo where
        type VkPDynamicStateMType VkGraphicsPipelineCreateInfo =
             Foreign.Ptr.Ptr VkPipelineDynamicStateCreateInfo
        vkPDynamicState (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPipelineDynamicStateCreateInfo),
            I## o <- vkPDynamicStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPDynamicState #-}
        vkPDynamicStateByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, pDynamicState}

        {-# INLINE vkPDynamicStateByteOffset #-}
        readVkPDynamicState (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPipelineDynamicStateCreateInfo),
            I## o <- vkPDynamicStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPDynamicState #-}
        writeVkPDynamicState (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPDynamicStateByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPDynamicState #-}

instance {-# OVERLAPPING #-}
         HasVkLayout VkGraphicsPipelineCreateInfo where
        type VkLayoutMType VkGraphicsPipelineCreateInfo = VkPipelineLayout
        vkLayout (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkPipelineLayout),
            I## o <- vkLayoutByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLayout #-}
        vkLayoutByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, layout}

        {-# INLINE vkLayoutByteOffset #-}
        readVkLayout (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPipelineLayout),
            I## o <- vkLayoutByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLayout #-}
        writeVkLayout (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLayoutByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLayout #-}

class HasVkRenderPass a where
        type VkRenderPassMType a :: *

        vkRenderPass :: a -> VkRenderPassMType a

        vkRenderPassByteOffset :: a -> Int

        readVkRenderPass :: Mutable a -> IO (VkRenderPassMType a)

        writeVkRenderPass :: Mutable a -> VkRenderPassMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'renderPass'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRenderPass a

instance {-# OVERLAPPING #-}
         HasVkRenderPass VkGraphicsPipelineCreateInfo where
        type VkRenderPassMType VkGraphicsPipelineCreateInfo = VkRenderPass
        vkRenderPass (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkRenderPass),
            I## o <- vkRenderPassByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkRenderPass #-}
        vkRenderPassByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, renderPass}

        {-# INLINE vkRenderPassByteOffset #-}
        readVkRenderPass (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkRenderPass),
            I## o <- vkRenderPassByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkRenderPass #-}
        writeVkRenderPass (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkRenderPassByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkRenderPass #-}

class HasVkSubpass a where
        type VkSubpassMType a :: *

        vkSubpass :: a -> VkSubpassMType a

        vkSubpassByteOffset :: a -> Int

        readVkSubpass :: Mutable a -> IO (VkSubpassMType a)

        writeVkSubpass :: Mutable a -> VkSubpassMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'subpass'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSubpass a

instance {-# OVERLAPPING #-}
         HasVkSubpass VkGraphicsPipelineCreateInfo where
        type VkSubpassMType VkGraphicsPipelineCreateInfo = Data.Word.Word32
        vkSubpass (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSubpassByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSubpass #-}
        vkSubpassByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, subpass}

        {-# INLINE vkSubpassByteOffset #-}
        readVkSubpass (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSubpassByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSubpass #-}
        writeVkSubpass (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSubpassByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSubpass #-}

instance {-# OVERLAPPING #-}
         HasVkBasePipelineHandle VkGraphicsPipelineCreateInfo where
        type VkBasePipelineHandleMType VkGraphicsPipelineCreateInfo =
             VkPipeline
        vkBasePipelineHandle (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkPipeline),
            I## o <- vkBasePipelineHandleByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBasePipelineHandle #-}
        vkBasePipelineHandleByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, basePipelineHandle}

        {-# INLINE vkBasePipelineHandleByteOffset #-}
        readVkBasePipelineHandle (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPipeline),
            I## o <- vkBasePipelineHandleByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBasePipelineHandle #-}
        writeVkBasePipelineHandle (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBasePipelineHandleByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBasePipelineHandle #-}

instance {-# OVERLAPPING #-}
         HasVkBasePipelineIndex VkGraphicsPipelineCreateInfo where
        type VkBasePipelineIndexMType VkGraphicsPipelineCreateInfo =
             Data.Int.Int32
        vkBasePipelineIndex (VkGraphicsPipelineCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkBasePipelineIndexByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBasePipelineIndex #-}
        vkBasePipelineIndexByteOffset ~_
          = #{offset VkGraphicsPipelineCreateInfo, basePipelineIndex}

        {-# INLINE vkBasePipelineIndexByteOffset #-}
        readVkBasePipelineIndex (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkBasePipelineIndexByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBasePipelineIndex #-}
        writeVkBasePipelineIndex (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBasePipelineIndexByteOffset
                      (undefined :: VkGraphicsPipelineCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBasePipelineIndex #-}

instance Show VkGraphicsPipelineCreateInfo where
        showsPrec d x
          = showString "VkGraphicsPipelineCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkStageCount = " .
                                  showsPrec d (vkStageCount x) .
                                    showString ", " .
                                      showString "vkPStages = " .
                                        showsPrec d (vkPStages x) .
                                          showString ", " .
                                            showString "vkPVertexInputState = " .
                                              showsPrec d (vkPVertexInputState x) .
                                                showString ", " .
                                                  showString "vkPInputAssemblyState = " .
                                                    showsPrec d (vkPInputAssemblyState x) .
                                                      showString ", " .
                                                        showString "vkPTessellationState = " .
                                                          showsPrec d (vkPTessellationState x) .
                                                            showString ", " .
                                                              showString "vkPViewportState = " .
                                                                showsPrec d (vkPViewportState x) .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkPRasterizationState = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkPRasterizationState x)
                                                                        .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkPMultisampleState = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkPMultisampleState
                                                                                 x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkPDepthStencilState = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkPDepthStencilState
                                                                                       x)
                                                                                    .
                                                                                    showString ", "
                                                                                      .
                                                                                      showString
                                                                                        "vkPColorBlendState = "
                                                                                        .
                                                                                        showsPrec d
                                                                                          (vkPColorBlendState
                                                                                             x)
                                                                                          .
                                                                                          showString
                                                                                            ", "
                                                                                            .
                                                                                            showString
                                                                                              "vkPDynamicState = "
                                                                                              .
                                                                                              showsPrec
                                                                                                d
                                                                                                (vkPDynamicState
                                                                                                   x)
                                                                                                .
                                                                                                showString
                                                                                                  ", "
                                                                                                  .
                                                                                                  showString
                                                                                                    "vkLayout = "
                                                                                                    .
                                                                                                    showsPrec
                                                                                                      d
                                                                                                      (vkLayout
                                                                                                         x)
                                                                                                      .
                                                                                                      showString
                                                                                                        ", "
                                                                                                        .
                                                                                                        showString
                                                                                                          "vkRenderPass = "
                                                                                                          .
                                                                                                          showsPrec
                                                                                                            d
                                                                                                            (vkRenderPass
                                                                                                               x)
                                                                                                            .
                                                                                                            showString
                                                                                                              ", "
                                                                                                              .
                                                                                                              showString
                                                                                                                "vkSubpass = "
                                                                                                                .
                                                                                                                showsPrec
                                                                                                                  d
                                                                                                                  (vkSubpass
                                                                                                                     x)
                                                                                                                  .
                                                                                                                  showString
                                                                                                                    ", "
                                                                                                                    .
                                                                                                                    showString
                                                                                                                      "vkBasePipelineHandle = "
                                                                                                                      .
                                                                                                                      showsPrec
                                                                                                                        d
                                                                                                                        (vkBasePipelineHandle
                                                                                                                           x)
                                                                                                                        .
                                                                                                                        showString
                                                                                                                          ", "
                                                                                                                          .
                                                                                                                          showString
                                                                                                                            "vkBasePipelineIndex = "
                                                                                                                            .
                                                                                                                            showsPrec
                                                                                                                              d
                                                                                                                              (vkBasePipelineIndex
                                                                                                                                 x)
                                                                                                                              .
                                                                                                                              showChar
                                                                                                                                '}'

data VkPipelineCacheCreateInfo = VkPipelineCacheCreateInfo## ByteArray##

instance Eq VkPipelineCacheCreateInfo where
        (VkPipelineCacheCreateInfo## a) == (VkPipelineCacheCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineCacheCreateInfo where
        (VkPipelineCacheCreateInfo## a) `compare`
          (VkPipelineCacheCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineCacheCreateInfo where
        sizeOf ~_ = #{size VkPipelineCacheCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPipelineCacheCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPipelineCacheCreateInfo),
            I## a <- alignment (undefined :: VkPipelineCacheCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineCacheCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineCacheCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineCacheCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineCacheCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkPipelineCacheCreateInfo),
            I## a <- alignment (undefined :: VkPipelineCacheCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPipelineCacheCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPipelineCacheCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPipelineCacheCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineCacheCreateInfo),
            I## a <- alignment (undefined :: VkPipelineCacheCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPipelineCacheCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPipelineCacheCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkPipelineCacheCreateInfo
         where
        type VkSTypeMType VkPipelineCacheCreateInfo = VkStructureType
        vkSType (VkPipelineCacheCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkPipelineCacheCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineCacheCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkPipelineCacheCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkPipelineCacheCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkPipelineCacheCreateInfo
         where
        type VkPNextMType VkPipelineCacheCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkPipelineCacheCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkPipelineCacheCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineCacheCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkPipelineCacheCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkPipelineCacheCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkPipelineCacheCreateInfo
         where
        type VkFlagsMType VkPipelineCacheCreateInfo =
             VkPipelineCacheCreateFlags
        vkFlags (VkPipelineCacheCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkPipelineCacheCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkPipelineCacheCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineCacheCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPipelineCacheCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkPipelineCacheCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkPipelineCacheCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkInitialDataSize a where
        type VkInitialDataSizeMType a :: *

        vkInitialDataSize :: a -> VkInitialDataSizeMType a

        vkInitialDataSizeByteOffset :: a -> Int

        readVkInitialDataSize :: Mutable a -> IO (VkInitialDataSizeMType a)

        writeVkInitialDataSize ::
                               Mutable a -> VkInitialDataSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'initialDataSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkInitialDataSize a

instance {-# OVERLAPPING #-}
         HasVkInitialDataSize VkPipelineCacheCreateInfo where
        type VkInitialDataSizeMType VkPipelineCacheCreateInfo =
             Foreign.C.Types.CSize
        vkInitialDataSize (VkPipelineCacheCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CSize),
            I## o <- vkInitialDataSizeByteOffset
                      (undefined :: VkPipelineCacheCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkInitialDataSize #-}
        vkInitialDataSizeByteOffset ~_
          = #{offset VkPipelineCacheCreateInfo, initialDataSize}

        {-# INLINE vkInitialDataSizeByteOffset #-}
        readVkInitialDataSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CSize),
            I## o <- vkInitialDataSizeByteOffset
                      (undefined :: VkPipelineCacheCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkInitialDataSize #-}
        writeVkInitialDataSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkInitialDataSizeByteOffset
                      (undefined :: VkPipelineCacheCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkInitialDataSize #-}

class HasVkPInitialData a where
        type VkPInitialDataMType a :: *

        vkPInitialData :: a -> VkPInitialDataMType a

        vkPInitialDataByteOffset :: a -> Int

        readVkPInitialData :: Mutable a -> IO (VkPInitialDataMType a)

        writeVkPInitialData :: Mutable a -> VkPInitialDataMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pInitialData'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPInitialData a

instance {-# OVERLAPPING #-}
         HasVkPInitialData VkPipelineCacheCreateInfo where
        type VkPInitialDataMType VkPipelineCacheCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPInitialData (VkPipelineCacheCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPInitialDataByteOffset
                      (undefined :: VkPipelineCacheCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPInitialData #-}
        vkPInitialDataByteOffset ~_
          = #{offset VkPipelineCacheCreateInfo, pInitialData}

        {-# INLINE vkPInitialDataByteOffset #-}
        readVkPInitialData (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPInitialDataByteOffset
                      (undefined :: VkPipelineCacheCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPInitialData #-}
        writeVkPInitialData (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPInitialDataByteOffset
                      (undefined :: VkPipelineCacheCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPInitialData #-}

instance Show VkPipelineCacheCreateInfo where
        showsPrec d x
          = showString "VkPipelineCacheCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkInitialDataSize = " .
                                  showsPrec d (vkInitialDataSize x) .
                                    showString ", " .
                                      showString "vkPInitialData = " .
                                        showsPrec d (vkPInitialData x) . showChar '}'

data VkPushConstantRange = VkPushConstantRange## ByteArray##

instance Eq VkPushConstantRange where
        (VkPushConstantRange## a) == (VkPushConstantRange## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPushConstantRange where
        (VkPushConstantRange## a) `compare` (VkPushConstantRange## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPushConstantRange where
        sizeOf ~_ = #{size VkPushConstantRange}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPushConstantRange}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPushConstantRange),
            I## a <- alignment (undefined :: VkPushConstantRange) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPushConstantRange## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPushConstantRange## ba)
          | I## n <- sizeOf (undefined :: VkPushConstantRange) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPushConstantRange where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkPushConstantRange),
            I## a <- alignment (undefined :: VkPushConstantRange) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPushConstantRange## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPushConstantRange## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPushConstantRange## ba)
          | I## n <- sizeOf (undefined :: VkPushConstantRange),
            I## a <- alignment (undefined :: VkPushConstantRange) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPushConstantRange## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPushConstantRange## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkStageFlags VkPushConstantRange
         where
        type VkStageFlagsMType VkPushConstantRange = VkShaderStageFlags
        vkStageFlags (VkPushConstantRange## ba)
          | I## _n <- sizeOf (undefined :: VkShaderStageFlags),
            I## o <- vkStageFlagsByteOffset (undefined :: VkPushConstantRange) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkStageFlags #-}
        vkStageFlagsByteOffset ~_
          = #{offset VkPushConstantRange, stageFlags}

        {-# INLINE vkStageFlagsByteOffset #-}
        readVkStageFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkShaderStageFlags),
            I## o <- vkStageFlagsByteOffset (undefined :: VkPushConstantRange) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkStageFlags #-}
        writeVkStageFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkStageFlagsByteOffset (undefined :: VkPushConstantRange) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkStageFlags #-}

instance {-# OVERLAPPING #-} HasVkOffset VkPushConstantRange where
        type VkOffsetMType VkPushConstantRange = Data.Word.Word32
        vkOffset (VkPushConstantRange## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkOffsetByteOffset (undefined :: VkPushConstantRange) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOffset #-}
        vkOffsetByteOffset ~_
          = #{offset VkPushConstantRange, offset}

        {-# INLINE vkOffsetByteOffset #-}
        readVkOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkOffsetByteOffset (undefined :: VkPushConstantRange) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOffset #-}
        writeVkOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOffsetByteOffset (undefined :: VkPushConstantRange) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOffset #-}

instance {-# OVERLAPPING #-} HasVkSize VkPushConstantRange where
        type VkSizeMType VkPushConstantRange = Data.Word.Word32
        vkSize (VkPushConstantRange## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSizeByteOffset (undefined :: VkPushConstantRange) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSize #-}
        vkSizeByteOffset ~_ = #{offset VkPushConstantRange, size}

        {-# INLINE vkSizeByteOffset #-}
        readVkSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSizeByteOffset (undefined :: VkPushConstantRange) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSize #-}
        writeVkSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSizeByteOffset (undefined :: VkPushConstantRange) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSize #-}

instance Show VkPushConstantRange where
        showsPrec d x
          = showString "VkPushConstantRange {" .
              showString "vkStageFlags = " .
                showsPrec d (vkStageFlags x) .
                  showString ", " .
                    showString "vkOffset = " .
                      showsPrec d (vkOffset x) .
                        showString ", " .
                          showString "vkSize = " . showsPrec d (vkSize x) . showChar '}'

data VkPipelineLayoutCreateInfo = VkPipelineLayoutCreateInfo## ByteArray##

instance Eq VkPipelineLayoutCreateInfo where
        (VkPipelineLayoutCreateInfo## a) == (VkPipelineLayoutCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPipelineLayoutCreateInfo where
        (VkPipelineLayoutCreateInfo## a) `compare`
          (VkPipelineLayoutCreateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPipelineLayoutCreateInfo where
        sizeOf ~_ = #{size VkPipelineLayoutCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPipelineLayoutCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPipelineLayoutCreateInfo),
            I## a <- alignment (undefined :: VkPipelineLayoutCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPipelineLayoutCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPipelineLayoutCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineLayoutCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPipelineLayoutCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkPipelineLayoutCreateInfo),
            I## a <- alignment (undefined :: VkPipelineLayoutCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPipelineLayoutCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPipelineLayoutCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPipelineLayoutCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkPipelineLayoutCreateInfo),
            I## a <- alignment (undefined :: VkPipelineLayoutCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPipelineLayoutCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPipelineLayoutCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkPipelineLayoutCreateInfo
         where
        type VkSTypeMType VkPipelineLayoutCreateInfo = VkStructureType
        vkSType (VkPipelineLayoutCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkPipelineLayoutCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkPipelineLayoutCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkPipelineLayoutCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkPipelineLayoutCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkPipelineLayoutCreateInfo
         where
        type VkPNextMType VkPipelineLayoutCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkPipelineLayoutCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkPipelineLayoutCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkPipelineLayoutCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkPipelineLayoutCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkPipelineLayoutCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkPipelineLayoutCreateInfo
         where
        type VkFlagsMType VkPipelineLayoutCreateInfo =
             VkPipelineLayoutCreateFlags
        vkFlags (VkPipelineLayoutCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkPipelineLayoutCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkPipelineLayoutCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkPipelineLayoutCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPipelineLayoutCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkPipelineLayoutCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkPipelineLayoutCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkSetLayoutCount a where
        type VkSetLayoutCountMType a :: *

        vkSetLayoutCount :: a -> VkSetLayoutCountMType a

        vkSetLayoutCountByteOffset :: a -> Int

        readVkSetLayoutCount :: Mutable a -> IO (VkSetLayoutCountMType a)

        writeVkSetLayoutCount ::
                              Mutable a -> VkSetLayoutCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'setLayoutCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSetLayoutCount a

instance {-# OVERLAPPING #-}
         HasVkSetLayoutCount VkPipelineLayoutCreateInfo where
        type VkSetLayoutCountMType VkPipelineLayoutCreateInfo =
             Data.Word.Word32
        vkSetLayoutCount (VkPipelineLayoutCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSetLayoutCountByteOffset
                      (undefined :: VkPipelineLayoutCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSetLayoutCount #-}
        vkSetLayoutCountByteOffset ~_
          = #{offset VkPipelineLayoutCreateInfo, setLayoutCount}

        {-# INLINE vkSetLayoutCountByteOffset #-}
        readVkSetLayoutCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSetLayoutCountByteOffset
                      (undefined :: VkPipelineLayoutCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSetLayoutCount #-}
        writeVkSetLayoutCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSetLayoutCountByteOffset
                      (undefined :: VkPipelineLayoutCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSetLayoutCount #-}

instance {-# OVERLAPPING #-}
         HasVkPSetLayouts VkPipelineLayoutCreateInfo where
        type VkPSetLayoutsMType VkPipelineLayoutCreateInfo =
             Foreign.Ptr.Ptr VkDescriptorSetLayout
        vkPSetLayouts (VkPipelineLayoutCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkDescriptorSetLayout),
            I## o <- vkPSetLayoutsByteOffset
                      (undefined :: VkPipelineLayoutCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPSetLayouts #-}
        vkPSetLayoutsByteOffset ~_
          = #{offset VkPipelineLayoutCreateInfo, pSetLayouts}

        {-# INLINE vkPSetLayoutsByteOffset #-}
        readVkPSetLayouts (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkDescriptorSetLayout),
            I## o <- vkPSetLayoutsByteOffset
                      (undefined :: VkPipelineLayoutCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPSetLayouts #-}
        writeVkPSetLayouts (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPSetLayoutsByteOffset
                      (undefined :: VkPipelineLayoutCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPSetLayouts #-}

class HasVkPushConstantRangeCount a where
        type VkPushConstantRangeCountMType a :: *

        vkPushConstantRangeCount :: a -> VkPushConstantRangeCountMType a

        vkPushConstantRangeCountByteOffset :: a -> Int

        readVkPushConstantRangeCount ::
                                     Mutable a -> IO (VkPushConstantRangeCountMType a)

        writeVkPushConstantRangeCount ::
                                      Mutable a -> VkPushConstantRangeCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pushConstantRangeCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPushConstantRangeCount a

instance {-# OVERLAPPING #-}
         HasVkPushConstantRangeCount VkPipelineLayoutCreateInfo where
        type VkPushConstantRangeCountMType VkPipelineLayoutCreateInfo =
             Data.Word.Word32
        vkPushConstantRangeCount (VkPipelineLayoutCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkPushConstantRangeCountByteOffset
                      (undefined :: VkPipelineLayoutCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPushConstantRangeCount #-}
        vkPushConstantRangeCountByteOffset ~_
          = #{offset VkPipelineLayoutCreateInfo, pushConstantRangeCount}

        {-# INLINE vkPushConstantRangeCountByteOffset #-}
        readVkPushConstantRangeCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkPushConstantRangeCountByteOffset
                      (undefined :: VkPipelineLayoutCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPushConstantRangeCount #-}
        writeVkPushConstantRangeCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPushConstantRangeCountByteOffset
                      (undefined :: VkPipelineLayoutCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPushConstantRangeCount #-}

class HasVkPPushConstantRanges a where
        type VkPPushConstantRangesMType a :: *

        vkPPushConstantRanges :: a -> VkPPushConstantRangesMType a

        vkPPushConstantRangesByteOffset :: a -> Int

        readVkPPushConstantRanges ::
                                  Mutable a -> IO (VkPPushConstantRangesMType a)

        writeVkPPushConstantRanges ::
                                   Mutable a -> VkPPushConstantRangesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pPushConstantRanges'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPPushConstantRanges a

instance {-# OVERLAPPING #-}
         HasVkPPushConstantRanges VkPipelineLayoutCreateInfo where
        type VkPPushConstantRangesMType VkPipelineLayoutCreateInfo =
             Foreign.Ptr.Ptr VkPushConstantRange
        vkPPushConstantRanges (VkPipelineLayoutCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPushConstantRange),
            I## o <- vkPPushConstantRangesByteOffset
                      (undefined :: VkPipelineLayoutCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPPushConstantRanges #-}
        vkPPushConstantRangesByteOffset ~_
          = #{offset VkPipelineLayoutCreateInfo, pPushConstantRanges}

        {-# INLINE vkPPushConstantRangesByteOffset #-}
        readVkPPushConstantRanges (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPushConstantRange),
            I## o <- vkPPushConstantRangesByteOffset
                      (undefined :: VkPipelineLayoutCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPPushConstantRanges #-}
        writeVkPPushConstantRanges (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPPushConstantRangesByteOffset
                      (undefined :: VkPipelineLayoutCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPPushConstantRanges #-}

instance Show VkPipelineLayoutCreateInfo where
        showsPrec d x
          = showString "VkPipelineLayoutCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkSetLayoutCount = " .
                                  showsPrec d (vkSetLayoutCount x) .
                                    showString ", " .
                                      showString "vkPSetLayouts = " .
                                        showsPrec d (vkPSetLayouts x) .
                                          showString ", " .
                                            showString "vkPushConstantRangeCount = " .
                                              showsPrec d (vkPushConstantRangeCount x) .
                                                showString ", " .
                                                  showString "vkPPushConstantRanges = " .
                                                    showsPrec d (vkPPushConstantRanges x) .
                                                      showChar '}'

data VkSamplerCreateInfo = VkSamplerCreateInfo## ByteArray##

instance Eq VkSamplerCreateInfo where
        (VkSamplerCreateInfo## a) == (VkSamplerCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSamplerCreateInfo where
        (VkSamplerCreateInfo## a) `compare` (VkSamplerCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSamplerCreateInfo where
        sizeOf ~_ = #{size VkSamplerCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSamplerCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSamplerCreateInfo),
            I## a <- alignment (undefined :: VkSamplerCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSamplerCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSamplerCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkSamplerCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSamplerCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSamplerCreateInfo),
            I## a <- alignment (undefined :: VkSamplerCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSamplerCreateInfo## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSamplerCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSamplerCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkSamplerCreateInfo),
            I## a <- alignment (undefined :: VkSamplerCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSamplerCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSamplerCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkSamplerCreateInfo where
        type VkSTypeMType VkSamplerCreateInfo = VkStructureType
        vkSType (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkSamplerCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkSamplerCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkSamplerCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkSamplerCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkSamplerCreateInfo where
        type VkPNextMType VkSamplerCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkSamplerCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkSamplerCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkSamplerCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkSamplerCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkSamplerCreateInfo where
        type VkFlagsMType VkSamplerCreateInfo = VkSamplerCreateFlags
        vkFlags (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkSamplerCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkSamplerCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkSamplerCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSamplerCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkSamplerCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkSamplerCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkMagFilter a where
        type VkMagFilterMType a :: *

        vkMagFilter :: a -> VkMagFilterMType a

        vkMagFilterByteOffset :: a -> Int

        readVkMagFilter :: Mutable a -> IO (VkMagFilterMType a)

        writeVkMagFilter :: Mutable a -> VkMagFilterMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'magFilter'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMagFilter a

instance {-# OVERLAPPING #-} HasVkMagFilter VkSamplerCreateInfo
         where
        type VkMagFilterMType VkSamplerCreateInfo = VkFilter
        vkMagFilter (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkFilter),
            I## o <- vkMagFilterByteOffset (undefined :: VkSamplerCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMagFilter #-}
        vkMagFilterByteOffset ~_
          = #{offset VkSamplerCreateInfo, magFilter}

        {-# INLINE vkMagFilterByteOffset #-}
        readVkMagFilter (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFilter),
            I## o <- vkMagFilterByteOffset (undefined :: VkSamplerCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMagFilter #-}
        writeVkMagFilter (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMagFilterByteOffset (undefined :: VkSamplerCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMagFilter #-}

class HasVkMinFilter a where
        type VkMinFilterMType a :: *

        vkMinFilter :: a -> VkMinFilterMType a

        vkMinFilterByteOffset :: a -> Int

        readVkMinFilter :: Mutable a -> IO (VkMinFilterMType a)

        writeVkMinFilter :: Mutable a -> VkMinFilterMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minFilter'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinFilter a

instance {-# OVERLAPPING #-} HasVkMinFilter VkSamplerCreateInfo
         where
        type VkMinFilterMType VkSamplerCreateInfo = VkFilter
        vkMinFilter (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkFilter),
            I## o <- vkMinFilterByteOffset (undefined :: VkSamplerCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinFilter #-}
        vkMinFilterByteOffset ~_
          = #{offset VkSamplerCreateInfo, minFilter}

        {-# INLINE vkMinFilterByteOffset #-}
        readVkMinFilter (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFilter),
            I## o <- vkMinFilterByteOffset (undefined :: VkSamplerCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinFilter #-}
        writeVkMinFilter (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinFilterByteOffset (undefined :: VkSamplerCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinFilter #-}

class HasVkMipmapMode a where
        type VkMipmapModeMType a :: *

        vkMipmapMode :: a -> VkMipmapModeMType a

        vkMipmapModeByteOffset :: a -> Int

        readVkMipmapMode :: Mutable a -> IO (VkMipmapModeMType a)

        writeVkMipmapMode :: Mutable a -> VkMipmapModeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'mipmapMode'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMipmapMode a

instance {-# OVERLAPPING #-} HasVkMipmapMode VkSamplerCreateInfo
         where
        type VkMipmapModeMType VkSamplerCreateInfo = VkSamplerMipmapMode
        vkMipmapMode (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkSamplerMipmapMode),
            I## o <- vkMipmapModeByteOffset (undefined :: VkSamplerCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMipmapMode #-}
        vkMipmapModeByteOffset ~_
          = #{offset VkSamplerCreateInfo, mipmapMode}

        {-# INLINE vkMipmapModeByteOffset #-}
        readVkMipmapMode (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSamplerMipmapMode),
            I## o <- vkMipmapModeByteOffset (undefined :: VkSamplerCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMipmapMode #-}
        writeVkMipmapMode (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMipmapModeByteOffset (undefined :: VkSamplerCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMipmapMode #-}

class HasVkAddressModeU a where
        type VkAddressModeUMType a :: *

        vkAddressModeU :: a -> VkAddressModeUMType a

        vkAddressModeUByteOffset :: a -> Int

        readVkAddressModeU :: Mutable a -> IO (VkAddressModeUMType a)

        writeVkAddressModeU :: Mutable a -> VkAddressModeUMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'addressModeU'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAddressModeU a

instance {-# OVERLAPPING #-} HasVkAddressModeU VkSamplerCreateInfo
         where
        type VkAddressModeUMType VkSamplerCreateInfo = VkSamplerAddressMode
        vkAddressModeU (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkSamplerAddressMode),
            I## o <- vkAddressModeUByteOffset (undefined :: VkSamplerCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAddressModeU #-}
        vkAddressModeUByteOffset ~_
          = #{offset VkSamplerCreateInfo, addressModeU}

        {-# INLINE vkAddressModeUByteOffset #-}
        readVkAddressModeU (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSamplerAddressMode),
            I## o <- vkAddressModeUByteOffset (undefined :: VkSamplerCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAddressModeU #-}
        writeVkAddressModeU (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAddressModeUByteOffset (undefined :: VkSamplerCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAddressModeU #-}

class HasVkAddressModeV a where
        type VkAddressModeVMType a :: *

        vkAddressModeV :: a -> VkAddressModeVMType a

        vkAddressModeVByteOffset :: a -> Int

        readVkAddressModeV :: Mutable a -> IO (VkAddressModeVMType a)

        writeVkAddressModeV :: Mutable a -> VkAddressModeVMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'addressModeV'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAddressModeV a

instance {-# OVERLAPPING #-} HasVkAddressModeV VkSamplerCreateInfo
         where
        type VkAddressModeVMType VkSamplerCreateInfo = VkSamplerAddressMode
        vkAddressModeV (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkSamplerAddressMode),
            I## o <- vkAddressModeVByteOffset (undefined :: VkSamplerCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAddressModeV #-}
        vkAddressModeVByteOffset ~_
          = #{offset VkSamplerCreateInfo, addressModeV}

        {-# INLINE vkAddressModeVByteOffset #-}
        readVkAddressModeV (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSamplerAddressMode),
            I## o <- vkAddressModeVByteOffset (undefined :: VkSamplerCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAddressModeV #-}
        writeVkAddressModeV (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAddressModeVByteOffset (undefined :: VkSamplerCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAddressModeV #-}

class HasVkAddressModeW a where
        type VkAddressModeWMType a :: *

        vkAddressModeW :: a -> VkAddressModeWMType a

        vkAddressModeWByteOffset :: a -> Int

        readVkAddressModeW :: Mutable a -> IO (VkAddressModeWMType a)

        writeVkAddressModeW :: Mutable a -> VkAddressModeWMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'addressModeW'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAddressModeW a

instance {-# OVERLAPPING #-} HasVkAddressModeW VkSamplerCreateInfo
         where
        type VkAddressModeWMType VkSamplerCreateInfo = VkSamplerAddressMode
        vkAddressModeW (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkSamplerAddressMode),
            I## o <- vkAddressModeWByteOffset (undefined :: VkSamplerCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAddressModeW #-}
        vkAddressModeWByteOffset ~_
          = #{offset VkSamplerCreateInfo, addressModeW}

        {-# INLINE vkAddressModeWByteOffset #-}
        readVkAddressModeW (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSamplerAddressMode),
            I## o <- vkAddressModeWByteOffset (undefined :: VkSamplerCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAddressModeW #-}
        writeVkAddressModeW (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAddressModeWByteOffset (undefined :: VkSamplerCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAddressModeW #-}

class HasVkMipLodBias a where
        type VkMipLodBiasMType a :: *

        vkMipLodBias :: a -> VkMipLodBiasMType a

        vkMipLodBiasByteOffset :: a -> Int

        readVkMipLodBias :: Mutable a -> IO (VkMipLodBiasMType a)

        writeVkMipLodBias :: Mutable a -> VkMipLodBiasMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'mipLodBias'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMipLodBias a

instance {-# OVERLAPPING #-} HasVkMipLodBias VkSamplerCreateInfo
         where
        type VkMipLodBiasMType VkSamplerCreateInfo = Foreign.C.Types.CFloat
        vkMipLodBias (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMipLodBiasByteOffset (undefined :: VkSamplerCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMipLodBias #-}
        vkMipLodBiasByteOffset ~_
          = #{offset VkSamplerCreateInfo, mipLodBias}

        {-# INLINE vkMipLodBiasByteOffset #-}
        readVkMipLodBias (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMipLodBiasByteOffset (undefined :: VkSamplerCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMipLodBias #-}
        writeVkMipLodBias (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMipLodBiasByteOffset (undefined :: VkSamplerCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMipLodBias #-}

class HasVkAnisotropyEnable a where
        type VkAnisotropyEnableMType a :: *

        vkAnisotropyEnable :: a -> VkAnisotropyEnableMType a

        vkAnisotropyEnableByteOffset :: a -> Int

        readVkAnisotropyEnable ::
                               Mutable a -> IO (VkAnisotropyEnableMType a)

        writeVkAnisotropyEnable ::
                                Mutable a -> VkAnisotropyEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'anisotropyEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAnisotropyEnable a

instance {-# OVERLAPPING #-}
         HasVkAnisotropyEnable VkSamplerCreateInfo where
        type VkAnisotropyEnableMType VkSamplerCreateInfo = VkBool32
        vkAnisotropyEnable (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkAnisotropyEnableByteOffset
                      (undefined :: VkSamplerCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAnisotropyEnable #-}
        vkAnisotropyEnableByteOffset ~_
          = #{offset VkSamplerCreateInfo, anisotropyEnable}

        {-# INLINE vkAnisotropyEnableByteOffset #-}
        readVkAnisotropyEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkAnisotropyEnableByteOffset
                      (undefined :: VkSamplerCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAnisotropyEnable #-}
        writeVkAnisotropyEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAnisotropyEnableByteOffset
                      (undefined :: VkSamplerCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAnisotropyEnable #-}

class HasVkMaxAnisotropy a where
        type VkMaxAnisotropyMType a :: *

        vkMaxAnisotropy :: a -> VkMaxAnisotropyMType a

        vkMaxAnisotropyByteOffset :: a -> Int

        readVkMaxAnisotropy :: Mutable a -> IO (VkMaxAnisotropyMType a)

        writeVkMaxAnisotropy ::
                             Mutable a -> VkMaxAnisotropyMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxAnisotropy'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxAnisotropy a

instance {-# OVERLAPPING #-} HasVkMaxAnisotropy VkSamplerCreateInfo
         where
        type VkMaxAnisotropyMType VkSamplerCreateInfo =
             Foreign.C.Types.CFloat
        vkMaxAnisotropy (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMaxAnisotropyByteOffset
                      (undefined :: VkSamplerCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxAnisotropy #-}
        vkMaxAnisotropyByteOffset ~_
          = #{offset VkSamplerCreateInfo, maxAnisotropy}

        {-# INLINE vkMaxAnisotropyByteOffset #-}
        readVkMaxAnisotropy (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMaxAnisotropyByteOffset
                      (undefined :: VkSamplerCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxAnisotropy #-}
        writeVkMaxAnisotropy (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxAnisotropyByteOffset
                      (undefined :: VkSamplerCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxAnisotropy #-}

class HasVkCompareEnable a where
        type VkCompareEnableMType a :: *

        vkCompareEnable :: a -> VkCompareEnableMType a

        vkCompareEnableByteOffset :: a -> Int

        readVkCompareEnable :: Mutable a -> IO (VkCompareEnableMType a)

        writeVkCompareEnable ::
                             Mutable a -> VkCompareEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'compareEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCompareEnable a

instance {-# OVERLAPPING #-} HasVkCompareEnable VkSamplerCreateInfo
         where
        type VkCompareEnableMType VkSamplerCreateInfo = VkBool32
        vkCompareEnable (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkCompareEnableByteOffset
                      (undefined :: VkSamplerCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkCompareEnable #-}
        vkCompareEnableByteOffset ~_
          = #{offset VkSamplerCreateInfo, compareEnable}

        {-# INLINE vkCompareEnableByteOffset #-}
        readVkCompareEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkCompareEnableByteOffset
                      (undefined :: VkSamplerCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkCompareEnable #-}
        writeVkCompareEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkCompareEnableByteOffset
                      (undefined :: VkSamplerCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkCompareEnable #-}

instance {-# OVERLAPPING #-} HasVkCompareOp VkSamplerCreateInfo
         where
        type VkCompareOpMType VkSamplerCreateInfo = VkCompareOp
        vkCompareOp (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkCompareOp),
            I## o <- vkCompareOpByteOffset (undefined :: VkSamplerCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkCompareOp #-}
        vkCompareOpByteOffset ~_
          = #{offset VkSamplerCreateInfo, compareOp}

        {-# INLINE vkCompareOpByteOffset #-}
        readVkCompareOp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkCompareOp),
            I## o <- vkCompareOpByteOffset (undefined :: VkSamplerCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkCompareOp #-}
        writeVkCompareOp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkCompareOpByteOffset (undefined :: VkSamplerCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkCompareOp #-}

class HasVkMinLod a where
        type VkMinLodMType a :: *

        vkMinLod :: a -> VkMinLodMType a

        vkMinLodByteOffset :: a -> Int

        readVkMinLod :: Mutable a -> IO (VkMinLodMType a)

        writeVkMinLod :: Mutable a -> VkMinLodMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minLod'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinLod a

instance {-# OVERLAPPING #-} HasVkMinLod VkSamplerCreateInfo where
        type VkMinLodMType VkSamplerCreateInfo = Foreign.C.Types.CFloat
        vkMinLod (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMinLodByteOffset (undefined :: VkSamplerCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinLod #-}
        vkMinLodByteOffset ~_
          = #{offset VkSamplerCreateInfo, minLod}

        {-# INLINE vkMinLodByteOffset #-}
        readVkMinLod (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMinLodByteOffset (undefined :: VkSamplerCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinLod #-}
        writeVkMinLod (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinLodByteOffset (undefined :: VkSamplerCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinLod #-}

class HasVkMaxLod a where
        type VkMaxLodMType a :: *

        vkMaxLod :: a -> VkMaxLodMType a

        vkMaxLodByteOffset :: a -> Int

        readVkMaxLod :: Mutable a -> IO (VkMaxLodMType a)

        writeVkMaxLod :: Mutable a -> VkMaxLodMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxLod'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxLod a

instance {-# OVERLAPPING #-} HasVkMaxLod VkSamplerCreateInfo where
        type VkMaxLodMType VkSamplerCreateInfo = Foreign.C.Types.CFloat
        vkMaxLod (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMaxLodByteOffset (undefined :: VkSamplerCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxLod #-}
        vkMaxLodByteOffset ~_
          = #{offset VkSamplerCreateInfo, maxLod}

        {-# INLINE vkMaxLodByteOffset #-}
        readVkMaxLod (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMaxLodByteOffset (undefined :: VkSamplerCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxLod #-}
        writeVkMaxLod (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxLodByteOffset (undefined :: VkSamplerCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxLod #-}

class HasVkBorderColor a where
        type VkBorderColorMType a :: *

        vkBorderColor :: a -> VkBorderColorMType a

        vkBorderColorByteOffset :: a -> Int

        readVkBorderColor :: Mutable a -> IO (VkBorderColorMType a)

        writeVkBorderColor :: Mutable a -> VkBorderColorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'borderColor'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBorderColor a

instance {-# OVERLAPPING #-} HasVkBorderColor VkSamplerCreateInfo
         where
        type VkBorderColorMType VkSamplerCreateInfo = VkBorderColor
        vkBorderColor (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBorderColor),
            I## o <- vkBorderColorByteOffset (undefined :: VkSamplerCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBorderColor #-}
        vkBorderColorByteOffset ~_
          = #{offset VkSamplerCreateInfo, borderColor}

        {-# INLINE vkBorderColorByteOffset #-}
        readVkBorderColor (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBorderColor),
            I## o <- vkBorderColorByteOffset (undefined :: VkSamplerCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBorderColor #-}
        writeVkBorderColor (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBorderColorByteOffset (undefined :: VkSamplerCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBorderColor #-}

class HasVkUnnormalizedCoordinates a where
        type VkUnnormalizedCoordinatesMType a :: *

        vkUnnormalizedCoordinates :: a -> VkUnnormalizedCoordinatesMType a

        vkUnnormalizedCoordinatesByteOffset :: a -> Int

        readVkUnnormalizedCoordinates ::
                                      Mutable a -> IO (VkUnnormalizedCoordinatesMType a)

        writeVkUnnormalizedCoordinates ::
                                       Mutable a -> VkUnnormalizedCoordinatesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'unnormalizedCoordinates'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkUnnormalizedCoordinates a

instance {-# OVERLAPPING #-}
         HasVkUnnormalizedCoordinates VkSamplerCreateInfo where
        type VkUnnormalizedCoordinatesMType VkSamplerCreateInfo = VkBool32
        vkUnnormalizedCoordinates (VkSamplerCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkUnnormalizedCoordinatesByteOffset
                      (undefined :: VkSamplerCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkUnnormalizedCoordinates #-}
        vkUnnormalizedCoordinatesByteOffset ~_
          = #{offset VkSamplerCreateInfo, unnormalizedCoordinates}

        {-# INLINE vkUnnormalizedCoordinatesByteOffset #-}
        readVkUnnormalizedCoordinates (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkUnnormalizedCoordinatesByteOffset
                      (undefined :: VkSamplerCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkUnnormalizedCoordinates #-}
        writeVkUnnormalizedCoordinates (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkUnnormalizedCoordinatesByteOffset
                      (undefined :: VkSamplerCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkUnnormalizedCoordinates #-}

instance Show VkSamplerCreateInfo where
        showsPrec d x
          = showString "VkSamplerCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkMagFilter = " .
                                  showsPrec d (vkMagFilter x) .
                                    showString ", " .
                                      showString "vkMinFilter = " .
                                        showsPrec d (vkMinFilter x) .
                                          showString ", " .
                                            showString "vkMipmapMode = " .
                                              showsPrec d (vkMipmapMode x) .
                                                showString ", " .
                                                  showString "vkAddressModeU = " .
                                                    showsPrec d (vkAddressModeU x) .
                                                      showString ", " .
                                                        showString "vkAddressModeV = " .
                                                          showsPrec d (vkAddressModeV x) .
                                                            showString ", " .
                                                              showString "vkAddressModeW = " .
                                                                showsPrec d (vkAddressModeW x) .
                                                                  showString ", " .
                                                                    showString "vkMipLodBias = " .
                                                                      showsPrec d (vkMipLodBias x) .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkAnisotropyEnable = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkAnisotropyEnable x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkMaxAnisotropy = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkMaxAnisotropy
                                                                                       x)
                                                                                    .
                                                                                    showString ", "
                                                                                      .
                                                                                      showString
                                                                                        "vkCompareEnable = "
                                                                                        .
                                                                                        showsPrec d
                                                                                          (vkCompareEnable
                                                                                             x)
                                                                                          .
                                                                                          showString
                                                                                            ", "
                                                                                            .
                                                                                            showString
                                                                                              "vkCompareOp = "
                                                                                              .
                                                                                              showsPrec
                                                                                                d
                                                                                                (vkCompareOp
                                                                                                   x)
                                                                                                .
                                                                                                showString
                                                                                                  ", "
                                                                                                  .
                                                                                                  showString
                                                                                                    "vkMinLod = "
                                                                                                    .
                                                                                                    showsPrec
                                                                                                      d
                                                                                                      (vkMinLod
                                                                                                         x)
                                                                                                      .
                                                                                                      showString
                                                                                                        ", "
                                                                                                        .
                                                                                                        showString
                                                                                                          "vkMaxLod = "
                                                                                                          .
                                                                                                          showsPrec
                                                                                                            d
                                                                                                            (vkMaxLod
                                                                                                               x)
                                                                                                            .
                                                                                                            showString
                                                                                                              ", "
                                                                                                              .
                                                                                                              showString
                                                                                                                "vkBorderColor = "
                                                                                                                .
                                                                                                                showsPrec
                                                                                                                  d
                                                                                                                  (vkBorderColor
                                                                                                                     x)
                                                                                                                  .
                                                                                                                  showString
                                                                                                                    ", "
                                                                                                                    .
                                                                                                                    showString
                                                                                                                      "vkUnnormalizedCoordinates = "
                                                                                                                      .
                                                                                                                      showsPrec
                                                                                                                        d
                                                                                                                        (vkUnnormalizedCoordinates
                                                                                                                           x)
                                                                                                                        .
                                                                                                                        showChar
                                                                                                                          '}'

data VkCommandPoolCreateInfo = VkCommandPoolCreateInfo## ByteArray##

instance Eq VkCommandPoolCreateInfo where
        (VkCommandPoolCreateInfo## a) == (VkCommandPoolCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkCommandPoolCreateInfo where
        (VkCommandPoolCreateInfo## a) `compare` (VkCommandPoolCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkCommandPoolCreateInfo where
        sizeOf ~_ = #{size VkCommandPoolCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkCommandPoolCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkCommandPoolCreateInfo),
            I## a <- alignment (undefined :: VkCommandPoolCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkCommandPoolCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkCommandPoolCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkCommandPoolCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkCommandPoolCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkCommandPoolCreateInfo),
            I## a <- alignment (undefined :: VkCommandPoolCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkCommandPoolCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkCommandPoolCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkCommandPoolCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkCommandPoolCreateInfo),
            I## a <- alignment (undefined :: VkCommandPoolCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkCommandPoolCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkCommandPoolCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkCommandPoolCreateInfo
         where
        type VkSTypeMType VkCommandPoolCreateInfo = VkStructureType
        vkSType (VkCommandPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkCommandPoolCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkCommandPoolCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkCommandPoolCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkCommandPoolCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkCommandPoolCreateInfo
         where
        type VkPNextMType VkCommandPoolCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkCommandPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkCommandPoolCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkCommandPoolCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkCommandPoolCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkCommandPoolCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkCommandPoolCreateInfo
         where
        type VkFlagsMType VkCommandPoolCreateInfo =
             VkCommandPoolCreateFlags
        vkFlags (VkCommandPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkCommandPoolCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkCommandPoolCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkCommandPoolCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkCommandPoolCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkCommandPoolCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkCommandPoolCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

instance {-# OVERLAPPING #-}
         HasVkQueueFamilyIndex VkCommandPoolCreateInfo where
        type VkQueueFamilyIndexMType VkCommandPoolCreateInfo =
             Data.Word.Word32
        vkQueueFamilyIndex (VkCommandPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueFamilyIndexByteOffset
                      (undefined :: VkCommandPoolCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkQueueFamilyIndex #-}
        vkQueueFamilyIndexByteOffset ~_
          = #{offset VkCommandPoolCreateInfo, queueFamilyIndex}

        {-# INLINE vkQueueFamilyIndexByteOffset #-}
        readVkQueueFamilyIndex (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueFamilyIndexByteOffset
                      (undefined :: VkCommandPoolCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkQueueFamilyIndex #-}
        writeVkQueueFamilyIndex (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkQueueFamilyIndexByteOffset
                      (undefined :: VkCommandPoolCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkQueueFamilyIndex #-}

instance Show VkCommandPoolCreateInfo where
        showsPrec d x
          = showString "VkCommandPoolCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkQueueFamilyIndex = " .
                                  showsPrec d (vkQueueFamilyIndex x) . showChar '}'

data VkCommandBufferAllocateInfo = VkCommandBufferAllocateInfo## ByteArray##

instance Eq VkCommandBufferAllocateInfo where
        (VkCommandBufferAllocateInfo## a) ==
          (VkCommandBufferAllocateInfo## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkCommandBufferAllocateInfo where
        (VkCommandBufferAllocateInfo## a) `compare`
          (VkCommandBufferAllocateInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkCommandBufferAllocateInfo where
        sizeOf ~_ = #{size VkCommandBufferAllocateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkCommandBufferAllocateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkCommandBufferAllocateInfo),
            I## a <- alignment (undefined :: VkCommandBufferAllocateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkCommandBufferAllocateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkCommandBufferAllocateInfo## ba)
          | I## n <- sizeOf (undefined :: VkCommandBufferAllocateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkCommandBufferAllocateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkCommandBufferAllocateInfo),
            I## a <- alignment (undefined :: VkCommandBufferAllocateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkCommandBufferAllocateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkCommandBufferAllocateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkCommandBufferAllocateInfo## ba)
          | I## n <- sizeOf (undefined :: VkCommandBufferAllocateInfo),
            I## a <- alignment (undefined :: VkCommandBufferAllocateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkCommandBufferAllocateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkCommandBufferAllocateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkCommandBufferAllocateInfo
         where
        type VkSTypeMType VkCommandBufferAllocateInfo = VkStructureType
        vkSType (VkCommandBufferAllocateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkCommandBufferAllocateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkCommandBufferAllocateInfo
         where
        type VkPNextMType VkCommandBufferAllocateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkCommandBufferAllocateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkCommandBufferAllocateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

class HasVkCommandPool a where
        type VkCommandPoolMType a :: *

        vkCommandPool :: a -> VkCommandPoolMType a

        vkCommandPoolByteOffset :: a -> Int

        readVkCommandPool :: Mutable a -> IO (VkCommandPoolMType a)

        writeVkCommandPool :: Mutable a -> VkCommandPoolMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'commandPool'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCommandPool a

instance {-# OVERLAPPING #-}
         HasVkCommandPool VkCommandBufferAllocateInfo where
        type VkCommandPoolMType VkCommandBufferAllocateInfo = VkCommandPool
        vkCommandPool (VkCommandBufferAllocateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkCommandPool),
            I## o <- vkCommandPoolByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkCommandPool #-}
        vkCommandPoolByteOffset ~_
          = #{offset VkCommandBufferAllocateInfo, commandPool}

        {-# INLINE vkCommandPoolByteOffset #-}
        readVkCommandPool (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkCommandPool),
            I## o <- vkCommandPoolByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkCommandPool #-}
        writeVkCommandPool (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkCommandPoolByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkCommandPool #-}

class HasVkLevel a where
        type VkLevelMType a :: *

        vkLevel :: a -> VkLevelMType a

        vkLevelByteOffset :: a -> Int

        readVkLevel :: Mutable a -> IO (VkLevelMType a)

        writeVkLevel :: Mutable a -> VkLevelMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'level'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLevel a

instance {-# OVERLAPPING #-} HasVkLevel VkCommandBufferAllocateInfo
         where
        type VkLevelMType VkCommandBufferAllocateInfo =
             VkCommandBufferLevel
        vkLevel (VkCommandBufferAllocateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkCommandBufferLevel),
            I## o <- vkLevelByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLevel #-}
        vkLevelByteOffset ~_
          = #{offset VkCommandBufferAllocateInfo, level}

        {-# INLINE vkLevelByteOffset #-}
        readVkLevel (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkCommandBufferLevel),
            I## o <- vkLevelByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLevel #-}
        writeVkLevel (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLevelByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLevel #-}

class HasVkCommandBufferCount a where
        type VkCommandBufferCountMType a :: *

        vkCommandBufferCount :: a -> VkCommandBufferCountMType a

        vkCommandBufferCountByteOffset :: a -> Int

        readVkCommandBufferCount ::
                                 Mutable a -> IO (VkCommandBufferCountMType a)

        writeVkCommandBufferCount ::
                                  Mutable a -> VkCommandBufferCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'commandBufferCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCommandBufferCount a

instance {-# OVERLAPPING #-}
         HasVkCommandBufferCount VkCommandBufferAllocateInfo where
        type VkCommandBufferCountMType VkCommandBufferAllocateInfo =
             Data.Word.Word32
        vkCommandBufferCount (VkCommandBufferAllocateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkCommandBufferCountByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkCommandBufferCount #-}
        vkCommandBufferCountByteOffset ~_
          = #{offset VkCommandBufferAllocateInfo, commandBufferCount}

        {-# INLINE vkCommandBufferCountByteOffset #-}
        readVkCommandBufferCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkCommandBufferCountByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkCommandBufferCount #-}
        writeVkCommandBufferCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkCommandBufferCountByteOffset
                      (undefined :: VkCommandBufferAllocateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkCommandBufferCount #-}

instance Show VkCommandBufferAllocateInfo where
        showsPrec d x
          = showString "VkCommandBufferAllocateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkCommandPool = " .
                            showsPrec d (vkCommandPool x) .
                              showString ", " .
                                showString "vkLevel = " .
                                  showsPrec d (vkLevel x) .
                                    showString ", " .
                                      showString "vkCommandBufferCount = " .
                                        showsPrec d (vkCommandBufferCount x) . showChar '}'

data VkCommandBufferInheritanceInfo = VkCommandBufferInheritanceInfo## ByteArray##

instance Eq VkCommandBufferInheritanceInfo where
        (VkCommandBufferInheritanceInfo## a) ==
          (VkCommandBufferInheritanceInfo## b) = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkCommandBufferInheritanceInfo where
        (VkCommandBufferInheritanceInfo## a) `compare`
          (VkCommandBufferInheritanceInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkCommandBufferInheritanceInfo where
        sizeOf ~_ = #{size VkCommandBufferInheritanceInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkCommandBufferInheritanceInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkCommandBufferInheritanceInfo),
            I## a <- alignment (undefined :: VkCommandBufferInheritanceInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkCommandBufferInheritanceInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkCommandBufferInheritanceInfo## ba)
          | I## n <- sizeOf (undefined :: VkCommandBufferInheritanceInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkCommandBufferInheritanceInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkCommandBufferInheritanceInfo),
            I## a <- alignment (undefined :: VkCommandBufferInheritanceInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkCommandBufferInheritanceInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkCommandBufferInheritanceInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkCommandBufferInheritanceInfo## ba)
          | I## n <- sizeOf (undefined :: VkCommandBufferInheritanceInfo),
            I## a <- alignment (undefined :: VkCommandBufferInheritanceInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkCommandBufferInheritanceInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkCommandBufferInheritanceInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-}
         HasVkSType VkCommandBufferInheritanceInfo where
        type VkSTypeMType VkCommandBufferInheritanceInfo = VkStructureType
        vkSType (VkCommandBufferInheritanceInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-}
         HasVkPNext VkCommandBufferInheritanceInfo where
        type VkPNextMType VkCommandBufferInheritanceInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkCommandBufferInheritanceInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-}
         HasVkRenderPass VkCommandBufferInheritanceInfo where
        type VkRenderPassMType VkCommandBufferInheritanceInfo =
             VkRenderPass
        vkRenderPass (VkCommandBufferInheritanceInfo## ba)
          | I## _n <- sizeOf (undefined :: VkRenderPass),
            I## o <- vkRenderPassByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkRenderPass #-}
        vkRenderPassByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, renderPass}

        {-# INLINE vkRenderPassByteOffset #-}
        readVkRenderPass (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkRenderPass),
            I## o <- vkRenderPassByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkRenderPass #-}
        writeVkRenderPass (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkRenderPassByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkRenderPass #-}

instance {-# OVERLAPPING #-}
         HasVkSubpass VkCommandBufferInheritanceInfo where
        type VkSubpassMType VkCommandBufferInheritanceInfo =
             Data.Word.Word32
        vkSubpass (VkCommandBufferInheritanceInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSubpassByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSubpass #-}
        vkSubpassByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, subpass}

        {-# INLINE vkSubpassByteOffset #-}
        readVkSubpass (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSubpassByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSubpass #-}
        writeVkSubpass (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSubpassByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSubpass #-}

class HasVkFramebuffer a where
        type VkFramebufferMType a :: *

        vkFramebuffer :: a -> VkFramebufferMType a

        vkFramebufferByteOffset :: a -> Int

        readVkFramebuffer :: Mutable a -> IO (VkFramebufferMType a)

        writeVkFramebuffer :: Mutable a -> VkFramebufferMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'framebuffer'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFramebuffer a

instance {-# OVERLAPPING #-}
         HasVkFramebuffer VkCommandBufferInheritanceInfo where
        type VkFramebufferMType VkCommandBufferInheritanceInfo =
             VkFramebuffer
        vkFramebuffer (VkCommandBufferInheritanceInfo## ba)
          | I## _n <- sizeOf (undefined :: VkFramebuffer),
            I## o <- vkFramebufferByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFramebuffer #-}
        vkFramebufferByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, framebuffer}

        {-# INLINE vkFramebufferByteOffset #-}
        readVkFramebuffer (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFramebuffer),
            I## o <- vkFramebufferByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFramebuffer #-}
        writeVkFramebuffer (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFramebufferByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFramebuffer #-}

class HasVkOcclusionQueryEnable a where
        type VkOcclusionQueryEnableMType a :: *

        vkOcclusionQueryEnable :: a -> VkOcclusionQueryEnableMType a

        vkOcclusionQueryEnableByteOffset :: a -> Int

        readVkOcclusionQueryEnable ::
                                   Mutable a -> IO (VkOcclusionQueryEnableMType a)

        writeVkOcclusionQueryEnable ::
                                    Mutable a -> VkOcclusionQueryEnableMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'occlusionQueryEnable'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkOcclusionQueryEnable a

instance {-# OVERLAPPING #-}
         HasVkOcclusionQueryEnable VkCommandBufferInheritanceInfo where
        type VkOcclusionQueryEnableMType VkCommandBufferInheritanceInfo =
             VkBool32
        vkOcclusionQueryEnable (VkCommandBufferInheritanceInfo## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkOcclusionQueryEnableByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOcclusionQueryEnable #-}
        vkOcclusionQueryEnableByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, occlusionQueryEnable}

        {-# INLINE vkOcclusionQueryEnableByteOffset #-}
        readVkOcclusionQueryEnable (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkOcclusionQueryEnableByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOcclusionQueryEnable #-}
        writeVkOcclusionQueryEnable (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOcclusionQueryEnableByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOcclusionQueryEnable #-}

class HasVkQueryFlags a where
        type VkQueryFlagsMType a :: *

        vkQueryFlags :: a -> VkQueryFlagsMType a

        vkQueryFlagsByteOffset :: a -> Int

        readVkQueryFlags :: Mutable a -> IO (VkQueryFlagsMType a)

        writeVkQueryFlags :: Mutable a -> VkQueryFlagsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queryFlags'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueryFlags a

instance {-# OVERLAPPING #-}
         HasVkQueryFlags VkCommandBufferInheritanceInfo where
        type VkQueryFlagsMType VkCommandBufferInheritanceInfo =
             VkQueryControlFlags
        vkQueryFlags (VkCommandBufferInheritanceInfo## ba)
          | I## _n <- sizeOf (undefined :: VkQueryControlFlags),
            I## o <- vkQueryFlagsByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkQueryFlags #-}
        vkQueryFlagsByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, queryFlags}

        {-# INLINE vkQueryFlagsByteOffset #-}
        readVkQueryFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkQueryControlFlags),
            I## o <- vkQueryFlagsByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkQueryFlags #-}
        writeVkQueryFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkQueryFlagsByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkQueryFlags #-}

class HasVkPipelineStatistics a where
        type VkPipelineStatisticsMType a :: *

        vkPipelineStatistics :: a -> VkPipelineStatisticsMType a

        vkPipelineStatisticsByteOffset :: a -> Int

        readVkPipelineStatistics ::
                                 Mutable a -> IO (VkPipelineStatisticsMType a)

        writeVkPipelineStatistics ::
                                  Mutable a -> VkPipelineStatisticsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pipelineStatistics'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPipelineStatistics a

instance {-# OVERLAPPING #-}
         HasVkPipelineStatistics VkCommandBufferInheritanceInfo where
        type VkPipelineStatisticsMType VkCommandBufferInheritanceInfo =
             VkQueryPipelineStatisticFlags
        vkPipelineStatistics (VkCommandBufferInheritanceInfo## ba)
          | I## _n <- sizeOf (undefined :: VkQueryPipelineStatisticFlags),
            I## o <- vkPipelineStatisticsByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPipelineStatistics #-}
        vkPipelineStatisticsByteOffset ~_
          = #{offset VkCommandBufferInheritanceInfo, pipelineStatistics}

        {-# INLINE vkPipelineStatisticsByteOffset #-}
        readVkPipelineStatistics (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkQueryPipelineStatisticFlags),
            I## o <- vkPipelineStatisticsByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPipelineStatistics #-}
        writeVkPipelineStatistics (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPipelineStatisticsByteOffset
                      (undefined :: VkCommandBufferInheritanceInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPipelineStatistics #-}

instance Show VkCommandBufferInheritanceInfo where
        showsPrec d x
          = showString "VkCommandBufferInheritanceInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkRenderPass = " .
                            showsPrec d (vkRenderPass x) .
                              showString ", " .
                                showString "vkSubpass = " .
                                  showsPrec d (vkSubpass x) .
                                    showString ", " .
                                      showString "vkFramebuffer = " .
                                        showsPrec d (vkFramebuffer x) .
                                          showString ", " .
                                            showString "vkOcclusionQueryEnable = " .
                                              showsPrec d (vkOcclusionQueryEnable x) .
                                                showString ", " .
                                                  showString "vkQueryFlags = " .
                                                    showsPrec d (vkQueryFlags x) .
                                                      showString ", " .
                                                        showString "vkPipelineStatistics = " .
                                                          showsPrec d (vkPipelineStatistics x) .
                                                            showChar '}'

data VkCommandBufferBeginInfo = VkCommandBufferBeginInfo## ByteArray##

instance Eq VkCommandBufferBeginInfo where
        (VkCommandBufferBeginInfo## a) == (VkCommandBufferBeginInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkCommandBufferBeginInfo where
        (VkCommandBufferBeginInfo## a) `compare`
          (VkCommandBufferBeginInfo## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkCommandBufferBeginInfo where
        sizeOf ~_ = #{size VkCommandBufferBeginInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkCommandBufferBeginInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkCommandBufferBeginInfo),
            I## a <- alignment (undefined :: VkCommandBufferBeginInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkCommandBufferBeginInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkCommandBufferBeginInfo## ba)
          | I## n <- sizeOf (undefined :: VkCommandBufferBeginInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkCommandBufferBeginInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkCommandBufferBeginInfo),
            I## a <- alignment (undefined :: VkCommandBufferBeginInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkCommandBufferBeginInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkCommandBufferBeginInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkCommandBufferBeginInfo## ba)
          | I## n <- sizeOf (undefined :: VkCommandBufferBeginInfo),
            I## a <- alignment (undefined :: VkCommandBufferBeginInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkCommandBufferBeginInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkCommandBufferBeginInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkCommandBufferBeginInfo
         where
        type VkSTypeMType VkCommandBufferBeginInfo = VkStructureType
        vkSType (VkCommandBufferBeginInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkCommandBufferBeginInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkCommandBufferBeginInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkCommandBufferBeginInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkCommandBufferBeginInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkCommandBufferBeginInfo
         where
        type VkPNextMType VkCommandBufferBeginInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkCommandBufferBeginInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkCommandBufferBeginInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkCommandBufferBeginInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkCommandBufferBeginInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkCommandBufferBeginInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkCommandBufferBeginInfo
         where
        type VkFlagsMType VkCommandBufferBeginInfo =
             VkCommandBufferUsageFlags
        vkFlags (VkCommandBufferBeginInfo## ba)
          | I## _n <- sizeOf (undefined :: VkCommandBufferUsageFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkCommandBufferBeginInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkCommandBufferBeginInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkCommandBufferUsageFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkCommandBufferBeginInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkCommandBufferBeginInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkPInheritanceInfo a where
        type VkPInheritanceInfoMType a :: *

        vkPInheritanceInfo :: a -> VkPInheritanceInfoMType a

        vkPInheritanceInfoByteOffset :: a -> Int

        readVkPInheritanceInfo ::
                               Mutable a -> IO (VkPInheritanceInfoMType a)

        writeVkPInheritanceInfo ::
                                Mutable a -> VkPInheritanceInfoMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pInheritanceInfo'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPInheritanceInfo a

instance {-# OVERLAPPING #-}
         HasVkPInheritanceInfo VkCommandBufferBeginInfo where
        type VkPInheritanceInfoMType VkCommandBufferBeginInfo =
             Foreign.Ptr.Ptr VkCommandBufferInheritanceInfo
        vkPInheritanceInfo (VkCommandBufferBeginInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkCommandBufferInheritanceInfo),
            I## o <- vkPInheritanceInfoByteOffset
                      (undefined :: VkCommandBufferBeginInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPInheritanceInfo #-}
        vkPInheritanceInfoByteOffset ~_
          = #{offset VkCommandBufferBeginInfo, pInheritanceInfo}

        {-# INLINE vkPInheritanceInfoByteOffset #-}
        readVkPInheritanceInfo (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkCommandBufferInheritanceInfo),
            I## o <- vkPInheritanceInfoByteOffset
                      (undefined :: VkCommandBufferBeginInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPInheritanceInfo #-}
        writeVkPInheritanceInfo (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPInheritanceInfoByteOffset
                      (undefined :: VkCommandBufferBeginInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPInheritanceInfo #-}

instance Show VkCommandBufferBeginInfo where
        showsPrec d x
          = showString "VkCommandBufferBeginInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkPInheritanceInfo = " .
                                  showsPrec d (vkPInheritanceInfo x) . showChar '}'

data VkRenderPassBeginInfo = VkRenderPassBeginInfo## ByteArray##

instance Eq VkRenderPassBeginInfo where
        (VkRenderPassBeginInfo## a) == (VkRenderPassBeginInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkRenderPassBeginInfo where
        (VkRenderPassBeginInfo## a) `compare` (VkRenderPassBeginInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkRenderPassBeginInfo where
        sizeOf ~_ = #{size VkRenderPassBeginInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkRenderPassBeginInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkRenderPassBeginInfo),
            I## a <- alignment (undefined :: VkRenderPassBeginInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkRenderPassBeginInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkRenderPassBeginInfo## ba)
          | I## n <- sizeOf (undefined :: VkRenderPassBeginInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkRenderPassBeginInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkRenderPassBeginInfo),
            I## a <- alignment (undefined :: VkRenderPassBeginInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkRenderPassBeginInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkRenderPassBeginInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkRenderPassBeginInfo## ba)
          | I## n <- sizeOf (undefined :: VkRenderPassBeginInfo),
            I## a <- alignment (undefined :: VkRenderPassBeginInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkRenderPassBeginInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkRenderPassBeginInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkRenderPassBeginInfo where
        type VkSTypeMType VkRenderPassBeginInfo = VkStructureType
        vkSType (VkRenderPassBeginInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkRenderPassBeginInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkRenderPassBeginInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkRenderPassBeginInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkRenderPassBeginInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkRenderPassBeginInfo where
        type VkPNextMType VkRenderPassBeginInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkRenderPassBeginInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkRenderPassBeginInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkRenderPassBeginInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkRenderPassBeginInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkRenderPassBeginInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkRenderPass VkRenderPassBeginInfo
         where
        type VkRenderPassMType VkRenderPassBeginInfo = VkRenderPass
        vkRenderPass (VkRenderPassBeginInfo## ba)
          | I## _n <- sizeOf (undefined :: VkRenderPass),
            I## o <- vkRenderPassByteOffset (undefined :: VkRenderPassBeginInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkRenderPass #-}
        vkRenderPassByteOffset ~_
          = #{offset VkRenderPassBeginInfo, renderPass}

        {-# INLINE vkRenderPassByteOffset #-}
        readVkRenderPass (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkRenderPass),
            I## o <- vkRenderPassByteOffset (undefined :: VkRenderPassBeginInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkRenderPass #-}
        writeVkRenderPass (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkRenderPassByteOffset (undefined :: VkRenderPassBeginInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkRenderPass #-}

instance {-# OVERLAPPING #-} HasVkFramebuffer VkRenderPassBeginInfo
         where
        type VkFramebufferMType VkRenderPassBeginInfo = VkFramebuffer
        vkFramebuffer (VkRenderPassBeginInfo## ba)
          | I## _n <- sizeOf (undefined :: VkFramebuffer),
            I## o <- vkFramebufferByteOffset
                      (undefined :: VkRenderPassBeginInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFramebuffer #-}
        vkFramebufferByteOffset ~_
          = #{offset VkRenderPassBeginInfo, framebuffer}

        {-# INLINE vkFramebufferByteOffset #-}
        readVkFramebuffer (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFramebuffer),
            I## o <- vkFramebufferByteOffset
                      (undefined :: VkRenderPassBeginInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFramebuffer #-}
        writeVkFramebuffer (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFramebufferByteOffset
                      (undefined :: VkRenderPassBeginInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFramebuffer #-}

class HasVkRenderArea a where
        type VkRenderAreaMType a :: *

        vkRenderArea :: a -> VkRenderAreaMType a

        vkRenderAreaByteOffset :: a -> Int

        readVkRenderArea :: Mutable a -> IO (VkRenderAreaMType a)

        writeVkRenderArea :: Mutable a -> VkRenderAreaMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'renderArea'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRenderArea a

instance {-# OVERLAPPING #-} HasVkRenderArea VkRenderPassBeginInfo
         where
        type VkRenderAreaMType VkRenderPassBeginInfo = VkRect2D
        vkRenderArea (VkRenderPassBeginInfo## ba)
          | I## _n <- sizeOf (undefined :: VkRect2D),
            I## o <- vkRenderAreaByteOffset (undefined :: VkRenderPassBeginInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkRenderArea #-}
        vkRenderAreaByteOffset ~_
          = #{offset VkRenderPassBeginInfo, renderArea}

        {-# INLINE vkRenderAreaByteOffset #-}
        readVkRenderArea (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkRect2D),
            I## o <- vkRenderAreaByteOffset (undefined :: VkRenderPassBeginInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkRenderArea #-}
        writeVkRenderArea (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkRenderAreaByteOffset (undefined :: VkRenderPassBeginInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkRenderArea #-}

class HasVkClearValueCount a where
        type VkClearValueCountMType a :: *

        vkClearValueCount :: a -> VkClearValueCountMType a

        vkClearValueCountByteOffset :: a -> Int

        readVkClearValueCount :: Mutable a -> IO (VkClearValueCountMType a)

        writeVkClearValueCount ::
                               Mutable a -> VkClearValueCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'clearValueCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkClearValueCount a

instance {-# OVERLAPPING #-}
         HasVkClearValueCount VkRenderPassBeginInfo where
        type VkClearValueCountMType VkRenderPassBeginInfo =
             Data.Word.Word32
        vkClearValueCount (VkRenderPassBeginInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkClearValueCountByteOffset
                      (undefined :: VkRenderPassBeginInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkClearValueCount #-}
        vkClearValueCountByteOffset ~_
          = #{offset VkRenderPassBeginInfo, clearValueCount}

        {-# INLINE vkClearValueCountByteOffset #-}
        readVkClearValueCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkClearValueCountByteOffset
                      (undefined :: VkRenderPassBeginInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkClearValueCount #-}
        writeVkClearValueCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkClearValueCountByteOffset
                      (undefined :: VkRenderPassBeginInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkClearValueCount #-}

class HasVkPClearValues a where
        type VkPClearValuesMType a :: *

        vkPClearValues :: a -> VkPClearValuesMType a

        vkPClearValuesByteOffset :: a -> Int

        readVkPClearValues :: Mutable a -> IO (VkPClearValuesMType a)

        writeVkPClearValues :: Mutable a -> VkPClearValuesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pClearValues'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPClearValues a

instance {-# OVERLAPPING #-}
         HasVkPClearValues VkRenderPassBeginInfo where
        type VkPClearValuesMType VkRenderPassBeginInfo =
             Foreign.Ptr.Ptr VkClearValue
        vkPClearValues (VkRenderPassBeginInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkClearValue),
            I## o <- vkPClearValuesByteOffset
                      (undefined :: VkRenderPassBeginInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPClearValues #-}
        vkPClearValuesByteOffset ~_
          = #{offset VkRenderPassBeginInfo, pClearValues}

        {-# INLINE vkPClearValuesByteOffset #-}
        readVkPClearValues (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkClearValue),
            I## o <- vkPClearValuesByteOffset
                      (undefined :: VkRenderPassBeginInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPClearValues #-}
        writeVkPClearValues (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPClearValuesByteOffset
                      (undefined :: VkRenderPassBeginInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPClearValues #-}

instance Show VkRenderPassBeginInfo where
        showsPrec d x
          = showString "VkRenderPassBeginInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkRenderPass = " .
                            showsPrec d (vkRenderPass x) .
                              showString ", " .
                                showString "vkFramebuffer = " .
                                  showsPrec d (vkFramebuffer x) .
                                    showString ", " .
                                      showString "vkRenderArea = " .
                                        showsPrec d (vkRenderArea x) .
                                          showString ", " .
                                            showString "vkClearValueCount = " .
                                              showsPrec d (vkClearValueCount x) .
                                                showString ", " .
                                                  showString "vkPClearValues = " .
                                                    showsPrec d (vkPClearValues x) . showChar '}'

-- | // Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.
--
data VkClearColorValue = VkClearColorValue## ByteArray##

instance Eq VkClearColorValue where
        (VkClearColorValue## a) == (VkClearColorValue## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkClearColorValue where
        (VkClearColorValue## a) `compare` (VkClearColorValue## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkClearColorValue where
        sizeOf ~_ = #{size VkClearColorValue}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkClearColorValue}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkClearColorValue),
            I## a <- alignment (undefined :: VkClearColorValue) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkClearColorValue## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkClearColorValue## ba)
          | I## n <- sizeOf (undefined :: VkClearColorValue) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkClearColorValue where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkClearColorValue),
            I## a <- alignment (undefined :: VkClearColorValue) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkClearColorValue## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkClearColorValue## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkClearColorValue## ba)
          | I## n <- sizeOf (undefined :: VkClearColorValue),
            I## a <- alignment (undefined :: VkClearColorValue) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkClearColorValue## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkClearColorValue## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkFloat32Array a where
        type VkFloat32ArrayMType a :: *

        vkFloat32Array :: a -> Int -> VkFloat32ArrayMType a

        vkFloat32ArrayByteOffset :: a -> Int

        readVkFloat32Array ::
                           Mutable a -> Int -> IO (VkFloat32ArrayMType a)

        writeVkFloat32Array ::
                            Mutable a -> Int -> VkFloat32ArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'float32'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFloat32Array a

instance {-# OVERLAPPING #-} HasVkFloat32Array VkClearColorValue
         where
        type VkFloat32ArrayMType VkClearColorValue = Foreign.C.Types.CFloat
        vkFloat32Array (VkClearColorValue## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkFloat32ArrayByteOffset (undefined :: VkClearColorValue) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkFloat32Array #-}
        vkFloat32ArrayByteOffset ~_
          = #{offset VkClearColorValue, float32}

        {-# INLINE vkFloat32ArrayByteOffset #-}
        readVkFloat32Array (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkFloat32ArrayByteOffset (undefined :: VkClearColorValue) =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkFloat32Array #-}
        writeVkFloat32Array (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkFloat32ArrayByteOffset (undefined :: VkClearColorValue) =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkFloat32Array #-}

class HasVkInt32Array a where
        type VkInt32ArrayMType a :: *

        vkInt32Array :: a -> Int -> VkInt32ArrayMType a

        vkInt32ArrayByteOffset :: a -> Int

        readVkInt32Array :: Mutable a -> Int -> IO (VkInt32ArrayMType a)

        writeVkInt32Array ::
                          Mutable a -> Int -> VkInt32ArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'int32'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkInt32Array a

instance {-# OVERLAPPING #-} HasVkInt32Array VkClearColorValue
         where
        type VkInt32ArrayMType VkClearColorValue = Data.Int.Int32
        vkInt32Array (VkClearColorValue## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkInt32ArrayByteOffset (undefined :: VkClearColorValue) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkInt32Array #-}
        vkInt32ArrayByteOffset ~_
          = #{offset VkClearColorValue, int32}

        {-# INLINE vkInt32ArrayByteOffset #-}
        readVkInt32Array (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkInt32ArrayByteOffset (undefined :: VkClearColorValue) =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkInt32Array #-}
        writeVkInt32Array (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkInt32ArrayByteOffset (undefined :: VkClearColorValue) =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkInt32Array #-}

class HasVkUint32Array a where
        type VkUint32ArrayMType a :: *

        vkUint32Array :: a -> Int -> VkUint32ArrayMType a

        vkUint32ArrayByteOffset :: a -> Int

        readVkUint32Array :: Mutable a -> Int -> IO (VkUint32ArrayMType a)

        writeVkUint32Array ::
                           Mutable a -> Int -> VkUint32ArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'uint32'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkUint32Array a

instance {-# OVERLAPPING #-} HasVkUint32Array VkClearColorValue
         where
        type VkUint32ArrayMType VkClearColorValue = Data.Word.Word32
        vkUint32Array (VkClearColorValue## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkUint32ArrayByteOffset (undefined :: VkClearColorValue) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkUint32Array #-}
        vkUint32ArrayByteOffset ~_
          = #{offset VkClearColorValue, uint32}

        {-# INLINE vkUint32ArrayByteOffset #-}
        readVkUint32Array (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkUint32ArrayByteOffset (undefined :: VkClearColorValue) =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkUint32Array #-}
        writeVkUint32Array (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkUint32ArrayByteOffset (undefined :: VkClearColorValue) =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkUint32Array #-}

instance Show VkClearColorValue where
        showsPrec d x
          = showString "VkClearColorValue {" .
              showString "vkFloat32Array = [" .
                showsPrec d (map (vkFloat32Array x) [1 .. 4]) .
                  showChar ']' .
                    showString ", " .
                      showString "vkInt32Array = [" .
                        showsPrec d (map (vkInt32Array x) [1 .. 4]) .
                          showChar ']' .
                            showString ", " .
                              showString "vkUint32Array = [" .
                                showsPrec d (map (vkUint32Array x) [1 .. 4]) .
                                  showChar ']' . showChar '}'

data VkClearDepthStencilValue = VkClearDepthStencilValue## ByteArray##

instance Eq VkClearDepthStencilValue where
        (VkClearDepthStencilValue## a) == (VkClearDepthStencilValue## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkClearDepthStencilValue where
        (VkClearDepthStencilValue## a) `compare`
          (VkClearDepthStencilValue## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkClearDepthStencilValue where
        sizeOf ~_ = #{size VkClearDepthStencilValue}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkClearDepthStencilValue}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkClearDepthStencilValue),
            I## a <- alignment (undefined :: VkClearDepthStencilValue) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkClearDepthStencilValue##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkClearDepthStencilValue## ba)
          | I## n <- sizeOf (undefined :: VkClearDepthStencilValue) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkClearDepthStencilValue where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkClearDepthStencilValue),
            I## a <- alignment (undefined :: VkClearDepthStencilValue) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkClearDepthStencilValue##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkClearDepthStencilValue## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkClearDepthStencilValue## ba)
          | I## n <- sizeOf (undefined :: VkClearDepthStencilValue),
            I## a <- alignment (undefined :: VkClearDepthStencilValue) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkClearDepthStencilValue## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkClearDepthStencilValue## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkDepth VkClearDepthStencilValue
         where
        type VkDepthMType VkClearDepthStencilValue = Foreign.C.Types.CFloat
        vkDepth (VkClearDepthStencilValue## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkDepthByteOffset (undefined :: VkClearDepthStencilValue) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepth #-}
        vkDepthByteOffset ~_
          = #{offset VkClearDepthStencilValue, depth}

        {-# INLINE vkDepthByteOffset #-}
        readVkDepth (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkDepthByteOffset (undefined :: VkClearDepthStencilValue) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepth #-}
        writeVkDepth (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthByteOffset (undefined :: VkClearDepthStencilValue) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepth #-}

class HasVkStencil a where
        type VkStencilMType a :: *

        vkStencil :: a -> VkStencilMType a

        vkStencilByteOffset :: a -> Int

        readVkStencil :: Mutable a -> IO (VkStencilMType a)

        writeVkStencil :: Mutable a -> VkStencilMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stencil'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStencil a

instance {-# OVERLAPPING #-} HasVkStencil VkClearDepthStencilValue
         where
        type VkStencilMType VkClearDepthStencilValue = Data.Word.Word32
        vkStencil (VkClearDepthStencilValue## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkStencilByteOffset (undefined :: VkClearDepthStencilValue)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkStencil #-}
        vkStencilByteOffset ~_
          = #{offset VkClearDepthStencilValue, stencil}

        {-# INLINE vkStencilByteOffset #-}
        readVkStencil (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkStencilByteOffset (undefined :: VkClearDepthStencilValue)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkStencil #-}
        writeVkStencil (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkStencilByteOffset (undefined :: VkClearDepthStencilValue)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkStencil #-}

instance Show VkClearDepthStencilValue where
        showsPrec d x
          = showString "VkClearDepthStencilValue {" .
              showString "vkDepth = " .
                showsPrec d (vkDepth x) .
                  showString ", " .
                    showString "vkStencil = " .
                      showsPrec d (vkStencil x) . showChar '}'

-- | // Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared.
--
data VkClearValue = VkClearValue## ByteArray##

instance Eq VkClearValue where
        (VkClearValue## a) == (VkClearValue## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkClearValue where
        (VkClearValue## a) `compare` (VkClearValue## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkClearValue where
        sizeOf ~_ = #{size VkClearValue}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkClearValue}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkClearValue),
            I## a <- alignment (undefined :: VkClearValue) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkClearValue## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkClearValue## ba)
          | I## n <- sizeOf (undefined :: VkClearValue) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkClearValue where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkClearValue),
            I## a <- alignment (undefined :: VkClearValue) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkClearValue## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkClearValue## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkClearValue## ba)
          | I## n <- sizeOf (undefined :: VkClearValue),
            I## a <- alignment (undefined :: VkClearValue) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkClearValue## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkClearValue## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkColor a where
        type VkColorMType a :: *

        vkColor :: a -> VkColorMType a

        vkColorByteOffset :: a -> Int

        readVkColor :: Mutable a -> IO (VkColorMType a)

        writeVkColor :: Mutable a -> VkColorMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'color'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkColor a

instance {-# OVERLAPPING #-} HasVkColor VkClearValue where
        type VkColorMType VkClearValue = VkClearColorValue
        vkColor (VkClearValue## ba)
          | I## _n <- sizeOf (undefined :: VkClearColorValue),
            I## o <- vkColorByteOffset (undefined :: VkClearValue) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkColor #-}
        vkColorByteOffset ~_ = #{offset VkClearValue, color}

        {-# INLINE vkColorByteOffset #-}
        readVkColor (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkClearColorValue),
            I## o <- vkColorByteOffset (undefined :: VkClearValue) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkColor #-}
        writeVkColor (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkColorByteOffset (undefined :: VkClearValue) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkColor #-}

class HasVkDepthStencil a where
        type VkDepthStencilMType a :: *

        vkDepthStencil :: a -> VkDepthStencilMType a

        vkDepthStencilByteOffset :: a -> Int

        readVkDepthStencil :: Mutable a -> IO (VkDepthStencilMType a)

        writeVkDepthStencil :: Mutable a -> VkDepthStencilMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthStencil'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthStencil a

instance {-# OVERLAPPING #-} HasVkDepthStencil VkClearValue where
        type VkDepthStencilMType VkClearValue = VkClearDepthStencilValue
        vkDepthStencil (VkClearValue## ba)
          | I## _n <- sizeOf (undefined :: VkClearDepthStencilValue),
            I## o <- vkDepthStencilByteOffset (undefined :: VkClearValue) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthStencil #-}
        vkDepthStencilByteOffset ~_
          = #{offset VkClearValue, depthStencil}

        {-# INLINE vkDepthStencilByteOffset #-}
        readVkDepthStencil (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkClearDepthStencilValue),
            I## o <- vkDepthStencilByteOffset (undefined :: VkClearValue) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthStencil #-}
        writeVkDepthStencil (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthStencilByteOffset (undefined :: VkClearValue) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthStencil #-}

instance Show VkClearValue where
        showsPrec d x
          = showString "VkClearValue {" .
              showString "vkColor = " .
                showsPrec d (vkColor x) .
                  showString ", " .
                    showString "vkDepthStencil = " .
                      showsPrec d (vkDepthStencil x) . showChar '}'

data VkClearAttachment = VkClearAttachment## ByteArray##

instance Eq VkClearAttachment where
        (VkClearAttachment## a) == (VkClearAttachment## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkClearAttachment where
        (VkClearAttachment## a) `compare` (VkClearAttachment## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkClearAttachment where
        sizeOf ~_ = #{size VkClearAttachment}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkClearAttachment}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkClearAttachment),
            I## a <- alignment (undefined :: VkClearAttachment) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkClearAttachment## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkClearAttachment## ba)
          | I## n <- sizeOf (undefined :: VkClearAttachment) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkClearAttachment where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkClearAttachment),
            I## a <- alignment (undefined :: VkClearAttachment) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkClearAttachment## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkClearAttachment## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkClearAttachment## ba)
          | I## n <- sizeOf (undefined :: VkClearAttachment),
            I## a <- alignment (undefined :: VkClearAttachment) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkClearAttachment## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkClearAttachment## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkAspectMask VkClearAttachment
         where
        type VkAspectMaskMType VkClearAttachment = VkImageAspectFlags
        vkAspectMask (VkClearAttachment## ba)
          | I## _n <- sizeOf (undefined :: VkImageAspectFlags),
            I## o <- vkAspectMaskByteOffset (undefined :: VkClearAttachment) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAspectMask #-}
        vkAspectMaskByteOffset ~_
          = #{offset VkClearAttachment, aspectMask}

        {-# INLINE vkAspectMaskByteOffset #-}
        readVkAspectMask (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageAspectFlags),
            I## o <- vkAspectMaskByteOffset (undefined :: VkClearAttachment) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAspectMask #-}
        writeVkAspectMask (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAspectMaskByteOffset (undefined :: VkClearAttachment) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAspectMask #-}

class HasVkColorAttachment a where
        type VkColorAttachmentMType a :: *

        vkColorAttachment :: a -> VkColorAttachmentMType a

        vkColorAttachmentByteOffset :: a -> Int

        readVkColorAttachment :: Mutable a -> IO (VkColorAttachmentMType a)

        writeVkColorAttachment ::
                               Mutable a -> VkColorAttachmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'colorAttachment'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkColorAttachment a

instance {-# OVERLAPPING #-} HasVkColorAttachment VkClearAttachment
         where
        type VkColorAttachmentMType VkClearAttachment = Data.Word.Word32
        vkColorAttachment (VkClearAttachment## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkColorAttachmentByteOffset
                      (undefined :: VkClearAttachment)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkColorAttachment #-}
        vkColorAttachmentByteOffset ~_
          = #{offset VkClearAttachment, colorAttachment}

        {-# INLINE vkColorAttachmentByteOffset #-}
        readVkColorAttachment (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkColorAttachmentByteOffset
                      (undefined :: VkClearAttachment)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkColorAttachment #-}
        writeVkColorAttachment (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkColorAttachmentByteOffset
                      (undefined :: VkClearAttachment)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkColorAttachment #-}

class HasVkClearValue a where
        type VkClearValueMType a :: *

        vkClearValue :: a -> VkClearValueMType a

        vkClearValueByteOffset :: a -> Int

        readVkClearValue :: Mutable a -> IO (VkClearValueMType a)

        writeVkClearValue :: Mutable a -> VkClearValueMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'clearValue'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkClearValue a

instance {-# OVERLAPPING #-} HasVkClearValue VkClearAttachment
         where
        type VkClearValueMType VkClearAttachment = VkClearValue
        vkClearValue (VkClearAttachment## ba)
          | I## _n <- sizeOf (undefined :: VkClearValue),
            I## o <- vkClearValueByteOffset (undefined :: VkClearAttachment) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkClearValue #-}
        vkClearValueByteOffset ~_
          = #{offset VkClearAttachment, clearValue}

        {-# INLINE vkClearValueByteOffset #-}
        readVkClearValue (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkClearValue),
            I## o <- vkClearValueByteOffset (undefined :: VkClearAttachment) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkClearValue #-}
        writeVkClearValue (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkClearValueByteOffset (undefined :: VkClearAttachment) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkClearValue #-}

instance Show VkClearAttachment where
        showsPrec d x
          = showString "VkClearAttachment {" .
              showString "vkAspectMask = " .
                showsPrec d (vkAspectMask x) .
                  showString ", " .
                    showString "vkColorAttachment = " .
                      showsPrec d (vkColorAttachment x) .
                        showString ", " .
                          showString "vkClearValue = " .
                            showsPrec d (vkClearValue x) . showChar '}'

data VkAttachmentDescription = VkAttachmentDescription## ByteArray##

instance Eq VkAttachmentDescription where
        (VkAttachmentDescription## a) == (VkAttachmentDescription## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkAttachmentDescription where
        (VkAttachmentDescription## a) `compare` (VkAttachmentDescription## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkAttachmentDescription where
        sizeOf ~_ = #{size VkAttachmentDescription}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkAttachmentDescription}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkAttachmentDescription),
            I## a <- alignment (undefined :: VkAttachmentDescription) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkAttachmentDescription##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkAttachmentDescription## ba)
          | I## n <- sizeOf (undefined :: VkAttachmentDescription) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkAttachmentDescription where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkAttachmentDescription),
            I## a <- alignment (undefined :: VkAttachmentDescription) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkAttachmentDescription##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkAttachmentDescription## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkAttachmentDescription## ba)
          | I## n <- sizeOf (undefined :: VkAttachmentDescription),
            I## a <- alignment (undefined :: VkAttachmentDescription) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkAttachmentDescription## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkAttachmentDescription## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkFlags VkAttachmentDescription
         where
        type VkFlagsMType VkAttachmentDescription =
             VkAttachmentDescriptionFlags
        vkFlags (VkAttachmentDescription## ba)
          | I## _n <- sizeOf (undefined :: VkAttachmentDescriptionFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkAttachmentDescription) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkAttachmentDescription, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkAttachmentDescriptionFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkAttachmentDescription) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkAttachmentDescription) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

instance {-# OVERLAPPING #-} HasVkFormat VkAttachmentDescription
         where
        type VkFormatMType VkAttachmentDescription = VkFormat
        vkFormat (VkAttachmentDescription## ba)
          | I## _n <- sizeOf (undefined :: VkFormat),
            I## o <- vkFormatByteOffset (undefined :: VkAttachmentDescription) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFormat #-}
        vkFormatByteOffset ~_
          = #{offset VkAttachmentDescription, format}

        {-# INLINE vkFormatByteOffset #-}
        readVkFormat (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFormat),
            I## o <- vkFormatByteOffset (undefined :: VkAttachmentDescription) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFormat #-}
        writeVkFormat (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFormatByteOffset (undefined :: VkAttachmentDescription) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFormat #-}

instance {-# OVERLAPPING #-} HasVkSamples VkAttachmentDescription
         where
        type VkSamplesMType VkAttachmentDescription = VkSampleCountFlagBits
        vkSamples (VkAttachmentDescription## ba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlagBits),
            I## o <- vkSamplesByteOffset (undefined :: VkAttachmentDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSamples #-}
        vkSamplesByteOffset ~_
          = #{offset VkAttachmentDescription, samples}

        {-# INLINE vkSamplesByteOffset #-}
        readVkSamples (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlagBits),
            I## o <- vkSamplesByteOffset (undefined :: VkAttachmentDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSamples #-}
        writeVkSamples (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSamplesByteOffset (undefined :: VkAttachmentDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSamples #-}

class HasVkLoadOp a where
        type VkLoadOpMType a :: *

        vkLoadOp :: a -> VkLoadOpMType a

        vkLoadOpByteOffset :: a -> Int

        readVkLoadOp :: Mutable a -> IO (VkLoadOpMType a)

        writeVkLoadOp :: Mutable a -> VkLoadOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'loadOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLoadOp a

instance {-# OVERLAPPING #-} HasVkLoadOp VkAttachmentDescription
         where
        type VkLoadOpMType VkAttachmentDescription = VkAttachmentLoadOp
        vkLoadOp (VkAttachmentDescription## ba)
          | I## _n <- sizeOf (undefined :: VkAttachmentLoadOp),
            I## o <- vkLoadOpByteOffset (undefined :: VkAttachmentDescription) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLoadOp #-}
        vkLoadOpByteOffset ~_
          = #{offset VkAttachmentDescription, loadOp}

        {-# INLINE vkLoadOpByteOffset #-}
        readVkLoadOp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkAttachmentLoadOp),
            I## o <- vkLoadOpByteOffset (undefined :: VkAttachmentDescription) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLoadOp #-}
        writeVkLoadOp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLoadOpByteOffset (undefined :: VkAttachmentDescription) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLoadOp #-}

class HasVkStoreOp a where
        type VkStoreOpMType a :: *

        vkStoreOp :: a -> VkStoreOpMType a

        vkStoreOpByteOffset :: a -> Int

        readVkStoreOp :: Mutable a -> IO (VkStoreOpMType a)

        writeVkStoreOp :: Mutable a -> VkStoreOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'storeOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStoreOp a

instance {-# OVERLAPPING #-} HasVkStoreOp VkAttachmentDescription
         where
        type VkStoreOpMType VkAttachmentDescription = VkAttachmentStoreOp
        vkStoreOp (VkAttachmentDescription## ba)
          | I## _n <- sizeOf (undefined :: VkAttachmentStoreOp),
            I## o <- vkStoreOpByteOffset (undefined :: VkAttachmentDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkStoreOp #-}
        vkStoreOpByteOffset ~_
          = #{offset VkAttachmentDescription, storeOp}

        {-# INLINE vkStoreOpByteOffset #-}
        readVkStoreOp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkAttachmentStoreOp),
            I## o <- vkStoreOpByteOffset (undefined :: VkAttachmentDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkStoreOp #-}
        writeVkStoreOp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkStoreOpByteOffset (undefined :: VkAttachmentDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkStoreOp #-}

class HasVkStencilLoadOp a where
        type VkStencilLoadOpMType a :: *

        vkStencilLoadOp :: a -> VkStencilLoadOpMType a

        vkStencilLoadOpByteOffset :: a -> Int

        readVkStencilLoadOp :: Mutable a -> IO (VkStencilLoadOpMType a)

        writeVkStencilLoadOp ::
                             Mutable a -> VkStencilLoadOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stencilLoadOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStencilLoadOp a

instance {-# OVERLAPPING #-}
         HasVkStencilLoadOp VkAttachmentDescription where
        type VkStencilLoadOpMType VkAttachmentDescription =
             VkAttachmentLoadOp
        vkStencilLoadOp (VkAttachmentDescription## ba)
          | I## _n <- sizeOf (undefined :: VkAttachmentLoadOp),
            I## o <- vkStencilLoadOpByteOffset
                      (undefined :: VkAttachmentDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkStencilLoadOp #-}
        vkStencilLoadOpByteOffset ~_
          = #{offset VkAttachmentDescription, stencilLoadOp}

        {-# INLINE vkStencilLoadOpByteOffset #-}
        readVkStencilLoadOp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkAttachmentLoadOp),
            I## o <- vkStencilLoadOpByteOffset
                      (undefined :: VkAttachmentDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkStencilLoadOp #-}
        writeVkStencilLoadOp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkStencilLoadOpByteOffset
                      (undefined :: VkAttachmentDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkStencilLoadOp #-}

class HasVkStencilStoreOp a where
        type VkStencilStoreOpMType a :: *

        vkStencilStoreOp :: a -> VkStencilStoreOpMType a

        vkStencilStoreOpByteOffset :: a -> Int

        readVkStencilStoreOp :: Mutable a -> IO (VkStencilStoreOpMType a)

        writeVkStencilStoreOp ::
                              Mutable a -> VkStencilStoreOpMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'stencilStoreOp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStencilStoreOp a

instance {-# OVERLAPPING #-}
         HasVkStencilStoreOp VkAttachmentDescription where
        type VkStencilStoreOpMType VkAttachmentDescription =
             VkAttachmentStoreOp
        vkStencilStoreOp (VkAttachmentDescription## ba)
          | I## _n <- sizeOf (undefined :: VkAttachmentStoreOp),
            I## o <- vkStencilStoreOpByteOffset
                      (undefined :: VkAttachmentDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkStencilStoreOp #-}
        vkStencilStoreOpByteOffset ~_
          = #{offset VkAttachmentDescription, stencilStoreOp}

        {-# INLINE vkStencilStoreOpByteOffset #-}
        readVkStencilStoreOp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkAttachmentStoreOp),
            I## o <- vkStencilStoreOpByteOffset
                      (undefined :: VkAttachmentDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkStencilStoreOp #-}
        writeVkStencilStoreOp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkStencilStoreOpByteOffset
                      (undefined :: VkAttachmentDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkStencilStoreOp #-}

instance {-# OVERLAPPING #-}
         HasVkInitialLayout VkAttachmentDescription where
        type VkInitialLayoutMType VkAttachmentDescription = VkImageLayout
        vkInitialLayout (VkAttachmentDescription## ba)
          | I## _n <- sizeOf (undefined :: VkImageLayout),
            I## o <- vkInitialLayoutByteOffset
                      (undefined :: VkAttachmentDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkInitialLayout #-}
        vkInitialLayoutByteOffset ~_
          = #{offset VkAttachmentDescription, initialLayout}

        {-# INLINE vkInitialLayoutByteOffset #-}
        readVkInitialLayout (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageLayout),
            I## o <- vkInitialLayoutByteOffset
                      (undefined :: VkAttachmentDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkInitialLayout #-}
        writeVkInitialLayout (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkInitialLayoutByteOffset
                      (undefined :: VkAttachmentDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkInitialLayout #-}

class HasVkFinalLayout a where
        type VkFinalLayoutMType a :: *

        vkFinalLayout :: a -> VkFinalLayoutMType a

        vkFinalLayoutByteOffset :: a -> Int

        readVkFinalLayout :: Mutable a -> IO (VkFinalLayoutMType a)

        writeVkFinalLayout :: Mutable a -> VkFinalLayoutMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'finalLayout'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFinalLayout a

instance {-# OVERLAPPING #-}
         HasVkFinalLayout VkAttachmentDescription where
        type VkFinalLayoutMType VkAttachmentDescription = VkImageLayout
        vkFinalLayout (VkAttachmentDescription## ba)
          | I## _n <- sizeOf (undefined :: VkImageLayout),
            I## o <- vkFinalLayoutByteOffset
                      (undefined :: VkAttachmentDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFinalLayout #-}
        vkFinalLayoutByteOffset ~_
          = #{offset VkAttachmentDescription, finalLayout}

        {-# INLINE vkFinalLayoutByteOffset #-}
        readVkFinalLayout (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageLayout),
            I## o <- vkFinalLayoutByteOffset
                      (undefined :: VkAttachmentDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFinalLayout #-}
        writeVkFinalLayout (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFinalLayoutByteOffset
                      (undefined :: VkAttachmentDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFinalLayout #-}

instance Show VkAttachmentDescription where
        showsPrec d x
          = showString "VkAttachmentDescription {" .
              showString "vkFlags = " .
                showsPrec d (vkFlags x) .
                  showString ", " .
                    showString "vkFormat = " .
                      showsPrec d (vkFormat x) .
                        showString ", " .
                          showString "vkSamples = " .
                            showsPrec d (vkSamples x) .
                              showString ", " .
                                showString "vkLoadOp = " .
                                  showsPrec d (vkLoadOp x) .
                                    showString ", " .
                                      showString "vkStoreOp = " .
                                        showsPrec d (vkStoreOp x) .
                                          showString ", " .
                                            showString "vkStencilLoadOp = " .
                                              showsPrec d (vkStencilLoadOp x) .
                                                showString ", " .
                                                  showString "vkStencilStoreOp = " .
                                                    showsPrec d (vkStencilStoreOp x) .
                                                      showString ", " .
                                                        showString "vkInitialLayout = " .
                                                          showsPrec d (vkInitialLayout x) .
                                                            showString ", " .
                                                              showString "vkFinalLayout = " .
                                                                showsPrec d (vkFinalLayout x) .
                                                                  showChar '}'

data VkAttachmentReference = VkAttachmentReference## ByteArray##

instance Eq VkAttachmentReference where
        (VkAttachmentReference## a) == (VkAttachmentReference## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkAttachmentReference where
        (VkAttachmentReference## a) `compare` (VkAttachmentReference## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkAttachmentReference where
        sizeOf ~_ = #{size VkAttachmentReference}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkAttachmentReference}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkAttachmentReference),
            I## a <- alignment (undefined :: VkAttachmentReference) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkAttachmentReference## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkAttachmentReference## ba)
          | I## n <- sizeOf (undefined :: VkAttachmentReference) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkAttachmentReference where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkAttachmentReference),
            I## a <- alignment (undefined :: VkAttachmentReference) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkAttachmentReference##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkAttachmentReference## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkAttachmentReference## ba)
          | I## n <- sizeOf (undefined :: VkAttachmentReference),
            I## a <- alignment (undefined :: VkAttachmentReference) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkAttachmentReference## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkAttachmentReference## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkAttachment a where
        type VkAttachmentMType a :: *

        vkAttachment :: a -> VkAttachmentMType a

        vkAttachmentByteOffset :: a -> Int

        readVkAttachment :: Mutable a -> IO (VkAttachmentMType a)

        writeVkAttachment :: Mutable a -> VkAttachmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'attachment'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAttachment a

instance {-# OVERLAPPING #-} HasVkAttachment VkAttachmentReference
         where
        type VkAttachmentMType VkAttachmentReference = Data.Word.Word32
        vkAttachment (VkAttachmentReference## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkAttachmentByteOffset (undefined :: VkAttachmentReference)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAttachment #-}
        vkAttachmentByteOffset ~_
          = #{offset VkAttachmentReference, attachment}

        {-# INLINE vkAttachmentByteOffset #-}
        readVkAttachment (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkAttachmentByteOffset (undefined :: VkAttachmentReference)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAttachment #-}
        writeVkAttachment (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAttachmentByteOffset (undefined :: VkAttachmentReference)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAttachment #-}

instance {-# OVERLAPPING #-} HasVkLayout VkAttachmentReference
         where
        type VkLayoutMType VkAttachmentReference = VkImageLayout
        vkLayout (VkAttachmentReference## ba)
          | I## _n <- sizeOf (undefined :: VkImageLayout),
            I## o <- vkLayoutByteOffset (undefined :: VkAttachmentReference) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLayout #-}
        vkLayoutByteOffset ~_
          = #{offset VkAttachmentReference, layout}

        {-# INLINE vkLayoutByteOffset #-}
        readVkLayout (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageLayout),
            I## o <- vkLayoutByteOffset (undefined :: VkAttachmentReference) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLayout #-}
        writeVkLayout (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLayoutByteOffset (undefined :: VkAttachmentReference) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLayout #-}

instance Show VkAttachmentReference where
        showsPrec d x
          = showString "VkAttachmentReference {" .
              showString "vkAttachment = " .
                showsPrec d (vkAttachment x) .
                  showString ", " .
                    showString "vkLayout = " . showsPrec d (vkLayout x) . showChar '}'

data VkSubpassDescription = VkSubpassDescription## ByteArray##

instance Eq VkSubpassDescription where
        (VkSubpassDescription## a) == (VkSubpassDescription## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSubpassDescription where
        (VkSubpassDescription## a) `compare` (VkSubpassDescription## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSubpassDescription where
        sizeOf ~_ = #{size VkSubpassDescription}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSubpassDescription}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSubpassDescription),
            I## a <- alignment (undefined :: VkSubpassDescription) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSubpassDescription## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSubpassDescription## ba)
          | I## n <- sizeOf (undefined :: VkSubpassDescription) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSubpassDescription where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSubpassDescription),
            I## a <- alignment (undefined :: VkSubpassDescription) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSubpassDescription## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSubpassDescription## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSubpassDescription## ba)
          | I## n <- sizeOf (undefined :: VkSubpassDescription),
            I## a <- alignment (undefined :: VkSubpassDescription) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSubpassDescription## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSubpassDescription## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkFlags VkSubpassDescription where
        type VkFlagsMType VkSubpassDescription = VkSubpassDescriptionFlags
        vkFlags (VkSubpassDescription## ba)
          | I## _n <- sizeOf (undefined :: VkSubpassDescriptionFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkSubpassDescription) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkSubpassDescription, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSubpassDescriptionFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkSubpassDescription) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkSubpassDescription) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkPipelineBindPoint a where
        type VkPipelineBindPointMType a :: *

        vkPipelineBindPoint :: a -> VkPipelineBindPointMType a

        vkPipelineBindPointByteOffset :: a -> Int

        readVkPipelineBindPoint ::
                                Mutable a -> IO (VkPipelineBindPointMType a)

        writeVkPipelineBindPoint ::
                                 Mutable a -> VkPipelineBindPointMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pipelineBindPoint'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPipelineBindPoint a

instance {-# OVERLAPPING #-}
         HasVkPipelineBindPoint VkSubpassDescription where
        type VkPipelineBindPointMType VkSubpassDescription =
             VkPipelineBindPoint
        vkPipelineBindPoint (VkSubpassDescription## ba)
          | I## _n <- sizeOf (undefined :: VkPipelineBindPoint),
            I## o <- vkPipelineBindPointByteOffset
                      (undefined :: VkSubpassDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPipelineBindPoint #-}
        vkPipelineBindPointByteOffset ~_
          = #{offset VkSubpassDescription, pipelineBindPoint}

        {-# INLINE vkPipelineBindPointByteOffset #-}
        readVkPipelineBindPoint (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPipelineBindPoint),
            I## o <- vkPipelineBindPointByteOffset
                      (undefined :: VkSubpassDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPipelineBindPoint #-}
        writeVkPipelineBindPoint (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPipelineBindPointByteOffset
                      (undefined :: VkSubpassDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPipelineBindPoint #-}

class HasVkInputAttachmentCount a where
        type VkInputAttachmentCountMType a :: *

        vkInputAttachmentCount :: a -> VkInputAttachmentCountMType a

        vkInputAttachmentCountByteOffset :: a -> Int

        readVkInputAttachmentCount ::
                                   Mutable a -> IO (VkInputAttachmentCountMType a)

        writeVkInputAttachmentCount ::
                                    Mutable a -> VkInputAttachmentCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'inputAttachmentCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkInputAttachmentCount a

instance {-# OVERLAPPING #-}
         HasVkInputAttachmentCount VkSubpassDescription where
        type VkInputAttachmentCountMType VkSubpassDescription =
             Data.Word.Word32
        vkInputAttachmentCount (VkSubpassDescription## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkInputAttachmentCountByteOffset
                      (undefined :: VkSubpassDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkInputAttachmentCount #-}
        vkInputAttachmentCountByteOffset ~_
          = #{offset VkSubpassDescription, inputAttachmentCount}

        {-# INLINE vkInputAttachmentCountByteOffset #-}
        readVkInputAttachmentCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkInputAttachmentCountByteOffset
                      (undefined :: VkSubpassDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkInputAttachmentCount #-}
        writeVkInputAttachmentCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkInputAttachmentCountByteOffset
                      (undefined :: VkSubpassDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkInputAttachmentCount #-}

class HasVkPInputAttachments a where
        type VkPInputAttachmentsMType a :: *

        vkPInputAttachments :: a -> VkPInputAttachmentsMType a

        vkPInputAttachmentsByteOffset :: a -> Int

        readVkPInputAttachments ::
                                Mutable a -> IO (VkPInputAttachmentsMType a)

        writeVkPInputAttachments ::
                                 Mutable a -> VkPInputAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pInputAttachments'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPInputAttachments a

instance {-# OVERLAPPING #-}
         HasVkPInputAttachments VkSubpassDescription where
        type VkPInputAttachmentsMType VkSubpassDescription =
             Foreign.Ptr.Ptr VkAttachmentReference
        vkPInputAttachments (VkSubpassDescription## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkAttachmentReference),
            I## o <- vkPInputAttachmentsByteOffset
                      (undefined :: VkSubpassDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPInputAttachments #-}
        vkPInputAttachmentsByteOffset ~_
          = #{offset VkSubpassDescription, pInputAttachments}

        {-# INLINE vkPInputAttachmentsByteOffset #-}
        readVkPInputAttachments (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkAttachmentReference),
            I## o <- vkPInputAttachmentsByteOffset
                      (undefined :: VkSubpassDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPInputAttachments #-}
        writeVkPInputAttachments (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPInputAttachmentsByteOffset
                      (undefined :: VkSubpassDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPInputAttachments #-}

class HasVkColorAttachmentCount a where
        type VkColorAttachmentCountMType a :: *

        vkColorAttachmentCount :: a -> VkColorAttachmentCountMType a

        vkColorAttachmentCountByteOffset :: a -> Int

        readVkColorAttachmentCount ::
                                   Mutable a -> IO (VkColorAttachmentCountMType a)

        writeVkColorAttachmentCount ::
                                    Mutable a -> VkColorAttachmentCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'colorAttachmentCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkColorAttachmentCount a

instance {-# OVERLAPPING #-}
         HasVkColorAttachmentCount VkSubpassDescription where
        type VkColorAttachmentCountMType VkSubpassDescription =
             Data.Word.Word32
        vkColorAttachmentCount (VkSubpassDescription## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkColorAttachmentCountByteOffset
                      (undefined :: VkSubpassDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkColorAttachmentCount #-}
        vkColorAttachmentCountByteOffset ~_
          = #{offset VkSubpassDescription, colorAttachmentCount}

        {-# INLINE vkColorAttachmentCountByteOffset #-}
        readVkColorAttachmentCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkColorAttachmentCountByteOffset
                      (undefined :: VkSubpassDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkColorAttachmentCount #-}
        writeVkColorAttachmentCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkColorAttachmentCountByteOffset
                      (undefined :: VkSubpassDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkColorAttachmentCount #-}

class HasVkPColorAttachments a where
        type VkPColorAttachmentsMType a :: *

        vkPColorAttachments :: a -> VkPColorAttachmentsMType a

        vkPColorAttachmentsByteOffset :: a -> Int

        readVkPColorAttachments ::
                                Mutable a -> IO (VkPColorAttachmentsMType a)

        writeVkPColorAttachments ::
                                 Mutable a -> VkPColorAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pColorAttachments'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPColorAttachments a

instance {-# OVERLAPPING #-}
         HasVkPColorAttachments VkSubpassDescription where
        type VkPColorAttachmentsMType VkSubpassDescription =
             Foreign.Ptr.Ptr VkAttachmentReference
        vkPColorAttachments (VkSubpassDescription## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkAttachmentReference),
            I## o <- vkPColorAttachmentsByteOffset
                      (undefined :: VkSubpassDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPColorAttachments #-}
        vkPColorAttachmentsByteOffset ~_
          = #{offset VkSubpassDescription, pColorAttachments}

        {-# INLINE vkPColorAttachmentsByteOffset #-}
        readVkPColorAttachments (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkAttachmentReference),
            I## o <- vkPColorAttachmentsByteOffset
                      (undefined :: VkSubpassDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPColorAttachments #-}
        writeVkPColorAttachments (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPColorAttachmentsByteOffset
                      (undefined :: VkSubpassDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPColorAttachments #-}

class HasVkPResolveAttachments a where
        type VkPResolveAttachmentsMType a :: *

        vkPResolveAttachments :: a -> VkPResolveAttachmentsMType a

        vkPResolveAttachmentsByteOffset :: a -> Int

        readVkPResolveAttachments ::
                                  Mutable a -> IO (VkPResolveAttachmentsMType a)

        writeVkPResolveAttachments ::
                                   Mutable a -> VkPResolveAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pResolveAttachments'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPResolveAttachments a

instance {-# OVERLAPPING #-}
         HasVkPResolveAttachments VkSubpassDescription where
        type VkPResolveAttachmentsMType VkSubpassDescription =
             Foreign.Ptr.Ptr VkAttachmentReference
        vkPResolveAttachments (VkSubpassDescription## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkAttachmentReference),
            I## o <- vkPResolveAttachmentsByteOffset
                      (undefined :: VkSubpassDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPResolveAttachments #-}
        vkPResolveAttachmentsByteOffset ~_
          = #{offset VkSubpassDescription, pResolveAttachments}

        {-# INLINE vkPResolveAttachmentsByteOffset #-}
        readVkPResolveAttachments (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkAttachmentReference),
            I## o <- vkPResolveAttachmentsByteOffset
                      (undefined :: VkSubpassDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPResolveAttachments #-}
        writeVkPResolveAttachments (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPResolveAttachmentsByteOffset
                      (undefined :: VkSubpassDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPResolveAttachments #-}

class HasVkPDepthStencilAttachment a where
        type VkPDepthStencilAttachmentMType a :: *

        vkPDepthStencilAttachment :: a -> VkPDepthStencilAttachmentMType a

        vkPDepthStencilAttachmentByteOffset :: a -> Int

        readVkPDepthStencilAttachment ::
                                      Mutable a -> IO (VkPDepthStencilAttachmentMType a)

        writeVkPDepthStencilAttachment ::
                                       Mutable a -> VkPDepthStencilAttachmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pDepthStencilAttachment'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPDepthStencilAttachment a

instance {-# OVERLAPPING #-}
         HasVkPDepthStencilAttachment VkSubpassDescription where
        type VkPDepthStencilAttachmentMType VkSubpassDescription =
             Foreign.Ptr.Ptr VkAttachmentReference
        vkPDepthStencilAttachment (VkSubpassDescription## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkAttachmentReference),
            I## o <- vkPDepthStencilAttachmentByteOffset
                      (undefined :: VkSubpassDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPDepthStencilAttachment #-}
        vkPDepthStencilAttachmentByteOffset ~_
          = #{offset VkSubpassDescription, pDepthStencilAttachment}

        {-# INLINE vkPDepthStencilAttachmentByteOffset #-}
        readVkPDepthStencilAttachment (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkAttachmentReference),
            I## o <- vkPDepthStencilAttachmentByteOffset
                      (undefined :: VkSubpassDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPDepthStencilAttachment #-}
        writeVkPDepthStencilAttachment (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPDepthStencilAttachmentByteOffset
                      (undefined :: VkSubpassDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPDepthStencilAttachment #-}

class HasVkPreserveAttachmentCount a where
        type VkPreserveAttachmentCountMType a :: *

        vkPreserveAttachmentCount :: a -> VkPreserveAttachmentCountMType a

        vkPreserveAttachmentCountByteOffset :: a -> Int

        readVkPreserveAttachmentCount ::
                                      Mutable a -> IO (VkPreserveAttachmentCountMType a)

        writeVkPreserveAttachmentCount ::
                                       Mutable a -> VkPreserveAttachmentCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'preserveAttachmentCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPreserveAttachmentCount a

instance {-# OVERLAPPING #-}
         HasVkPreserveAttachmentCount VkSubpassDescription where
        type VkPreserveAttachmentCountMType VkSubpassDescription =
             Data.Word.Word32
        vkPreserveAttachmentCount (VkSubpassDescription## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkPreserveAttachmentCountByteOffset
                      (undefined :: VkSubpassDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPreserveAttachmentCount #-}
        vkPreserveAttachmentCountByteOffset ~_
          = #{offset VkSubpassDescription, preserveAttachmentCount}

        {-# INLINE vkPreserveAttachmentCountByteOffset #-}
        readVkPreserveAttachmentCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkPreserveAttachmentCountByteOffset
                      (undefined :: VkSubpassDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPreserveAttachmentCount #-}
        writeVkPreserveAttachmentCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPreserveAttachmentCountByteOffset
                      (undefined :: VkSubpassDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPreserveAttachmentCount #-}

class HasVkPPreserveAttachments a where
        type VkPPreserveAttachmentsMType a :: *

        vkPPreserveAttachments :: a -> VkPPreserveAttachmentsMType a

        vkPPreserveAttachmentsByteOffset :: a -> Int

        readVkPPreserveAttachments ::
                                   Mutable a -> IO (VkPPreserveAttachmentsMType a)

        writeVkPPreserveAttachments ::
                                    Mutable a -> VkPPreserveAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pPreserveAttachments'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPPreserveAttachments a

instance {-# OVERLAPPING #-}
         HasVkPPreserveAttachments VkSubpassDescription where
        type VkPPreserveAttachmentsMType VkSubpassDescription =
             Foreign.Ptr.Ptr Data.Word.Word32
        vkPPreserveAttachments (VkSubpassDescription## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Word.Word32),
            I## o <- vkPPreserveAttachmentsByteOffset
                      (undefined :: VkSubpassDescription)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPPreserveAttachments #-}
        vkPPreserveAttachmentsByteOffset ~_
          = #{offset VkSubpassDescription, pPreserveAttachments}

        {-# INLINE vkPPreserveAttachmentsByteOffset #-}
        readVkPPreserveAttachments (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Word.Word32),
            I## o <- vkPPreserveAttachmentsByteOffset
                      (undefined :: VkSubpassDescription)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPPreserveAttachments #-}
        writeVkPPreserveAttachments (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPPreserveAttachmentsByteOffset
                      (undefined :: VkSubpassDescription)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPPreserveAttachments #-}

instance Show VkSubpassDescription where
        showsPrec d x
          = showString "VkSubpassDescription {" .
              showString "vkFlags = " .
                showsPrec d (vkFlags x) .
                  showString ", " .
                    showString "vkPipelineBindPoint = " .
                      showsPrec d (vkPipelineBindPoint x) .
                        showString ", " .
                          showString "vkInputAttachmentCount = " .
                            showsPrec d (vkInputAttachmentCount x) .
                              showString ", " .
                                showString "vkPInputAttachments = " .
                                  showsPrec d (vkPInputAttachments x) .
                                    showString ", " .
                                      showString "vkColorAttachmentCount = " .
                                        showsPrec d (vkColorAttachmentCount x) .
                                          showString ", " .
                                            showString "vkPColorAttachments = " .
                                              showsPrec d (vkPColorAttachments x) .
                                                showString ", " .
                                                  showString "vkPResolveAttachments = " .
                                                    showsPrec d (vkPResolveAttachments x) .
                                                      showString ", " .
                                                        showString "vkPDepthStencilAttachment = " .
                                                          showsPrec d (vkPDepthStencilAttachment x)
                                                            .
                                                            showString ", " .
                                                              showString
                                                                "vkPreserveAttachmentCount = "
                                                                .
                                                                showsPrec d
                                                                  (vkPreserveAttachmentCount x)
                                                                  .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkPPreserveAttachments = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkPPreserveAttachments x)
                                                                        . showChar '}'

data VkSubpassDependency = VkSubpassDependency## ByteArray##

instance Eq VkSubpassDependency where
        (VkSubpassDependency## a) == (VkSubpassDependency## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSubpassDependency where
        (VkSubpassDependency## a) `compare` (VkSubpassDependency## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSubpassDependency where
        sizeOf ~_ = #{size VkSubpassDependency}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSubpassDependency}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSubpassDependency),
            I## a <- alignment (undefined :: VkSubpassDependency) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSubpassDependency## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSubpassDependency## ba)
          | I## n <- sizeOf (undefined :: VkSubpassDependency) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSubpassDependency where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSubpassDependency),
            I## a <- alignment (undefined :: VkSubpassDependency) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSubpassDependency## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSubpassDependency## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSubpassDependency## ba)
          | I## n <- sizeOf (undefined :: VkSubpassDependency),
            I## a <- alignment (undefined :: VkSubpassDependency) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSubpassDependency## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSubpassDependency## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkSrcSubpass a where
        type VkSrcSubpassMType a :: *

        vkSrcSubpass :: a -> VkSrcSubpassMType a

        vkSrcSubpassByteOffset :: a -> Int

        readVkSrcSubpass :: Mutable a -> IO (VkSrcSubpassMType a)

        writeVkSrcSubpass :: Mutable a -> VkSrcSubpassMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcSubpass'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcSubpass a

instance {-# OVERLAPPING #-} HasVkSrcSubpass VkSubpassDependency
         where
        type VkSrcSubpassMType VkSubpassDependency = Data.Word.Word32
        vkSrcSubpass (VkSubpassDependency## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSrcSubpassByteOffset (undefined :: VkSubpassDependency) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSrcSubpass #-}
        vkSrcSubpassByteOffset ~_
          = #{offset VkSubpassDependency, srcSubpass}

        {-# INLINE vkSrcSubpassByteOffset #-}
        readVkSrcSubpass (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSrcSubpassByteOffset (undefined :: VkSubpassDependency) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSrcSubpass #-}
        writeVkSrcSubpass (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcSubpassByteOffset (undefined :: VkSubpassDependency) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSrcSubpass #-}

class HasVkDstSubpass a where
        type VkDstSubpassMType a :: *

        vkDstSubpass :: a -> VkDstSubpassMType a

        vkDstSubpassByteOffset :: a -> Int

        readVkDstSubpass :: Mutable a -> IO (VkDstSubpassMType a)

        writeVkDstSubpass :: Mutable a -> VkDstSubpassMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstSubpass'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstSubpass a

instance {-# OVERLAPPING #-} HasVkDstSubpass VkSubpassDependency
         where
        type VkDstSubpassMType VkSubpassDependency = Data.Word.Word32
        vkDstSubpass (VkSubpassDependency## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDstSubpassByteOffset (undefined :: VkSubpassDependency) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstSubpass #-}
        vkDstSubpassByteOffset ~_
          = #{offset VkSubpassDependency, dstSubpass}

        {-# INLINE vkDstSubpassByteOffset #-}
        readVkDstSubpass (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDstSubpassByteOffset (undefined :: VkSubpassDependency) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstSubpass #-}
        writeVkDstSubpass (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstSubpassByteOffset (undefined :: VkSubpassDependency) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstSubpass #-}

class HasVkSrcStageMask a where
        type VkSrcStageMaskMType a :: *

        vkSrcStageMask :: a -> VkSrcStageMaskMType a

        vkSrcStageMaskByteOffset :: a -> Int

        readVkSrcStageMask :: Mutable a -> IO (VkSrcStageMaskMType a)

        writeVkSrcStageMask :: Mutable a -> VkSrcStageMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcStageMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcStageMask a

instance {-# OVERLAPPING #-} HasVkSrcStageMask VkSubpassDependency
         where
        type VkSrcStageMaskMType VkSubpassDependency = VkPipelineStageFlags
        vkSrcStageMask (VkSubpassDependency## ba)
          | I## _n <- sizeOf (undefined :: VkPipelineStageFlags),
            I## o <- vkSrcStageMaskByteOffset (undefined :: VkSubpassDependency)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSrcStageMask #-}
        vkSrcStageMaskByteOffset ~_
          = #{offset VkSubpassDependency, srcStageMask}

        {-# INLINE vkSrcStageMaskByteOffset #-}
        readVkSrcStageMask (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPipelineStageFlags),
            I## o <- vkSrcStageMaskByteOffset (undefined :: VkSubpassDependency)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSrcStageMask #-}
        writeVkSrcStageMask (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcStageMaskByteOffset (undefined :: VkSubpassDependency)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSrcStageMask #-}

class HasVkDstStageMask a where
        type VkDstStageMaskMType a :: *

        vkDstStageMask :: a -> VkDstStageMaskMType a

        vkDstStageMaskByteOffset :: a -> Int

        readVkDstStageMask :: Mutable a -> IO (VkDstStageMaskMType a)

        writeVkDstStageMask :: Mutable a -> VkDstStageMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstStageMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstStageMask a

instance {-# OVERLAPPING #-} HasVkDstStageMask VkSubpassDependency
         where
        type VkDstStageMaskMType VkSubpassDependency = VkPipelineStageFlags
        vkDstStageMask (VkSubpassDependency## ba)
          | I## _n <- sizeOf (undefined :: VkPipelineStageFlags),
            I## o <- vkDstStageMaskByteOffset (undefined :: VkSubpassDependency)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstStageMask #-}
        vkDstStageMaskByteOffset ~_
          = #{offset VkSubpassDependency, dstStageMask}

        {-# INLINE vkDstStageMaskByteOffset #-}
        readVkDstStageMask (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPipelineStageFlags),
            I## o <- vkDstStageMaskByteOffset (undefined :: VkSubpassDependency)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstStageMask #-}
        writeVkDstStageMask (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstStageMaskByteOffset (undefined :: VkSubpassDependency)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstStageMask #-}

class HasVkSrcAccessMask a where
        type VkSrcAccessMaskMType a :: *

        vkSrcAccessMask :: a -> VkSrcAccessMaskMType a

        vkSrcAccessMaskByteOffset :: a -> Int

        readVkSrcAccessMask :: Mutable a -> IO (VkSrcAccessMaskMType a)

        writeVkSrcAccessMask ::
                             Mutable a -> VkSrcAccessMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'srcAccessMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSrcAccessMask a

instance {-# OVERLAPPING #-} HasVkSrcAccessMask VkSubpassDependency
         where
        type VkSrcAccessMaskMType VkSubpassDependency = VkAccessFlags
        vkSrcAccessMask (VkSubpassDependency## ba)
          | I## _n <- sizeOf (undefined :: VkAccessFlags),
            I## o <- vkSrcAccessMaskByteOffset
                      (undefined :: VkSubpassDependency)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSrcAccessMask #-}
        vkSrcAccessMaskByteOffset ~_
          = #{offset VkSubpassDependency, srcAccessMask}

        {-# INLINE vkSrcAccessMaskByteOffset #-}
        readVkSrcAccessMask (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkAccessFlags),
            I## o <- vkSrcAccessMaskByteOffset
                      (undefined :: VkSubpassDependency)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSrcAccessMask #-}
        writeVkSrcAccessMask (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSrcAccessMaskByteOffset
                      (undefined :: VkSubpassDependency)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSrcAccessMask #-}

class HasVkDstAccessMask a where
        type VkDstAccessMaskMType a :: *

        vkDstAccessMask :: a -> VkDstAccessMaskMType a

        vkDstAccessMaskByteOffset :: a -> Int

        readVkDstAccessMask :: Mutable a -> IO (VkDstAccessMaskMType a)

        writeVkDstAccessMask ::
                             Mutable a -> VkDstAccessMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dstAccessMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDstAccessMask a

instance {-# OVERLAPPING #-} HasVkDstAccessMask VkSubpassDependency
         where
        type VkDstAccessMaskMType VkSubpassDependency = VkAccessFlags
        vkDstAccessMask (VkSubpassDependency## ba)
          | I## _n <- sizeOf (undefined :: VkAccessFlags),
            I## o <- vkDstAccessMaskByteOffset
                      (undefined :: VkSubpassDependency)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDstAccessMask #-}
        vkDstAccessMaskByteOffset ~_
          = #{offset VkSubpassDependency, dstAccessMask}

        {-# INLINE vkDstAccessMaskByteOffset #-}
        readVkDstAccessMask (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkAccessFlags),
            I## o <- vkDstAccessMaskByteOffset
                      (undefined :: VkSubpassDependency)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDstAccessMask #-}
        writeVkDstAccessMask (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDstAccessMaskByteOffset
                      (undefined :: VkSubpassDependency)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDstAccessMask #-}

class HasVkDependencyFlags a where
        type VkDependencyFlagsMType a :: *

        vkDependencyFlags :: a -> VkDependencyFlagsMType a

        vkDependencyFlagsByteOffset :: a -> Int

        readVkDependencyFlags :: Mutable a -> IO (VkDependencyFlagsMType a)

        writeVkDependencyFlags ::
                               Mutable a -> VkDependencyFlagsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dependencyFlags'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDependencyFlags a

instance {-# OVERLAPPING #-}
         HasVkDependencyFlags VkSubpassDependency where
        type VkDependencyFlagsMType VkSubpassDependency = VkDependencyFlags
        vkDependencyFlags (VkSubpassDependency## ba)
          | I## _n <- sizeOf (undefined :: VkDependencyFlags),
            I## o <- vkDependencyFlagsByteOffset
                      (undefined :: VkSubpassDependency)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDependencyFlags #-}
        vkDependencyFlagsByteOffset ~_
          = #{offset VkSubpassDependency, dependencyFlags}

        {-# INLINE vkDependencyFlagsByteOffset #-}
        readVkDependencyFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDependencyFlags),
            I## o <- vkDependencyFlagsByteOffset
                      (undefined :: VkSubpassDependency)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDependencyFlags #-}
        writeVkDependencyFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDependencyFlagsByteOffset
                      (undefined :: VkSubpassDependency)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDependencyFlags #-}

instance Show VkSubpassDependency where
        showsPrec d x
          = showString "VkSubpassDependency {" .
              showString "vkSrcSubpass = " .
                showsPrec d (vkSrcSubpass x) .
                  showString ", " .
                    showString "vkDstSubpass = " .
                      showsPrec d (vkDstSubpass x) .
                        showString ", " .
                          showString "vkSrcStageMask = " .
                            showsPrec d (vkSrcStageMask x) .
                              showString ", " .
                                showString "vkDstStageMask = " .
                                  showsPrec d (vkDstStageMask x) .
                                    showString ", " .
                                      showString "vkSrcAccessMask = " .
                                        showsPrec d (vkSrcAccessMask x) .
                                          showString ", " .
                                            showString "vkDstAccessMask = " .
                                              showsPrec d (vkDstAccessMask x) .
                                                showString ", " .
                                                  showString "vkDependencyFlags = " .
                                                    showsPrec d (vkDependencyFlags x) . showChar '}'

data VkRenderPassCreateInfo = VkRenderPassCreateInfo## ByteArray##

instance Eq VkRenderPassCreateInfo where
        (VkRenderPassCreateInfo## a) == (VkRenderPassCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkRenderPassCreateInfo where
        (VkRenderPassCreateInfo## a) `compare` (VkRenderPassCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkRenderPassCreateInfo where
        sizeOf ~_ = #{size VkRenderPassCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkRenderPassCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkRenderPassCreateInfo),
            I## a <- alignment (undefined :: VkRenderPassCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkRenderPassCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkRenderPassCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkRenderPassCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkRenderPassCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkRenderPassCreateInfo),
            I## a <- alignment (undefined :: VkRenderPassCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkRenderPassCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkRenderPassCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkRenderPassCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkRenderPassCreateInfo),
            I## a <- alignment (undefined :: VkRenderPassCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkRenderPassCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkRenderPassCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkRenderPassCreateInfo
         where
        type VkSTypeMType VkRenderPassCreateInfo = VkStructureType
        vkSType (VkRenderPassCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkRenderPassCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkRenderPassCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkRenderPassCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkRenderPassCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkRenderPassCreateInfo
         where
        type VkPNextMType VkRenderPassCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkRenderPassCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkRenderPassCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkRenderPassCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkRenderPassCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkRenderPassCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkRenderPassCreateInfo
         where
        type VkFlagsMType VkRenderPassCreateInfo = VkRenderPassCreateFlags
        vkFlags (VkRenderPassCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkRenderPassCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkRenderPassCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkRenderPassCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkRenderPassCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkRenderPassCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkRenderPassCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

instance {-# OVERLAPPING #-}
         HasVkAttachmentCount VkRenderPassCreateInfo where
        type VkAttachmentCountMType VkRenderPassCreateInfo =
             Data.Word.Word32
        vkAttachmentCount (VkRenderPassCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkAttachmentCountByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAttachmentCount #-}
        vkAttachmentCountByteOffset ~_
          = #{offset VkRenderPassCreateInfo, attachmentCount}

        {-# INLINE vkAttachmentCountByteOffset #-}
        readVkAttachmentCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkAttachmentCountByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAttachmentCount #-}
        writeVkAttachmentCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAttachmentCountByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAttachmentCount #-}

instance {-# OVERLAPPING #-}
         HasVkPAttachments VkRenderPassCreateInfo where
        type VkPAttachmentsMType VkRenderPassCreateInfo =
             Foreign.Ptr.Ptr VkAttachmentDescription
        vkPAttachments (VkRenderPassCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkAttachmentDescription),
            I## o <- vkPAttachmentsByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPAttachments #-}
        vkPAttachmentsByteOffset ~_
          = #{offset VkRenderPassCreateInfo, pAttachments}

        {-# INLINE vkPAttachmentsByteOffset #-}
        readVkPAttachments (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkAttachmentDescription),
            I## o <- vkPAttachmentsByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPAttachments #-}
        writeVkPAttachments (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPAttachmentsByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPAttachments #-}

class HasVkSubpassCount a where
        type VkSubpassCountMType a :: *

        vkSubpassCount :: a -> VkSubpassCountMType a

        vkSubpassCountByteOffset :: a -> Int

        readVkSubpassCount :: Mutable a -> IO (VkSubpassCountMType a)

        writeVkSubpassCount :: Mutable a -> VkSubpassCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'subpassCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSubpassCount a

instance {-# OVERLAPPING #-}
         HasVkSubpassCount VkRenderPassCreateInfo where
        type VkSubpassCountMType VkRenderPassCreateInfo = Data.Word.Word32
        vkSubpassCount (VkRenderPassCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSubpassCountByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSubpassCount #-}
        vkSubpassCountByteOffset ~_
          = #{offset VkRenderPassCreateInfo, subpassCount}

        {-# INLINE vkSubpassCountByteOffset #-}
        readVkSubpassCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSubpassCountByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSubpassCount #-}
        writeVkSubpassCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSubpassCountByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSubpassCount #-}

class HasVkPSubpasses a where
        type VkPSubpassesMType a :: *

        vkPSubpasses :: a -> VkPSubpassesMType a

        vkPSubpassesByteOffset :: a -> Int

        readVkPSubpasses :: Mutable a -> IO (VkPSubpassesMType a)

        writeVkPSubpasses :: Mutable a -> VkPSubpassesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pSubpasses'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPSubpasses a

instance {-# OVERLAPPING #-} HasVkPSubpasses VkRenderPassCreateInfo
         where
        type VkPSubpassesMType VkRenderPassCreateInfo =
             Foreign.Ptr.Ptr VkSubpassDescription
        vkPSubpasses (VkRenderPassCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSubpassDescription),
            I## o <- vkPSubpassesByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPSubpasses #-}
        vkPSubpassesByteOffset ~_
          = #{offset VkRenderPassCreateInfo, pSubpasses}

        {-# INLINE vkPSubpassesByteOffset #-}
        readVkPSubpasses (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSubpassDescription),
            I## o <- vkPSubpassesByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPSubpasses #-}
        writeVkPSubpasses (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPSubpassesByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPSubpasses #-}

class HasVkDependencyCount a where
        type VkDependencyCountMType a :: *

        vkDependencyCount :: a -> VkDependencyCountMType a

        vkDependencyCountByteOffset :: a -> Int

        readVkDependencyCount :: Mutable a -> IO (VkDependencyCountMType a)

        writeVkDependencyCount ::
                               Mutable a -> VkDependencyCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dependencyCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDependencyCount a

instance {-# OVERLAPPING #-}
         HasVkDependencyCount VkRenderPassCreateInfo where
        type VkDependencyCountMType VkRenderPassCreateInfo =
             Data.Word.Word32
        vkDependencyCount (VkRenderPassCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDependencyCountByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDependencyCount #-}
        vkDependencyCountByteOffset ~_
          = #{offset VkRenderPassCreateInfo, dependencyCount}

        {-# INLINE vkDependencyCountByteOffset #-}
        readVkDependencyCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDependencyCountByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDependencyCount #-}
        writeVkDependencyCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDependencyCountByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDependencyCount #-}

class HasVkPDependencies a where
        type VkPDependenciesMType a :: *

        vkPDependencies :: a -> VkPDependenciesMType a

        vkPDependenciesByteOffset :: a -> Int

        readVkPDependencies :: Mutable a -> IO (VkPDependenciesMType a)

        writeVkPDependencies ::
                             Mutable a -> VkPDependenciesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pDependencies'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPDependencies a

instance {-# OVERLAPPING #-}
         HasVkPDependencies VkRenderPassCreateInfo where
        type VkPDependenciesMType VkRenderPassCreateInfo =
             Foreign.Ptr.Ptr VkSubpassDependency
        vkPDependencies (VkRenderPassCreateInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSubpassDependency),
            I## o <- vkPDependenciesByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPDependencies #-}
        vkPDependenciesByteOffset ~_
          = #{offset VkRenderPassCreateInfo, pDependencies}

        {-# INLINE vkPDependenciesByteOffset #-}
        readVkPDependencies (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkSubpassDependency),
            I## o <- vkPDependenciesByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPDependencies #-}
        writeVkPDependencies (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPDependenciesByteOffset
                      (undefined :: VkRenderPassCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPDependencies #-}

instance Show VkRenderPassCreateInfo where
        showsPrec d x
          = showString "VkRenderPassCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkAttachmentCount = " .
                                  showsPrec d (vkAttachmentCount x) .
                                    showString ", " .
                                      showString "vkPAttachments = " .
                                        showsPrec d (vkPAttachments x) .
                                          showString ", " .
                                            showString "vkSubpassCount = " .
                                              showsPrec d (vkSubpassCount x) .
                                                showString ", " .
                                                  showString "vkPSubpasses = " .
                                                    showsPrec d (vkPSubpasses x) .
                                                      showString ", " .
                                                        showString "vkDependencyCount = " .
                                                          showsPrec d (vkDependencyCount x) .
                                                            showString ", " .
                                                              showString "vkPDependencies = " .
                                                                showsPrec d (vkPDependencies x) .
                                                                  showChar '}'

data VkEventCreateInfo = VkEventCreateInfo## ByteArray##

instance Eq VkEventCreateInfo where
        (VkEventCreateInfo## a) == (VkEventCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkEventCreateInfo where
        (VkEventCreateInfo## a) `compare` (VkEventCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkEventCreateInfo where
        sizeOf ~_ = #{size VkEventCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkEventCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkEventCreateInfo),
            I## a <- alignment (undefined :: VkEventCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkEventCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkEventCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkEventCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkEventCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkEventCreateInfo),
            I## a <- alignment (undefined :: VkEventCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkEventCreateInfo## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkEventCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkEventCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkEventCreateInfo),
            I## a <- alignment (undefined :: VkEventCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkEventCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkEventCreateInfo## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkEventCreateInfo where
        type VkSTypeMType VkEventCreateInfo = VkStructureType
        vkSType (VkEventCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkEventCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_ = #{offset VkEventCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkEventCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkEventCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkEventCreateInfo where
        type VkPNextMType VkEventCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkEventCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkEventCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_ = #{offset VkEventCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkEventCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkEventCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkEventCreateInfo where
        type VkFlagsMType VkEventCreateInfo = VkEventCreateFlags
        vkFlags (VkEventCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkEventCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkEventCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_ = #{offset VkEventCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkEventCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkEventCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkEventCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

instance Show VkEventCreateInfo where
        showsPrec d x
          = showString "VkEventCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " . showsPrec d (vkFlags x) . showChar '}'

data VkFenceCreateInfo = VkFenceCreateInfo## ByteArray##

instance Eq VkFenceCreateInfo where
        (VkFenceCreateInfo## a) == (VkFenceCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkFenceCreateInfo where
        (VkFenceCreateInfo## a) `compare` (VkFenceCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkFenceCreateInfo where
        sizeOf ~_ = #{size VkFenceCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkFenceCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkFenceCreateInfo),
            I## a <- alignment (undefined :: VkFenceCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkFenceCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkFenceCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkFenceCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkFenceCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkFenceCreateInfo),
            I## a <- alignment (undefined :: VkFenceCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkFenceCreateInfo## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkFenceCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkFenceCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkFenceCreateInfo),
            I## a <- alignment (undefined :: VkFenceCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkFenceCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkFenceCreateInfo## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkFenceCreateInfo where
        type VkSTypeMType VkFenceCreateInfo = VkStructureType
        vkSType (VkFenceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkFenceCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_ = #{offset VkFenceCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkFenceCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkFenceCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkFenceCreateInfo where
        type VkPNextMType VkFenceCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkFenceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkFenceCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_ = #{offset VkFenceCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkFenceCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkFenceCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkFenceCreateInfo where
        type VkFlagsMType VkFenceCreateInfo = VkFenceCreateFlags
        vkFlags (VkFenceCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkFenceCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkFenceCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_ = #{offset VkFenceCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFenceCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkFenceCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkFenceCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

instance Show VkFenceCreateInfo where
        showsPrec d x
          = showString "VkFenceCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " . showsPrec d (vkFlags x) . showChar '}'

data VkPhysicalDeviceFeatures = VkPhysicalDeviceFeatures## ByteArray##

instance Eq VkPhysicalDeviceFeatures where
        (VkPhysicalDeviceFeatures## a) == (VkPhysicalDeviceFeatures## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPhysicalDeviceFeatures where
        (VkPhysicalDeviceFeatures## a) `compare`
          (VkPhysicalDeviceFeatures## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPhysicalDeviceFeatures where
        sizeOf ~_ = #{size VkPhysicalDeviceFeatures}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPhysicalDeviceFeatures}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceFeatures),
            I## a <- alignment (undefined :: VkPhysicalDeviceFeatures) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPhysicalDeviceFeatures##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPhysicalDeviceFeatures## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceFeatures) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPhysicalDeviceFeatures where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceFeatures),
            I## a <- alignment (undefined :: VkPhysicalDeviceFeatures) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPhysicalDeviceFeatures##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPhysicalDeviceFeatures## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPhysicalDeviceFeatures## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceFeatures),
            I## a <- alignment (undefined :: VkPhysicalDeviceFeatures) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPhysicalDeviceFeatures## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPhysicalDeviceFeatures## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkRobustBufferAccess a where
        type VkRobustBufferAccessMType a :: *

        vkRobustBufferAccess :: a -> VkRobustBufferAccessMType a

        vkRobustBufferAccessByteOffset :: a -> Int

        readVkRobustBufferAccess ::
                                 Mutable a -> IO (VkRobustBufferAccessMType a)

        writeVkRobustBufferAccess ::
                                  Mutable a -> VkRobustBufferAccessMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'robustBufferAccess'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkRobustBufferAccess a

instance {-# OVERLAPPING #-}
         HasVkRobustBufferAccess VkPhysicalDeviceFeatures where
        type VkRobustBufferAccessMType VkPhysicalDeviceFeatures = VkBool32
        vkRobustBufferAccess (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkRobustBufferAccessByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkRobustBufferAccess #-}
        vkRobustBufferAccessByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, robustBufferAccess}

        {-# INLINE vkRobustBufferAccessByteOffset #-}
        readVkRobustBufferAccess (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkRobustBufferAccessByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkRobustBufferAccess #-}
        writeVkRobustBufferAccess (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkRobustBufferAccessByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkRobustBufferAccess #-}

class HasVkFullDrawIndexUint32 a where
        type VkFullDrawIndexUint32MType a :: *

        vkFullDrawIndexUint32 :: a -> VkFullDrawIndexUint32MType a

        vkFullDrawIndexUint32ByteOffset :: a -> Int

        readVkFullDrawIndexUint32 ::
                                  Mutable a -> IO (VkFullDrawIndexUint32MType a)

        writeVkFullDrawIndexUint32 ::
                                   Mutable a -> VkFullDrawIndexUint32MType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'fullDrawIndexUint32'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFullDrawIndexUint32 a

instance {-# OVERLAPPING #-}
         HasVkFullDrawIndexUint32 VkPhysicalDeviceFeatures where
        type VkFullDrawIndexUint32MType VkPhysicalDeviceFeatures = VkBool32
        vkFullDrawIndexUint32 (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkFullDrawIndexUint32ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFullDrawIndexUint32 #-}
        vkFullDrawIndexUint32ByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, fullDrawIndexUint32}

        {-# INLINE vkFullDrawIndexUint32ByteOffset #-}
        readVkFullDrawIndexUint32 (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkFullDrawIndexUint32ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFullDrawIndexUint32 #-}
        writeVkFullDrawIndexUint32 (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFullDrawIndexUint32ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFullDrawIndexUint32 #-}

class HasVkImageCubeArray a where
        type VkImageCubeArrayMType a :: *

        vkImageCubeArray :: a -> VkImageCubeArrayMType a

        vkImageCubeArrayByteOffset :: a -> Int

        readVkImageCubeArray :: Mutable a -> IO (VkImageCubeArrayMType a)

        writeVkImageCubeArray ::
                              Mutable a -> VkImageCubeArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageCubeArray'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageCubeArray a

instance {-# OVERLAPPING #-}
         HasVkImageCubeArray VkPhysicalDeviceFeatures where
        type VkImageCubeArrayMType VkPhysicalDeviceFeatures = VkBool32
        vkImageCubeArray (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkImageCubeArrayByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageCubeArray #-}
        vkImageCubeArrayByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, imageCubeArray}

        {-# INLINE vkImageCubeArrayByteOffset #-}
        readVkImageCubeArray (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkImageCubeArrayByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageCubeArray #-}
        writeVkImageCubeArray (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageCubeArrayByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageCubeArray #-}

class HasVkIndependentBlend a where
        type VkIndependentBlendMType a :: *

        vkIndependentBlend :: a -> VkIndependentBlendMType a

        vkIndependentBlendByteOffset :: a -> Int

        readVkIndependentBlend ::
                               Mutable a -> IO (VkIndependentBlendMType a)

        writeVkIndependentBlend ::
                                Mutable a -> VkIndependentBlendMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'independentBlend'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkIndependentBlend a

instance {-# OVERLAPPING #-}
         HasVkIndependentBlend VkPhysicalDeviceFeatures where
        type VkIndependentBlendMType VkPhysicalDeviceFeatures = VkBool32
        vkIndependentBlend (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkIndependentBlendByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkIndependentBlend #-}
        vkIndependentBlendByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, independentBlend}

        {-# INLINE vkIndependentBlendByteOffset #-}
        readVkIndependentBlend (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkIndependentBlendByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkIndependentBlend #-}
        writeVkIndependentBlend (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkIndependentBlendByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkIndependentBlend #-}

class HasVkGeometryShader a where
        type VkGeometryShaderMType a :: *

        vkGeometryShader :: a -> VkGeometryShaderMType a

        vkGeometryShaderByteOffset :: a -> Int

        readVkGeometryShader :: Mutable a -> IO (VkGeometryShaderMType a)

        writeVkGeometryShader ::
                              Mutable a -> VkGeometryShaderMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'geometryShader'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkGeometryShader a

instance {-# OVERLAPPING #-}
         HasVkGeometryShader VkPhysicalDeviceFeatures where
        type VkGeometryShaderMType VkPhysicalDeviceFeatures = VkBool32
        vkGeometryShader (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkGeometryShaderByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkGeometryShader #-}
        vkGeometryShaderByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, geometryShader}

        {-# INLINE vkGeometryShaderByteOffset #-}
        readVkGeometryShader (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkGeometryShaderByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkGeometryShader #-}
        writeVkGeometryShader (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkGeometryShaderByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkGeometryShader #-}

class HasVkTessellationShader a where
        type VkTessellationShaderMType a :: *

        vkTessellationShader :: a -> VkTessellationShaderMType a

        vkTessellationShaderByteOffset :: a -> Int

        readVkTessellationShader ::
                                 Mutable a -> IO (VkTessellationShaderMType a)

        writeVkTessellationShader ::
                                  Mutable a -> VkTessellationShaderMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'tessellationShader'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTessellationShader a

instance {-# OVERLAPPING #-}
         HasVkTessellationShader VkPhysicalDeviceFeatures where
        type VkTessellationShaderMType VkPhysicalDeviceFeatures = VkBool32
        vkTessellationShader (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkTessellationShaderByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkTessellationShader #-}
        vkTessellationShaderByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, tessellationShader}

        {-# INLINE vkTessellationShaderByteOffset #-}
        readVkTessellationShader (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkTessellationShaderByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkTessellationShader #-}
        writeVkTessellationShader (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkTessellationShaderByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkTessellationShader #-}

class HasVkSampleRateShading a where
        type VkSampleRateShadingMType a :: *

        vkSampleRateShading :: a -> VkSampleRateShadingMType a

        vkSampleRateShadingByteOffset :: a -> Int

        readVkSampleRateShading ::
                                Mutable a -> IO (VkSampleRateShadingMType a)

        writeVkSampleRateShading ::
                                 Mutable a -> VkSampleRateShadingMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sampleRateShading'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampleRateShading a

instance {-# OVERLAPPING #-}
         HasVkSampleRateShading VkPhysicalDeviceFeatures where
        type VkSampleRateShadingMType VkPhysicalDeviceFeatures = VkBool32
        vkSampleRateShading (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSampleRateShadingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSampleRateShading #-}
        vkSampleRateShadingByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sampleRateShading}

        {-# INLINE vkSampleRateShadingByteOffset #-}
        readVkSampleRateShading (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSampleRateShadingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSampleRateShading #-}
        writeVkSampleRateShading (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSampleRateShadingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSampleRateShading #-}

class HasVkDualSrcBlend a where
        type VkDualSrcBlendMType a :: *

        vkDualSrcBlend :: a -> VkDualSrcBlendMType a

        vkDualSrcBlendByteOffset :: a -> Int

        readVkDualSrcBlend :: Mutable a -> IO (VkDualSrcBlendMType a)

        writeVkDualSrcBlend :: Mutable a -> VkDualSrcBlendMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'dualSrcBlend'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDualSrcBlend a

instance {-# OVERLAPPING #-}
         HasVkDualSrcBlend VkPhysicalDeviceFeatures where
        type VkDualSrcBlendMType VkPhysicalDeviceFeatures = VkBool32
        vkDualSrcBlend (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDualSrcBlendByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDualSrcBlend #-}
        vkDualSrcBlendByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, dualSrcBlend}

        {-# INLINE vkDualSrcBlendByteOffset #-}
        readVkDualSrcBlend (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDualSrcBlendByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDualSrcBlend #-}
        writeVkDualSrcBlend (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDualSrcBlendByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDualSrcBlend #-}

instance {-# OVERLAPPING #-} HasVkLogicOp VkPhysicalDeviceFeatures
         where
        type VkLogicOpMType VkPhysicalDeviceFeatures = VkBool32
        vkLogicOp (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkLogicOpByteOffset (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLogicOp #-}
        vkLogicOpByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, logicOp}

        {-# INLINE vkLogicOpByteOffset #-}
        readVkLogicOp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkLogicOpByteOffset (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLogicOp #-}
        writeVkLogicOp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLogicOpByteOffset (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLogicOp #-}

class HasVkMultiDrawIndirect a where
        type VkMultiDrawIndirectMType a :: *

        vkMultiDrawIndirect :: a -> VkMultiDrawIndirectMType a

        vkMultiDrawIndirectByteOffset :: a -> Int

        readVkMultiDrawIndirect ::
                                Mutable a -> IO (VkMultiDrawIndirectMType a)

        writeVkMultiDrawIndirect ::
                                 Mutable a -> VkMultiDrawIndirectMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'multiDrawIndirect'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMultiDrawIndirect a

instance {-# OVERLAPPING #-}
         HasVkMultiDrawIndirect VkPhysicalDeviceFeatures where
        type VkMultiDrawIndirectMType VkPhysicalDeviceFeatures = VkBool32
        vkMultiDrawIndirect (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkMultiDrawIndirectByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMultiDrawIndirect #-}
        vkMultiDrawIndirectByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, multiDrawIndirect}

        {-# INLINE vkMultiDrawIndirectByteOffset #-}
        readVkMultiDrawIndirect (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkMultiDrawIndirectByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMultiDrawIndirect #-}
        writeVkMultiDrawIndirect (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMultiDrawIndirectByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMultiDrawIndirect #-}

class HasVkDrawIndirectFirstInstance a where
        type VkDrawIndirectFirstInstanceMType a :: *

        vkDrawIndirectFirstInstance ::
                                    a -> VkDrawIndirectFirstInstanceMType a

        vkDrawIndirectFirstInstanceByteOffset :: a -> Int

        readVkDrawIndirectFirstInstance ::
                                        Mutable a -> IO (VkDrawIndirectFirstInstanceMType a)

        writeVkDrawIndirectFirstInstance ::
                                         Mutable a -> VkDrawIndirectFirstInstanceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'drawIndirectFirstInstance'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDrawIndirectFirstInstance a

instance {-# OVERLAPPING #-}
         HasVkDrawIndirectFirstInstance VkPhysicalDeviceFeatures where
        type VkDrawIndirectFirstInstanceMType VkPhysicalDeviceFeatures =
             VkBool32
        vkDrawIndirectFirstInstance (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDrawIndirectFirstInstanceByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDrawIndirectFirstInstance #-}
        vkDrawIndirectFirstInstanceByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, drawIndirectFirstInstance}

        {-# INLINE vkDrawIndirectFirstInstanceByteOffset #-}
        readVkDrawIndirectFirstInstance (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDrawIndirectFirstInstanceByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDrawIndirectFirstInstance #-}
        writeVkDrawIndirectFirstInstance (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDrawIndirectFirstInstanceByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDrawIndirectFirstInstance #-}

class HasVkDepthClamp a where
        type VkDepthClampMType a :: *

        vkDepthClamp :: a -> VkDepthClampMType a

        vkDepthClampByteOffset :: a -> Int

        readVkDepthClamp :: Mutable a -> IO (VkDepthClampMType a)

        writeVkDepthClamp :: Mutable a -> VkDepthClampMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthClamp'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthClamp a

instance {-# OVERLAPPING #-}
         HasVkDepthClamp VkPhysicalDeviceFeatures where
        type VkDepthClampMType VkPhysicalDeviceFeatures = VkBool32
        vkDepthClamp (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthClampByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthClamp #-}
        vkDepthClampByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, depthClamp}

        {-# INLINE vkDepthClampByteOffset #-}
        readVkDepthClamp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthClampByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthClamp #-}
        writeVkDepthClamp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthClampByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthClamp #-}

instance {-# OVERLAPPING #-}
         HasVkDepthBiasClamp VkPhysicalDeviceFeatures where
        type VkDepthBiasClampMType VkPhysicalDeviceFeatures = VkBool32
        vkDepthBiasClamp (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthBiasClampByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthBiasClamp #-}
        vkDepthBiasClampByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, depthBiasClamp}

        {-# INLINE vkDepthBiasClampByteOffset #-}
        readVkDepthBiasClamp (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthBiasClampByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthBiasClamp #-}
        writeVkDepthBiasClamp (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthBiasClampByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthBiasClamp #-}

class HasVkFillModeNonSolid a where
        type VkFillModeNonSolidMType a :: *

        vkFillModeNonSolid :: a -> VkFillModeNonSolidMType a

        vkFillModeNonSolidByteOffset :: a -> Int

        readVkFillModeNonSolid ::
                               Mutable a -> IO (VkFillModeNonSolidMType a)

        writeVkFillModeNonSolid ::
                                Mutable a -> VkFillModeNonSolidMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'fillModeNonSolid'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFillModeNonSolid a

instance {-# OVERLAPPING #-}
         HasVkFillModeNonSolid VkPhysicalDeviceFeatures where
        type VkFillModeNonSolidMType VkPhysicalDeviceFeatures = VkBool32
        vkFillModeNonSolid (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkFillModeNonSolidByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFillModeNonSolid #-}
        vkFillModeNonSolidByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, fillModeNonSolid}

        {-# INLINE vkFillModeNonSolidByteOffset #-}
        readVkFillModeNonSolid (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkFillModeNonSolidByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFillModeNonSolid #-}
        writeVkFillModeNonSolid (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFillModeNonSolidByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFillModeNonSolid #-}

class HasVkDepthBounds a where
        type VkDepthBoundsMType a :: *

        vkDepthBounds :: a -> VkDepthBoundsMType a

        vkDepthBoundsByteOffset :: a -> Int

        readVkDepthBounds :: Mutable a -> IO (VkDepthBoundsMType a)

        writeVkDepthBounds :: Mutable a -> VkDepthBoundsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'depthBounds'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDepthBounds a

instance {-# OVERLAPPING #-}
         HasVkDepthBounds VkPhysicalDeviceFeatures where
        type VkDepthBoundsMType VkPhysicalDeviceFeatures = VkBool32
        vkDepthBounds (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthBoundsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDepthBounds #-}
        vkDepthBoundsByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, depthBounds}

        {-# INLINE vkDepthBoundsByteOffset #-}
        readVkDepthBounds (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkDepthBoundsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDepthBounds #-}
        writeVkDepthBounds (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDepthBoundsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDepthBounds #-}

class HasVkWideLines a where
        type VkWideLinesMType a :: *

        vkWideLines :: a -> VkWideLinesMType a

        vkWideLinesByteOffset :: a -> Int

        readVkWideLines :: Mutable a -> IO (VkWideLinesMType a)

        writeVkWideLines :: Mutable a -> VkWideLinesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'wideLines'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkWideLines a

instance {-# OVERLAPPING #-}
         HasVkWideLines VkPhysicalDeviceFeatures where
        type VkWideLinesMType VkPhysicalDeviceFeatures = VkBool32
        vkWideLines (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkWideLinesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkWideLines #-}
        vkWideLinesByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, wideLines}

        {-# INLINE vkWideLinesByteOffset #-}
        readVkWideLines (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkWideLinesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkWideLines #-}
        writeVkWideLines (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkWideLinesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkWideLines #-}

class HasVkLargePoints a where
        type VkLargePointsMType a :: *

        vkLargePoints :: a -> VkLargePointsMType a

        vkLargePointsByteOffset :: a -> Int

        readVkLargePoints :: Mutable a -> IO (VkLargePointsMType a)

        writeVkLargePoints :: Mutable a -> VkLargePointsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'largePoints'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLargePoints a

instance {-# OVERLAPPING #-}
         HasVkLargePoints VkPhysicalDeviceFeatures where
        type VkLargePointsMType VkPhysicalDeviceFeatures = VkBool32
        vkLargePoints (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkLargePointsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLargePoints #-}
        vkLargePointsByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, largePoints}

        {-# INLINE vkLargePointsByteOffset #-}
        readVkLargePoints (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkLargePointsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLargePoints #-}
        writeVkLargePoints (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLargePointsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLargePoints #-}

class HasVkAlphaToOne a where
        type VkAlphaToOneMType a :: *

        vkAlphaToOne :: a -> VkAlphaToOneMType a

        vkAlphaToOneByteOffset :: a -> Int

        readVkAlphaToOne :: Mutable a -> IO (VkAlphaToOneMType a)

        writeVkAlphaToOne :: Mutable a -> VkAlphaToOneMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'alphaToOne'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkAlphaToOne a

instance {-# OVERLAPPING #-}
         HasVkAlphaToOne VkPhysicalDeviceFeatures where
        type VkAlphaToOneMType VkPhysicalDeviceFeatures = VkBool32
        vkAlphaToOne (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkAlphaToOneByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAlphaToOne #-}
        vkAlphaToOneByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, alphaToOne}

        {-# INLINE vkAlphaToOneByteOffset #-}
        readVkAlphaToOne (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkAlphaToOneByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAlphaToOne #-}
        writeVkAlphaToOne (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAlphaToOneByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAlphaToOne #-}

class HasVkMultiViewport a where
        type VkMultiViewportMType a :: *

        vkMultiViewport :: a -> VkMultiViewportMType a

        vkMultiViewportByteOffset :: a -> Int

        readVkMultiViewport :: Mutable a -> IO (VkMultiViewportMType a)

        writeVkMultiViewport ::
                             Mutable a -> VkMultiViewportMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'multiViewport'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMultiViewport a

instance {-# OVERLAPPING #-}
         HasVkMultiViewport VkPhysicalDeviceFeatures where
        type VkMultiViewportMType VkPhysicalDeviceFeatures = VkBool32
        vkMultiViewport (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkMultiViewportByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMultiViewport #-}
        vkMultiViewportByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, multiViewport}

        {-# INLINE vkMultiViewportByteOffset #-}
        readVkMultiViewport (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkMultiViewportByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMultiViewport #-}
        writeVkMultiViewport (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMultiViewportByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMultiViewport #-}

class HasVkSamplerAnisotropy a where
        type VkSamplerAnisotropyMType a :: *

        vkSamplerAnisotropy :: a -> VkSamplerAnisotropyMType a

        vkSamplerAnisotropyByteOffset :: a -> Int

        readVkSamplerAnisotropy ::
                                Mutable a -> IO (VkSamplerAnisotropyMType a)

        writeVkSamplerAnisotropy ::
                                 Mutable a -> VkSamplerAnisotropyMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'samplerAnisotropy'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSamplerAnisotropy a

instance {-# OVERLAPPING #-}
         HasVkSamplerAnisotropy VkPhysicalDeviceFeatures where
        type VkSamplerAnisotropyMType VkPhysicalDeviceFeatures = VkBool32
        vkSamplerAnisotropy (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSamplerAnisotropyByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSamplerAnisotropy #-}
        vkSamplerAnisotropyByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, samplerAnisotropy}

        {-# INLINE vkSamplerAnisotropyByteOffset #-}
        readVkSamplerAnisotropy (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSamplerAnisotropyByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSamplerAnisotropy #-}
        writeVkSamplerAnisotropy (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSamplerAnisotropyByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSamplerAnisotropy #-}

class HasVkTextureCompressionETC2 a where
        type VkTextureCompressionETC2MType a :: *

        vkTextureCompressionETC2 :: a -> VkTextureCompressionETC2MType a

        vkTextureCompressionETC2ByteOffset :: a -> Int

        readVkTextureCompressionETC2 ::
                                     Mutable a -> IO (VkTextureCompressionETC2MType a)

        writeVkTextureCompressionETC2 ::
                                      Mutable a -> VkTextureCompressionETC2MType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'textureCompressionETC2'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTextureCompressionETC2 a

instance {-# OVERLAPPING #-}
         HasVkTextureCompressionETC2 VkPhysicalDeviceFeatures where
        type VkTextureCompressionETC2MType VkPhysicalDeviceFeatures =
             VkBool32
        vkTextureCompressionETC2 (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkTextureCompressionETC2ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkTextureCompressionETC2 #-}
        vkTextureCompressionETC2ByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, textureCompressionETC2}

        {-# INLINE vkTextureCompressionETC2ByteOffset #-}
        readVkTextureCompressionETC2 (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkTextureCompressionETC2ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkTextureCompressionETC2 #-}
        writeVkTextureCompressionETC2 (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkTextureCompressionETC2ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkTextureCompressionETC2 #-}

class HasVkTextureCompressionASTC_LDR a where
        type VkTextureCompressionASTC_LDRMType a :: *

        vkTextureCompressionASTC_LDR ::
                                     a -> VkTextureCompressionASTC_LDRMType a

        vkTextureCompressionASTC_LDRByteOffset :: a -> Int

        readVkTextureCompressionASTC_LDR ::
                                         Mutable a -> IO (VkTextureCompressionASTC_LDRMType a)

        writeVkTextureCompressionASTC_LDR ::
                                          Mutable a -> VkTextureCompressionASTC_LDRMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'textureCompressionASTC_LDR'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTextureCompressionASTC_LDR a

instance {-# OVERLAPPING #-}
         HasVkTextureCompressionASTC_LDR VkPhysicalDeviceFeatures where
        type VkTextureCompressionASTC_LDRMType VkPhysicalDeviceFeatures =
             VkBool32
        vkTextureCompressionASTC_LDR (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkTextureCompressionASTC_LDRByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkTextureCompressionASTC_LDR #-}
        vkTextureCompressionASTC_LDRByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, textureCompressionASTC_LDR}

        {-# INLINE vkTextureCompressionASTC_LDRByteOffset #-}
        readVkTextureCompressionASTC_LDR (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkTextureCompressionASTC_LDRByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkTextureCompressionASTC_LDR #-}
        writeVkTextureCompressionASTC_LDR (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkTextureCompressionASTC_LDRByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkTextureCompressionASTC_LDR #-}

class HasVkTextureCompressionBC a where
        type VkTextureCompressionBCMType a :: *

        vkTextureCompressionBC :: a -> VkTextureCompressionBCMType a

        vkTextureCompressionBCByteOffset :: a -> Int

        readVkTextureCompressionBC ::
                                   Mutable a -> IO (VkTextureCompressionBCMType a)

        writeVkTextureCompressionBC ::
                                    Mutable a -> VkTextureCompressionBCMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'textureCompressionBC'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTextureCompressionBC a

instance {-# OVERLAPPING #-}
         HasVkTextureCompressionBC VkPhysicalDeviceFeatures where
        type VkTextureCompressionBCMType VkPhysicalDeviceFeatures =
             VkBool32
        vkTextureCompressionBC (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkTextureCompressionBCByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkTextureCompressionBC #-}
        vkTextureCompressionBCByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, textureCompressionBC}

        {-# INLINE vkTextureCompressionBCByteOffset #-}
        readVkTextureCompressionBC (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkTextureCompressionBCByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkTextureCompressionBC #-}
        writeVkTextureCompressionBC (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkTextureCompressionBCByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkTextureCompressionBC #-}

class HasVkOcclusionQueryPrecise a where
        type VkOcclusionQueryPreciseMType a :: *

        vkOcclusionQueryPrecise :: a -> VkOcclusionQueryPreciseMType a

        vkOcclusionQueryPreciseByteOffset :: a -> Int

        readVkOcclusionQueryPrecise ::
                                    Mutable a -> IO (VkOcclusionQueryPreciseMType a)

        writeVkOcclusionQueryPrecise ::
                                     Mutable a -> VkOcclusionQueryPreciseMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'occlusionQueryPrecise'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkOcclusionQueryPrecise a

instance {-# OVERLAPPING #-}
         HasVkOcclusionQueryPrecise VkPhysicalDeviceFeatures where
        type VkOcclusionQueryPreciseMType VkPhysicalDeviceFeatures =
             VkBool32
        vkOcclusionQueryPrecise (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkOcclusionQueryPreciseByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOcclusionQueryPrecise #-}
        vkOcclusionQueryPreciseByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, occlusionQueryPrecise}

        {-# INLINE vkOcclusionQueryPreciseByteOffset #-}
        readVkOcclusionQueryPrecise (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkOcclusionQueryPreciseByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOcclusionQueryPrecise #-}
        writeVkOcclusionQueryPrecise (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOcclusionQueryPreciseByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOcclusionQueryPrecise #-}

class HasVkPipelineStatisticsQuery a where
        type VkPipelineStatisticsQueryMType a :: *

        vkPipelineStatisticsQuery :: a -> VkPipelineStatisticsQueryMType a

        vkPipelineStatisticsQueryByteOffset :: a -> Int

        readVkPipelineStatisticsQuery ::
                                      Mutable a -> IO (VkPipelineStatisticsQueryMType a)

        writeVkPipelineStatisticsQuery ::
                                       Mutable a -> VkPipelineStatisticsQueryMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pipelineStatisticsQuery'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPipelineStatisticsQuery a

instance {-# OVERLAPPING #-}
         HasVkPipelineStatisticsQuery VkPhysicalDeviceFeatures where
        type VkPipelineStatisticsQueryMType VkPhysicalDeviceFeatures =
             VkBool32
        vkPipelineStatisticsQuery (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkPipelineStatisticsQueryByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPipelineStatisticsQuery #-}
        vkPipelineStatisticsQueryByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, pipelineStatisticsQuery}

        {-# INLINE vkPipelineStatisticsQueryByteOffset #-}
        readVkPipelineStatisticsQuery (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkPipelineStatisticsQueryByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPipelineStatisticsQuery #-}
        writeVkPipelineStatisticsQuery (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPipelineStatisticsQueryByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPipelineStatisticsQuery #-}

class HasVkVertexPipelineStoresAndAtomics a where
        type VkVertexPipelineStoresAndAtomicsMType a :: *

        vkVertexPipelineStoresAndAtomics ::
                                         a -> VkVertexPipelineStoresAndAtomicsMType a

        vkVertexPipelineStoresAndAtomicsByteOffset :: a -> Int

        readVkVertexPipelineStoresAndAtomics ::
                                             Mutable a ->
                                               IO (VkVertexPipelineStoresAndAtomicsMType a)

        writeVkVertexPipelineStoresAndAtomics ::
                                              Mutable a ->
                                                VkVertexPipelineStoresAndAtomicsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'vertexPipelineStoresAndAtomics'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkVertexPipelineStoresAndAtomics a

instance {-# OVERLAPPING #-}
         HasVkVertexPipelineStoresAndAtomics VkPhysicalDeviceFeatures where
        type VkVertexPipelineStoresAndAtomicsMType VkPhysicalDeviceFeatures
             = VkBool32
        vkVertexPipelineStoresAndAtomics (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkVertexPipelineStoresAndAtomicsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkVertexPipelineStoresAndAtomics #-}
        vkVertexPipelineStoresAndAtomicsByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, vertexPipelineStoresAndAtomics}

        {-# INLINE vkVertexPipelineStoresAndAtomicsByteOffset #-}
        readVkVertexPipelineStoresAndAtomics (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkVertexPipelineStoresAndAtomicsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkVertexPipelineStoresAndAtomics #-}
        writeVkVertexPipelineStoresAndAtomics (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkVertexPipelineStoresAndAtomicsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkVertexPipelineStoresAndAtomics #-}

class HasVkFragmentStoresAndAtomics a where
        type VkFragmentStoresAndAtomicsMType a :: *

        vkFragmentStoresAndAtomics ::
                                   a -> VkFragmentStoresAndAtomicsMType a

        vkFragmentStoresAndAtomicsByteOffset :: a -> Int

        readVkFragmentStoresAndAtomics ::
                                       Mutable a -> IO (VkFragmentStoresAndAtomicsMType a)

        writeVkFragmentStoresAndAtomics ::
                                        Mutable a -> VkFragmentStoresAndAtomicsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'fragmentStoresAndAtomics'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFragmentStoresAndAtomics a

instance {-# OVERLAPPING #-}
         HasVkFragmentStoresAndAtomics VkPhysicalDeviceFeatures where
        type VkFragmentStoresAndAtomicsMType VkPhysicalDeviceFeatures =
             VkBool32
        vkFragmentStoresAndAtomics (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkFragmentStoresAndAtomicsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFragmentStoresAndAtomics #-}
        vkFragmentStoresAndAtomicsByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, fragmentStoresAndAtomics}

        {-# INLINE vkFragmentStoresAndAtomicsByteOffset #-}
        readVkFragmentStoresAndAtomics (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkFragmentStoresAndAtomicsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFragmentStoresAndAtomics #-}
        writeVkFragmentStoresAndAtomics (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFragmentStoresAndAtomicsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFragmentStoresAndAtomics #-}

class HasVkShaderTessellationAndGeometryPointSize a where
        type VkShaderTessellationAndGeometryPointSizeMType a :: *

        vkShaderTessellationAndGeometryPointSize ::
                                                 a ->
                                                   VkShaderTessellationAndGeometryPointSizeMType a

        vkShaderTessellationAndGeometryPointSizeByteOffset :: a -> Int

        readVkShaderTessellationAndGeometryPointSize ::
                                                     Mutable a ->
                                                       IO
                                                         (VkShaderTessellationAndGeometryPointSizeMType
                                                            a)

        writeVkShaderTessellationAndGeometryPointSize ::
                                                      Mutable a ->
                                                        VkShaderTessellationAndGeometryPointSizeMType
                                                          a
                                                          -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderTessellationAndGeometryPointSize'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderTessellationAndGeometryPointSize a

instance {-# OVERLAPPING #-}
         HasVkShaderTessellationAndGeometryPointSize
           VkPhysicalDeviceFeatures
         where
        type VkShaderTessellationAndGeometryPointSizeMType
               VkPhysicalDeviceFeatures
             = VkBool32
        vkShaderTessellationAndGeometryPointSize
          (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderTessellationAndGeometryPointSizeByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderTessellationAndGeometryPointSize #-}
        vkShaderTessellationAndGeometryPointSizeByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderTessellationAndGeometryPointSize}

        {-# INLINE vkShaderTessellationAndGeometryPointSizeByteOffset #-}
        readVkShaderTessellationAndGeometryPointSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderTessellationAndGeometryPointSizeByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderTessellationAndGeometryPointSize #-}
        writeVkShaderTessellationAndGeometryPointSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderTessellationAndGeometryPointSizeByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderTessellationAndGeometryPointSize #-}

class HasVkShaderImageGatherExtended a where
        type VkShaderImageGatherExtendedMType a :: *

        vkShaderImageGatherExtended ::
                                    a -> VkShaderImageGatherExtendedMType a

        vkShaderImageGatherExtendedByteOffset :: a -> Int

        readVkShaderImageGatherExtended ::
                                        Mutable a -> IO (VkShaderImageGatherExtendedMType a)

        writeVkShaderImageGatherExtended ::
                                         Mutable a -> VkShaderImageGatherExtendedMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderImageGatherExtended'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderImageGatherExtended a

instance {-# OVERLAPPING #-}
         HasVkShaderImageGatherExtended VkPhysicalDeviceFeatures where
        type VkShaderImageGatherExtendedMType VkPhysicalDeviceFeatures =
             VkBool32
        vkShaderImageGatherExtended (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderImageGatherExtendedByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderImageGatherExtended #-}
        vkShaderImageGatherExtendedByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderImageGatherExtended}

        {-# INLINE vkShaderImageGatherExtendedByteOffset #-}
        readVkShaderImageGatherExtended (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderImageGatherExtendedByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderImageGatherExtended #-}
        writeVkShaderImageGatherExtended (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderImageGatherExtendedByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderImageGatherExtended #-}

class HasVkShaderStorageImageExtendedFormats a where
        type VkShaderStorageImageExtendedFormatsMType a :: *

        vkShaderStorageImageExtendedFormats ::
                                            a -> VkShaderStorageImageExtendedFormatsMType a

        vkShaderStorageImageExtendedFormatsByteOffset :: a -> Int

        readVkShaderStorageImageExtendedFormats ::
                                                Mutable a ->
                                                  IO (VkShaderStorageImageExtendedFormatsMType a)

        writeVkShaderStorageImageExtendedFormats ::
                                                 Mutable a ->
                                                   VkShaderStorageImageExtendedFormatsMType a ->
                                                     IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderStorageImageExtendedFormats'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderStorageImageExtendedFormats a

instance {-# OVERLAPPING #-}
         HasVkShaderStorageImageExtendedFormats VkPhysicalDeviceFeatures
         where
        type VkShaderStorageImageExtendedFormatsMType
               VkPhysicalDeviceFeatures
             = VkBool32
        vkShaderStorageImageExtendedFormats (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderStorageImageExtendedFormatsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderStorageImageExtendedFormats #-}
        vkShaderStorageImageExtendedFormatsByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderStorageImageExtendedFormats}

        {-# INLINE vkShaderStorageImageExtendedFormatsByteOffset #-}
        readVkShaderStorageImageExtendedFormats (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderStorageImageExtendedFormatsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderStorageImageExtendedFormats #-}
        writeVkShaderStorageImageExtendedFormats (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderStorageImageExtendedFormatsByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderStorageImageExtendedFormats #-}

class HasVkShaderStorageImageMultisample a where
        type VkShaderStorageImageMultisampleMType a :: *

        vkShaderStorageImageMultisample ::
                                        a -> VkShaderStorageImageMultisampleMType a

        vkShaderStorageImageMultisampleByteOffset :: a -> Int

        readVkShaderStorageImageMultisample ::
                                            Mutable a -> IO (VkShaderStorageImageMultisampleMType a)

        writeVkShaderStorageImageMultisample ::
                                             Mutable a ->
                                               VkShaderStorageImageMultisampleMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderStorageImageMultisample'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderStorageImageMultisample a

instance {-# OVERLAPPING #-}
         HasVkShaderStorageImageMultisample VkPhysicalDeviceFeatures where
        type VkShaderStorageImageMultisampleMType VkPhysicalDeviceFeatures
             = VkBool32
        vkShaderStorageImageMultisample (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderStorageImageMultisampleByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderStorageImageMultisample #-}
        vkShaderStorageImageMultisampleByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderStorageImageMultisample}

        {-# INLINE vkShaderStorageImageMultisampleByteOffset #-}
        readVkShaderStorageImageMultisample (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderStorageImageMultisampleByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderStorageImageMultisample #-}
        writeVkShaderStorageImageMultisample (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderStorageImageMultisampleByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderStorageImageMultisample #-}

class HasVkShaderStorageImageReadWithoutFormat a where
        type VkShaderStorageImageReadWithoutFormatMType a :: *

        vkShaderStorageImageReadWithoutFormat ::
                                              a -> VkShaderStorageImageReadWithoutFormatMType a

        vkShaderStorageImageReadWithoutFormatByteOffset :: a -> Int

        readVkShaderStorageImageReadWithoutFormat ::
                                                  Mutable a ->
                                                    IO
                                                      (VkShaderStorageImageReadWithoutFormatMType a)

        writeVkShaderStorageImageReadWithoutFormat ::
                                                   Mutable a ->
                                                     VkShaderStorageImageReadWithoutFormatMType a ->
                                                       IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderStorageImageReadWithoutFormat'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderStorageImageReadWithoutFormat a

instance {-# OVERLAPPING #-}
         HasVkShaderStorageImageReadWithoutFormat VkPhysicalDeviceFeatures
         where
        type VkShaderStorageImageReadWithoutFormatMType
               VkPhysicalDeviceFeatures
             = VkBool32
        vkShaderStorageImageReadWithoutFormat
          (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderStorageImageReadWithoutFormatByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderStorageImageReadWithoutFormat #-}
        vkShaderStorageImageReadWithoutFormatByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderStorageImageReadWithoutFormat}

        {-# INLINE vkShaderStorageImageReadWithoutFormatByteOffset #-}
        readVkShaderStorageImageReadWithoutFormat (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderStorageImageReadWithoutFormatByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderStorageImageReadWithoutFormat #-}
        writeVkShaderStorageImageReadWithoutFormat (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderStorageImageReadWithoutFormatByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderStorageImageReadWithoutFormat #-}

class HasVkShaderStorageImageWriteWithoutFormat a where
        type VkShaderStorageImageWriteWithoutFormatMType a :: *

        vkShaderStorageImageWriteWithoutFormat ::
                                               a -> VkShaderStorageImageWriteWithoutFormatMType a

        vkShaderStorageImageWriteWithoutFormatByteOffset :: a -> Int

        readVkShaderStorageImageWriteWithoutFormat ::
                                                   Mutable a ->
                                                     IO
                                                       (VkShaderStorageImageWriteWithoutFormatMType
                                                          a)

        writeVkShaderStorageImageWriteWithoutFormat ::
                                                    Mutable a ->
                                                      VkShaderStorageImageWriteWithoutFormatMType a
                                                        -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderStorageImageWriteWithoutFormat'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderStorageImageWriteWithoutFormat a

instance {-# OVERLAPPING #-}
         HasVkShaderStorageImageWriteWithoutFormat VkPhysicalDeviceFeatures
         where
        type VkShaderStorageImageWriteWithoutFormatMType
               VkPhysicalDeviceFeatures
             = VkBool32
        vkShaderStorageImageWriteWithoutFormat
          (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderStorageImageWriteWithoutFormatByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderStorageImageWriteWithoutFormat #-}
        vkShaderStorageImageWriteWithoutFormatByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderStorageImageWriteWithoutFormat}

        {-# INLINE vkShaderStorageImageWriteWithoutFormatByteOffset #-}
        readVkShaderStorageImageWriteWithoutFormat (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderStorageImageWriteWithoutFormatByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderStorageImageWriteWithoutFormat #-}
        writeVkShaderStorageImageWriteWithoutFormat (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderStorageImageWriteWithoutFormatByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderStorageImageWriteWithoutFormat #-}

class HasVkShaderUniformBufferArrayDynamicIndexing a where
        type VkShaderUniformBufferArrayDynamicIndexingMType a :: *

        vkShaderUniformBufferArrayDynamicIndexing ::
                                                  a ->
                                                    VkShaderUniformBufferArrayDynamicIndexingMType a

        vkShaderUniformBufferArrayDynamicIndexingByteOffset :: a -> Int

        readVkShaderUniformBufferArrayDynamicIndexing ::
                                                      Mutable a ->
                                                        IO
                                                          (VkShaderUniformBufferArrayDynamicIndexingMType
                                                             a)

        writeVkShaderUniformBufferArrayDynamicIndexing ::
                                                       Mutable a ->
                                                         VkShaderUniformBufferArrayDynamicIndexingMType
                                                           a
                                                           -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderUniformBufferArrayDynamicIndexing'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderUniformBufferArrayDynamicIndexing a

instance {-# OVERLAPPING #-}
         HasVkShaderUniformBufferArrayDynamicIndexing
           VkPhysicalDeviceFeatures
         where
        type VkShaderUniformBufferArrayDynamicIndexingMType
               VkPhysicalDeviceFeatures
             = VkBool32
        vkShaderUniformBufferArrayDynamicIndexing
          (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderUniformBufferArrayDynamicIndexingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderUniformBufferArrayDynamicIndexing #-}
        vkShaderUniformBufferArrayDynamicIndexingByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderUniformBufferArrayDynamicIndexing}

        {-# INLINE vkShaderUniformBufferArrayDynamicIndexingByteOffset #-}
        readVkShaderUniformBufferArrayDynamicIndexing (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderUniformBufferArrayDynamicIndexingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderUniformBufferArrayDynamicIndexing #-}
        writeVkShaderUniformBufferArrayDynamicIndexing (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderUniformBufferArrayDynamicIndexingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderUniformBufferArrayDynamicIndexing #-}

class HasVkShaderSampledImageArrayDynamicIndexing a where
        type VkShaderSampledImageArrayDynamicIndexingMType a :: *

        vkShaderSampledImageArrayDynamicIndexing ::
                                                 a ->
                                                   VkShaderSampledImageArrayDynamicIndexingMType a

        vkShaderSampledImageArrayDynamicIndexingByteOffset :: a -> Int

        readVkShaderSampledImageArrayDynamicIndexing ::
                                                     Mutable a ->
                                                       IO
                                                         (VkShaderSampledImageArrayDynamicIndexingMType
                                                            a)

        writeVkShaderSampledImageArrayDynamicIndexing ::
                                                      Mutable a ->
                                                        VkShaderSampledImageArrayDynamicIndexingMType
                                                          a
                                                          -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderSampledImageArrayDynamicIndexing'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderSampledImageArrayDynamicIndexing a

instance {-# OVERLAPPING #-}
         HasVkShaderSampledImageArrayDynamicIndexing
           VkPhysicalDeviceFeatures
         where
        type VkShaderSampledImageArrayDynamicIndexingMType
               VkPhysicalDeviceFeatures
             = VkBool32
        vkShaderSampledImageArrayDynamicIndexing
          (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderSampledImageArrayDynamicIndexingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderSampledImageArrayDynamicIndexing #-}
        vkShaderSampledImageArrayDynamicIndexingByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderSampledImageArrayDynamicIndexing}

        {-# INLINE vkShaderSampledImageArrayDynamicIndexingByteOffset #-}
        readVkShaderSampledImageArrayDynamicIndexing (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderSampledImageArrayDynamicIndexingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderSampledImageArrayDynamicIndexing #-}
        writeVkShaderSampledImageArrayDynamicIndexing (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderSampledImageArrayDynamicIndexingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderSampledImageArrayDynamicIndexing #-}

class HasVkShaderStorageBufferArrayDynamicIndexing a where
        type VkShaderStorageBufferArrayDynamicIndexingMType a :: *

        vkShaderStorageBufferArrayDynamicIndexing ::
                                                  a ->
                                                    VkShaderStorageBufferArrayDynamicIndexingMType a

        vkShaderStorageBufferArrayDynamicIndexingByteOffset :: a -> Int

        readVkShaderStorageBufferArrayDynamicIndexing ::
                                                      Mutable a ->
                                                        IO
                                                          (VkShaderStorageBufferArrayDynamicIndexingMType
                                                             a)

        writeVkShaderStorageBufferArrayDynamicIndexing ::
                                                       Mutable a ->
                                                         VkShaderStorageBufferArrayDynamicIndexingMType
                                                           a
                                                           -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderStorageBufferArrayDynamicIndexing'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderStorageBufferArrayDynamicIndexing a

instance {-# OVERLAPPING #-}
         HasVkShaderStorageBufferArrayDynamicIndexing
           VkPhysicalDeviceFeatures
         where
        type VkShaderStorageBufferArrayDynamicIndexingMType
               VkPhysicalDeviceFeatures
             = VkBool32
        vkShaderStorageBufferArrayDynamicIndexing
          (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderStorageBufferArrayDynamicIndexingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderStorageBufferArrayDynamicIndexing #-}
        vkShaderStorageBufferArrayDynamicIndexingByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderStorageBufferArrayDynamicIndexing}

        {-# INLINE vkShaderStorageBufferArrayDynamicIndexingByteOffset #-}
        readVkShaderStorageBufferArrayDynamicIndexing (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderStorageBufferArrayDynamicIndexingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderStorageBufferArrayDynamicIndexing #-}
        writeVkShaderStorageBufferArrayDynamicIndexing (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderStorageBufferArrayDynamicIndexingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderStorageBufferArrayDynamicIndexing #-}

class HasVkShaderStorageImageArrayDynamicIndexing a where
        type VkShaderStorageImageArrayDynamicIndexingMType a :: *

        vkShaderStorageImageArrayDynamicIndexing ::
                                                 a ->
                                                   VkShaderStorageImageArrayDynamicIndexingMType a

        vkShaderStorageImageArrayDynamicIndexingByteOffset :: a -> Int

        readVkShaderStorageImageArrayDynamicIndexing ::
                                                     Mutable a ->
                                                       IO
                                                         (VkShaderStorageImageArrayDynamicIndexingMType
                                                            a)

        writeVkShaderStorageImageArrayDynamicIndexing ::
                                                      Mutable a ->
                                                        VkShaderStorageImageArrayDynamicIndexingMType
                                                          a
                                                          -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'shaderStorageImageArrayDynamicIndexing'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderStorageImageArrayDynamicIndexing a

instance {-# OVERLAPPING #-}
         HasVkShaderStorageImageArrayDynamicIndexing
           VkPhysicalDeviceFeatures
         where
        type VkShaderStorageImageArrayDynamicIndexingMType
               VkPhysicalDeviceFeatures
             = VkBool32
        vkShaderStorageImageArrayDynamicIndexing
          (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderStorageImageArrayDynamicIndexingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderStorageImageArrayDynamicIndexing #-}
        vkShaderStorageImageArrayDynamicIndexingByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderStorageImageArrayDynamicIndexing}

        {-# INLINE vkShaderStorageImageArrayDynamicIndexingByteOffset #-}
        readVkShaderStorageImageArrayDynamicIndexing (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderStorageImageArrayDynamicIndexingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderStorageImageArrayDynamicIndexing #-}
        writeVkShaderStorageImageArrayDynamicIndexing (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderStorageImageArrayDynamicIndexingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderStorageImageArrayDynamicIndexing #-}

class HasVkShaderClipDistance a where
        type VkShaderClipDistanceMType a :: *

        vkShaderClipDistance :: a -> VkShaderClipDistanceMType a

        vkShaderClipDistanceByteOffset :: a -> Int

        readVkShaderClipDistance ::
                                 Mutable a -> IO (VkShaderClipDistanceMType a)

        writeVkShaderClipDistance ::
                                  Mutable a -> VkShaderClipDistanceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderClipDistance'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderClipDistance a

instance {-# OVERLAPPING #-}
         HasVkShaderClipDistance VkPhysicalDeviceFeatures where
        type VkShaderClipDistanceMType VkPhysicalDeviceFeatures = VkBool32
        vkShaderClipDistance (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderClipDistanceByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderClipDistance #-}
        vkShaderClipDistanceByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderClipDistance}

        {-# INLINE vkShaderClipDistanceByteOffset #-}
        readVkShaderClipDistance (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderClipDistanceByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderClipDistance #-}
        writeVkShaderClipDistance (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderClipDistanceByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderClipDistance #-}

class HasVkShaderCullDistance a where
        type VkShaderCullDistanceMType a :: *

        vkShaderCullDistance :: a -> VkShaderCullDistanceMType a

        vkShaderCullDistanceByteOffset :: a -> Int

        readVkShaderCullDistance ::
                                 Mutable a -> IO (VkShaderCullDistanceMType a)

        writeVkShaderCullDistance ::
                                  Mutable a -> VkShaderCullDistanceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderCullDistance'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderCullDistance a

instance {-# OVERLAPPING #-}
         HasVkShaderCullDistance VkPhysicalDeviceFeatures where
        type VkShaderCullDistanceMType VkPhysicalDeviceFeatures = VkBool32
        vkShaderCullDistance (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderCullDistanceByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderCullDistance #-}
        vkShaderCullDistanceByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderCullDistance}

        {-# INLINE vkShaderCullDistanceByteOffset #-}
        readVkShaderCullDistance (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderCullDistanceByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderCullDistance #-}
        writeVkShaderCullDistance (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderCullDistanceByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderCullDistance #-}

class HasVkShaderFloat64 a where
        type VkShaderFloat64MType a :: *

        vkShaderFloat64 :: a -> VkShaderFloat64MType a

        vkShaderFloat64ByteOffset :: a -> Int

        readVkShaderFloat64 :: Mutable a -> IO (VkShaderFloat64MType a)

        writeVkShaderFloat64 ::
                             Mutable a -> VkShaderFloat64MType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderFloat64'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderFloat64 a

instance {-# OVERLAPPING #-}
         HasVkShaderFloat64 VkPhysicalDeviceFeatures where
        type VkShaderFloat64MType VkPhysicalDeviceFeatures = VkBool32
        vkShaderFloat64 (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderFloat64ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderFloat64 #-}
        vkShaderFloat64ByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderFloat64}

        {-# INLINE vkShaderFloat64ByteOffset #-}
        readVkShaderFloat64 (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderFloat64ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderFloat64 #-}
        writeVkShaderFloat64 (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderFloat64ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderFloat64 #-}

class HasVkShaderInt64 a where
        type VkShaderInt64MType a :: *

        vkShaderInt64 :: a -> VkShaderInt64MType a

        vkShaderInt64ByteOffset :: a -> Int

        readVkShaderInt64 :: Mutable a -> IO (VkShaderInt64MType a)

        writeVkShaderInt64 :: Mutable a -> VkShaderInt64MType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderInt64'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderInt64 a

instance {-# OVERLAPPING #-}
         HasVkShaderInt64 VkPhysicalDeviceFeatures where
        type VkShaderInt64MType VkPhysicalDeviceFeatures = VkBool32
        vkShaderInt64 (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderInt64ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderInt64 #-}
        vkShaderInt64ByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderInt64}

        {-# INLINE vkShaderInt64ByteOffset #-}
        readVkShaderInt64 (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderInt64ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderInt64 #-}
        writeVkShaderInt64 (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderInt64ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderInt64 #-}

class HasVkShaderInt16 a where
        type VkShaderInt16MType a :: *

        vkShaderInt16 :: a -> VkShaderInt16MType a

        vkShaderInt16ByteOffset :: a -> Int

        readVkShaderInt16 :: Mutable a -> IO (VkShaderInt16MType a)

        writeVkShaderInt16 :: Mutable a -> VkShaderInt16MType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderInt16'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderInt16 a

instance {-# OVERLAPPING #-}
         HasVkShaderInt16 VkPhysicalDeviceFeatures where
        type VkShaderInt16MType VkPhysicalDeviceFeatures = VkBool32
        vkShaderInt16 (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderInt16ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderInt16 #-}
        vkShaderInt16ByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderInt16}

        {-# INLINE vkShaderInt16ByteOffset #-}
        readVkShaderInt16 (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderInt16ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderInt16 #-}
        writeVkShaderInt16 (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderInt16ByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderInt16 #-}

class HasVkShaderResourceResidency a where
        type VkShaderResourceResidencyMType a :: *

        vkShaderResourceResidency :: a -> VkShaderResourceResidencyMType a

        vkShaderResourceResidencyByteOffset :: a -> Int

        readVkShaderResourceResidency ::
                                      Mutable a -> IO (VkShaderResourceResidencyMType a)

        writeVkShaderResourceResidency ::
                                       Mutable a -> VkShaderResourceResidencyMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderResourceResidency'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderResourceResidency a

instance {-# OVERLAPPING #-}
         HasVkShaderResourceResidency VkPhysicalDeviceFeatures where
        type VkShaderResourceResidencyMType VkPhysicalDeviceFeatures =
             VkBool32
        vkShaderResourceResidency (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderResourceResidencyByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderResourceResidency #-}
        vkShaderResourceResidencyByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderResourceResidency}

        {-# INLINE vkShaderResourceResidencyByteOffset #-}
        readVkShaderResourceResidency (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderResourceResidencyByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderResourceResidency #-}
        writeVkShaderResourceResidency (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderResourceResidencyByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderResourceResidency #-}

class HasVkShaderResourceMinLod a where
        type VkShaderResourceMinLodMType a :: *

        vkShaderResourceMinLod :: a -> VkShaderResourceMinLodMType a

        vkShaderResourceMinLodByteOffset :: a -> Int

        readVkShaderResourceMinLod ::
                                   Mutable a -> IO (VkShaderResourceMinLodMType a)

        writeVkShaderResourceMinLod ::
                                    Mutable a -> VkShaderResourceMinLodMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'shaderResourceMinLod'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkShaderResourceMinLod a

instance {-# OVERLAPPING #-}
         HasVkShaderResourceMinLod VkPhysicalDeviceFeatures where
        type VkShaderResourceMinLodMType VkPhysicalDeviceFeatures =
             VkBool32
        vkShaderResourceMinLod (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderResourceMinLodByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkShaderResourceMinLod #-}
        vkShaderResourceMinLodByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, shaderResourceMinLod}

        {-# INLINE vkShaderResourceMinLodByteOffset #-}
        readVkShaderResourceMinLod (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkShaderResourceMinLodByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkShaderResourceMinLod #-}
        writeVkShaderResourceMinLod (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkShaderResourceMinLodByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkShaderResourceMinLod #-}

class HasVkSparseBinding a where
        type VkSparseBindingMType a :: *

        vkSparseBinding :: a -> VkSparseBindingMType a

        vkSparseBindingByteOffset :: a -> Int

        readVkSparseBinding :: Mutable a -> IO (VkSparseBindingMType a)

        writeVkSparseBinding ::
                             Mutable a -> VkSparseBindingMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseBinding'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseBinding a

instance {-# OVERLAPPING #-}
         HasVkSparseBinding VkPhysicalDeviceFeatures where
        type VkSparseBindingMType VkPhysicalDeviceFeatures = VkBool32
        vkSparseBinding (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseBindingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSparseBinding #-}
        vkSparseBindingByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseBinding}

        {-# INLINE vkSparseBindingByteOffset #-}
        readVkSparseBinding (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseBindingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSparseBinding #-}
        writeVkSparseBinding (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSparseBindingByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSparseBinding #-}

class HasVkSparseResidencyBuffer a where
        type VkSparseResidencyBufferMType a :: *

        vkSparseResidencyBuffer :: a -> VkSparseResidencyBufferMType a

        vkSparseResidencyBufferByteOffset :: a -> Int

        readVkSparseResidencyBuffer ::
                                    Mutable a -> IO (VkSparseResidencyBufferMType a)

        writeVkSparseResidencyBuffer ::
                                     Mutable a -> VkSparseResidencyBufferMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidencyBuffer'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidencyBuffer a

instance {-# OVERLAPPING #-}
         HasVkSparseResidencyBuffer VkPhysicalDeviceFeatures where
        type VkSparseResidencyBufferMType VkPhysicalDeviceFeatures =
             VkBool32
        vkSparseResidencyBuffer (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidencyBufferByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSparseResidencyBuffer #-}
        vkSparseResidencyBufferByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidencyBuffer}

        {-# INLINE vkSparseResidencyBufferByteOffset #-}
        readVkSparseResidencyBuffer (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidencyBufferByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSparseResidencyBuffer #-}
        writeVkSparseResidencyBuffer (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSparseResidencyBufferByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSparseResidencyBuffer #-}

class HasVkSparseResidencyImage2D a where
        type VkSparseResidencyImage2DMType a :: *

        vkSparseResidencyImage2D :: a -> VkSparseResidencyImage2DMType a

        vkSparseResidencyImage2DByteOffset :: a -> Int

        readVkSparseResidencyImage2D ::
                                     Mutable a -> IO (VkSparseResidencyImage2DMType a)

        writeVkSparseResidencyImage2D ::
                                      Mutable a -> VkSparseResidencyImage2DMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidencyImage2D'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidencyImage2D a

instance {-# OVERLAPPING #-}
         HasVkSparseResidencyImage2D VkPhysicalDeviceFeatures where
        type VkSparseResidencyImage2DMType VkPhysicalDeviceFeatures =
             VkBool32
        vkSparseResidencyImage2D (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidencyImage2DByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSparseResidencyImage2D #-}
        vkSparseResidencyImage2DByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidencyImage2D}

        {-# INLINE vkSparseResidencyImage2DByteOffset #-}
        readVkSparseResidencyImage2D (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidencyImage2DByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSparseResidencyImage2D #-}
        writeVkSparseResidencyImage2D (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSparseResidencyImage2DByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSparseResidencyImage2D #-}

class HasVkSparseResidencyImage3D a where
        type VkSparseResidencyImage3DMType a :: *

        vkSparseResidencyImage3D :: a -> VkSparseResidencyImage3DMType a

        vkSparseResidencyImage3DByteOffset :: a -> Int

        readVkSparseResidencyImage3D ::
                                     Mutable a -> IO (VkSparseResidencyImage3DMType a)

        writeVkSparseResidencyImage3D ::
                                      Mutable a -> VkSparseResidencyImage3DMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidencyImage3D'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidencyImage3D a

instance {-# OVERLAPPING #-}
         HasVkSparseResidencyImage3D VkPhysicalDeviceFeatures where
        type VkSparseResidencyImage3DMType VkPhysicalDeviceFeatures =
             VkBool32
        vkSparseResidencyImage3D (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidencyImage3DByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSparseResidencyImage3D #-}
        vkSparseResidencyImage3DByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidencyImage3D}

        {-# INLINE vkSparseResidencyImage3DByteOffset #-}
        readVkSparseResidencyImage3D (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidencyImage3DByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSparseResidencyImage3D #-}
        writeVkSparseResidencyImage3D (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSparseResidencyImage3DByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSparseResidencyImage3D #-}

class HasVkSparseResidency2Samples a where
        type VkSparseResidency2SamplesMType a :: *

        vkSparseResidency2Samples :: a -> VkSparseResidency2SamplesMType a

        vkSparseResidency2SamplesByteOffset :: a -> Int

        readVkSparseResidency2Samples ::
                                      Mutable a -> IO (VkSparseResidency2SamplesMType a)

        writeVkSparseResidency2Samples ::
                                       Mutable a -> VkSparseResidency2SamplesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidency2Samples'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidency2Samples a

instance {-# OVERLAPPING #-}
         HasVkSparseResidency2Samples VkPhysicalDeviceFeatures where
        type VkSparseResidency2SamplesMType VkPhysicalDeviceFeatures =
             VkBool32
        vkSparseResidency2Samples (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidency2SamplesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSparseResidency2Samples #-}
        vkSparseResidency2SamplesByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidency2Samples}

        {-# INLINE vkSparseResidency2SamplesByteOffset #-}
        readVkSparseResidency2Samples (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidency2SamplesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSparseResidency2Samples #-}
        writeVkSparseResidency2Samples (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSparseResidency2SamplesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSparseResidency2Samples #-}

class HasVkSparseResidency4Samples a where
        type VkSparseResidency4SamplesMType a :: *

        vkSparseResidency4Samples :: a -> VkSparseResidency4SamplesMType a

        vkSparseResidency4SamplesByteOffset :: a -> Int

        readVkSparseResidency4Samples ::
                                      Mutable a -> IO (VkSparseResidency4SamplesMType a)

        writeVkSparseResidency4Samples ::
                                       Mutable a -> VkSparseResidency4SamplesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidency4Samples'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidency4Samples a

instance {-# OVERLAPPING #-}
         HasVkSparseResidency4Samples VkPhysicalDeviceFeatures where
        type VkSparseResidency4SamplesMType VkPhysicalDeviceFeatures =
             VkBool32
        vkSparseResidency4Samples (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidency4SamplesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSparseResidency4Samples #-}
        vkSparseResidency4SamplesByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidency4Samples}

        {-# INLINE vkSparseResidency4SamplesByteOffset #-}
        readVkSparseResidency4Samples (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidency4SamplesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSparseResidency4Samples #-}
        writeVkSparseResidency4Samples (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSparseResidency4SamplesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSparseResidency4Samples #-}

class HasVkSparseResidency8Samples a where
        type VkSparseResidency8SamplesMType a :: *

        vkSparseResidency8Samples :: a -> VkSparseResidency8SamplesMType a

        vkSparseResidency8SamplesByteOffset :: a -> Int

        readVkSparseResidency8Samples ::
                                      Mutable a -> IO (VkSparseResidency8SamplesMType a)

        writeVkSparseResidency8Samples ::
                                       Mutable a -> VkSparseResidency8SamplesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidency8Samples'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidency8Samples a

instance {-# OVERLAPPING #-}
         HasVkSparseResidency8Samples VkPhysicalDeviceFeatures where
        type VkSparseResidency8SamplesMType VkPhysicalDeviceFeatures =
             VkBool32
        vkSparseResidency8Samples (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidency8SamplesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSparseResidency8Samples #-}
        vkSparseResidency8SamplesByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidency8Samples}

        {-# INLINE vkSparseResidency8SamplesByteOffset #-}
        readVkSparseResidency8Samples (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidency8SamplesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSparseResidency8Samples #-}
        writeVkSparseResidency8Samples (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSparseResidency8SamplesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSparseResidency8Samples #-}

class HasVkSparseResidency16Samples a where
        type VkSparseResidency16SamplesMType a :: *

        vkSparseResidency16Samples ::
                                   a -> VkSparseResidency16SamplesMType a

        vkSparseResidency16SamplesByteOffset :: a -> Int

        readVkSparseResidency16Samples ::
                                       Mutable a -> IO (VkSparseResidency16SamplesMType a)

        writeVkSparseResidency16Samples ::
                                        Mutable a -> VkSparseResidency16SamplesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidency16Samples'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidency16Samples a

instance {-# OVERLAPPING #-}
         HasVkSparseResidency16Samples VkPhysicalDeviceFeatures where
        type VkSparseResidency16SamplesMType VkPhysicalDeviceFeatures =
             VkBool32
        vkSparseResidency16Samples (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidency16SamplesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSparseResidency16Samples #-}
        vkSparseResidency16SamplesByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidency16Samples}

        {-# INLINE vkSparseResidency16SamplesByteOffset #-}
        readVkSparseResidency16Samples (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidency16SamplesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSparseResidency16Samples #-}
        writeVkSparseResidency16Samples (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSparseResidency16SamplesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSparseResidency16Samples #-}

class HasVkSparseResidencyAliased a where
        type VkSparseResidencyAliasedMType a :: *

        vkSparseResidencyAliased :: a -> VkSparseResidencyAliasedMType a

        vkSparseResidencyAliasedByteOffset :: a -> Int

        readVkSparseResidencyAliased ::
                                     Mutable a -> IO (VkSparseResidencyAliasedMType a)

        writeVkSparseResidencyAliased ::
                                      Mutable a -> VkSparseResidencyAliasedMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseResidencyAliased'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseResidencyAliased a

instance {-# OVERLAPPING #-}
         HasVkSparseResidencyAliased VkPhysicalDeviceFeatures where
        type VkSparseResidencyAliasedMType VkPhysicalDeviceFeatures =
             VkBool32
        vkSparseResidencyAliased (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidencyAliasedByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSparseResidencyAliased #-}
        vkSparseResidencyAliasedByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, sparseResidencyAliased}

        {-# INLINE vkSparseResidencyAliasedByteOffset #-}
        readVkSparseResidencyAliased (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkSparseResidencyAliasedByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSparseResidencyAliased #-}
        writeVkSparseResidencyAliased (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSparseResidencyAliasedByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSparseResidencyAliased #-}

class HasVkVariableMultisampleRate a where
        type VkVariableMultisampleRateMType a :: *

        vkVariableMultisampleRate :: a -> VkVariableMultisampleRateMType a

        vkVariableMultisampleRateByteOffset :: a -> Int

        readVkVariableMultisampleRate ::
                                      Mutable a -> IO (VkVariableMultisampleRateMType a)

        writeVkVariableMultisampleRate ::
                                       Mutable a -> VkVariableMultisampleRateMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'variableMultisampleRate'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkVariableMultisampleRate a

instance {-# OVERLAPPING #-}
         HasVkVariableMultisampleRate VkPhysicalDeviceFeatures where
        type VkVariableMultisampleRateMType VkPhysicalDeviceFeatures =
             VkBool32
        vkVariableMultisampleRate (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkVariableMultisampleRateByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkVariableMultisampleRate #-}
        vkVariableMultisampleRateByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, variableMultisampleRate}

        {-# INLINE vkVariableMultisampleRateByteOffset #-}
        readVkVariableMultisampleRate (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkVariableMultisampleRateByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkVariableMultisampleRate #-}
        writeVkVariableMultisampleRate (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkVariableMultisampleRateByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkVariableMultisampleRate #-}

class HasVkInheritedQueries a where
        type VkInheritedQueriesMType a :: *

        vkInheritedQueries :: a -> VkInheritedQueriesMType a

        vkInheritedQueriesByteOffset :: a -> Int

        readVkInheritedQueries ::
                               Mutable a -> IO (VkInheritedQueriesMType a)

        writeVkInheritedQueries ::
                                Mutable a -> VkInheritedQueriesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'inheritedQueries'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkInheritedQueries a

instance {-# OVERLAPPING #-}
         HasVkInheritedQueries VkPhysicalDeviceFeatures where
        type VkInheritedQueriesMType VkPhysicalDeviceFeatures = VkBool32
        vkInheritedQueries (VkPhysicalDeviceFeatures## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkInheritedQueriesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkInheritedQueries #-}
        vkInheritedQueriesByteOffset ~_
          = #{offset VkPhysicalDeviceFeatures, inheritedQueries}

        {-# INLINE vkInheritedQueriesByteOffset #-}
        readVkInheritedQueries (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkInheritedQueriesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkInheritedQueries #-}
        writeVkInheritedQueries (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkInheritedQueriesByteOffset
                      (undefined :: VkPhysicalDeviceFeatures)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkInheritedQueries #-}

instance Show VkPhysicalDeviceFeatures where
        showsPrec d x
          = showString "VkPhysicalDeviceFeatures {" .
              showString "vkRobustBufferAccess = " .
                showsPrec d (vkRobustBufferAccess x) .
                  showString ", " .
                    showString "vkFullDrawIndexUint32 = " .
                      showsPrec d (vkFullDrawIndexUint32 x) .
                        showString ", " .
                          showString "vkImageCubeArray = " .
                            showsPrec d (vkImageCubeArray x) .
                              showString ", " .
                                showString "vkIndependentBlend = " .
                                  showsPrec d (vkIndependentBlend x) .
                                    showString ", " .
                                      showString "vkGeometryShader = " .
                                        showsPrec d (vkGeometryShader x) .
                                          showString ", " .
                                            showString "vkTessellationShader = " .
                                              showsPrec d (vkTessellationShader x) .
                                                showString ", " .
                                                  showString "vkSampleRateShading = " .
                                                    showsPrec d (vkSampleRateShading x) .
                                                      showString ", " .
                                                        showString "vkDualSrcBlend = " .
                                                          showsPrec d (vkDualSrcBlend x) .
                                                            showString ", " .
                                                              showString "vkLogicOp = " .
                                                                showsPrec d (vkLogicOp x) .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkMultiDrawIndirect = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkMultiDrawIndirect x)
                                                                        .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkDrawIndirectFirstInstance = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkDrawIndirectFirstInstance
                                                                                 x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkDepthClamp = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkDepthClamp x)
                                                                                    .
                                                                                    showString ", "
                                                                                      .
                                                                                      showString
                                                                                        "vkDepthBiasClamp = "
                                                                                        .
                                                                                        showsPrec d
                                                                                          (vkDepthBiasClamp
                                                                                             x)
                                                                                          .
                                                                                          showString
                                                                                            ", "
                                                                                            .
                                                                                            showString
                                                                                              "vkFillModeNonSolid = "
                                                                                              .
                                                                                              showsPrec
                                                                                                d
                                                                                                (vkFillModeNonSolid
                                                                                                   x)
                                                                                                .
                                                                                                showString
                                                                                                  ", "
                                                                                                  .
                                                                                                  showString
                                                                                                    "vkDepthBounds = "
                                                                                                    .
                                                                                                    showsPrec
                                                                                                      d
                                                                                                      (vkDepthBounds
                                                                                                         x)
                                                                                                      .
                                                                                                      showString
                                                                                                        ", "
                                                                                                        .
                                                                                                        showString
                                                                                                          "vkWideLines = "
                                                                                                          .
                                                                                                          showsPrec
                                                                                                            d
                                                                                                            (vkWideLines
                                                                                                               x)
                                                                                                            .
                                                                                                            showString
                                                                                                              ", "
                                                                                                              .
                                                                                                              showString
                                                                                                                "vkLargePoints = "
                                                                                                                .
                                                                                                                showsPrec
                                                                                                                  d
                                                                                                                  (vkLargePoints
                                                                                                                     x)
                                                                                                                  .
                                                                                                                  showString
                                                                                                                    ", "
                                                                                                                    .
                                                                                                                    showString
                                                                                                                      "vkAlphaToOne = "
                                                                                                                      .
                                                                                                                      showsPrec
                                                                                                                        d
                                                                                                                        (vkAlphaToOne
                                                                                                                           x)
                                                                                                                        .
                                                                                                                        showString
                                                                                                                          ", "
                                                                                                                          .
                                                                                                                          showString
                                                                                                                            "vkMultiViewport = "
                                                                                                                            .
                                                                                                                            showsPrec
                                                                                                                              d
                                                                                                                              (vkMultiViewport
                                                                                                                                 x)
                                                                                                                              .
                                                                                                                              showString
                                                                                                                                ", "
                                                                                                                                .
                                                                                                                                showString
                                                                                                                                  "vkSamplerAnisotropy = "
                                                                                                                                  .
                                                                                                                                  showsPrec
                                                                                                                                    d
                                                                                                                                    (vkSamplerAnisotropy
                                                                                                                                       x)
                                                                                                                                    .
                                                                                                                                    showString
                                                                                                                                      ", "
                                                                                                                                      .
                                                                                                                                      showString
                                                                                                                                        "vkTextureCompressionETC2 = "
                                                                                                                                        .
                                                                                                                                        showsPrec
                                                                                                                                          d
                                                                                                                                          (vkTextureCompressionETC2
                                                                                                                                             x)
                                                                                                                                          .
                                                                                                                                          showString
                                                                                                                                            ", "
                                                                                                                                            .
                                                                                                                                            showString
                                                                                                                                              "vkTextureCompressionASTC_LDR = "
                                                                                                                                              .
                                                                                                                                              showsPrec
                                                                                                                                                d
                                                                                                                                                (vkTextureCompressionASTC_LDR
                                                                                                                                                   x)
                                                                                                                                                .
                                                                                                                                                showString
                                                                                                                                                  ", "
                                                                                                                                                  .
                                                                                                                                                  showString
                                                                                                                                                    "vkTextureCompressionBC = "
                                                                                                                                                    .
                                                                                                                                                    showsPrec
                                                                                                                                                      d
                                                                                                                                                      (vkTextureCompressionBC
                                                                                                                                                         x)
                                                                                                                                                      .
                                                                                                                                                      showString
                                                                                                                                                        ", "
                                                                                                                                                        .
                                                                                                                                                        showString
                                                                                                                                                          "vkOcclusionQueryPrecise = "
                                                                                                                                                          .
                                                                                                                                                          showsPrec
                                                                                                                                                            d
                                                                                                                                                            (vkOcclusionQueryPrecise
                                                                                                                                                               x)
                                                                                                                                                            .
                                                                                                                                                            showString
                                                                                                                                                              ", "
                                                                                                                                                              .
                                                                                                                                                              showString
                                                                                                                                                                "vkPipelineStatisticsQuery = "
                                                                                                                                                                .
                                                                                                                                                                showsPrec
                                                                                                                                                                  d
                                                                                                                                                                  (vkPipelineStatisticsQuery
                                                                                                                                                                     x)
                                                                                                                                                                  .
                                                                                                                                                                  showString
                                                                                                                                                                    ", "
                                                                                                                                                                    .
                                                                                                                                                                    showString
                                                                                                                                                                      "vkVertexPipelineStoresAndAtomics = "
                                                                                                                                                                      .
                                                                                                                                                                      showsPrec
                                                                                                                                                                        d
                                                                                                                                                                        (vkVertexPipelineStoresAndAtomics
                                                                                                                                                                           x)
                                                                                                                                                                        .
                                                                                                                                                                        showString
                                                                                                                                                                          ", "
                                                                                                                                                                          .
                                                                                                                                                                          showString
                                                                                                                                                                            "vkFragmentStoresAndAtomics = "
                                                                                                                                                                            .
                                                                                                                                                                            showsPrec
                                                                                                                                                                              d
                                                                                                                                                                              (vkFragmentStoresAndAtomics
                                                                                                                                                                                 x)
                                                                                                                                                                              .
                                                                                                                                                                              showString
                                                                                                                                                                                ", "
                                                                                                                                                                                .
                                                                                                                                                                                showString
                                                                                                                                                                                  "vkShaderTessellationAndGeometryPointSize = "
                                                                                                                                                                                  .
                                                                                                                                                                                  showsPrec
                                                                                                                                                                                    d
                                                                                                                                                                                    (vkShaderTessellationAndGeometryPointSize
                                                                                                                                                                                       x)
                                                                                                                                                                                    .
                                                                                                                                                                                    showString
                                                                                                                                                                                      ", "
                                                                                                                                                                                      .
                                                                                                                                                                                      showString
                                                                                                                                                                                        "vkShaderImageGatherExtended = "
                                                                                                                                                                                        .
                                                                                                                                                                                        showsPrec
                                                                                                                                                                                          d
                                                                                                                                                                                          (vkShaderImageGatherExtended
                                                                                                                                                                                             x)
                                                                                                                                                                                          .
                                                                                                                                                                                          showString
                                                                                                                                                                                            ", "
                                                                                                                                                                                            .
                                                                                                                                                                                            showString
                                                                                                                                                                                              "vkShaderStorageImageExtendedFormats = "
                                                                                                                                                                                              .
                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                d
                                                                                                                                                                                                (vkShaderStorageImageExtendedFormats
                                                                                                                                                                                                   x)
                                                                                                                                                                                                .
                                                                                                                                                                                                showString
                                                                                                                                                                                                  ", "
                                                                                                                                                                                                  .
                                                                                                                                                                                                  showString
                                                                                                                                                                                                    "vkShaderStorageImageMultisample = "
                                                                                                                                                                                                    .
                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                      d
                                                                                                                                                                                                      (vkShaderStorageImageMultisample
                                                                                                                                                                                                         x)
                                                                                                                                                                                                      .
                                                                                                                                                                                                      showString
                                                                                                                                                                                                        ", "
                                                                                                                                                                                                        .
                                                                                                                                                                                                        showString
                                                                                                                                                                                                          "vkShaderStorageImageReadWithoutFormat = "
                                                                                                                                                                                                          .
                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                            d
                                                                                                                                                                                                            (vkShaderStorageImageReadWithoutFormat
                                                                                                                                                                                                               x)
                                                                                                                                                                                                            .
                                                                                                                                                                                                            showString
                                                                                                                                                                                                              ", "
                                                                                                                                                                                                              .
                                                                                                                                                                                                              showString
                                                                                                                                                                                                                "vkShaderStorageImageWriteWithoutFormat = "
                                                                                                                                                                                                                .
                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                  d
                                                                                                                                                                                                                  (vkShaderStorageImageWriteWithoutFormat
                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                  .
                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                    .
                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                      "vkShaderUniformBufferArrayDynamicIndexing = "
                                                                                                                                                                                                                      .
                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                        d
                                                                                                                                                                                                                        (vkShaderUniformBufferArrayDynamicIndexing
                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                        .
                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                          .
                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                            "vkShaderSampledImageArrayDynamicIndexing = "
                                                                                                                                                                                                                            .
                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                              d
                                                                                                                                                                                                                              (vkShaderSampledImageArrayDynamicIndexing
                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                              .
                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                  "vkShaderStorageBufferArrayDynamicIndexing = "
                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                    (vkShaderStorageBufferArrayDynamicIndexing
                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                        "vkShaderStorageImageArrayDynamicIndexing = "
                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                          (vkShaderStorageImageArrayDynamicIndexing
                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                              "vkShaderClipDistance = "
                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                (vkShaderClipDistance
                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                    "vkShaderCullDistance = "
                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                      (vkShaderCullDistance
                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                          "vkShaderFloat64 = "
                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                            (vkShaderFloat64
                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                "vkShaderInt64 = "
                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                  (vkShaderInt64
                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                      "vkShaderInt16 = "
                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                        (vkShaderInt16
                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                            "vkShaderResourceResidency = "
                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                              (vkShaderResourceResidency
                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                  "vkShaderResourceMinLod = "
                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                    (vkShaderResourceMinLod
                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                        "vkSparseBinding = "
                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                          (vkSparseBinding
                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                              "vkSparseResidencyBuffer = "
                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                (vkSparseResidencyBuffer
                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                    "vkSparseResidencyImage2D = "
                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                      (vkSparseResidencyImage2D
                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                          "vkSparseResidencyImage3D = "
                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                            (vkSparseResidencyImage3D
                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                "vkSparseResidency2Samples = "
                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                  (vkSparseResidency2Samples
                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                      "vkSparseResidency4Samples = "
                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                        (vkSparseResidency4Samples
                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                            "vkSparseResidency8Samples = "
                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                              (vkSparseResidency8Samples
                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                  "vkSparseResidency16Samples = "
                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                    (vkSparseResidency16Samples
                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                        "vkSparseResidencyAliased = "
                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                                                                          (vkSparseResidencyAliased
                                                                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                              "vkVariableMultisampleRate = "
                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                (vkVariableMultisampleRate
                                                                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                    "vkInheritedQueries = "
                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                                                                      (vkInheritedQueries
                                                                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                      showChar
                                                                                                                                                                                                                                                                                                                                                        '}'

data VkPhysicalDeviceSparseProperties = VkPhysicalDeviceSparseProperties## ByteArray##

instance Eq VkPhysicalDeviceSparseProperties where
        (VkPhysicalDeviceSparseProperties## a) ==
          (VkPhysicalDeviceSparseProperties## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPhysicalDeviceSparseProperties where
        (VkPhysicalDeviceSparseProperties## a) `compare`
          (VkPhysicalDeviceSparseProperties## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPhysicalDeviceSparseProperties where
        sizeOf ~_ = #{size VkPhysicalDeviceSparseProperties}

        {-# INLINE sizeOf #-}
        alignment ~_
          = #{alignment VkPhysicalDeviceSparseProperties}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceSparseProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceSparseProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPhysicalDeviceSparseProperties##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPhysicalDeviceSparseProperties## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceSparseProperties) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPhysicalDeviceSparseProperties where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceSparseProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceSparseProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPhysicalDeviceSparseProperties##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPhysicalDeviceSparseProperties## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPhysicalDeviceSparseProperties## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceSparseProperties),
            I## a <- alignment (undefined :: VkPhysicalDeviceSparseProperties) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPhysicalDeviceSparseProperties## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPhysicalDeviceSparseProperties## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkResidencyStandard2DBlockShape a where
        type VkResidencyStandard2DBlockShapeMType a :: *

        vkResidencyStandard2DBlockShape ::
                                        a -> VkResidencyStandard2DBlockShapeMType a

        vkResidencyStandard2DBlockShapeByteOffset :: a -> Int

        readVkResidencyStandard2DBlockShape ::
                                            Mutable a -> IO (VkResidencyStandard2DBlockShapeMType a)

        writeVkResidencyStandard2DBlockShape ::
                                             Mutable a ->
                                               VkResidencyStandard2DBlockShapeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'residencyStandard2DBlockShape'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkResidencyStandard2DBlockShape a

instance {-# OVERLAPPING #-}
         HasVkResidencyStandard2DBlockShape VkPhysicalDeviceSparseProperties
         where
        type VkResidencyStandard2DBlockShapeMType
               VkPhysicalDeviceSparseProperties
             = VkBool32
        vkResidencyStandard2DBlockShape
          (VkPhysicalDeviceSparseProperties## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkResidencyStandard2DBlockShapeByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkResidencyStandard2DBlockShape #-}
        vkResidencyStandard2DBlockShapeByteOffset ~_
          = #{offset VkPhysicalDeviceSparseProperties, residencyStandard2DBlockShape}

        {-# INLINE vkResidencyStandard2DBlockShapeByteOffset #-}
        readVkResidencyStandard2DBlockShape (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkResidencyStandard2DBlockShapeByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkResidencyStandard2DBlockShape #-}
        writeVkResidencyStandard2DBlockShape (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkResidencyStandard2DBlockShapeByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkResidencyStandard2DBlockShape #-}

class HasVkResidencyStandard2DMultisampleBlockShape a where
        type VkResidencyStandard2DMultisampleBlockShapeMType a :: *

        vkResidencyStandard2DMultisampleBlockShape ::
                                                   a ->
                                                     VkResidencyStandard2DMultisampleBlockShapeMType
                                                       a

        vkResidencyStandard2DMultisampleBlockShapeByteOffset :: a -> Int

        readVkResidencyStandard2DMultisampleBlockShape ::
                                                       Mutable a ->
                                                         IO
                                                           (VkResidencyStandard2DMultisampleBlockShapeMType
                                                              a)

        writeVkResidencyStandard2DMultisampleBlockShape ::
                                                        Mutable a ->
                                                          VkResidencyStandard2DMultisampleBlockShapeMType
                                                            a
                                                            -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'residencyStandard2DMultisampleBlockShape'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkResidencyStandard2DMultisampleBlockShape a

instance {-# OVERLAPPING #-}
         HasVkResidencyStandard2DMultisampleBlockShape
           VkPhysicalDeviceSparseProperties
         where
        type VkResidencyStandard2DMultisampleBlockShapeMType
               VkPhysicalDeviceSparseProperties
             = VkBool32
        vkResidencyStandard2DMultisampleBlockShape
          (VkPhysicalDeviceSparseProperties## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkResidencyStandard2DMultisampleBlockShapeByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkResidencyStandard2DMultisampleBlockShape #-}
        vkResidencyStandard2DMultisampleBlockShapeByteOffset ~_
          = #{offset VkPhysicalDeviceSparseProperties, residencyStandard2DMultisampleBlockShape}

        {-# INLINE vkResidencyStandard2DMultisampleBlockShapeByteOffset #-}
        readVkResidencyStandard2DMultisampleBlockShape (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkResidencyStandard2DMultisampleBlockShapeByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkResidencyStandard2DMultisampleBlockShape #-}
        writeVkResidencyStandard2DMultisampleBlockShape (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkResidencyStandard2DMultisampleBlockShapeByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkResidencyStandard2DMultisampleBlockShape #-}

class HasVkResidencyStandard3DBlockShape a where
        type VkResidencyStandard3DBlockShapeMType a :: *

        vkResidencyStandard3DBlockShape ::
                                        a -> VkResidencyStandard3DBlockShapeMType a

        vkResidencyStandard3DBlockShapeByteOffset :: a -> Int

        readVkResidencyStandard3DBlockShape ::
                                            Mutable a -> IO (VkResidencyStandard3DBlockShapeMType a)

        writeVkResidencyStandard3DBlockShape ::
                                             Mutable a ->
                                               VkResidencyStandard3DBlockShapeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'residencyStandard3DBlockShape'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkResidencyStandard3DBlockShape a

instance {-# OVERLAPPING #-}
         HasVkResidencyStandard3DBlockShape VkPhysicalDeviceSparseProperties
         where
        type VkResidencyStandard3DBlockShapeMType
               VkPhysicalDeviceSparseProperties
             = VkBool32
        vkResidencyStandard3DBlockShape
          (VkPhysicalDeviceSparseProperties## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkResidencyStandard3DBlockShapeByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkResidencyStandard3DBlockShape #-}
        vkResidencyStandard3DBlockShapeByteOffset ~_
          = #{offset VkPhysicalDeviceSparseProperties, residencyStandard3DBlockShape}

        {-# INLINE vkResidencyStandard3DBlockShapeByteOffset #-}
        readVkResidencyStandard3DBlockShape (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkResidencyStandard3DBlockShapeByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkResidencyStandard3DBlockShape #-}
        writeVkResidencyStandard3DBlockShape (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkResidencyStandard3DBlockShapeByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkResidencyStandard3DBlockShape #-}

class HasVkResidencyAlignedMipSize a where
        type VkResidencyAlignedMipSizeMType a :: *

        vkResidencyAlignedMipSize :: a -> VkResidencyAlignedMipSizeMType a

        vkResidencyAlignedMipSizeByteOffset :: a -> Int

        readVkResidencyAlignedMipSize ::
                                      Mutable a -> IO (VkResidencyAlignedMipSizeMType a)

        writeVkResidencyAlignedMipSize ::
                                       Mutable a -> VkResidencyAlignedMipSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'residencyAlignedMipSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkResidencyAlignedMipSize a

instance {-# OVERLAPPING #-}
         HasVkResidencyAlignedMipSize VkPhysicalDeviceSparseProperties where
        type VkResidencyAlignedMipSizeMType
               VkPhysicalDeviceSparseProperties
             = VkBool32
        vkResidencyAlignedMipSize (VkPhysicalDeviceSparseProperties## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkResidencyAlignedMipSizeByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkResidencyAlignedMipSize #-}
        vkResidencyAlignedMipSizeByteOffset ~_
          = #{offset VkPhysicalDeviceSparseProperties, residencyAlignedMipSize}

        {-# INLINE vkResidencyAlignedMipSizeByteOffset #-}
        readVkResidencyAlignedMipSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkResidencyAlignedMipSizeByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkResidencyAlignedMipSize #-}
        writeVkResidencyAlignedMipSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkResidencyAlignedMipSizeByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkResidencyAlignedMipSize #-}

class HasVkResidencyNonResidentStrict a where
        type VkResidencyNonResidentStrictMType a :: *

        vkResidencyNonResidentStrict ::
                                     a -> VkResidencyNonResidentStrictMType a

        vkResidencyNonResidentStrictByteOffset :: a -> Int

        readVkResidencyNonResidentStrict ::
                                         Mutable a -> IO (VkResidencyNonResidentStrictMType a)

        writeVkResidencyNonResidentStrict ::
                                          Mutable a -> VkResidencyNonResidentStrictMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'residencyNonResidentStrict'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkResidencyNonResidentStrict a

instance {-# OVERLAPPING #-}
         HasVkResidencyNonResidentStrict VkPhysicalDeviceSparseProperties
         where
        type VkResidencyNonResidentStrictMType
               VkPhysicalDeviceSparseProperties
             = VkBool32
        vkResidencyNonResidentStrict (VkPhysicalDeviceSparseProperties## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkResidencyNonResidentStrictByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkResidencyNonResidentStrict #-}
        vkResidencyNonResidentStrictByteOffset ~_
          = #{offset VkPhysicalDeviceSparseProperties, residencyNonResidentStrict}

        {-# INLINE vkResidencyNonResidentStrictByteOffset #-}
        readVkResidencyNonResidentStrict (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkResidencyNonResidentStrictByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkResidencyNonResidentStrict #-}
        writeVkResidencyNonResidentStrict (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkResidencyNonResidentStrictByteOffset
                      (undefined :: VkPhysicalDeviceSparseProperties)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkResidencyNonResidentStrict #-}

instance Show VkPhysicalDeviceSparseProperties where
        showsPrec d x
          = showString "VkPhysicalDeviceSparseProperties {" .
              showString "vkResidencyStandard2DBlockShape = " .
                showsPrec d (vkResidencyStandard2DBlockShape x) .
                  showString ", " .
                    showString "vkResidencyStandard2DMultisampleBlockShape = " .
                      showsPrec d (vkResidencyStandard2DMultisampleBlockShape x) .
                        showString ", " .
                          showString "vkResidencyStandard3DBlockShape = " .
                            showsPrec d (vkResidencyStandard3DBlockShape x) .
                              showString ", " .
                                showString "vkResidencyAlignedMipSize = " .
                                  showsPrec d (vkResidencyAlignedMipSize x) .
                                    showString ", " .
                                      showString "vkResidencyNonResidentStrict = " .
                                        showsPrec d (vkResidencyNonResidentStrict x) . showChar '}'

data VkPhysicalDeviceLimits = VkPhysicalDeviceLimits## ByteArray##

instance Eq VkPhysicalDeviceLimits where
        (VkPhysicalDeviceLimits## a) == (VkPhysicalDeviceLimits## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPhysicalDeviceLimits where
        (VkPhysicalDeviceLimits## a) `compare` (VkPhysicalDeviceLimits## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPhysicalDeviceLimits where
        sizeOf ~_ = #{size VkPhysicalDeviceLimits}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPhysicalDeviceLimits}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceLimits),
            I## a <- alignment (undefined :: VkPhysicalDeviceLimits) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkPhysicalDeviceLimits##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPhysicalDeviceLimits## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceLimits) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPhysicalDeviceLimits where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceLimits),
            I## a <- alignment (undefined :: VkPhysicalDeviceLimits) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkPhysicalDeviceLimits##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPhysicalDeviceLimits## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPhysicalDeviceLimits## ba)
          | I## n <- sizeOf (undefined :: VkPhysicalDeviceLimits),
            I## a <- alignment (undefined :: VkPhysicalDeviceLimits) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPhysicalDeviceLimits## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPhysicalDeviceLimits## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkMaxImageDimension1D a where
        type VkMaxImageDimension1DMType a :: *

        vkMaxImageDimension1D :: a -> VkMaxImageDimension1DMType a

        vkMaxImageDimension1DByteOffset :: a -> Int

        readVkMaxImageDimension1D ::
                                  Mutable a -> IO (VkMaxImageDimension1DMType a)

        writeVkMaxImageDimension1D ::
                                   Mutable a -> VkMaxImageDimension1DMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxImageDimension1D'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxImageDimension1D a

instance {-# OVERLAPPING #-}
         HasVkMaxImageDimension1D VkPhysicalDeviceLimits where
        type VkMaxImageDimension1DMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxImageDimension1D (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxImageDimension1DByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxImageDimension1D #-}
        vkMaxImageDimension1DByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxImageDimension1D}

        {-# INLINE vkMaxImageDimension1DByteOffset #-}
        readVkMaxImageDimension1D (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxImageDimension1DByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxImageDimension1D #-}
        writeVkMaxImageDimension1D (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxImageDimension1DByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxImageDimension1D #-}

class HasVkMaxImageDimension2D a where
        type VkMaxImageDimension2DMType a :: *

        vkMaxImageDimension2D :: a -> VkMaxImageDimension2DMType a

        vkMaxImageDimension2DByteOffset :: a -> Int

        readVkMaxImageDimension2D ::
                                  Mutable a -> IO (VkMaxImageDimension2DMType a)

        writeVkMaxImageDimension2D ::
                                   Mutable a -> VkMaxImageDimension2DMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxImageDimension2D'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxImageDimension2D a

instance {-# OVERLAPPING #-}
         HasVkMaxImageDimension2D VkPhysicalDeviceLimits where
        type VkMaxImageDimension2DMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxImageDimension2D (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxImageDimension2DByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxImageDimension2D #-}
        vkMaxImageDimension2DByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxImageDimension2D}

        {-# INLINE vkMaxImageDimension2DByteOffset #-}
        readVkMaxImageDimension2D (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxImageDimension2DByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxImageDimension2D #-}
        writeVkMaxImageDimension2D (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxImageDimension2DByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxImageDimension2D #-}

class HasVkMaxImageDimension3D a where
        type VkMaxImageDimension3DMType a :: *

        vkMaxImageDimension3D :: a -> VkMaxImageDimension3DMType a

        vkMaxImageDimension3DByteOffset :: a -> Int

        readVkMaxImageDimension3D ::
                                  Mutable a -> IO (VkMaxImageDimension3DMType a)

        writeVkMaxImageDimension3D ::
                                   Mutable a -> VkMaxImageDimension3DMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxImageDimension3D'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxImageDimension3D a

instance {-# OVERLAPPING #-}
         HasVkMaxImageDimension3D VkPhysicalDeviceLimits where
        type VkMaxImageDimension3DMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxImageDimension3D (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxImageDimension3DByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxImageDimension3D #-}
        vkMaxImageDimension3DByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxImageDimension3D}

        {-# INLINE vkMaxImageDimension3DByteOffset #-}
        readVkMaxImageDimension3D (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxImageDimension3DByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxImageDimension3D #-}
        writeVkMaxImageDimension3D (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxImageDimension3DByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxImageDimension3D #-}

class HasVkMaxImageDimensionCube a where
        type VkMaxImageDimensionCubeMType a :: *

        vkMaxImageDimensionCube :: a -> VkMaxImageDimensionCubeMType a

        vkMaxImageDimensionCubeByteOffset :: a -> Int

        readVkMaxImageDimensionCube ::
                                    Mutable a -> IO (VkMaxImageDimensionCubeMType a)

        writeVkMaxImageDimensionCube ::
                                     Mutable a -> VkMaxImageDimensionCubeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxImageDimensionCube'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxImageDimensionCube a

instance {-# OVERLAPPING #-}
         HasVkMaxImageDimensionCube VkPhysicalDeviceLimits where
        type VkMaxImageDimensionCubeMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxImageDimensionCube (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxImageDimensionCubeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxImageDimensionCube #-}
        vkMaxImageDimensionCubeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxImageDimensionCube}

        {-# INLINE vkMaxImageDimensionCubeByteOffset #-}
        readVkMaxImageDimensionCube (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxImageDimensionCubeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxImageDimensionCube #-}
        writeVkMaxImageDimensionCube (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxImageDimensionCubeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxImageDimensionCube #-}

class HasVkMaxImageArrayLayers a where
        type VkMaxImageArrayLayersMType a :: *

        vkMaxImageArrayLayers :: a -> VkMaxImageArrayLayersMType a

        vkMaxImageArrayLayersByteOffset :: a -> Int

        readVkMaxImageArrayLayers ::
                                  Mutable a -> IO (VkMaxImageArrayLayersMType a)

        writeVkMaxImageArrayLayers ::
                                   Mutable a -> VkMaxImageArrayLayersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxImageArrayLayers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxImageArrayLayers a

instance {-# OVERLAPPING #-}
         HasVkMaxImageArrayLayers VkPhysicalDeviceLimits where
        type VkMaxImageArrayLayersMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxImageArrayLayers (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxImageArrayLayersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxImageArrayLayers #-}
        vkMaxImageArrayLayersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxImageArrayLayers}

        {-# INLINE vkMaxImageArrayLayersByteOffset #-}
        readVkMaxImageArrayLayers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxImageArrayLayersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxImageArrayLayers #-}
        writeVkMaxImageArrayLayers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxImageArrayLayersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxImageArrayLayers #-}

class HasVkMaxTexelBufferElements a where
        type VkMaxTexelBufferElementsMType a :: *

        vkMaxTexelBufferElements :: a -> VkMaxTexelBufferElementsMType a

        vkMaxTexelBufferElementsByteOffset :: a -> Int

        readVkMaxTexelBufferElements ::
                                     Mutable a -> IO (VkMaxTexelBufferElementsMType a)

        writeVkMaxTexelBufferElements ::
                                      Mutable a -> VkMaxTexelBufferElementsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxTexelBufferElements'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTexelBufferElements a

instance {-# OVERLAPPING #-}
         HasVkMaxTexelBufferElements VkPhysicalDeviceLimits where
        type VkMaxTexelBufferElementsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxTexelBufferElements (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTexelBufferElementsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxTexelBufferElements #-}
        vkMaxTexelBufferElementsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTexelBufferElements}

        {-# INLINE vkMaxTexelBufferElementsByteOffset #-}
        readVkMaxTexelBufferElements (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTexelBufferElementsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxTexelBufferElements #-}
        writeVkMaxTexelBufferElements (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxTexelBufferElementsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxTexelBufferElements #-}

class HasVkMaxUniformBufferRange a where
        type VkMaxUniformBufferRangeMType a :: *

        vkMaxUniformBufferRange :: a -> VkMaxUniformBufferRangeMType a

        vkMaxUniformBufferRangeByteOffset :: a -> Int

        readVkMaxUniformBufferRange ::
                                    Mutable a -> IO (VkMaxUniformBufferRangeMType a)

        writeVkMaxUniformBufferRange ::
                                     Mutable a -> VkMaxUniformBufferRangeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxUniformBufferRange'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxUniformBufferRange a

instance {-# OVERLAPPING #-}
         HasVkMaxUniformBufferRange VkPhysicalDeviceLimits where
        type VkMaxUniformBufferRangeMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxUniformBufferRange (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxUniformBufferRangeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxUniformBufferRange #-}
        vkMaxUniformBufferRangeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxUniformBufferRange}

        {-# INLINE vkMaxUniformBufferRangeByteOffset #-}
        readVkMaxUniformBufferRange (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxUniformBufferRangeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxUniformBufferRange #-}
        writeVkMaxUniformBufferRange (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxUniformBufferRangeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxUniformBufferRange #-}

class HasVkMaxStorageBufferRange a where
        type VkMaxStorageBufferRangeMType a :: *

        vkMaxStorageBufferRange :: a -> VkMaxStorageBufferRangeMType a

        vkMaxStorageBufferRangeByteOffset :: a -> Int

        readVkMaxStorageBufferRange ::
                                    Mutable a -> IO (VkMaxStorageBufferRangeMType a)

        writeVkMaxStorageBufferRange ::
                                     Mutable a -> VkMaxStorageBufferRangeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxStorageBufferRange'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxStorageBufferRange a

instance {-# OVERLAPPING #-}
         HasVkMaxStorageBufferRange VkPhysicalDeviceLimits where
        type VkMaxStorageBufferRangeMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxStorageBufferRange (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxStorageBufferRangeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxStorageBufferRange #-}
        vkMaxStorageBufferRangeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxStorageBufferRange}

        {-# INLINE vkMaxStorageBufferRangeByteOffset #-}
        readVkMaxStorageBufferRange (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxStorageBufferRangeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxStorageBufferRange #-}
        writeVkMaxStorageBufferRange (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxStorageBufferRangeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxStorageBufferRange #-}

class HasVkMaxPushConstantsSize a where
        type VkMaxPushConstantsSizeMType a :: *

        vkMaxPushConstantsSize :: a -> VkMaxPushConstantsSizeMType a

        vkMaxPushConstantsSizeByteOffset :: a -> Int

        readVkMaxPushConstantsSize ::
                                   Mutable a -> IO (VkMaxPushConstantsSizeMType a)

        writeVkMaxPushConstantsSize ::
                                    Mutable a -> VkMaxPushConstantsSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxPushConstantsSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPushConstantsSize a

instance {-# OVERLAPPING #-}
         HasVkMaxPushConstantsSize VkPhysicalDeviceLimits where
        type VkMaxPushConstantsSizeMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxPushConstantsSize (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPushConstantsSizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxPushConstantsSize #-}
        vkMaxPushConstantsSizeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPushConstantsSize}

        {-# INLINE vkMaxPushConstantsSizeByteOffset #-}
        readVkMaxPushConstantsSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPushConstantsSizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxPushConstantsSize #-}
        writeVkMaxPushConstantsSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxPushConstantsSizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxPushConstantsSize #-}

class HasVkMaxMemoryAllocationCount a where
        type VkMaxMemoryAllocationCountMType a :: *

        vkMaxMemoryAllocationCount ::
                                   a -> VkMaxMemoryAllocationCountMType a

        vkMaxMemoryAllocationCountByteOffset :: a -> Int

        readVkMaxMemoryAllocationCount ::
                                       Mutable a -> IO (VkMaxMemoryAllocationCountMType a)

        writeVkMaxMemoryAllocationCount ::
                                        Mutable a -> VkMaxMemoryAllocationCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxMemoryAllocationCount'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxMemoryAllocationCount a

instance {-# OVERLAPPING #-}
         HasVkMaxMemoryAllocationCount VkPhysicalDeviceLimits where
        type VkMaxMemoryAllocationCountMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxMemoryAllocationCount (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxMemoryAllocationCountByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxMemoryAllocationCount #-}
        vkMaxMemoryAllocationCountByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxMemoryAllocationCount}

        {-# INLINE vkMaxMemoryAllocationCountByteOffset #-}
        readVkMaxMemoryAllocationCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxMemoryAllocationCountByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxMemoryAllocationCount #-}
        writeVkMaxMemoryAllocationCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxMemoryAllocationCountByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxMemoryAllocationCount #-}

class HasVkMaxSamplerAllocationCount a where
        type VkMaxSamplerAllocationCountMType a :: *

        vkMaxSamplerAllocationCount ::
                                    a -> VkMaxSamplerAllocationCountMType a

        vkMaxSamplerAllocationCountByteOffset :: a -> Int

        readVkMaxSamplerAllocationCount ::
                                        Mutable a -> IO (VkMaxSamplerAllocationCountMType a)

        writeVkMaxSamplerAllocationCount ::
                                         Mutable a -> VkMaxSamplerAllocationCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxSamplerAllocationCount'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxSamplerAllocationCount a

instance {-# OVERLAPPING #-}
         HasVkMaxSamplerAllocationCount VkPhysicalDeviceLimits where
        type VkMaxSamplerAllocationCountMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxSamplerAllocationCount (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxSamplerAllocationCountByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxSamplerAllocationCount #-}
        vkMaxSamplerAllocationCountByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxSamplerAllocationCount}

        {-# INLINE vkMaxSamplerAllocationCountByteOffset #-}
        readVkMaxSamplerAllocationCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxSamplerAllocationCountByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxSamplerAllocationCount #-}
        writeVkMaxSamplerAllocationCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxSamplerAllocationCountByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxSamplerAllocationCount #-}

class HasVkBufferImageGranularity a where
        type VkBufferImageGranularityMType a :: *

        vkBufferImageGranularity :: a -> VkBufferImageGranularityMType a

        vkBufferImageGranularityByteOffset :: a -> Int

        readVkBufferImageGranularity ::
                                     Mutable a -> IO (VkBufferImageGranularityMType a)

        writeVkBufferImageGranularity ::
                                      Mutable a -> VkBufferImageGranularityMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'bufferImageGranularity'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkBufferImageGranularity a

instance {-# OVERLAPPING #-}
         HasVkBufferImageGranularity VkPhysicalDeviceLimits where
        type VkBufferImageGranularityMType VkPhysicalDeviceLimits =
             VkDeviceSize
        vkBufferImageGranularity (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkBufferImageGranularityByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkBufferImageGranularity #-}
        vkBufferImageGranularityByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, bufferImageGranularity}

        {-# INLINE vkBufferImageGranularityByteOffset #-}
        readVkBufferImageGranularity (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkBufferImageGranularityByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkBufferImageGranularity #-}
        writeVkBufferImageGranularity (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkBufferImageGranularityByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkBufferImageGranularity #-}

class HasVkSparseAddressSpaceSize a where
        type VkSparseAddressSpaceSizeMType a :: *

        vkSparseAddressSpaceSize :: a -> VkSparseAddressSpaceSizeMType a

        vkSparseAddressSpaceSizeByteOffset :: a -> Int

        readVkSparseAddressSpaceSize ::
                                     Mutable a -> IO (VkSparseAddressSpaceSizeMType a)

        writeVkSparseAddressSpaceSize ::
                                      Mutable a -> VkSparseAddressSpaceSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'sparseAddressSpaceSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSparseAddressSpaceSize a

instance {-# OVERLAPPING #-}
         HasVkSparseAddressSpaceSize VkPhysicalDeviceLimits where
        type VkSparseAddressSpaceSizeMType VkPhysicalDeviceLimits =
             VkDeviceSize
        vkSparseAddressSpaceSize (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSparseAddressSpaceSizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSparseAddressSpaceSize #-}
        vkSparseAddressSpaceSizeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, sparseAddressSpaceSize}

        {-# INLINE vkSparseAddressSpaceSizeByteOffset #-}
        readVkSparseAddressSpaceSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkSparseAddressSpaceSizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSparseAddressSpaceSize #-}
        writeVkSparseAddressSpaceSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSparseAddressSpaceSizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSparseAddressSpaceSize #-}

class HasVkMaxBoundDescriptorSets a where
        type VkMaxBoundDescriptorSetsMType a :: *

        vkMaxBoundDescriptorSets :: a -> VkMaxBoundDescriptorSetsMType a

        vkMaxBoundDescriptorSetsByteOffset :: a -> Int

        readVkMaxBoundDescriptorSets ::
                                     Mutable a -> IO (VkMaxBoundDescriptorSetsMType a)

        writeVkMaxBoundDescriptorSets ::
                                      Mutable a -> VkMaxBoundDescriptorSetsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxBoundDescriptorSets'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxBoundDescriptorSets a

instance {-# OVERLAPPING #-}
         HasVkMaxBoundDescriptorSets VkPhysicalDeviceLimits where
        type VkMaxBoundDescriptorSetsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxBoundDescriptorSets (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxBoundDescriptorSetsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxBoundDescriptorSets #-}
        vkMaxBoundDescriptorSetsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxBoundDescriptorSets}

        {-# INLINE vkMaxBoundDescriptorSetsByteOffset #-}
        readVkMaxBoundDescriptorSets (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxBoundDescriptorSetsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxBoundDescriptorSets #-}
        writeVkMaxBoundDescriptorSets (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxBoundDescriptorSetsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxBoundDescriptorSets #-}

class HasVkMaxPerStageDescriptorSamplers a where
        type VkMaxPerStageDescriptorSamplersMType a :: *

        vkMaxPerStageDescriptorSamplers ::
                                        a -> VkMaxPerStageDescriptorSamplersMType a

        vkMaxPerStageDescriptorSamplersByteOffset :: a -> Int

        readVkMaxPerStageDescriptorSamplers ::
                                            Mutable a -> IO (VkMaxPerStageDescriptorSamplersMType a)

        writeVkMaxPerStageDescriptorSamplers ::
                                             Mutable a ->
                                               VkMaxPerStageDescriptorSamplersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxPerStageDescriptorSamplers'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPerStageDescriptorSamplers a

instance {-# OVERLAPPING #-}
         HasVkMaxPerStageDescriptorSamplers VkPhysicalDeviceLimits where
        type VkMaxPerStageDescriptorSamplersMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxPerStageDescriptorSamplers (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPerStageDescriptorSamplersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxPerStageDescriptorSamplers #-}
        vkMaxPerStageDescriptorSamplersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorSamplers}

        {-# INLINE vkMaxPerStageDescriptorSamplersByteOffset #-}
        readVkMaxPerStageDescriptorSamplers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPerStageDescriptorSamplersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxPerStageDescriptorSamplers #-}
        writeVkMaxPerStageDescriptorSamplers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxPerStageDescriptorSamplersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxPerStageDescriptorSamplers #-}

class HasVkMaxPerStageDescriptorUniformBuffers a where
        type VkMaxPerStageDescriptorUniformBuffersMType a :: *

        vkMaxPerStageDescriptorUniformBuffers ::
                                              a -> VkMaxPerStageDescriptorUniformBuffersMType a

        vkMaxPerStageDescriptorUniformBuffersByteOffset :: a -> Int

        readVkMaxPerStageDescriptorUniformBuffers ::
                                                  Mutable a ->
                                                    IO
                                                      (VkMaxPerStageDescriptorUniformBuffersMType a)

        writeVkMaxPerStageDescriptorUniformBuffers ::
                                                   Mutable a ->
                                                     VkMaxPerStageDescriptorUniformBuffersMType a ->
                                                       IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxPerStageDescriptorUniformBuffers'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPerStageDescriptorUniformBuffers a

instance {-# OVERLAPPING #-}
         HasVkMaxPerStageDescriptorUniformBuffers VkPhysicalDeviceLimits
         where
        type VkMaxPerStageDescriptorUniformBuffersMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxPerStageDescriptorUniformBuffers (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPerStageDescriptorUniformBuffersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxPerStageDescriptorUniformBuffers #-}
        vkMaxPerStageDescriptorUniformBuffersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorUniformBuffers}

        {-# INLINE vkMaxPerStageDescriptorUniformBuffersByteOffset #-}
        readVkMaxPerStageDescriptorUniformBuffers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPerStageDescriptorUniformBuffersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxPerStageDescriptorUniformBuffers #-}
        writeVkMaxPerStageDescriptorUniformBuffers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxPerStageDescriptorUniformBuffersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxPerStageDescriptorUniformBuffers #-}

class HasVkMaxPerStageDescriptorStorageBuffers a where
        type VkMaxPerStageDescriptorStorageBuffersMType a :: *

        vkMaxPerStageDescriptorStorageBuffers ::
                                              a -> VkMaxPerStageDescriptorStorageBuffersMType a

        vkMaxPerStageDescriptorStorageBuffersByteOffset :: a -> Int

        readVkMaxPerStageDescriptorStorageBuffers ::
                                                  Mutable a ->
                                                    IO
                                                      (VkMaxPerStageDescriptorStorageBuffersMType a)

        writeVkMaxPerStageDescriptorStorageBuffers ::
                                                   Mutable a ->
                                                     VkMaxPerStageDescriptorStorageBuffersMType a ->
                                                       IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxPerStageDescriptorStorageBuffers'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPerStageDescriptorStorageBuffers a

instance {-# OVERLAPPING #-}
         HasVkMaxPerStageDescriptorStorageBuffers VkPhysicalDeviceLimits
         where
        type VkMaxPerStageDescriptorStorageBuffersMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxPerStageDescriptorStorageBuffers (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPerStageDescriptorStorageBuffersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxPerStageDescriptorStorageBuffers #-}
        vkMaxPerStageDescriptorStorageBuffersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorStorageBuffers}

        {-# INLINE vkMaxPerStageDescriptorStorageBuffersByteOffset #-}
        readVkMaxPerStageDescriptorStorageBuffers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPerStageDescriptorStorageBuffersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxPerStageDescriptorStorageBuffers #-}
        writeVkMaxPerStageDescriptorStorageBuffers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxPerStageDescriptorStorageBuffersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxPerStageDescriptorStorageBuffers #-}

class HasVkMaxPerStageDescriptorSampledImages a where
        type VkMaxPerStageDescriptorSampledImagesMType a :: *

        vkMaxPerStageDescriptorSampledImages ::
                                             a -> VkMaxPerStageDescriptorSampledImagesMType a

        vkMaxPerStageDescriptorSampledImagesByteOffset :: a -> Int

        readVkMaxPerStageDescriptorSampledImages ::
                                                 Mutable a ->
                                                   IO (VkMaxPerStageDescriptorSampledImagesMType a)

        writeVkMaxPerStageDescriptorSampledImages ::
                                                  Mutable a ->
                                                    VkMaxPerStageDescriptorSampledImagesMType a ->
                                                      IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxPerStageDescriptorSampledImages'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPerStageDescriptorSampledImages a

instance {-# OVERLAPPING #-}
         HasVkMaxPerStageDescriptorSampledImages VkPhysicalDeviceLimits
         where
        type VkMaxPerStageDescriptorSampledImagesMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxPerStageDescriptorSampledImages (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPerStageDescriptorSampledImagesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxPerStageDescriptorSampledImages #-}
        vkMaxPerStageDescriptorSampledImagesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorSampledImages}

        {-# INLINE vkMaxPerStageDescriptorSampledImagesByteOffset #-}
        readVkMaxPerStageDescriptorSampledImages (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPerStageDescriptorSampledImagesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxPerStageDescriptorSampledImages #-}
        writeVkMaxPerStageDescriptorSampledImages (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxPerStageDescriptorSampledImagesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxPerStageDescriptorSampledImages #-}

class HasVkMaxPerStageDescriptorStorageImages a where
        type VkMaxPerStageDescriptorStorageImagesMType a :: *

        vkMaxPerStageDescriptorStorageImages ::
                                             a -> VkMaxPerStageDescriptorStorageImagesMType a

        vkMaxPerStageDescriptorStorageImagesByteOffset :: a -> Int

        readVkMaxPerStageDescriptorStorageImages ::
                                                 Mutable a ->
                                                   IO (VkMaxPerStageDescriptorStorageImagesMType a)

        writeVkMaxPerStageDescriptorStorageImages ::
                                                  Mutable a ->
                                                    VkMaxPerStageDescriptorStorageImagesMType a ->
                                                      IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxPerStageDescriptorStorageImages'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPerStageDescriptorStorageImages a

instance {-# OVERLAPPING #-}
         HasVkMaxPerStageDescriptorStorageImages VkPhysicalDeviceLimits
         where
        type VkMaxPerStageDescriptorStorageImagesMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxPerStageDescriptorStorageImages (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPerStageDescriptorStorageImagesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxPerStageDescriptorStorageImages #-}
        vkMaxPerStageDescriptorStorageImagesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorStorageImages}

        {-# INLINE vkMaxPerStageDescriptorStorageImagesByteOffset #-}
        readVkMaxPerStageDescriptorStorageImages (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPerStageDescriptorStorageImagesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxPerStageDescriptorStorageImages #-}
        writeVkMaxPerStageDescriptorStorageImages (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxPerStageDescriptorStorageImagesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxPerStageDescriptorStorageImages #-}

class HasVkMaxPerStageDescriptorInputAttachments a where
        type VkMaxPerStageDescriptorInputAttachmentsMType a :: *

        vkMaxPerStageDescriptorInputAttachments ::
                                                a -> VkMaxPerStageDescriptorInputAttachmentsMType a

        vkMaxPerStageDescriptorInputAttachmentsByteOffset :: a -> Int

        readVkMaxPerStageDescriptorInputAttachments ::
                                                    Mutable a ->
                                                      IO
                                                        (VkMaxPerStageDescriptorInputAttachmentsMType
                                                           a)

        writeVkMaxPerStageDescriptorInputAttachments ::
                                                     Mutable a ->
                                                       VkMaxPerStageDescriptorInputAttachmentsMType
                                                         a
                                                         -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxPerStageDescriptorInputAttachments'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPerStageDescriptorInputAttachments a

instance {-# OVERLAPPING #-}
         HasVkMaxPerStageDescriptorInputAttachments VkPhysicalDeviceLimits
         where
        type VkMaxPerStageDescriptorInputAttachmentsMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxPerStageDescriptorInputAttachments
          (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPerStageDescriptorInputAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxPerStageDescriptorInputAttachments #-}
        vkMaxPerStageDescriptorInputAttachmentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPerStageDescriptorInputAttachments}

        {-# INLINE vkMaxPerStageDescriptorInputAttachmentsByteOffset #-}
        readVkMaxPerStageDescriptorInputAttachments (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPerStageDescriptorInputAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxPerStageDescriptorInputAttachments #-}
        writeVkMaxPerStageDescriptorInputAttachments (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxPerStageDescriptorInputAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxPerStageDescriptorInputAttachments #-}

class HasVkMaxPerStageResources a where
        type VkMaxPerStageResourcesMType a :: *

        vkMaxPerStageResources :: a -> VkMaxPerStageResourcesMType a

        vkMaxPerStageResourcesByteOffset :: a -> Int

        readVkMaxPerStageResources ::
                                   Mutable a -> IO (VkMaxPerStageResourcesMType a)

        writeVkMaxPerStageResources ::
                                    Mutable a -> VkMaxPerStageResourcesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxPerStageResources'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxPerStageResources a

instance {-# OVERLAPPING #-}
         HasVkMaxPerStageResources VkPhysicalDeviceLimits where
        type VkMaxPerStageResourcesMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxPerStageResources (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPerStageResourcesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxPerStageResources #-}
        vkMaxPerStageResourcesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxPerStageResources}

        {-# INLINE vkMaxPerStageResourcesByteOffset #-}
        readVkMaxPerStageResources (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxPerStageResourcesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxPerStageResources #-}
        writeVkMaxPerStageResources (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxPerStageResourcesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxPerStageResources #-}

class HasVkMaxDescriptorSetSamplers a where
        type VkMaxDescriptorSetSamplersMType a :: *

        vkMaxDescriptorSetSamplers ::
                                   a -> VkMaxDescriptorSetSamplersMType a

        vkMaxDescriptorSetSamplersByteOffset :: a -> Int

        readVkMaxDescriptorSetSamplers ::
                                       Mutable a -> IO (VkMaxDescriptorSetSamplersMType a)

        writeVkMaxDescriptorSetSamplers ::
                                        Mutable a -> VkMaxDescriptorSetSamplersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxDescriptorSetSamplers'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetSamplers a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetSamplers VkPhysicalDeviceLimits where
        type VkMaxDescriptorSetSamplersMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxDescriptorSetSamplers (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetSamplersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxDescriptorSetSamplers #-}
        vkMaxDescriptorSetSamplersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetSamplers}

        {-# INLINE vkMaxDescriptorSetSamplersByteOffset #-}
        readVkMaxDescriptorSetSamplers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetSamplersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxDescriptorSetSamplers #-}
        writeVkMaxDescriptorSetSamplers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxDescriptorSetSamplersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxDescriptorSetSamplers #-}

class HasVkMaxDescriptorSetUniformBuffers a where
        type VkMaxDescriptorSetUniformBuffersMType a :: *

        vkMaxDescriptorSetUniformBuffers ::
                                         a -> VkMaxDescriptorSetUniformBuffersMType a

        vkMaxDescriptorSetUniformBuffersByteOffset :: a -> Int

        readVkMaxDescriptorSetUniformBuffers ::
                                             Mutable a ->
                                               IO (VkMaxDescriptorSetUniformBuffersMType a)

        writeVkMaxDescriptorSetUniformBuffers ::
                                              Mutable a ->
                                                VkMaxDescriptorSetUniformBuffersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxDescriptorSetUniformBuffers'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetUniformBuffers a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetUniformBuffers VkPhysicalDeviceLimits where
        type VkMaxDescriptorSetUniformBuffersMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxDescriptorSetUniformBuffers (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetUniformBuffersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxDescriptorSetUniformBuffers #-}
        vkMaxDescriptorSetUniformBuffersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetUniformBuffers}

        {-# INLINE vkMaxDescriptorSetUniformBuffersByteOffset #-}
        readVkMaxDescriptorSetUniformBuffers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetUniformBuffersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxDescriptorSetUniformBuffers #-}
        writeVkMaxDescriptorSetUniformBuffers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxDescriptorSetUniformBuffersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxDescriptorSetUniformBuffers #-}

class HasVkMaxDescriptorSetUniformBuffersDynamic a where
        type VkMaxDescriptorSetUniformBuffersDynamicMType a :: *

        vkMaxDescriptorSetUniformBuffersDynamic ::
                                                a -> VkMaxDescriptorSetUniformBuffersDynamicMType a

        vkMaxDescriptorSetUniformBuffersDynamicByteOffset :: a -> Int

        readVkMaxDescriptorSetUniformBuffersDynamic ::
                                                    Mutable a ->
                                                      IO
                                                        (VkMaxDescriptorSetUniformBuffersDynamicMType
                                                           a)

        writeVkMaxDescriptorSetUniformBuffersDynamic ::
                                                     Mutable a ->
                                                       VkMaxDescriptorSetUniformBuffersDynamicMType
                                                         a
                                                         -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxDescriptorSetUniformBuffersDynamic'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetUniformBuffersDynamic a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetUniformBuffersDynamic VkPhysicalDeviceLimits
         where
        type VkMaxDescriptorSetUniformBuffersDynamicMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxDescriptorSetUniformBuffersDynamic
          (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetUniformBuffersDynamicByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxDescriptorSetUniformBuffersDynamic #-}
        vkMaxDescriptorSetUniformBuffersDynamicByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetUniformBuffersDynamic}

        {-# INLINE vkMaxDescriptorSetUniformBuffersDynamicByteOffset #-}
        readVkMaxDescriptorSetUniformBuffersDynamic (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetUniformBuffersDynamicByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxDescriptorSetUniformBuffersDynamic #-}
        writeVkMaxDescriptorSetUniformBuffersDynamic (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxDescriptorSetUniformBuffersDynamicByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxDescriptorSetUniformBuffersDynamic #-}

class HasVkMaxDescriptorSetStorageBuffers a where
        type VkMaxDescriptorSetStorageBuffersMType a :: *

        vkMaxDescriptorSetStorageBuffers ::
                                         a -> VkMaxDescriptorSetStorageBuffersMType a

        vkMaxDescriptorSetStorageBuffersByteOffset :: a -> Int

        readVkMaxDescriptorSetStorageBuffers ::
                                             Mutable a ->
                                               IO (VkMaxDescriptorSetStorageBuffersMType a)

        writeVkMaxDescriptorSetStorageBuffers ::
                                              Mutable a ->
                                                VkMaxDescriptorSetStorageBuffersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxDescriptorSetStorageBuffers'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetStorageBuffers a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetStorageBuffers VkPhysicalDeviceLimits where
        type VkMaxDescriptorSetStorageBuffersMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxDescriptorSetStorageBuffers (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetStorageBuffersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxDescriptorSetStorageBuffers #-}
        vkMaxDescriptorSetStorageBuffersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageBuffers}

        {-# INLINE vkMaxDescriptorSetStorageBuffersByteOffset #-}
        readVkMaxDescriptorSetStorageBuffers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetStorageBuffersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxDescriptorSetStorageBuffers #-}
        writeVkMaxDescriptorSetStorageBuffers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxDescriptorSetStorageBuffersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxDescriptorSetStorageBuffers #-}

class HasVkMaxDescriptorSetStorageBuffersDynamic a where
        type VkMaxDescriptorSetStorageBuffersDynamicMType a :: *

        vkMaxDescriptorSetStorageBuffersDynamic ::
                                                a -> VkMaxDescriptorSetStorageBuffersDynamicMType a

        vkMaxDescriptorSetStorageBuffersDynamicByteOffset :: a -> Int

        readVkMaxDescriptorSetStorageBuffersDynamic ::
                                                    Mutable a ->
                                                      IO
                                                        (VkMaxDescriptorSetStorageBuffersDynamicMType
                                                           a)

        writeVkMaxDescriptorSetStorageBuffersDynamic ::
                                                     Mutable a ->
                                                       VkMaxDescriptorSetStorageBuffersDynamicMType
                                                         a
                                                         -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxDescriptorSetStorageBuffersDynamic'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetStorageBuffersDynamic a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetStorageBuffersDynamic VkPhysicalDeviceLimits
         where
        type VkMaxDescriptorSetStorageBuffersDynamicMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxDescriptorSetStorageBuffersDynamic
          (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetStorageBuffersDynamicByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxDescriptorSetStorageBuffersDynamic #-}
        vkMaxDescriptorSetStorageBuffersDynamicByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageBuffersDynamic}

        {-# INLINE vkMaxDescriptorSetStorageBuffersDynamicByteOffset #-}
        readVkMaxDescriptorSetStorageBuffersDynamic (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetStorageBuffersDynamicByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxDescriptorSetStorageBuffersDynamic #-}
        writeVkMaxDescriptorSetStorageBuffersDynamic (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxDescriptorSetStorageBuffersDynamicByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxDescriptorSetStorageBuffersDynamic #-}

class HasVkMaxDescriptorSetSampledImages a where
        type VkMaxDescriptorSetSampledImagesMType a :: *

        vkMaxDescriptorSetSampledImages ::
                                        a -> VkMaxDescriptorSetSampledImagesMType a

        vkMaxDescriptorSetSampledImagesByteOffset :: a -> Int

        readVkMaxDescriptorSetSampledImages ::
                                            Mutable a -> IO (VkMaxDescriptorSetSampledImagesMType a)

        writeVkMaxDescriptorSetSampledImages ::
                                             Mutable a ->
                                               VkMaxDescriptorSetSampledImagesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxDescriptorSetSampledImages'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetSampledImages a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetSampledImages VkPhysicalDeviceLimits where
        type VkMaxDescriptorSetSampledImagesMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxDescriptorSetSampledImages (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetSampledImagesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxDescriptorSetSampledImages #-}
        vkMaxDescriptorSetSampledImagesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetSampledImages}

        {-# INLINE vkMaxDescriptorSetSampledImagesByteOffset #-}
        readVkMaxDescriptorSetSampledImages (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetSampledImagesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxDescriptorSetSampledImages #-}
        writeVkMaxDescriptorSetSampledImages (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxDescriptorSetSampledImagesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxDescriptorSetSampledImages #-}

class HasVkMaxDescriptorSetStorageImages a where
        type VkMaxDescriptorSetStorageImagesMType a :: *

        vkMaxDescriptorSetStorageImages ::
                                        a -> VkMaxDescriptorSetStorageImagesMType a

        vkMaxDescriptorSetStorageImagesByteOffset :: a -> Int

        readVkMaxDescriptorSetStorageImages ::
                                            Mutable a -> IO (VkMaxDescriptorSetStorageImagesMType a)

        writeVkMaxDescriptorSetStorageImages ::
                                             Mutable a ->
                                               VkMaxDescriptorSetStorageImagesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxDescriptorSetStorageImages'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetStorageImages a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetStorageImages VkPhysicalDeviceLimits where
        type VkMaxDescriptorSetStorageImagesMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxDescriptorSetStorageImages (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetStorageImagesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxDescriptorSetStorageImages #-}
        vkMaxDescriptorSetStorageImagesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetStorageImages}

        {-# INLINE vkMaxDescriptorSetStorageImagesByteOffset #-}
        readVkMaxDescriptorSetStorageImages (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetStorageImagesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxDescriptorSetStorageImages #-}
        writeVkMaxDescriptorSetStorageImages (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxDescriptorSetStorageImagesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxDescriptorSetStorageImages #-}

class HasVkMaxDescriptorSetInputAttachments a where
        type VkMaxDescriptorSetInputAttachmentsMType a :: *

        vkMaxDescriptorSetInputAttachments ::
                                           a -> VkMaxDescriptorSetInputAttachmentsMType a

        vkMaxDescriptorSetInputAttachmentsByteOffset :: a -> Int

        readVkMaxDescriptorSetInputAttachments ::
                                               Mutable a ->
                                                 IO (VkMaxDescriptorSetInputAttachmentsMType a)

        writeVkMaxDescriptorSetInputAttachments ::
                                                Mutable a ->
                                                  VkMaxDescriptorSetInputAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxDescriptorSetInputAttachments'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDescriptorSetInputAttachments a

instance {-# OVERLAPPING #-}
         HasVkMaxDescriptorSetInputAttachments VkPhysicalDeviceLimits where
        type VkMaxDescriptorSetInputAttachmentsMType VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxDescriptorSetInputAttachments (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetInputAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxDescriptorSetInputAttachments #-}
        vkMaxDescriptorSetInputAttachmentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDescriptorSetInputAttachments}

        {-# INLINE vkMaxDescriptorSetInputAttachmentsByteOffset #-}
        readVkMaxDescriptorSetInputAttachments (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDescriptorSetInputAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxDescriptorSetInputAttachments #-}
        writeVkMaxDescriptorSetInputAttachments (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxDescriptorSetInputAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxDescriptorSetInputAttachments #-}

class HasVkMaxVertexInputAttributes a where
        type VkMaxVertexInputAttributesMType a :: *

        vkMaxVertexInputAttributes ::
                                   a -> VkMaxVertexInputAttributesMType a

        vkMaxVertexInputAttributesByteOffset :: a -> Int

        readVkMaxVertexInputAttributes ::
                                       Mutable a -> IO (VkMaxVertexInputAttributesMType a)

        writeVkMaxVertexInputAttributes ::
                                        Mutable a -> VkMaxVertexInputAttributesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxVertexInputAttributes'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxVertexInputAttributes a

instance {-# OVERLAPPING #-}
         HasVkMaxVertexInputAttributes VkPhysicalDeviceLimits where
        type VkMaxVertexInputAttributesMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxVertexInputAttributes (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxVertexInputAttributesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxVertexInputAttributes #-}
        vkMaxVertexInputAttributesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxVertexInputAttributes}

        {-# INLINE vkMaxVertexInputAttributesByteOffset #-}
        readVkMaxVertexInputAttributes (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxVertexInputAttributesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxVertexInputAttributes #-}
        writeVkMaxVertexInputAttributes (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxVertexInputAttributesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxVertexInputAttributes #-}

class HasVkMaxVertexInputBindings a where
        type VkMaxVertexInputBindingsMType a :: *

        vkMaxVertexInputBindings :: a -> VkMaxVertexInputBindingsMType a

        vkMaxVertexInputBindingsByteOffset :: a -> Int

        readVkMaxVertexInputBindings ::
                                     Mutable a -> IO (VkMaxVertexInputBindingsMType a)

        writeVkMaxVertexInputBindings ::
                                      Mutable a -> VkMaxVertexInputBindingsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxVertexInputBindings'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxVertexInputBindings a

instance {-# OVERLAPPING #-}
         HasVkMaxVertexInputBindings VkPhysicalDeviceLimits where
        type VkMaxVertexInputBindingsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxVertexInputBindings (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxVertexInputBindingsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxVertexInputBindings #-}
        vkMaxVertexInputBindingsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxVertexInputBindings}

        {-# INLINE vkMaxVertexInputBindingsByteOffset #-}
        readVkMaxVertexInputBindings (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxVertexInputBindingsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxVertexInputBindings #-}
        writeVkMaxVertexInputBindings (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxVertexInputBindingsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxVertexInputBindings #-}

class HasVkMaxVertexInputAttributeOffset a where
        type VkMaxVertexInputAttributeOffsetMType a :: *

        vkMaxVertexInputAttributeOffset ::
                                        a -> VkMaxVertexInputAttributeOffsetMType a

        vkMaxVertexInputAttributeOffsetByteOffset :: a -> Int

        readVkMaxVertexInputAttributeOffset ::
                                            Mutable a -> IO (VkMaxVertexInputAttributeOffsetMType a)

        writeVkMaxVertexInputAttributeOffset ::
                                             Mutable a ->
                                               VkMaxVertexInputAttributeOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxVertexInputAttributeOffset'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxVertexInputAttributeOffset a

instance {-# OVERLAPPING #-}
         HasVkMaxVertexInputAttributeOffset VkPhysicalDeviceLimits where
        type VkMaxVertexInputAttributeOffsetMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxVertexInputAttributeOffset (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxVertexInputAttributeOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxVertexInputAttributeOffset #-}
        vkMaxVertexInputAttributeOffsetByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxVertexInputAttributeOffset}

        {-# INLINE vkMaxVertexInputAttributeOffsetByteOffset #-}
        readVkMaxVertexInputAttributeOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxVertexInputAttributeOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxVertexInputAttributeOffset #-}
        writeVkMaxVertexInputAttributeOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxVertexInputAttributeOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxVertexInputAttributeOffset #-}

class HasVkMaxVertexInputBindingStride a where
        type VkMaxVertexInputBindingStrideMType a :: *

        vkMaxVertexInputBindingStride ::
                                      a -> VkMaxVertexInputBindingStrideMType a

        vkMaxVertexInputBindingStrideByteOffset :: a -> Int

        readVkMaxVertexInputBindingStride ::
                                          Mutable a -> IO (VkMaxVertexInputBindingStrideMType a)

        writeVkMaxVertexInputBindingStride ::
                                           Mutable a ->
                                             VkMaxVertexInputBindingStrideMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxVertexInputBindingStride'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxVertexInputBindingStride a

instance {-# OVERLAPPING #-}
         HasVkMaxVertexInputBindingStride VkPhysicalDeviceLimits where
        type VkMaxVertexInputBindingStrideMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxVertexInputBindingStride (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxVertexInputBindingStrideByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxVertexInputBindingStride #-}
        vkMaxVertexInputBindingStrideByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxVertexInputBindingStride}

        {-# INLINE vkMaxVertexInputBindingStrideByteOffset #-}
        readVkMaxVertexInputBindingStride (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxVertexInputBindingStrideByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxVertexInputBindingStride #-}
        writeVkMaxVertexInputBindingStride (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxVertexInputBindingStrideByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxVertexInputBindingStride #-}

class HasVkMaxVertexOutputComponents a where
        type VkMaxVertexOutputComponentsMType a :: *

        vkMaxVertexOutputComponents ::
                                    a -> VkMaxVertexOutputComponentsMType a

        vkMaxVertexOutputComponentsByteOffset :: a -> Int

        readVkMaxVertexOutputComponents ::
                                        Mutable a -> IO (VkMaxVertexOutputComponentsMType a)

        writeVkMaxVertexOutputComponents ::
                                         Mutable a -> VkMaxVertexOutputComponentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxVertexOutputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxVertexOutputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxVertexOutputComponents VkPhysicalDeviceLimits where
        type VkMaxVertexOutputComponentsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxVertexOutputComponents (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxVertexOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxVertexOutputComponents #-}
        vkMaxVertexOutputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxVertexOutputComponents}

        {-# INLINE vkMaxVertexOutputComponentsByteOffset #-}
        readVkMaxVertexOutputComponents (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxVertexOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxVertexOutputComponents #-}
        writeVkMaxVertexOutputComponents (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxVertexOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxVertexOutputComponents #-}

class HasVkMaxTessellationGenerationLevel a where
        type VkMaxTessellationGenerationLevelMType a :: *

        vkMaxTessellationGenerationLevel ::
                                         a -> VkMaxTessellationGenerationLevelMType a

        vkMaxTessellationGenerationLevelByteOffset :: a -> Int

        readVkMaxTessellationGenerationLevel ::
                                             Mutable a ->
                                               IO (VkMaxTessellationGenerationLevelMType a)

        writeVkMaxTessellationGenerationLevel ::
                                              Mutable a ->
                                                VkMaxTessellationGenerationLevelMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxTessellationGenerationLevel'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationGenerationLevel a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationGenerationLevel VkPhysicalDeviceLimits where
        type VkMaxTessellationGenerationLevelMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxTessellationGenerationLevel (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationGenerationLevelByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxTessellationGenerationLevel #-}
        vkMaxTessellationGenerationLevelByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationGenerationLevel}

        {-# INLINE vkMaxTessellationGenerationLevelByteOffset #-}
        readVkMaxTessellationGenerationLevel (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationGenerationLevelByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxTessellationGenerationLevel #-}
        writeVkMaxTessellationGenerationLevel (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxTessellationGenerationLevelByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxTessellationGenerationLevel #-}

class HasVkMaxTessellationPatchSize a where
        type VkMaxTessellationPatchSizeMType a :: *

        vkMaxTessellationPatchSize ::
                                   a -> VkMaxTessellationPatchSizeMType a

        vkMaxTessellationPatchSizeByteOffset :: a -> Int

        readVkMaxTessellationPatchSize ::
                                       Mutable a -> IO (VkMaxTessellationPatchSizeMType a)

        writeVkMaxTessellationPatchSize ::
                                        Mutable a -> VkMaxTessellationPatchSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxTessellationPatchSize'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationPatchSize a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationPatchSize VkPhysicalDeviceLimits where
        type VkMaxTessellationPatchSizeMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxTessellationPatchSize (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationPatchSizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxTessellationPatchSize #-}
        vkMaxTessellationPatchSizeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationPatchSize}

        {-# INLINE vkMaxTessellationPatchSizeByteOffset #-}
        readVkMaxTessellationPatchSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationPatchSizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxTessellationPatchSize #-}
        writeVkMaxTessellationPatchSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxTessellationPatchSizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxTessellationPatchSize #-}

class HasVkMaxTessellationControlPerVertexInputComponents a where
        type VkMaxTessellationControlPerVertexInputComponentsMType a :: *

        vkMaxTessellationControlPerVertexInputComponents ::
                                                         a ->
                                                           VkMaxTessellationControlPerVertexInputComponentsMType
                                                             a

        vkMaxTessellationControlPerVertexInputComponentsByteOffset ::
                                                                   a -> Int

        readVkMaxTessellationControlPerVertexInputComponents ::
                                                             Mutable a ->
                                                               IO
                                                                 (VkMaxTessellationControlPerVertexInputComponentsMType
                                                                    a)

        writeVkMaxTessellationControlPerVertexInputComponents ::
                                                              Mutable a ->
                                                                VkMaxTessellationControlPerVertexInputComponentsMType
                                                                  a
                                                                  -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxTessellationControlPerVertexInputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationControlPerVertexInputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationControlPerVertexInputComponents
           VkPhysicalDeviceLimits
         where
        type VkMaxTessellationControlPerVertexInputComponentsMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxTessellationControlPerVertexInputComponents
          (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationControlPerVertexInputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxTessellationControlPerVertexInputComponents #-}
        vkMaxTessellationControlPerVertexInputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationControlPerVertexInputComponents}

        {-# INLINE vkMaxTessellationControlPerVertexInputComponentsByteOffset
                   #-}
        readVkMaxTessellationControlPerVertexInputComponents (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationControlPerVertexInputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxTessellationControlPerVertexInputComponents #-}
        writeVkMaxTessellationControlPerVertexInputComponents
          (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxTessellationControlPerVertexInputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxTessellationControlPerVertexInputComponents
                   #-}

class HasVkMaxTessellationControlPerVertexOutputComponents a where
        type VkMaxTessellationControlPerVertexOutputComponentsMType a :: *

        vkMaxTessellationControlPerVertexOutputComponents ::
                                                          a ->
                                                            VkMaxTessellationControlPerVertexOutputComponentsMType
                                                              a

        vkMaxTessellationControlPerVertexOutputComponentsByteOffset ::
                                                                    a -> Int

        readVkMaxTessellationControlPerVertexOutputComponents ::
                                                              Mutable a ->
                                                                IO
                                                                  (VkMaxTessellationControlPerVertexOutputComponentsMType
                                                                     a)

        writeVkMaxTessellationControlPerVertexOutputComponents ::
                                                               Mutable a ->
                                                                 VkMaxTessellationControlPerVertexOutputComponentsMType
                                                                   a
                                                                   -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxTessellationControlPerVertexOutputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationControlPerVertexOutputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationControlPerVertexOutputComponents
           VkPhysicalDeviceLimits
         where
        type VkMaxTessellationControlPerVertexOutputComponentsMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxTessellationControlPerVertexOutputComponents
          (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationControlPerVertexOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxTessellationControlPerVertexOutputComponents #-}
        vkMaxTessellationControlPerVertexOutputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationControlPerVertexOutputComponents}

        {-# INLINE vkMaxTessellationControlPerVertexOutputComponentsByteOffset
                   #-}
        readVkMaxTessellationControlPerVertexOutputComponents
          (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationControlPerVertexOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxTessellationControlPerVertexOutputComponents
                   #-}
        writeVkMaxTessellationControlPerVertexOutputComponents
          (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxTessellationControlPerVertexOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxTessellationControlPerVertexOutputComponents
                   #-}

class HasVkMaxTessellationControlPerPatchOutputComponents a where
        type VkMaxTessellationControlPerPatchOutputComponentsMType a :: *

        vkMaxTessellationControlPerPatchOutputComponents ::
                                                         a ->
                                                           VkMaxTessellationControlPerPatchOutputComponentsMType
                                                             a

        vkMaxTessellationControlPerPatchOutputComponentsByteOffset ::
                                                                   a -> Int

        readVkMaxTessellationControlPerPatchOutputComponents ::
                                                             Mutable a ->
                                                               IO
                                                                 (VkMaxTessellationControlPerPatchOutputComponentsMType
                                                                    a)

        writeVkMaxTessellationControlPerPatchOutputComponents ::
                                                              Mutable a ->
                                                                VkMaxTessellationControlPerPatchOutputComponentsMType
                                                                  a
                                                                  -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxTessellationControlPerPatchOutputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationControlPerPatchOutputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationControlPerPatchOutputComponents
           VkPhysicalDeviceLimits
         where
        type VkMaxTessellationControlPerPatchOutputComponentsMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxTessellationControlPerPatchOutputComponents
          (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationControlPerPatchOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxTessellationControlPerPatchOutputComponents #-}
        vkMaxTessellationControlPerPatchOutputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationControlPerPatchOutputComponents}

        {-# INLINE vkMaxTessellationControlPerPatchOutputComponentsByteOffset
                   #-}
        readVkMaxTessellationControlPerPatchOutputComponents (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationControlPerPatchOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxTessellationControlPerPatchOutputComponents #-}
        writeVkMaxTessellationControlPerPatchOutputComponents
          (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxTessellationControlPerPatchOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxTessellationControlPerPatchOutputComponents
                   #-}

class HasVkMaxTessellationControlTotalOutputComponents a where
        type VkMaxTessellationControlTotalOutputComponentsMType a :: *

        vkMaxTessellationControlTotalOutputComponents ::
                                                      a ->
                                                        VkMaxTessellationControlTotalOutputComponentsMType
                                                          a

        vkMaxTessellationControlTotalOutputComponentsByteOffset :: a -> Int

        readVkMaxTessellationControlTotalOutputComponents ::
                                                          Mutable a ->
                                                            IO
                                                              (VkMaxTessellationControlTotalOutputComponentsMType
                                                                 a)

        writeVkMaxTessellationControlTotalOutputComponents ::
                                                           Mutable a ->
                                                             VkMaxTessellationControlTotalOutputComponentsMType
                                                               a
                                                               -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxTessellationControlTotalOutputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationControlTotalOutputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationControlTotalOutputComponents
           VkPhysicalDeviceLimits
         where
        type VkMaxTessellationControlTotalOutputComponentsMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxTessellationControlTotalOutputComponents
          (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationControlTotalOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxTessellationControlTotalOutputComponents #-}
        vkMaxTessellationControlTotalOutputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationControlTotalOutputComponents}

        {-# INLINE vkMaxTessellationControlTotalOutputComponentsByteOffset
                   #-}
        readVkMaxTessellationControlTotalOutputComponents (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationControlTotalOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxTessellationControlTotalOutputComponents #-}
        writeVkMaxTessellationControlTotalOutputComponents (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxTessellationControlTotalOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxTessellationControlTotalOutputComponents #-}

class HasVkMaxTessellationEvaluationInputComponents a where
        type VkMaxTessellationEvaluationInputComponentsMType a :: *

        vkMaxTessellationEvaluationInputComponents ::
                                                   a ->
                                                     VkMaxTessellationEvaluationInputComponentsMType
                                                       a

        vkMaxTessellationEvaluationInputComponentsByteOffset :: a -> Int

        readVkMaxTessellationEvaluationInputComponents ::
                                                       Mutable a ->
                                                         IO
                                                           (VkMaxTessellationEvaluationInputComponentsMType
                                                              a)

        writeVkMaxTessellationEvaluationInputComponents ::
                                                        Mutable a ->
                                                          VkMaxTessellationEvaluationInputComponentsMType
                                                            a
                                                            -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxTessellationEvaluationInputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationEvaluationInputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationEvaluationInputComponents
           VkPhysicalDeviceLimits
         where
        type VkMaxTessellationEvaluationInputComponentsMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxTessellationEvaluationInputComponents
          (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationEvaluationInputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxTessellationEvaluationInputComponents #-}
        vkMaxTessellationEvaluationInputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationEvaluationInputComponents}

        {-# INLINE vkMaxTessellationEvaluationInputComponentsByteOffset #-}
        readVkMaxTessellationEvaluationInputComponents (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationEvaluationInputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxTessellationEvaluationInputComponents #-}
        writeVkMaxTessellationEvaluationInputComponents (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxTessellationEvaluationInputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxTessellationEvaluationInputComponents #-}

class HasVkMaxTessellationEvaluationOutputComponents a where
        type VkMaxTessellationEvaluationOutputComponentsMType a :: *

        vkMaxTessellationEvaluationOutputComponents ::
                                                    a ->
                                                      VkMaxTessellationEvaluationOutputComponentsMType
                                                        a

        vkMaxTessellationEvaluationOutputComponentsByteOffset :: a -> Int

        readVkMaxTessellationEvaluationOutputComponents ::
                                                        Mutable a ->
                                                          IO
                                                            (VkMaxTessellationEvaluationOutputComponentsMType
                                                               a)

        writeVkMaxTessellationEvaluationOutputComponents ::
                                                         Mutable a ->
                                                           VkMaxTessellationEvaluationOutputComponentsMType
                                                             a
                                                             -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxTessellationEvaluationOutputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTessellationEvaluationOutputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxTessellationEvaluationOutputComponents
           VkPhysicalDeviceLimits
         where
        type VkMaxTessellationEvaluationOutputComponentsMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxTessellationEvaluationOutputComponents
          (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationEvaluationOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxTessellationEvaluationOutputComponents #-}
        vkMaxTessellationEvaluationOutputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTessellationEvaluationOutputComponents}

        {-# INLINE vkMaxTessellationEvaluationOutputComponentsByteOffset
                   #-}
        readVkMaxTessellationEvaluationOutputComponents (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTessellationEvaluationOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxTessellationEvaluationOutputComponents #-}
        writeVkMaxTessellationEvaluationOutputComponents (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxTessellationEvaluationOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxTessellationEvaluationOutputComponents #-}

class HasVkMaxGeometryShaderInvocations a where
        type VkMaxGeometryShaderInvocationsMType a :: *

        vkMaxGeometryShaderInvocations ::
                                       a -> VkMaxGeometryShaderInvocationsMType a

        vkMaxGeometryShaderInvocationsByteOffset :: a -> Int

        readVkMaxGeometryShaderInvocations ::
                                           Mutable a -> IO (VkMaxGeometryShaderInvocationsMType a)

        writeVkMaxGeometryShaderInvocations ::
                                            Mutable a ->
                                              VkMaxGeometryShaderInvocationsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxGeometryShaderInvocations'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxGeometryShaderInvocations a

instance {-# OVERLAPPING #-}
         HasVkMaxGeometryShaderInvocations VkPhysicalDeviceLimits where
        type VkMaxGeometryShaderInvocationsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxGeometryShaderInvocations (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxGeometryShaderInvocationsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxGeometryShaderInvocations #-}
        vkMaxGeometryShaderInvocationsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxGeometryShaderInvocations}

        {-# INLINE vkMaxGeometryShaderInvocationsByteOffset #-}
        readVkMaxGeometryShaderInvocations (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxGeometryShaderInvocationsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxGeometryShaderInvocations #-}
        writeVkMaxGeometryShaderInvocations (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxGeometryShaderInvocationsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxGeometryShaderInvocations #-}

class HasVkMaxGeometryInputComponents a where
        type VkMaxGeometryInputComponentsMType a :: *

        vkMaxGeometryInputComponents ::
                                     a -> VkMaxGeometryInputComponentsMType a

        vkMaxGeometryInputComponentsByteOffset :: a -> Int

        readVkMaxGeometryInputComponents ::
                                         Mutable a -> IO (VkMaxGeometryInputComponentsMType a)

        writeVkMaxGeometryInputComponents ::
                                          Mutable a -> VkMaxGeometryInputComponentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxGeometryInputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxGeometryInputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxGeometryInputComponents VkPhysicalDeviceLimits where
        type VkMaxGeometryInputComponentsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxGeometryInputComponents (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxGeometryInputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxGeometryInputComponents #-}
        vkMaxGeometryInputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxGeometryInputComponents}

        {-# INLINE vkMaxGeometryInputComponentsByteOffset #-}
        readVkMaxGeometryInputComponents (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxGeometryInputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxGeometryInputComponents #-}
        writeVkMaxGeometryInputComponents (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxGeometryInputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxGeometryInputComponents #-}

class HasVkMaxGeometryOutputComponents a where
        type VkMaxGeometryOutputComponentsMType a :: *

        vkMaxGeometryOutputComponents ::
                                      a -> VkMaxGeometryOutputComponentsMType a

        vkMaxGeometryOutputComponentsByteOffset :: a -> Int

        readVkMaxGeometryOutputComponents ::
                                          Mutable a -> IO (VkMaxGeometryOutputComponentsMType a)

        writeVkMaxGeometryOutputComponents ::
                                           Mutable a ->
                                             VkMaxGeometryOutputComponentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxGeometryOutputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxGeometryOutputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxGeometryOutputComponents VkPhysicalDeviceLimits where
        type VkMaxGeometryOutputComponentsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxGeometryOutputComponents (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxGeometryOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxGeometryOutputComponents #-}
        vkMaxGeometryOutputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxGeometryOutputComponents}

        {-# INLINE vkMaxGeometryOutputComponentsByteOffset #-}
        readVkMaxGeometryOutputComponents (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxGeometryOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxGeometryOutputComponents #-}
        writeVkMaxGeometryOutputComponents (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxGeometryOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxGeometryOutputComponents #-}

class HasVkMaxGeometryOutputVertices a where
        type VkMaxGeometryOutputVerticesMType a :: *

        vkMaxGeometryOutputVertices ::
                                    a -> VkMaxGeometryOutputVerticesMType a

        vkMaxGeometryOutputVerticesByteOffset :: a -> Int

        readVkMaxGeometryOutputVertices ::
                                        Mutable a -> IO (VkMaxGeometryOutputVerticesMType a)

        writeVkMaxGeometryOutputVertices ::
                                         Mutable a -> VkMaxGeometryOutputVerticesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxGeometryOutputVertices'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxGeometryOutputVertices a

instance {-# OVERLAPPING #-}
         HasVkMaxGeometryOutputVertices VkPhysicalDeviceLimits where
        type VkMaxGeometryOutputVerticesMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxGeometryOutputVertices (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxGeometryOutputVerticesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxGeometryOutputVertices #-}
        vkMaxGeometryOutputVerticesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxGeometryOutputVertices}

        {-# INLINE vkMaxGeometryOutputVerticesByteOffset #-}
        readVkMaxGeometryOutputVertices (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxGeometryOutputVerticesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxGeometryOutputVertices #-}
        writeVkMaxGeometryOutputVertices (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxGeometryOutputVerticesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxGeometryOutputVertices #-}

class HasVkMaxGeometryTotalOutputComponents a where
        type VkMaxGeometryTotalOutputComponentsMType a :: *

        vkMaxGeometryTotalOutputComponents ::
                                           a -> VkMaxGeometryTotalOutputComponentsMType a

        vkMaxGeometryTotalOutputComponentsByteOffset :: a -> Int

        readVkMaxGeometryTotalOutputComponents ::
                                               Mutable a ->
                                                 IO (VkMaxGeometryTotalOutputComponentsMType a)

        writeVkMaxGeometryTotalOutputComponents ::
                                                Mutable a ->
                                                  VkMaxGeometryTotalOutputComponentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxGeometryTotalOutputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxGeometryTotalOutputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxGeometryTotalOutputComponents VkPhysicalDeviceLimits where
        type VkMaxGeometryTotalOutputComponentsMType VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxGeometryTotalOutputComponents (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxGeometryTotalOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxGeometryTotalOutputComponents #-}
        vkMaxGeometryTotalOutputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxGeometryTotalOutputComponents}

        {-# INLINE vkMaxGeometryTotalOutputComponentsByteOffset #-}
        readVkMaxGeometryTotalOutputComponents (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxGeometryTotalOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxGeometryTotalOutputComponents #-}
        writeVkMaxGeometryTotalOutputComponents (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxGeometryTotalOutputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxGeometryTotalOutputComponents #-}

class HasVkMaxFragmentInputComponents a where
        type VkMaxFragmentInputComponentsMType a :: *

        vkMaxFragmentInputComponents ::
                                     a -> VkMaxFragmentInputComponentsMType a

        vkMaxFragmentInputComponentsByteOffset :: a -> Int

        readVkMaxFragmentInputComponents ::
                                         Mutable a -> IO (VkMaxFragmentInputComponentsMType a)

        writeVkMaxFragmentInputComponents ::
                                          Mutable a -> VkMaxFragmentInputComponentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxFragmentInputComponents'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxFragmentInputComponents a

instance {-# OVERLAPPING #-}
         HasVkMaxFragmentInputComponents VkPhysicalDeviceLimits where
        type VkMaxFragmentInputComponentsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxFragmentInputComponents (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxFragmentInputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxFragmentInputComponents #-}
        vkMaxFragmentInputComponentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxFragmentInputComponents}

        {-# INLINE vkMaxFragmentInputComponentsByteOffset #-}
        readVkMaxFragmentInputComponents (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxFragmentInputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxFragmentInputComponents #-}
        writeVkMaxFragmentInputComponents (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxFragmentInputComponentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxFragmentInputComponents #-}

class HasVkMaxFragmentOutputAttachments a where
        type VkMaxFragmentOutputAttachmentsMType a :: *

        vkMaxFragmentOutputAttachments ::
                                       a -> VkMaxFragmentOutputAttachmentsMType a

        vkMaxFragmentOutputAttachmentsByteOffset :: a -> Int

        readVkMaxFragmentOutputAttachments ::
                                           Mutable a -> IO (VkMaxFragmentOutputAttachmentsMType a)

        writeVkMaxFragmentOutputAttachments ::
                                            Mutable a ->
                                              VkMaxFragmentOutputAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxFragmentOutputAttachments'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxFragmentOutputAttachments a

instance {-# OVERLAPPING #-}
         HasVkMaxFragmentOutputAttachments VkPhysicalDeviceLimits where
        type VkMaxFragmentOutputAttachmentsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxFragmentOutputAttachments (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxFragmentOutputAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxFragmentOutputAttachments #-}
        vkMaxFragmentOutputAttachmentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxFragmentOutputAttachments}

        {-# INLINE vkMaxFragmentOutputAttachmentsByteOffset #-}
        readVkMaxFragmentOutputAttachments (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxFragmentOutputAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxFragmentOutputAttachments #-}
        writeVkMaxFragmentOutputAttachments (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxFragmentOutputAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxFragmentOutputAttachments #-}

class HasVkMaxFragmentDualSrcAttachments a where
        type VkMaxFragmentDualSrcAttachmentsMType a :: *

        vkMaxFragmentDualSrcAttachments ::
                                        a -> VkMaxFragmentDualSrcAttachmentsMType a

        vkMaxFragmentDualSrcAttachmentsByteOffset :: a -> Int

        readVkMaxFragmentDualSrcAttachments ::
                                            Mutable a -> IO (VkMaxFragmentDualSrcAttachmentsMType a)

        writeVkMaxFragmentDualSrcAttachments ::
                                             Mutable a ->
                                               VkMaxFragmentDualSrcAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxFragmentDualSrcAttachments'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxFragmentDualSrcAttachments a

instance {-# OVERLAPPING #-}
         HasVkMaxFragmentDualSrcAttachments VkPhysicalDeviceLimits where
        type VkMaxFragmentDualSrcAttachmentsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxFragmentDualSrcAttachments (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxFragmentDualSrcAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxFragmentDualSrcAttachments #-}
        vkMaxFragmentDualSrcAttachmentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxFragmentDualSrcAttachments}

        {-# INLINE vkMaxFragmentDualSrcAttachmentsByteOffset #-}
        readVkMaxFragmentDualSrcAttachments (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxFragmentDualSrcAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxFragmentDualSrcAttachments #-}
        writeVkMaxFragmentDualSrcAttachments (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxFragmentDualSrcAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxFragmentDualSrcAttachments #-}

class HasVkMaxFragmentCombinedOutputResources a where
        type VkMaxFragmentCombinedOutputResourcesMType a :: *

        vkMaxFragmentCombinedOutputResources ::
                                             a -> VkMaxFragmentCombinedOutputResourcesMType a

        vkMaxFragmentCombinedOutputResourcesByteOffset :: a -> Int

        readVkMaxFragmentCombinedOutputResources ::
                                                 Mutable a ->
                                                   IO (VkMaxFragmentCombinedOutputResourcesMType a)

        writeVkMaxFragmentCombinedOutputResources ::
                                                  Mutable a ->
                                                    VkMaxFragmentCombinedOutputResourcesMType a ->
                                                      IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxFragmentCombinedOutputResources'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxFragmentCombinedOutputResources a

instance {-# OVERLAPPING #-}
         HasVkMaxFragmentCombinedOutputResources VkPhysicalDeviceLimits
         where
        type VkMaxFragmentCombinedOutputResourcesMType
               VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxFragmentCombinedOutputResources (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxFragmentCombinedOutputResourcesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxFragmentCombinedOutputResources #-}
        vkMaxFragmentCombinedOutputResourcesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxFragmentCombinedOutputResources}

        {-# INLINE vkMaxFragmentCombinedOutputResourcesByteOffset #-}
        readVkMaxFragmentCombinedOutputResources (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxFragmentCombinedOutputResourcesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxFragmentCombinedOutputResources #-}
        writeVkMaxFragmentCombinedOutputResources (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxFragmentCombinedOutputResourcesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxFragmentCombinedOutputResources #-}

class HasVkMaxComputeSharedMemorySize a where
        type VkMaxComputeSharedMemorySizeMType a :: *

        vkMaxComputeSharedMemorySize ::
                                     a -> VkMaxComputeSharedMemorySizeMType a

        vkMaxComputeSharedMemorySizeByteOffset :: a -> Int

        readVkMaxComputeSharedMemorySize ::
                                         Mutable a -> IO (VkMaxComputeSharedMemorySizeMType a)

        writeVkMaxComputeSharedMemorySize ::
                                          Mutable a -> VkMaxComputeSharedMemorySizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxComputeSharedMemorySize'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxComputeSharedMemorySize a

instance {-# OVERLAPPING #-}
         HasVkMaxComputeSharedMemorySize VkPhysicalDeviceLimits where
        type VkMaxComputeSharedMemorySizeMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxComputeSharedMemorySize (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxComputeSharedMemorySizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxComputeSharedMemorySize #-}
        vkMaxComputeSharedMemorySizeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxComputeSharedMemorySize}

        {-# INLINE vkMaxComputeSharedMemorySizeByteOffset #-}
        readVkMaxComputeSharedMemorySize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxComputeSharedMemorySizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxComputeSharedMemorySize #-}
        writeVkMaxComputeSharedMemorySize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxComputeSharedMemorySizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxComputeSharedMemorySize #-}

class HasVkMaxComputeWorkGroupCountArray a where
        type VkMaxComputeWorkGroupCountArrayMType a :: *

        vkMaxComputeWorkGroupCountArray ::
                                        a -> Int -> VkMaxComputeWorkGroupCountArrayMType a

        vkMaxComputeWorkGroupCountArrayByteOffset :: a -> Int

        readVkMaxComputeWorkGroupCountArray ::
                                            Mutable a ->
                                              Int -> IO (VkMaxComputeWorkGroupCountArrayMType a)

        writeVkMaxComputeWorkGroupCountArray ::
                                             Mutable a ->
                                               Int ->
                                                 VkMaxComputeWorkGroupCountArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxComputeWorkGroupCount'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxComputeWorkGroupCountArray a

instance {-# OVERLAPPING #-}
         HasVkMaxComputeWorkGroupCountArray VkPhysicalDeviceLimits where
        type VkMaxComputeWorkGroupCountArrayMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxComputeWorkGroupCountArray (VkPhysicalDeviceLimits## ba)
          (I## idx)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxComputeWorkGroupCountArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkMaxComputeWorkGroupCountArray #-}
        vkMaxComputeWorkGroupCountArrayByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupCount}

        {-# INLINE vkMaxComputeWorkGroupCountArrayByteOffset #-}
        readVkMaxComputeWorkGroupCountArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxComputeWorkGroupCountArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkMaxComputeWorkGroupCountArray #-}
        writeVkMaxComputeWorkGroupCountArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxComputeWorkGroupCountArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkMaxComputeWorkGroupCountArray #-}

class HasVkMaxComputeWorkGroupInvocations a where
        type VkMaxComputeWorkGroupInvocationsMType a :: *

        vkMaxComputeWorkGroupInvocations ::
                                         a -> VkMaxComputeWorkGroupInvocationsMType a

        vkMaxComputeWorkGroupInvocationsByteOffset :: a -> Int

        readVkMaxComputeWorkGroupInvocations ::
                                             Mutable a ->
                                               IO (VkMaxComputeWorkGroupInvocationsMType a)

        writeVkMaxComputeWorkGroupInvocations ::
                                              Mutable a ->
                                                VkMaxComputeWorkGroupInvocationsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxComputeWorkGroupInvocations'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxComputeWorkGroupInvocations a

instance {-# OVERLAPPING #-}
         HasVkMaxComputeWorkGroupInvocations VkPhysicalDeviceLimits where
        type VkMaxComputeWorkGroupInvocationsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxComputeWorkGroupInvocations (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxComputeWorkGroupInvocationsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxComputeWorkGroupInvocations #-}
        vkMaxComputeWorkGroupInvocationsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupInvocations}

        {-# INLINE vkMaxComputeWorkGroupInvocationsByteOffset #-}
        readVkMaxComputeWorkGroupInvocations (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxComputeWorkGroupInvocationsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxComputeWorkGroupInvocations #-}
        writeVkMaxComputeWorkGroupInvocations (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxComputeWorkGroupInvocationsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxComputeWorkGroupInvocations #-}

class HasVkMaxComputeWorkGroupSizeArray a where
        type VkMaxComputeWorkGroupSizeArrayMType a :: *

        vkMaxComputeWorkGroupSizeArray ::
                                       a -> Int -> VkMaxComputeWorkGroupSizeArrayMType a

        vkMaxComputeWorkGroupSizeArrayByteOffset :: a -> Int

        readVkMaxComputeWorkGroupSizeArray ::
                                           Mutable a ->
                                             Int -> IO (VkMaxComputeWorkGroupSizeArrayMType a)

        writeVkMaxComputeWorkGroupSizeArray ::
                                            Mutable a ->
                                              Int -> VkMaxComputeWorkGroupSizeArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxComputeWorkGroupSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxComputeWorkGroupSizeArray a

instance {-# OVERLAPPING #-}
         HasVkMaxComputeWorkGroupSizeArray VkPhysicalDeviceLimits where
        type VkMaxComputeWorkGroupSizeArrayMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxComputeWorkGroupSizeArray (VkPhysicalDeviceLimits## ba)
          (I## idx)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxComputeWorkGroupSizeArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkMaxComputeWorkGroupSizeArray #-}
        vkMaxComputeWorkGroupSizeArrayByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxComputeWorkGroupSize}

        {-# INLINE vkMaxComputeWorkGroupSizeArrayByteOffset #-}
        readVkMaxComputeWorkGroupSizeArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxComputeWorkGroupSizeArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkMaxComputeWorkGroupSizeArray #-}
        writeVkMaxComputeWorkGroupSizeArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxComputeWorkGroupSizeArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkMaxComputeWorkGroupSizeArray #-}

class HasVkSubPixelPrecisionBits a where
        type VkSubPixelPrecisionBitsMType a :: *

        vkSubPixelPrecisionBits :: a -> VkSubPixelPrecisionBitsMType a

        vkSubPixelPrecisionBitsByteOffset :: a -> Int

        readVkSubPixelPrecisionBits ::
                                    Mutable a -> IO (VkSubPixelPrecisionBitsMType a)

        writeVkSubPixelPrecisionBits ::
                                     Mutable a -> VkSubPixelPrecisionBitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'subPixelPrecisionBits'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSubPixelPrecisionBits a

instance {-# OVERLAPPING #-}
         HasVkSubPixelPrecisionBits VkPhysicalDeviceLimits where
        type VkSubPixelPrecisionBitsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkSubPixelPrecisionBits (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSubPixelPrecisionBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSubPixelPrecisionBits #-}
        vkSubPixelPrecisionBitsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, subPixelPrecisionBits}

        {-# INLINE vkSubPixelPrecisionBitsByteOffset #-}
        readVkSubPixelPrecisionBits (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSubPixelPrecisionBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSubPixelPrecisionBits #-}
        writeVkSubPixelPrecisionBits (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSubPixelPrecisionBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSubPixelPrecisionBits #-}

class HasVkSubTexelPrecisionBits a where
        type VkSubTexelPrecisionBitsMType a :: *

        vkSubTexelPrecisionBits :: a -> VkSubTexelPrecisionBitsMType a

        vkSubTexelPrecisionBitsByteOffset :: a -> Int

        readVkSubTexelPrecisionBits ::
                                    Mutable a -> IO (VkSubTexelPrecisionBitsMType a)

        writeVkSubTexelPrecisionBits ::
                                     Mutable a -> VkSubTexelPrecisionBitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'subTexelPrecisionBits'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSubTexelPrecisionBits a

instance {-# OVERLAPPING #-}
         HasVkSubTexelPrecisionBits VkPhysicalDeviceLimits where
        type VkSubTexelPrecisionBitsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkSubTexelPrecisionBits (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSubTexelPrecisionBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSubTexelPrecisionBits #-}
        vkSubTexelPrecisionBitsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, subTexelPrecisionBits}

        {-# INLINE vkSubTexelPrecisionBitsByteOffset #-}
        readVkSubTexelPrecisionBits (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSubTexelPrecisionBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSubTexelPrecisionBits #-}
        writeVkSubTexelPrecisionBits (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSubTexelPrecisionBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSubTexelPrecisionBits #-}

class HasVkMipmapPrecisionBits a where
        type VkMipmapPrecisionBitsMType a :: *

        vkMipmapPrecisionBits :: a -> VkMipmapPrecisionBitsMType a

        vkMipmapPrecisionBitsByteOffset :: a -> Int

        readVkMipmapPrecisionBits ::
                                  Mutable a -> IO (VkMipmapPrecisionBitsMType a)

        writeVkMipmapPrecisionBits ::
                                   Mutable a -> VkMipmapPrecisionBitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'mipmapPrecisionBits'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMipmapPrecisionBits a

instance {-# OVERLAPPING #-}
         HasVkMipmapPrecisionBits VkPhysicalDeviceLimits where
        type VkMipmapPrecisionBitsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMipmapPrecisionBits (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMipmapPrecisionBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMipmapPrecisionBits #-}
        vkMipmapPrecisionBitsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, mipmapPrecisionBits}

        {-# INLINE vkMipmapPrecisionBitsByteOffset #-}
        readVkMipmapPrecisionBits (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMipmapPrecisionBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMipmapPrecisionBits #-}
        writeVkMipmapPrecisionBits (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMipmapPrecisionBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMipmapPrecisionBits #-}

class HasVkMaxDrawIndexedIndexValue a where
        type VkMaxDrawIndexedIndexValueMType a :: *

        vkMaxDrawIndexedIndexValue ::
                                   a -> VkMaxDrawIndexedIndexValueMType a

        vkMaxDrawIndexedIndexValueByteOffset :: a -> Int

        readVkMaxDrawIndexedIndexValue ::
                                       Mutable a -> IO (VkMaxDrawIndexedIndexValueMType a)

        writeVkMaxDrawIndexedIndexValue ::
                                        Mutable a -> VkMaxDrawIndexedIndexValueMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxDrawIndexedIndexValue'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDrawIndexedIndexValue a

instance {-# OVERLAPPING #-}
         HasVkMaxDrawIndexedIndexValue VkPhysicalDeviceLimits where
        type VkMaxDrawIndexedIndexValueMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxDrawIndexedIndexValue (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDrawIndexedIndexValueByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxDrawIndexedIndexValue #-}
        vkMaxDrawIndexedIndexValueByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDrawIndexedIndexValue}

        {-# INLINE vkMaxDrawIndexedIndexValueByteOffset #-}
        readVkMaxDrawIndexedIndexValue (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDrawIndexedIndexValueByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxDrawIndexedIndexValue #-}
        writeVkMaxDrawIndexedIndexValue (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxDrawIndexedIndexValueByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxDrawIndexedIndexValue #-}

class HasVkMaxDrawIndirectCount a where
        type VkMaxDrawIndirectCountMType a :: *

        vkMaxDrawIndirectCount :: a -> VkMaxDrawIndirectCountMType a

        vkMaxDrawIndirectCountByteOffset :: a -> Int

        readVkMaxDrawIndirectCount ::
                                   Mutable a -> IO (VkMaxDrawIndirectCountMType a)

        writeVkMaxDrawIndirectCount ::
                                    Mutable a -> VkMaxDrawIndirectCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxDrawIndirectCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxDrawIndirectCount a

instance {-# OVERLAPPING #-}
         HasVkMaxDrawIndirectCount VkPhysicalDeviceLimits where
        type VkMaxDrawIndirectCountMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxDrawIndirectCount (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDrawIndirectCountByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxDrawIndirectCount #-}
        vkMaxDrawIndirectCountByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxDrawIndirectCount}

        {-# INLINE vkMaxDrawIndirectCountByteOffset #-}
        readVkMaxDrawIndirectCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxDrawIndirectCountByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxDrawIndirectCount #-}
        writeVkMaxDrawIndirectCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxDrawIndirectCountByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxDrawIndirectCount #-}

class HasVkMaxSamplerLodBias a where
        type VkMaxSamplerLodBiasMType a :: *

        vkMaxSamplerLodBias :: a -> VkMaxSamplerLodBiasMType a

        vkMaxSamplerLodBiasByteOffset :: a -> Int

        readVkMaxSamplerLodBias ::
                                Mutable a -> IO (VkMaxSamplerLodBiasMType a)

        writeVkMaxSamplerLodBias ::
                                 Mutable a -> VkMaxSamplerLodBiasMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxSamplerLodBias'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxSamplerLodBias a

instance {-# OVERLAPPING #-}
         HasVkMaxSamplerLodBias VkPhysicalDeviceLimits where
        type VkMaxSamplerLodBiasMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat
        vkMaxSamplerLodBias (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMaxSamplerLodBiasByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxSamplerLodBias #-}
        vkMaxSamplerLodBiasByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxSamplerLodBias}

        {-# INLINE vkMaxSamplerLodBiasByteOffset #-}
        readVkMaxSamplerLodBias (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMaxSamplerLodBiasByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxSamplerLodBias #-}
        writeVkMaxSamplerLodBias (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxSamplerLodBiasByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxSamplerLodBias #-}

class HasVkMaxSamplerAnisotropy a where
        type VkMaxSamplerAnisotropyMType a :: *

        vkMaxSamplerAnisotropy :: a -> VkMaxSamplerAnisotropyMType a

        vkMaxSamplerAnisotropyByteOffset :: a -> Int

        readVkMaxSamplerAnisotropy ::
                                   Mutable a -> IO (VkMaxSamplerAnisotropyMType a)

        writeVkMaxSamplerAnisotropy ::
                                    Mutable a -> VkMaxSamplerAnisotropyMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxSamplerAnisotropy'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxSamplerAnisotropy a

instance {-# OVERLAPPING #-}
         HasVkMaxSamplerAnisotropy VkPhysicalDeviceLimits where
        type VkMaxSamplerAnisotropyMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat
        vkMaxSamplerAnisotropy (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMaxSamplerAnisotropyByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxSamplerAnisotropy #-}
        vkMaxSamplerAnisotropyByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxSamplerAnisotropy}

        {-# INLINE vkMaxSamplerAnisotropyByteOffset #-}
        readVkMaxSamplerAnisotropy (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMaxSamplerAnisotropyByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxSamplerAnisotropy #-}
        writeVkMaxSamplerAnisotropy (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxSamplerAnisotropyByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxSamplerAnisotropy #-}

class HasVkMaxViewports a where
        type VkMaxViewportsMType a :: *

        vkMaxViewports :: a -> VkMaxViewportsMType a

        vkMaxViewportsByteOffset :: a -> Int

        readVkMaxViewports :: Mutable a -> IO (VkMaxViewportsMType a)

        writeVkMaxViewports :: Mutable a -> VkMaxViewportsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxViewports'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxViewports a

instance {-# OVERLAPPING #-}
         HasVkMaxViewports VkPhysicalDeviceLimits where
        type VkMaxViewportsMType VkPhysicalDeviceLimits = Data.Word.Word32
        vkMaxViewports (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxViewportsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxViewports #-}
        vkMaxViewportsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxViewports}

        {-# INLINE vkMaxViewportsByteOffset #-}
        readVkMaxViewports (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxViewportsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxViewports #-}
        writeVkMaxViewports (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxViewportsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxViewports #-}

class HasVkMaxViewportDimensionsArray a where
        type VkMaxViewportDimensionsArrayMType a :: *

        vkMaxViewportDimensionsArray ::
                                     a -> Int -> VkMaxViewportDimensionsArrayMType a

        vkMaxViewportDimensionsArrayByteOffset :: a -> Int

        readVkMaxViewportDimensionsArray ::
                                         Mutable a ->
                                           Int -> IO (VkMaxViewportDimensionsArrayMType a)

        writeVkMaxViewportDimensionsArray ::
                                          Mutable a ->
                                            Int -> VkMaxViewportDimensionsArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxViewportDimensions'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxViewportDimensionsArray a

instance {-# OVERLAPPING #-}
         HasVkMaxViewportDimensionsArray VkPhysicalDeviceLimits where
        type VkMaxViewportDimensionsArrayMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxViewportDimensionsArray (VkPhysicalDeviceLimits## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxViewportDimensionsArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkMaxViewportDimensionsArray #-}
        vkMaxViewportDimensionsArrayByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxViewportDimensions}

        {-# INLINE vkMaxViewportDimensionsArrayByteOffset #-}
        readVkMaxViewportDimensionsArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxViewportDimensionsArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkMaxViewportDimensionsArray #-}
        writeVkMaxViewportDimensionsArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxViewportDimensionsArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkMaxViewportDimensionsArray #-}

class HasVkViewportBoundsRangeArray a where
        type VkViewportBoundsRangeArrayMType a :: *

        vkViewportBoundsRangeArray ::
                                   a -> Int -> VkViewportBoundsRangeArrayMType a

        vkViewportBoundsRangeArrayByteOffset :: a -> Int

        readVkViewportBoundsRangeArray ::
                                       Mutable a -> Int -> IO (VkViewportBoundsRangeArrayMType a)

        writeVkViewportBoundsRangeArray ::
                                        Mutable a ->
                                          Int -> VkViewportBoundsRangeArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'viewportBoundsRange'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkViewportBoundsRangeArray a

instance {-# OVERLAPPING #-}
         HasVkViewportBoundsRangeArray VkPhysicalDeviceLimits where
        type VkViewportBoundsRangeArrayMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat
        vkViewportBoundsRangeArray (VkPhysicalDeviceLimits## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkViewportBoundsRangeArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkViewportBoundsRangeArray #-}
        vkViewportBoundsRangeArrayByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, viewportBoundsRange}

        {-# INLINE vkViewportBoundsRangeArrayByteOffset #-}
        readVkViewportBoundsRangeArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkViewportBoundsRangeArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkViewportBoundsRangeArray #-}
        writeVkViewportBoundsRangeArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkViewportBoundsRangeArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkViewportBoundsRangeArray #-}

class HasVkViewportSubPixelBits a where
        type VkViewportSubPixelBitsMType a :: *

        vkViewportSubPixelBits :: a -> VkViewportSubPixelBitsMType a

        vkViewportSubPixelBitsByteOffset :: a -> Int

        readVkViewportSubPixelBits ::
                                   Mutable a -> IO (VkViewportSubPixelBitsMType a)

        writeVkViewportSubPixelBits ::
                                    Mutable a -> VkViewportSubPixelBitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'viewportSubPixelBits'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkViewportSubPixelBits a

instance {-# OVERLAPPING #-}
         HasVkViewportSubPixelBits VkPhysicalDeviceLimits where
        type VkViewportSubPixelBitsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkViewportSubPixelBits (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkViewportSubPixelBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkViewportSubPixelBits #-}
        vkViewportSubPixelBitsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, viewportSubPixelBits}

        {-# INLINE vkViewportSubPixelBitsByteOffset #-}
        readVkViewportSubPixelBits (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkViewportSubPixelBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkViewportSubPixelBits #-}
        writeVkViewportSubPixelBits (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkViewportSubPixelBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkViewportSubPixelBits #-}

class HasVkMinMemoryMapAlignment a where
        type VkMinMemoryMapAlignmentMType a :: *

        vkMinMemoryMapAlignment :: a -> VkMinMemoryMapAlignmentMType a

        vkMinMemoryMapAlignmentByteOffset :: a -> Int

        readVkMinMemoryMapAlignment ::
                                    Mutable a -> IO (VkMinMemoryMapAlignmentMType a)

        writeVkMinMemoryMapAlignment ::
                                     Mutable a -> VkMinMemoryMapAlignmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minMemoryMapAlignment'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinMemoryMapAlignment a

instance {-# OVERLAPPING #-}
         HasVkMinMemoryMapAlignment VkPhysicalDeviceLimits where
        type VkMinMemoryMapAlignmentMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CSize
        vkMinMemoryMapAlignment (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CSize),
            I## o <- vkMinMemoryMapAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinMemoryMapAlignment #-}
        vkMinMemoryMapAlignmentByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, minMemoryMapAlignment}

        {-# INLINE vkMinMemoryMapAlignmentByteOffset #-}
        readVkMinMemoryMapAlignment (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CSize),
            I## o <- vkMinMemoryMapAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinMemoryMapAlignment #-}
        writeVkMinMemoryMapAlignment (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinMemoryMapAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinMemoryMapAlignment #-}

class HasVkMinTexelBufferOffsetAlignment a where
        type VkMinTexelBufferOffsetAlignmentMType a :: *

        vkMinTexelBufferOffsetAlignment ::
                                        a -> VkMinTexelBufferOffsetAlignmentMType a

        vkMinTexelBufferOffsetAlignmentByteOffset :: a -> Int

        readVkMinTexelBufferOffsetAlignment ::
                                            Mutable a -> IO (VkMinTexelBufferOffsetAlignmentMType a)

        writeVkMinTexelBufferOffsetAlignment ::
                                             Mutable a ->
                                               VkMinTexelBufferOffsetAlignmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'minTexelBufferOffsetAlignment'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinTexelBufferOffsetAlignment a

instance {-# OVERLAPPING #-}
         HasVkMinTexelBufferOffsetAlignment VkPhysicalDeviceLimits where
        type VkMinTexelBufferOffsetAlignmentMType VkPhysicalDeviceLimits =
             VkDeviceSize
        vkMinTexelBufferOffsetAlignment (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkMinTexelBufferOffsetAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinTexelBufferOffsetAlignment #-}
        vkMinTexelBufferOffsetAlignmentByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, minTexelBufferOffsetAlignment}

        {-# INLINE vkMinTexelBufferOffsetAlignmentByteOffset #-}
        readVkMinTexelBufferOffsetAlignment (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkMinTexelBufferOffsetAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinTexelBufferOffsetAlignment #-}
        writeVkMinTexelBufferOffsetAlignment (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinTexelBufferOffsetAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinTexelBufferOffsetAlignment #-}

class HasVkMinUniformBufferOffsetAlignment a where
        type VkMinUniformBufferOffsetAlignmentMType a :: *

        vkMinUniformBufferOffsetAlignment ::
                                          a -> VkMinUniformBufferOffsetAlignmentMType a

        vkMinUniformBufferOffsetAlignmentByteOffset :: a -> Int

        readVkMinUniformBufferOffsetAlignment ::
                                              Mutable a ->
                                                IO (VkMinUniformBufferOffsetAlignmentMType a)

        writeVkMinUniformBufferOffsetAlignment ::
                                               Mutable a ->
                                                 VkMinUniformBufferOffsetAlignmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'minUniformBufferOffsetAlignment'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinUniformBufferOffsetAlignment a

instance {-# OVERLAPPING #-}
         HasVkMinUniformBufferOffsetAlignment VkPhysicalDeviceLimits where
        type VkMinUniformBufferOffsetAlignmentMType VkPhysicalDeviceLimits
             = VkDeviceSize
        vkMinUniformBufferOffsetAlignment (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkMinUniformBufferOffsetAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinUniformBufferOffsetAlignment #-}
        vkMinUniformBufferOffsetAlignmentByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, minUniformBufferOffsetAlignment}

        {-# INLINE vkMinUniformBufferOffsetAlignmentByteOffset #-}
        readVkMinUniformBufferOffsetAlignment (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkMinUniformBufferOffsetAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinUniformBufferOffsetAlignment #-}
        writeVkMinUniformBufferOffsetAlignment (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinUniformBufferOffsetAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinUniformBufferOffsetAlignment #-}

class HasVkMinStorageBufferOffsetAlignment a where
        type VkMinStorageBufferOffsetAlignmentMType a :: *

        vkMinStorageBufferOffsetAlignment ::
                                          a -> VkMinStorageBufferOffsetAlignmentMType a

        vkMinStorageBufferOffsetAlignmentByteOffset :: a -> Int

        readVkMinStorageBufferOffsetAlignment ::
                                              Mutable a ->
                                                IO (VkMinStorageBufferOffsetAlignmentMType a)

        writeVkMinStorageBufferOffsetAlignment ::
                                               Mutable a ->
                                                 VkMinStorageBufferOffsetAlignmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'minStorageBufferOffsetAlignment'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinStorageBufferOffsetAlignment a

instance {-# OVERLAPPING #-}
         HasVkMinStorageBufferOffsetAlignment VkPhysicalDeviceLimits where
        type VkMinStorageBufferOffsetAlignmentMType VkPhysicalDeviceLimits
             = VkDeviceSize
        vkMinStorageBufferOffsetAlignment (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkMinStorageBufferOffsetAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinStorageBufferOffsetAlignment #-}
        vkMinStorageBufferOffsetAlignmentByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, minStorageBufferOffsetAlignment}

        {-# INLINE vkMinStorageBufferOffsetAlignmentByteOffset #-}
        readVkMinStorageBufferOffsetAlignment (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkMinStorageBufferOffsetAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinStorageBufferOffsetAlignment #-}
        writeVkMinStorageBufferOffsetAlignment (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinStorageBufferOffsetAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinStorageBufferOffsetAlignment #-}

class HasVkMinTexelOffset a where
        type VkMinTexelOffsetMType a :: *

        vkMinTexelOffset :: a -> VkMinTexelOffsetMType a

        vkMinTexelOffsetByteOffset :: a -> Int

        readVkMinTexelOffset :: Mutable a -> IO (VkMinTexelOffsetMType a)

        writeVkMinTexelOffset ::
                              Mutable a -> VkMinTexelOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minTexelOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinTexelOffset a

instance {-# OVERLAPPING #-}
         HasVkMinTexelOffset VkPhysicalDeviceLimits where
        type VkMinTexelOffsetMType VkPhysicalDeviceLimits = Data.Int.Int32
        vkMinTexelOffset (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkMinTexelOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinTexelOffset #-}
        vkMinTexelOffsetByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, minTexelOffset}

        {-# INLINE vkMinTexelOffsetByteOffset #-}
        readVkMinTexelOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkMinTexelOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinTexelOffset #-}
        writeVkMinTexelOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinTexelOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinTexelOffset #-}

class HasVkMaxTexelOffset a where
        type VkMaxTexelOffsetMType a :: *

        vkMaxTexelOffset :: a -> VkMaxTexelOffsetMType a

        vkMaxTexelOffsetByteOffset :: a -> Int

        readVkMaxTexelOffset :: Mutable a -> IO (VkMaxTexelOffsetMType a)

        writeVkMaxTexelOffset ::
                              Mutable a -> VkMaxTexelOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxTexelOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTexelOffset a

instance {-# OVERLAPPING #-}
         HasVkMaxTexelOffset VkPhysicalDeviceLimits where
        type VkMaxTexelOffsetMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxTexelOffset (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTexelOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxTexelOffset #-}
        vkMaxTexelOffsetByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTexelOffset}

        {-# INLINE vkMaxTexelOffsetByteOffset #-}
        readVkMaxTexelOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTexelOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxTexelOffset #-}
        writeVkMaxTexelOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxTexelOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxTexelOffset #-}

class HasVkMinTexelGatherOffset a where
        type VkMinTexelGatherOffsetMType a :: *

        vkMinTexelGatherOffset :: a -> VkMinTexelGatherOffsetMType a

        vkMinTexelGatherOffsetByteOffset :: a -> Int

        readVkMinTexelGatherOffset ::
                                   Mutable a -> IO (VkMinTexelGatherOffsetMType a)

        writeVkMinTexelGatherOffset ::
                                    Mutable a -> VkMinTexelGatherOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minTexelGatherOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinTexelGatherOffset a

instance {-# OVERLAPPING #-}
         HasVkMinTexelGatherOffset VkPhysicalDeviceLimits where
        type VkMinTexelGatherOffsetMType VkPhysicalDeviceLimits =
             Data.Int.Int32
        vkMinTexelGatherOffset (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkMinTexelGatherOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinTexelGatherOffset #-}
        vkMinTexelGatherOffsetByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, minTexelGatherOffset}

        {-# INLINE vkMinTexelGatherOffsetByteOffset #-}
        readVkMinTexelGatherOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Int.Int32),
            I## o <- vkMinTexelGatherOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinTexelGatherOffset #-}
        writeVkMinTexelGatherOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinTexelGatherOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinTexelGatherOffset #-}

class HasVkMaxTexelGatherOffset a where
        type VkMaxTexelGatherOffsetMType a :: *

        vkMaxTexelGatherOffset :: a -> VkMaxTexelGatherOffsetMType a

        vkMaxTexelGatherOffsetByteOffset :: a -> Int

        readVkMaxTexelGatherOffset ::
                                   Mutable a -> IO (VkMaxTexelGatherOffsetMType a)

        writeVkMaxTexelGatherOffset ::
                                    Mutable a -> VkMaxTexelGatherOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxTexelGatherOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxTexelGatherOffset a

instance {-# OVERLAPPING #-}
         HasVkMaxTexelGatherOffset VkPhysicalDeviceLimits where
        type VkMaxTexelGatherOffsetMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxTexelGatherOffset (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTexelGatherOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxTexelGatherOffset #-}
        vkMaxTexelGatherOffsetByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxTexelGatherOffset}

        {-# INLINE vkMaxTexelGatherOffsetByteOffset #-}
        readVkMaxTexelGatherOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxTexelGatherOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxTexelGatherOffset #-}
        writeVkMaxTexelGatherOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxTexelGatherOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxTexelGatherOffset #-}

class HasVkMinInterpolationOffset a where
        type VkMinInterpolationOffsetMType a :: *

        vkMinInterpolationOffset :: a -> VkMinInterpolationOffsetMType a

        vkMinInterpolationOffsetByteOffset :: a -> Int

        readVkMinInterpolationOffset ::
                                     Mutable a -> IO (VkMinInterpolationOffsetMType a)

        writeVkMinInterpolationOffset ::
                                      Mutable a -> VkMinInterpolationOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minInterpolationOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinInterpolationOffset a

instance {-# OVERLAPPING #-}
         HasVkMinInterpolationOffset VkPhysicalDeviceLimits where
        type VkMinInterpolationOffsetMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat
        vkMinInterpolationOffset (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMinInterpolationOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinInterpolationOffset #-}
        vkMinInterpolationOffsetByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, minInterpolationOffset}

        {-# INLINE vkMinInterpolationOffsetByteOffset #-}
        readVkMinInterpolationOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMinInterpolationOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinInterpolationOffset #-}
        writeVkMinInterpolationOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinInterpolationOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinInterpolationOffset #-}

class HasVkMaxInterpolationOffset a where
        type VkMaxInterpolationOffsetMType a :: *

        vkMaxInterpolationOffset :: a -> VkMaxInterpolationOffsetMType a

        vkMaxInterpolationOffsetByteOffset :: a -> Int

        readVkMaxInterpolationOffset ::
                                     Mutable a -> IO (VkMaxInterpolationOffsetMType a)

        writeVkMaxInterpolationOffset ::
                                      Mutable a -> VkMaxInterpolationOffsetMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxInterpolationOffset'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxInterpolationOffset a

instance {-# OVERLAPPING #-}
         HasVkMaxInterpolationOffset VkPhysicalDeviceLimits where
        type VkMaxInterpolationOffsetMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat
        vkMaxInterpolationOffset (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMaxInterpolationOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxInterpolationOffset #-}
        vkMaxInterpolationOffsetByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxInterpolationOffset}

        {-# INLINE vkMaxInterpolationOffsetByteOffset #-}
        readVkMaxInterpolationOffset (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkMaxInterpolationOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxInterpolationOffset #-}
        writeVkMaxInterpolationOffset (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxInterpolationOffsetByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxInterpolationOffset #-}

class HasVkSubPixelInterpolationOffsetBits a where
        type VkSubPixelInterpolationOffsetBitsMType a :: *

        vkSubPixelInterpolationOffsetBits ::
                                          a -> VkSubPixelInterpolationOffsetBitsMType a

        vkSubPixelInterpolationOffsetBitsByteOffset :: a -> Int

        readVkSubPixelInterpolationOffsetBits ::
                                              Mutable a ->
                                                IO (VkSubPixelInterpolationOffsetBitsMType a)

        writeVkSubPixelInterpolationOffsetBits ::
                                               Mutable a ->
                                                 VkSubPixelInterpolationOffsetBitsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'subPixelInterpolationOffsetBits'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSubPixelInterpolationOffsetBits a

instance {-# OVERLAPPING #-}
         HasVkSubPixelInterpolationOffsetBits VkPhysicalDeviceLimits where
        type VkSubPixelInterpolationOffsetBitsMType VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkSubPixelInterpolationOffsetBits (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSubPixelInterpolationOffsetBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSubPixelInterpolationOffsetBits #-}
        vkSubPixelInterpolationOffsetBitsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, subPixelInterpolationOffsetBits}

        {-# INLINE vkSubPixelInterpolationOffsetBitsByteOffset #-}
        readVkSubPixelInterpolationOffsetBits (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSubPixelInterpolationOffsetBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSubPixelInterpolationOffsetBits #-}
        writeVkSubPixelInterpolationOffsetBits (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSubPixelInterpolationOffsetBitsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSubPixelInterpolationOffsetBits #-}

class HasVkMaxFramebufferWidth a where
        type VkMaxFramebufferWidthMType a :: *

        vkMaxFramebufferWidth :: a -> VkMaxFramebufferWidthMType a

        vkMaxFramebufferWidthByteOffset :: a -> Int

        readVkMaxFramebufferWidth ::
                                  Mutable a -> IO (VkMaxFramebufferWidthMType a)

        writeVkMaxFramebufferWidth ::
                                   Mutable a -> VkMaxFramebufferWidthMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxFramebufferWidth'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxFramebufferWidth a

instance {-# OVERLAPPING #-}
         HasVkMaxFramebufferWidth VkPhysicalDeviceLimits where
        type VkMaxFramebufferWidthMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxFramebufferWidth (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxFramebufferWidthByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxFramebufferWidth #-}
        vkMaxFramebufferWidthByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxFramebufferWidth}

        {-# INLINE vkMaxFramebufferWidthByteOffset #-}
        readVkMaxFramebufferWidth (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxFramebufferWidthByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxFramebufferWidth #-}
        writeVkMaxFramebufferWidth (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxFramebufferWidthByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxFramebufferWidth #-}

class HasVkMaxFramebufferHeight a where
        type VkMaxFramebufferHeightMType a :: *

        vkMaxFramebufferHeight :: a -> VkMaxFramebufferHeightMType a

        vkMaxFramebufferHeightByteOffset :: a -> Int

        readVkMaxFramebufferHeight ::
                                   Mutable a -> IO (VkMaxFramebufferHeightMType a)

        writeVkMaxFramebufferHeight ::
                                    Mutable a -> VkMaxFramebufferHeightMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxFramebufferHeight'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxFramebufferHeight a

instance {-# OVERLAPPING #-}
         HasVkMaxFramebufferHeight VkPhysicalDeviceLimits where
        type VkMaxFramebufferHeightMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxFramebufferHeight (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxFramebufferHeightByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxFramebufferHeight #-}
        vkMaxFramebufferHeightByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxFramebufferHeight}

        {-# INLINE vkMaxFramebufferHeightByteOffset #-}
        readVkMaxFramebufferHeight (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxFramebufferHeightByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxFramebufferHeight #-}
        writeVkMaxFramebufferHeight (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxFramebufferHeightByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxFramebufferHeight #-}

class HasVkMaxFramebufferLayers a where
        type VkMaxFramebufferLayersMType a :: *

        vkMaxFramebufferLayers :: a -> VkMaxFramebufferLayersMType a

        vkMaxFramebufferLayersByteOffset :: a -> Int

        readVkMaxFramebufferLayers ::
                                   Mutable a -> IO (VkMaxFramebufferLayersMType a)

        writeVkMaxFramebufferLayers ::
                                    Mutable a -> VkMaxFramebufferLayersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxFramebufferLayers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxFramebufferLayers a

instance {-# OVERLAPPING #-}
         HasVkMaxFramebufferLayers VkPhysicalDeviceLimits where
        type VkMaxFramebufferLayersMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxFramebufferLayers (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxFramebufferLayersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxFramebufferLayers #-}
        vkMaxFramebufferLayersByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxFramebufferLayers}

        {-# INLINE vkMaxFramebufferLayersByteOffset #-}
        readVkMaxFramebufferLayers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxFramebufferLayersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxFramebufferLayers #-}
        writeVkMaxFramebufferLayers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxFramebufferLayersByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxFramebufferLayers #-}

class HasVkFramebufferColorSampleCounts a where
        type VkFramebufferColorSampleCountsMType a :: *

        vkFramebufferColorSampleCounts ::
                                       a -> VkFramebufferColorSampleCountsMType a

        vkFramebufferColorSampleCountsByteOffset :: a -> Int

        readVkFramebufferColorSampleCounts ::
                                           Mutable a -> IO (VkFramebufferColorSampleCountsMType a)

        writeVkFramebufferColorSampleCounts ::
                                            Mutable a ->
                                              VkFramebufferColorSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'framebufferColorSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFramebufferColorSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkFramebufferColorSampleCounts VkPhysicalDeviceLimits where
        type VkFramebufferColorSampleCountsMType VkPhysicalDeviceLimits =
             VkSampleCountFlags
        vkFramebufferColorSampleCounts (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkFramebufferColorSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFramebufferColorSampleCounts #-}
        vkFramebufferColorSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, framebufferColorSampleCounts}

        {-# INLINE vkFramebufferColorSampleCountsByteOffset #-}
        readVkFramebufferColorSampleCounts (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkFramebufferColorSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFramebufferColorSampleCounts #-}
        writeVkFramebufferColorSampleCounts (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFramebufferColorSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFramebufferColorSampleCounts #-}

class HasVkFramebufferDepthSampleCounts a where
        type VkFramebufferDepthSampleCountsMType a :: *

        vkFramebufferDepthSampleCounts ::
                                       a -> VkFramebufferDepthSampleCountsMType a

        vkFramebufferDepthSampleCountsByteOffset :: a -> Int

        readVkFramebufferDepthSampleCounts ::
                                           Mutable a -> IO (VkFramebufferDepthSampleCountsMType a)

        writeVkFramebufferDepthSampleCounts ::
                                            Mutable a ->
                                              VkFramebufferDepthSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'framebufferDepthSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFramebufferDepthSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkFramebufferDepthSampleCounts VkPhysicalDeviceLimits where
        type VkFramebufferDepthSampleCountsMType VkPhysicalDeviceLimits =
             VkSampleCountFlags
        vkFramebufferDepthSampleCounts (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkFramebufferDepthSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFramebufferDepthSampleCounts #-}
        vkFramebufferDepthSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, framebufferDepthSampleCounts}

        {-# INLINE vkFramebufferDepthSampleCountsByteOffset #-}
        readVkFramebufferDepthSampleCounts (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkFramebufferDepthSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFramebufferDepthSampleCounts #-}
        writeVkFramebufferDepthSampleCounts (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFramebufferDepthSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFramebufferDepthSampleCounts #-}

class HasVkFramebufferStencilSampleCounts a where
        type VkFramebufferStencilSampleCountsMType a :: *

        vkFramebufferStencilSampleCounts ::
                                         a -> VkFramebufferStencilSampleCountsMType a

        vkFramebufferStencilSampleCountsByteOffset :: a -> Int

        readVkFramebufferStencilSampleCounts ::
                                             Mutable a ->
                                               IO (VkFramebufferStencilSampleCountsMType a)

        writeVkFramebufferStencilSampleCounts ::
                                              Mutable a ->
                                                VkFramebufferStencilSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'framebufferStencilSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFramebufferStencilSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkFramebufferStencilSampleCounts VkPhysicalDeviceLimits where
        type VkFramebufferStencilSampleCountsMType VkPhysicalDeviceLimits =
             VkSampleCountFlags
        vkFramebufferStencilSampleCounts (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkFramebufferStencilSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFramebufferStencilSampleCounts #-}
        vkFramebufferStencilSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, framebufferStencilSampleCounts}

        {-# INLINE vkFramebufferStencilSampleCountsByteOffset #-}
        readVkFramebufferStencilSampleCounts (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkFramebufferStencilSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFramebufferStencilSampleCounts #-}
        writeVkFramebufferStencilSampleCounts (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFramebufferStencilSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFramebufferStencilSampleCounts #-}

class HasVkFramebufferNoAttachmentsSampleCounts a where
        type VkFramebufferNoAttachmentsSampleCountsMType a :: *

        vkFramebufferNoAttachmentsSampleCounts ::
                                               a -> VkFramebufferNoAttachmentsSampleCountsMType a

        vkFramebufferNoAttachmentsSampleCountsByteOffset :: a -> Int

        readVkFramebufferNoAttachmentsSampleCounts ::
                                                   Mutable a ->
                                                     IO
                                                       (VkFramebufferNoAttachmentsSampleCountsMType
                                                          a)

        writeVkFramebufferNoAttachmentsSampleCounts ::
                                                    Mutable a ->
                                                      VkFramebufferNoAttachmentsSampleCountsMType a
                                                        -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'framebufferNoAttachmentsSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkFramebufferNoAttachmentsSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkFramebufferNoAttachmentsSampleCounts VkPhysicalDeviceLimits
         where
        type VkFramebufferNoAttachmentsSampleCountsMType
               VkPhysicalDeviceLimits
             = VkSampleCountFlags
        vkFramebufferNoAttachmentsSampleCounts (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkFramebufferNoAttachmentsSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFramebufferNoAttachmentsSampleCounts #-}
        vkFramebufferNoAttachmentsSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, framebufferNoAttachmentsSampleCounts}

        {-# INLINE vkFramebufferNoAttachmentsSampleCountsByteOffset #-}
        readVkFramebufferNoAttachmentsSampleCounts (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkFramebufferNoAttachmentsSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFramebufferNoAttachmentsSampleCounts #-}
        writeVkFramebufferNoAttachmentsSampleCounts (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFramebufferNoAttachmentsSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFramebufferNoAttachmentsSampleCounts #-}

class HasVkMaxColorAttachments a where
        type VkMaxColorAttachmentsMType a :: *

        vkMaxColorAttachments :: a -> VkMaxColorAttachmentsMType a

        vkMaxColorAttachmentsByteOffset :: a -> Int

        readVkMaxColorAttachments ::
                                  Mutable a -> IO (VkMaxColorAttachmentsMType a)

        writeVkMaxColorAttachments ::
                                   Mutable a -> VkMaxColorAttachmentsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxColorAttachments'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxColorAttachments a

instance {-# OVERLAPPING #-}
         HasVkMaxColorAttachments VkPhysicalDeviceLimits where
        type VkMaxColorAttachmentsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxColorAttachments (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxColorAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxColorAttachments #-}
        vkMaxColorAttachmentsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxColorAttachments}

        {-# INLINE vkMaxColorAttachmentsByteOffset #-}
        readVkMaxColorAttachments (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxColorAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxColorAttachments #-}
        writeVkMaxColorAttachments (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxColorAttachmentsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxColorAttachments #-}

class HasVkSampledImageColorSampleCounts a where
        type VkSampledImageColorSampleCountsMType a :: *

        vkSampledImageColorSampleCounts ::
                                        a -> VkSampledImageColorSampleCountsMType a

        vkSampledImageColorSampleCountsByteOffset :: a -> Int

        readVkSampledImageColorSampleCounts ::
                                            Mutable a -> IO (VkSampledImageColorSampleCountsMType a)

        writeVkSampledImageColorSampleCounts ::
                                             Mutable a ->
                                               VkSampledImageColorSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'sampledImageColorSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampledImageColorSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkSampledImageColorSampleCounts VkPhysicalDeviceLimits where
        type VkSampledImageColorSampleCountsMType VkPhysicalDeviceLimits =
             VkSampleCountFlags
        vkSampledImageColorSampleCounts (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkSampledImageColorSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSampledImageColorSampleCounts #-}
        vkSampledImageColorSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, sampledImageColorSampleCounts}

        {-# INLINE vkSampledImageColorSampleCountsByteOffset #-}
        readVkSampledImageColorSampleCounts (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkSampledImageColorSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSampledImageColorSampleCounts #-}
        writeVkSampledImageColorSampleCounts (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSampledImageColorSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSampledImageColorSampleCounts #-}

class HasVkSampledImageIntegerSampleCounts a where
        type VkSampledImageIntegerSampleCountsMType a :: *

        vkSampledImageIntegerSampleCounts ::
                                          a -> VkSampledImageIntegerSampleCountsMType a

        vkSampledImageIntegerSampleCountsByteOffset :: a -> Int

        readVkSampledImageIntegerSampleCounts ::
                                              Mutable a ->
                                                IO (VkSampledImageIntegerSampleCountsMType a)

        writeVkSampledImageIntegerSampleCounts ::
                                               Mutable a ->
                                                 VkSampledImageIntegerSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'sampledImageIntegerSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampledImageIntegerSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkSampledImageIntegerSampleCounts VkPhysicalDeviceLimits where
        type VkSampledImageIntegerSampleCountsMType VkPhysicalDeviceLimits
             = VkSampleCountFlags
        vkSampledImageIntegerSampleCounts (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkSampledImageIntegerSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSampledImageIntegerSampleCounts #-}
        vkSampledImageIntegerSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, sampledImageIntegerSampleCounts}

        {-# INLINE vkSampledImageIntegerSampleCountsByteOffset #-}
        readVkSampledImageIntegerSampleCounts (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkSampledImageIntegerSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSampledImageIntegerSampleCounts #-}
        writeVkSampledImageIntegerSampleCounts (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSampledImageIntegerSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSampledImageIntegerSampleCounts #-}

class HasVkSampledImageDepthSampleCounts a where
        type VkSampledImageDepthSampleCountsMType a :: *

        vkSampledImageDepthSampleCounts ::
                                        a -> VkSampledImageDepthSampleCountsMType a

        vkSampledImageDepthSampleCountsByteOffset :: a -> Int

        readVkSampledImageDepthSampleCounts ::
                                            Mutable a -> IO (VkSampledImageDepthSampleCountsMType a)

        writeVkSampledImageDepthSampleCounts ::
                                             Mutable a ->
                                               VkSampledImageDepthSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'sampledImageDepthSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampledImageDepthSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkSampledImageDepthSampleCounts VkPhysicalDeviceLimits where
        type VkSampledImageDepthSampleCountsMType VkPhysicalDeviceLimits =
             VkSampleCountFlags
        vkSampledImageDepthSampleCounts (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkSampledImageDepthSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSampledImageDepthSampleCounts #-}
        vkSampledImageDepthSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, sampledImageDepthSampleCounts}

        {-# INLINE vkSampledImageDepthSampleCountsByteOffset #-}
        readVkSampledImageDepthSampleCounts (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkSampledImageDepthSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSampledImageDepthSampleCounts #-}
        writeVkSampledImageDepthSampleCounts (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSampledImageDepthSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSampledImageDepthSampleCounts #-}

class HasVkSampledImageStencilSampleCounts a where
        type VkSampledImageStencilSampleCountsMType a :: *

        vkSampledImageStencilSampleCounts ::
                                          a -> VkSampledImageStencilSampleCountsMType a

        vkSampledImageStencilSampleCountsByteOffset :: a -> Int

        readVkSampledImageStencilSampleCounts ::
                                              Mutable a ->
                                                IO (VkSampledImageStencilSampleCountsMType a)

        writeVkSampledImageStencilSampleCounts ::
                                               Mutable a ->
                                                 VkSampledImageStencilSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'sampledImageStencilSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSampledImageStencilSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkSampledImageStencilSampleCounts VkPhysicalDeviceLimits where
        type VkSampledImageStencilSampleCountsMType VkPhysicalDeviceLimits
             = VkSampleCountFlags
        vkSampledImageStencilSampleCounts (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkSampledImageStencilSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSampledImageStencilSampleCounts #-}
        vkSampledImageStencilSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, sampledImageStencilSampleCounts}

        {-# INLINE vkSampledImageStencilSampleCountsByteOffset #-}
        readVkSampledImageStencilSampleCounts (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkSampledImageStencilSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSampledImageStencilSampleCounts #-}
        writeVkSampledImageStencilSampleCounts (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSampledImageStencilSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSampledImageStencilSampleCounts #-}

class HasVkStorageImageSampleCounts a where
        type VkStorageImageSampleCountsMType a :: *

        vkStorageImageSampleCounts ::
                                   a -> VkStorageImageSampleCountsMType a

        vkStorageImageSampleCountsByteOffset :: a -> Int

        readVkStorageImageSampleCounts ::
                                       Mutable a -> IO (VkStorageImageSampleCountsMType a)

        writeVkStorageImageSampleCounts ::
                                        Mutable a -> VkStorageImageSampleCountsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'storageImageSampleCounts'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStorageImageSampleCounts a

instance {-# OVERLAPPING #-}
         HasVkStorageImageSampleCounts VkPhysicalDeviceLimits where
        type VkStorageImageSampleCountsMType VkPhysicalDeviceLimits =
             VkSampleCountFlags
        vkStorageImageSampleCounts (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkStorageImageSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkStorageImageSampleCounts #-}
        vkStorageImageSampleCountsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, storageImageSampleCounts}

        {-# INLINE vkStorageImageSampleCountsByteOffset #-}
        readVkStorageImageSampleCounts (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSampleCountFlags),
            I## o <- vkStorageImageSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkStorageImageSampleCounts #-}
        writeVkStorageImageSampleCounts (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkStorageImageSampleCountsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkStorageImageSampleCounts #-}

class HasVkMaxSampleMaskWords a where
        type VkMaxSampleMaskWordsMType a :: *

        vkMaxSampleMaskWords :: a -> VkMaxSampleMaskWordsMType a

        vkMaxSampleMaskWordsByteOffset :: a -> Int

        readVkMaxSampleMaskWords ::
                                 Mutable a -> IO (VkMaxSampleMaskWordsMType a)

        writeVkMaxSampleMaskWords ::
                                  Mutable a -> VkMaxSampleMaskWordsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxSampleMaskWords'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxSampleMaskWords a

instance {-# OVERLAPPING #-}
         HasVkMaxSampleMaskWords VkPhysicalDeviceLimits where
        type VkMaxSampleMaskWordsMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxSampleMaskWords (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxSampleMaskWordsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxSampleMaskWords #-}
        vkMaxSampleMaskWordsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxSampleMaskWords}

        {-# INLINE vkMaxSampleMaskWordsByteOffset #-}
        readVkMaxSampleMaskWords (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxSampleMaskWordsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxSampleMaskWords #-}
        writeVkMaxSampleMaskWords (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxSampleMaskWordsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxSampleMaskWords #-}

class HasVkTimestampComputeAndGraphics a where
        type VkTimestampComputeAndGraphicsMType a :: *

        vkTimestampComputeAndGraphics ::
                                      a -> VkTimestampComputeAndGraphicsMType a

        vkTimestampComputeAndGraphicsByteOffset :: a -> Int

        readVkTimestampComputeAndGraphics ::
                                          Mutable a -> IO (VkTimestampComputeAndGraphicsMType a)

        writeVkTimestampComputeAndGraphics ::
                                           Mutable a ->
                                             VkTimestampComputeAndGraphicsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'timestampComputeAndGraphics'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTimestampComputeAndGraphics a

instance {-# OVERLAPPING #-}
         HasVkTimestampComputeAndGraphics VkPhysicalDeviceLimits where
        type VkTimestampComputeAndGraphicsMType VkPhysicalDeviceLimits =
             VkBool32
        vkTimestampComputeAndGraphics (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkTimestampComputeAndGraphicsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkTimestampComputeAndGraphics #-}
        vkTimestampComputeAndGraphicsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, timestampComputeAndGraphics}

        {-# INLINE vkTimestampComputeAndGraphicsByteOffset #-}
        readVkTimestampComputeAndGraphics (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkTimestampComputeAndGraphicsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkTimestampComputeAndGraphics #-}
        writeVkTimestampComputeAndGraphics (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkTimestampComputeAndGraphicsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkTimestampComputeAndGraphics #-}

class HasVkTimestampPeriod a where
        type VkTimestampPeriodMType a :: *

        vkTimestampPeriod :: a -> VkTimestampPeriodMType a

        vkTimestampPeriodByteOffset :: a -> Int

        readVkTimestampPeriod :: Mutable a -> IO (VkTimestampPeriodMType a)

        writeVkTimestampPeriod ::
                               Mutable a -> VkTimestampPeriodMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'timestampPeriod'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkTimestampPeriod a

instance {-# OVERLAPPING #-}
         HasVkTimestampPeriod VkPhysicalDeviceLimits where
        type VkTimestampPeriodMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat
        vkTimestampPeriod (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkTimestampPeriodByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkTimestampPeriod #-}
        vkTimestampPeriodByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, timestampPeriod}

        {-# INLINE vkTimestampPeriodByteOffset #-}
        readVkTimestampPeriod (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkTimestampPeriodByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkTimestampPeriod #-}
        writeVkTimestampPeriod (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkTimestampPeriodByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkTimestampPeriod #-}

class HasVkMaxClipDistances a where
        type VkMaxClipDistancesMType a :: *

        vkMaxClipDistances :: a -> VkMaxClipDistancesMType a

        vkMaxClipDistancesByteOffset :: a -> Int

        readVkMaxClipDistances ::
                               Mutable a -> IO (VkMaxClipDistancesMType a)

        writeVkMaxClipDistances ::
                                Mutable a -> VkMaxClipDistancesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxClipDistances'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxClipDistances a

instance {-# OVERLAPPING #-}
         HasVkMaxClipDistances VkPhysicalDeviceLimits where
        type VkMaxClipDistancesMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxClipDistances (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxClipDistancesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxClipDistances #-}
        vkMaxClipDistancesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxClipDistances}

        {-# INLINE vkMaxClipDistancesByteOffset #-}
        readVkMaxClipDistances (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxClipDistancesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxClipDistances #-}
        writeVkMaxClipDistances (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxClipDistancesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxClipDistances #-}

class HasVkMaxCullDistances a where
        type VkMaxCullDistancesMType a :: *

        vkMaxCullDistances :: a -> VkMaxCullDistancesMType a

        vkMaxCullDistancesByteOffset :: a -> Int

        readVkMaxCullDistances ::
                               Mutable a -> IO (VkMaxCullDistancesMType a)

        writeVkMaxCullDistances ::
                                Mutable a -> VkMaxCullDistancesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxCullDistances'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxCullDistances a

instance {-# OVERLAPPING #-}
         HasVkMaxCullDistances VkPhysicalDeviceLimits where
        type VkMaxCullDistancesMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkMaxCullDistances (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxCullDistancesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxCullDistances #-}
        vkMaxCullDistancesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxCullDistances}

        {-# INLINE vkMaxCullDistancesByteOffset #-}
        readVkMaxCullDistances (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxCullDistancesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxCullDistances #-}
        writeVkMaxCullDistances (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxCullDistancesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxCullDistances #-}

class HasVkMaxCombinedClipAndCullDistances a where
        type VkMaxCombinedClipAndCullDistancesMType a :: *

        vkMaxCombinedClipAndCullDistances ::
                                          a -> VkMaxCombinedClipAndCullDistancesMType a

        vkMaxCombinedClipAndCullDistancesByteOffset :: a -> Int

        readVkMaxCombinedClipAndCullDistances ::
                                              Mutable a ->
                                                IO (VkMaxCombinedClipAndCullDistancesMType a)

        writeVkMaxCombinedClipAndCullDistances ::
                                               Mutable a ->
                                                 VkMaxCombinedClipAndCullDistancesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'maxCombinedClipAndCullDistances'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxCombinedClipAndCullDistances a

instance {-# OVERLAPPING #-}
         HasVkMaxCombinedClipAndCullDistances VkPhysicalDeviceLimits where
        type VkMaxCombinedClipAndCullDistancesMType VkPhysicalDeviceLimits
             = Data.Word.Word32
        vkMaxCombinedClipAndCullDistances (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxCombinedClipAndCullDistancesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxCombinedClipAndCullDistances #-}
        vkMaxCombinedClipAndCullDistancesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, maxCombinedClipAndCullDistances}

        {-# INLINE vkMaxCombinedClipAndCullDistancesByteOffset #-}
        readVkMaxCombinedClipAndCullDistances (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxCombinedClipAndCullDistancesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxCombinedClipAndCullDistances #-}
        writeVkMaxCombinedClipAndCullDistances (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxCombinedClipAndCullDistancesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxCombinedClipAndCullDistances #-}

class HasVkDiscreteQueuePriorities a where
        type VkDiscreteQueuePrioritiesMType a :: *

        vkDiscreteQueuePriorities :: a -> VkDiscreteQueuePrioritiesMType a

        vkDiscreteQueuePrioritiesByteOffset :: a -> Int

        readVkDiscreteQueuePriorities ::
                                      Mutable a -> IO (VkDiscreteQueuePrioritiesMType a)

        writeVkDiscreteQueuePriorities ::
                                       Mutable a -> VkDiscreteQueuePrioritiesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'discreteQueuePriorities'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkDiscreteQueuePriorities a

instance {-# OVERLAPPING #-}
         HasVkDiscreteQueuePriorities VkPhysicalDeviceLimits where
        type VkDiscreteQueuePrioritiesMType VkPhysicalDeviceLimits =
             Data.Word.Word32
        vkDiscreteQueuePriorities (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDiscreteQueuePrioritiesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkDiscreteQueuePriorities #-}
        vkDiscreteQueuePrioritiesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, discreteQueuePriorities}

        {-# INLINE vkDiscreteQueuePrioritiesByteOffset #-}
        readVkDiscreteQueuePriorities (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkDiscreteQueuePrioritiesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkDiscreteQueuePriorities #-}
        writeVkDiscreteQueuePriorities (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkDiscreteQueuePrioritiesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkDiscreteQueuePriorities #-}

class HasVkPointSizeRangeArray a where
        type VkPointSizeRangeArrayMType a :: *

        vkPointSizeRangeArray :: a -> Int -> VkPointSizeRangeArrayMType a

        vkPointSizeRangeArrayByteOffset :: a -> Int

        readVkPointSizeRangeArray ::
                                  Mutable a -> Int -> IO (VkPointSizeRangeArrayMType a)

        writeVkPointSizeRangeArray ::
                                   Mutable a -> Int -> VkPointSizeRangeArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pointSizeRange'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPointSizeRangeArray a

instance {-# OVERLAPPING #-}
         HasVkPointSizeRangeArray VkPhysicalDeviceLimits where
        type VkPointSizeRangeArrayMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat
        vkPointSizeRangeArray (VkPhysicalDeviceLimits## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkPointSizeRangeArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkPointSizeRangeArray #-}
        vkPointSizeRangeArrayByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, pointSizeRange}

        {-# INLINE vkPointSizeRangeArrayByteOffset #-}
        readVkPointSizeRangeArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkPointSizeRangeArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkPointSizeRangeArray #-}
        writeVkPointSizeRangeArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkPointSizeRangeArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkPointSizeRangeArray #-}

class HasVkLineWidthRangeArray a where
        type VkLineWidthRangeArrayMType a :: *

        vkLineWidthRangeArray :: a -> Int -> VkLineWidthRangeArrayMType a

        vkLineWidthRangeArrayByteOffset :: a -> Int

        readVkLineWidthRangeArray ::
                                  Mutable a -> Int -> IO (VkLineWidthRangeArrayMType a)

        writeVkLineWidthRangeArray ::
                                   Mutable a -> Int -> VkLineWidthRangeArrayMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'lineWidthRange'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLineWidthRangeArray a

instance {-# OVERLAPPING #-}
         HasVkLineWidthRangeArray VkPhysicalDeviceLimits where
        type VkLineWidthRangeArrayMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat
        vkLineWidthRangeArray (VkPhysicalDeviceLimits## ba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkLineWidthRangeArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` (idx *## _n +## o))))

        {-# NOINLINE vkLineWidthRangeArray #-}
        vkLineWidthRangeArrayByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, lineWidthRange}

        {-# INLINE vkLineWidthRangeArrayByteOffset #-}
        readVkLineWidthRangeArray (Mutable## mba) (I## idx)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkLineWidthRangeArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            peek
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))

        {-# INLINE readVkLineWidthRangeArray #-}
        writeVkLineWidthRangeArray (Mutable## mba) (I## idx) x
          | I## _n <- sizeOf x,
            I## o <- vkLineWidthRangeArrayByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke
              (Ptr
                 (byteArrayContents## (unsafeCoerce## mba) `plusAddr##`
                    (idx *## _n +## o)))
              x

        {-# INLINE writeVkLineWidthRangeArray #-}

class HasVkPointSizeGranularity a where
        type VkPointSizeGranularityMType a :: *

        vkPointSizeGranularity :: a -> VkPointSizeGranularityMType a

        vkPointSizeGranularityByteOffset :: a -> Int

        readVkPointSizeGranularity ::
                                   Mutable a -> IO (VkPointSizeGranularityMType a)

        writeVkPointSizeGranularity ::
                                    Mutable a -> VkPointSizeGranularityMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pointSizeGranularity'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPointSizeGranularity a

instance {-# OVERLAPPING #-}
         HasVkPointSizeGranularity VkPhysicalDeviceLimits where
        type VkPointSizeGranularityMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat
        vkPointSizeGranularity (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkPointSizeGranularityByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPointSizeGranularity #-}
        vkPointSizeGranularityByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, pointSizeGranularity}

        {-# INLINE vkPointSizeGranularityByteOffset #-}
        readVkPointSizeGranularity (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkPointSizeGranularityByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPointSizeGranularity #-}
        writeVkPointSizeGranularity (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPointSizeGranularityByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPointSizeGranularity #-}

class HasVkLineWidthGranularity a where
        type VkLineWidthGranularityMType a :: *

        vkLineWidthGranularity :: a -> VkLineWidthGranularityMType a

        vkLineWidthGranularityByteOffset :: a -> Int

        readVkLineWidthGranularity ::
                                   Mutable a -> IO (VkLineWidthGranularityMType a)

        writeVkLineWidthGranularity ::
                                    Mutable a -> VkLineWidthGranularityMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'lineWidthGranularity'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLineWidthGranularity a

instance {-# OVERLAPPING #-}
         HasVkLineWidthGranularity VkPhysicalDeviceLimits where
        type VkLineWidthGranularityMType VkPhysicalDeviceLimits =
             Foreign.C.Types.CFloat
        vkLineWidthGranularity (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkLineWidthGranularityByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLineWidthGranularity #-}
        vkLineWidthGranularityByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, lineWidthGranularity}

        {-# INLINE vkLineWidthGranularityByteOffset #-}
        readVkLineWidthGranularity (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.C.Types.CFloat),
            I## o <- vkLineWidthGranularityByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLineWidthGranularity #-}
        writeVkLineWidthGranularity (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLineWidthGranularityByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLineWidthGranularity #-}

class HasVkStrictLines a where
        type VkStrictLinesMType a :: *

        vkStrictLines :: a -> VkStrictLinesMType a

        vkStrictLinesByteOffset :: a -> Int

        readVkStrictLines :: Mutable a -> IO (VkStrictLinesMType a)

        writeVkStrictLines :: Mutable a -> VkStrictLinesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'strictLines'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStrictLines a

instance {-# OVERLAPPING #-}
         HasVkStrictLines VkPhysicalDeviceLimits where
        type VkStrictLinesMType VkPhysicalDeviceLimits = VkBool32
        vkStrictLines (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkStrictLinesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkStrictLines #-}
        vkStrictLinesByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, strictLines}

        {-# INLINE vkStrictLinesByteOffset #-}
        readVkStrictLines (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkStrictLinesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkStrictLines #-}
        writeVkStrictLines (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkStrictLinesByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkStrictLines #-}

class HasVkStandardSampleLocations a where
        type VkStandardSampleLocationsMType a :: *

        vkStandardSampleLocations :: a -> VkStandardSampleLocationsMType a

        vkStandardSampleLocationsByteOffset :: a -> Int

        readVkStandardSampleLocations ::
                                      Mutable a -> IO (VkStandardSampleLocationsMType a)

        writeVkStandardSampleLocations ::
                                       Mutable a -> VkStandardSampleLocationsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'standardSampleLocations'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkStandardSampleLocations a

instance {-# OVERLAPPING #-}
         HasVkStandardSampleLocations VkPhysicalDeviceLimits where
        type VkStandardSampleLocationsMType VkPhysicalDeviceLimits =
             VkBool32
        vkStandardSampleLocations (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkStandardSampleLocationsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkStandardSampleLocations #-}
        vkStandardSampleLocationsByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, standardSampleLocations}

        {-# INLINE vkStandardSampleLocationsByteOffset #-}
        readVkStandardSampleLocations (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkStandardSampleLocationsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkStandardSampleLocations #-}
        writeVkStandardSampleLocations (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkStandardSampleLocationsByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkStandardSampleLocations #-}

class HasVkOptimalBufferCopyOffsetAlignment a where
        type VkOptimalBufferCopyOffsetAlignmentMType a :: *

        vkOptimalBufferCopyOffsetAlignment ::
                                           a -> VkOptimalBufferCopyOffsetAlignmentMType a

        vkOptimalBufferCopyOffsetAlignmentByteOffset :: a -> Int

        readVkOptimalBufferCopyOffsetAlignment ::
                                               Mutable a ->
                                                 IO (VkOptimalBufferCopyOffsetAlignmentMType a)

        writeVkOptimalBufferCopyOffsetAlignment ::
                                                Mutable a ->
                                                  VkOptimalBufferCopyOffsetAlignmentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'optimalBufferCopyOffsetAlignment'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkOptimalBufferCopyOffsetAlignment a

instance {-# OVERLAPPING #-}
         HasVkOptimalBufferCopyOffsetAlignment VkPhysicalDeviceLimits where
        type VkOptimalBufferCopyOffsetAlignmentMType VkPhysicalDeviceLimits
             = VkDeviceSize
        vkOptimalBufferCopyOffsetAlignment (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkOptimalBufferCopyOffsetAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOptimalBufferCopyOffsetAlignment #-}
        vkOptimalBufferCopyOffsetAlignmentByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, optimalBufferCopyOffsetAlignment}

        {-# INLINE vkOptimalBufferCopyOffsetAlignmentByteOffset #-}
        readVkOptimalBufferCopyOffsetAlignment (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkOptimalBufferCopyOffsetAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOptimalBufferCopyOffsetAlignment #-}
        writeVkOptimalBufferCopyOffsetAlignment (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOptimalBufferCopyOffsetAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOptimalBufferCopyOffsetAlignment #-}

class HasVkOptimalBufferCopyRowPitchAlignment a where
        type VkOptimalBufferCopyRowPitchAlignmentMType a :: *

        vkOptimalBufferCopyRowPitchAlignment ::
                                             a -> VkOptimalBufferCopyRowPitchAlignmentMType a

        vkOptimalBufferCopyRowPitchAlignmentByteOffset :: a -> Int

        readVkOptimalBufferCopyRowPitchAlignment ::
                                                 Mutable a ->
                                                   IO (VkOptimalBufferCopyRowPitchAlignmentMType a)

        writeVkOptimalBufferCopyRowPitchAlignment ::
                                                  Mutable a ->
                                                    VkOptimalBufferCopyRowPitchAlignmentMType a ->
                                                      IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text
                " does not seem to have field 'optimalBufferCopyRowPitchAlignment'."
                :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkOptimalBufferCopyRowPitchAlignment a

instance {-# OVERLAPPING #-}
         HasVkOptimalBufferCopyRowPitchAlignment VkPhysicalDeviceLimits
         where
        type VkOptimalBufferCopyRowPitchAlignmentMType
               VkPhysicalDeviceLimits
             = VkDeviceSize
        vkOptimalBufferCopyRowPitchAlignment (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkOptimalBufferCopyRowPitchAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOptimalBufferCopyRowPitchAlignment #-}
        vkOptimalBufferCopyRowPitchAlignmentByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, optimalBufferCopyRowPitchAlignment}

        {-# INLINE vkOptimalBufferCopyRowPitchAlignmentByteOffset #-}
        readVkOptimalBufferCopyRowPitchAlignment (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkOptimalBufferCopyRowPitchAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOptimalBufferCopyRowPitchAlignment #-}
        writeVkOptimalBufferCopyRowPitchAlignment (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOptimalBufferCopyRowPitchAlignmentByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOptimalBufferCopyRowPitchAlignment #-}

class HasVkNonCoherentAtomSize a where
        type VkNonCoherentAtomSizeMType a :: *

        vkNonCoherentAtomSize :: a -> VkNonCoherentAtomSizeMType a

        vkNonCoherentAtomSizeByteOffset :: a -> Int

        readVkNonCoherentAtomSize ::
                                  Mutable a -> IO (VkNonCoherentAtomSizeMType a)

        writeVkNonCoherentAtomSize ::
                                   Mutable a -> VkNonCoherentAtomSizeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'nonCoherentAtomSize'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkNonCoherentAtomSize a

instance {-# OVERLAPPING #-}
         HasVkNonCoherentAtomSize VkPhysicalDeviceLimits where
        type VkNonCoherentAtomSizeMType VkPhysicalDeviceLimits =
             VkDeviceSize
        vkNonCoherentAtomSize (VkPhysicalDeviceLimits## ba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkNonCoherentAtomSizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkNonCoherentAtomSize #-}
        vkNonCoherentAtomSizeByteOffset ~_
          = #{offset VkPhysicalDeviceLimits, nonCoherentAtomSize}

        {-# INLINE vkNonCoherentAtomSizeByteOffset #-}
        readVkNonCoherentAtomSize (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkDeviceSize),
            I## o <- vkNonCoherentAtomSizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkNonCoherentAtomSize #-}
        writeVkNonCoherentAtomSize (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkNonCoherentAtomSizeByteOffset
                      (undefined :: VkPhysicalDeviceLimits)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkNonCoherentAtomSize #-}

instance Show VkPhysicalDeviceLimits where
        showsPrec d x
          = showString "VkPhysicalDeviceLimits {" .
              showString "vkMaxImageDimension1D = " .
                showsPrec d (vkMaxImageDimension1D x) .
                  showString ", " .
                    showString "vkMaxImageDimension2D = " .
                      showsPrec d (vkMaxImageDimension2D x) .
                        showString ", " .
                          showString "vkMaxImageDimension3D = " .
                            showsPrec d (vkMaxImageDimension3D x) .
                              showString ", " .
                                showString "vkMaxImageDimensionCube = " .
                                  showsPrec d (vkMaxImageDimensionCube x) .
                                    showString ", " .
                                      showString "vkMaxImageArrayLayers = " .
                                        showsPrec d (vkMaxImageArrayLayers x) .
                                          showString ", " .
                                            showString "vkMaxTexelBufferElements = " .
                                              showsPrec d (vkMaxTexelBufferElements x) .
                                                showString ", " .
                                                  showString "vkMaxUniformBufferRange = " .
                                                    showsPrec d (vkMaxUniformBufferRange x) .
                                                      showString ", " .
                                                        showString "vkMaxStorageBufferRange = " .
                                                          showsPrec d (vkMaxStorageBufferRange x) .
                                                            showString ", " .
                                                              showString "vkMaxPushConstantsSize = "
                                                                .
                                                                showsPrec d
                                                                  (vkMaxPushConstantsSize x)
                                                                  .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkMaxMemoryAllocationCount = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkMaxMemoryAllocationCount
                                                                           x)
                                                                        .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkMaxSamplerAllocationCount = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkMaxSamplerAllocationCount
                                                                                 x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkBufferImageGranularity = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkBufferImageGranularity
                                                                                       x)
                                                                                    .
                                                                                    showString ", "
                                                                                      .
                                                                                      showString
                                                                                        "vkSparseAddressSpaceSize = "
                                                                                        .
                                                                                        showsPrec d
                                                                                          (vkSparseAddressSpaceSize
                                                                                             x)
                                                                                          .
                                                                                          showString
                                                                                            ", "
                                                                                            .
                                                                                            showString
                                                                                              "vkMaxBoundDescriptorSets = "
                                                                                              .
                                                                                              showsPrec
                                                                                                d
                                                                                                (vkMaxBoundDescriptorSets
                                                                                                   x)
                                                                                                .
                                                                                                showString
                                                                                                  ", "
                                                                                                  .
                                                                                                  showString
                                                                                                    "vkMaxPerStageDescriptorSamplers = "
                                                                                                    .
                                                                                                    showsPrec
                                                                                                      d
                                                                                                      (vkMaxPerStageDescriptorSamplers
                                                                                                         x)
                                                                                                      .
                                                                                                      showString
                                                                                                        ", "
                                                                                                        .
                                                                                                        showString
                                                                                                          "vkMaxPerStageDescriptorUniformBuffers = "
                                                                                                          .
                                                                                                          showsPrec
                                                                                                            d
                                                                                                            (vkMaxPerStageDescriptorUniformBuffers
                                                                                                               x)
                                                                                                            .
                                                                                                            showString
                                                                                                              ", "
                                                                                                              .
                                                                                                              showString
                                                                                                                "vkMaxPerStageDescriptorStorageBuffers = "
                                                                                                                .
                                                                                                                showsPrec
                                                                                                                  d
                                                                                                                  (vkMaxPerStageDescriptorStorageBuffers
                                                                                                                     x)
                                                                                                                  .
                                                                                                                  showString
                                                                                                                    ", "
                                                                                                                    .
                                                                                                                    showString
                                                                                                                      "vkMaxPerStageDescriptorSampledImages = "
                                                                                                                      .
                                                                                                                      showsPrec
                                                                                                                        d
                                                                                                                        (vkMaxPerStageDescriptorSampledImages
                                                                                                                           x)
                                                                                                                        .
                                                                                                                        showString
                                                                                                                          ", "
                                                                                                                          .
                                                                                                                          showString
                                                                                                                            "vkMaxPerStageDescriptorStorageImages = "
                                                                                                                            .
                                                                                                                            showsPrec
                                                                                                                              d
                                                                                                                              (vkMaxPerStageDescriptorStorageImages
                                                                                                                                 x)
                                                                                                                              .
                                                                                                                              showString
                                                                                                                                ", "
                                                                                                                                .
                                                                                                                                showString
                                                                                                                                  "vkMaxPerStageDescriptorInputAttachments = "
                                                                                                                                  .
                                                                                                                                  showsPrec
                                                                                                                                    d
                                                                                                                                    (vkMaxPerStageDescriptorInputAttachments
                                                                                                                                       x)
                                                                                                                                    .
                                                                                                                                    showString
                                                                                                                                      ", "
                                                                                                                                      .
                                                                                                                                      showString
                                                                                                                                        "vkMaxPerStageResources = "
                                                                                                                                        .
                                                                                                                                        showsPrec
                                                                                                                                          d
                                                                                                                                          (vkMaxPerStageResources
                                                                                                                                             x)
                                                                                                                                          .
                                                                                                                                          showString
                                                                                                                                            ", "
                                                                                                                                            .
                                                                                                                                            showString
                                                                                                                                              "vkMaxDescriptorSetSamplers = "
                                                                                                                                              .
                                                                                                                                              showsPrec
                                                                                                                                                d
                                                                                                                                                (vkMaxDescriptorSetSamplers
                                                                                                                                                   x)
                                                                                                                                                .
                                                                                                                                                showString
                                                                                                                                                  ", "
                                                                                                                                                  .
                                                                                                                                                  showString
                                                                                                                                                    "vkMaxDescriptorSetUniformBuffers = "
                                                                                                                                                    .
                                                                                                                                                    showsPrec
                                                                                                                                                      d
                                                                                                                                                      (vkMaxDescriptorSetUniformBuffers
                                                                                                                                                         x)
                                                                                                                                                      .
                                                                                                                                                      showString
                                                                                                                                                        ", "
                                                                                                                                                        .
                                                                                                                                                        showString
                                                                                                                                                          "vkMaxDescriptorSetUniformBuffersDynamic = "
                                                                                                                                                          .
                                                                                                                                                          showsPrec
                                                                                                                                                            d
                                                                                                                                                            (vkMaxDescriptorSetUniformBuffersDynamic
                                                                                                                                                               x)
                                                                                                                                                            .
                                                                                                                                                            showString
                                                                                                                                                              ", "
                                                                                                                                                              .
                                                                                                                                                              showString
                                                                                                                                                                "vkMaxDescriptorSetStorageBuffers = "
                                                                                                                                                                .
                                                                                                                                                                showsPrec
                                                                                                                                                                  d
                                                                                                                                                                  (vkMaxDescriptorSetStorageBuffers
                                                                                                                                                                     x)
                                                                                                                                                                  .
                                                                                                                                                                  showString
                                                                                                                                                                    ", "
                                                                                                                                                                    .
                                                                                                                                                                    showString
                                                                                                                                                                      "vkMaxDescriptorSetStorageBuffersDynamic = "
                                                                                                                                                                      .
                                                                                                                                                                      showsPrec
                                                                                                                                                                        d
                                                                                                                                                                        (vkMaxDescriptorSetStorageBuffersDynamic
                                                                                                                                                                           x)
                                                                                                                                                                        .
                                                                                                                                                                        showString
                                                                                                                                                                          ", "
                                                                                                                                                                          .
                                                                                                                                                                          showString
                                                                                                                                                                            "vkMaxDescriptorSetSampledImages = "
                                                                                                                                                                            .
                                                                                                                                                                            showsPrec
                                                                                                                                                                              d
                                                                                                                                                                              (vkMaxDescriptorSetSampledImages
                                                                                                                                                                                 x)
                                                                                                                                                                              .
                                                                                                                                                                              showString
                                                                                                                                                                                ", "
                                                                                                                                                                                .
                                                                                                                                                                                showString
                                                                                                                                                                                  "vkMaxDescriptorSetStorageImages = "
                                                                                                                                                                                  .
                                                                                                                                                                                  showsPrec
                                                                                                                                                                                    d
                                                                                                                                                                                    (vkMaxDescriptorSetStorageImages
                                                                                                                                                                                       x)
                                                                                                                                                                                    .
                                                                                                                                                                                    showString
                                                                                                                                                                                      ", "
                                                                                                                                                                                      .
                                                                                                                                                                                      showString
                                                                                                                                                                                        "vkMaxDescriptorSetInputAttachments = "
                                                                                                                                                                                        .
                                                                                                                                                                                        showsPrec
                                                                                                                                                                                          d
                                                                                                                                                                                          (vkMaxDescriptorSetInputAttachments
                                                                                                                                                                                             x)
                                                                                                                                                                                          .
                                                                                                                                                                                          showString
                                                                                                                                                                                            ", "
                                                                                                                                                                                            .
                                                                                                                                                                                            showString
                                                                                                                                                                                              "vkMaxVertexInputAttributes = "
                                                                                                                                                                                              .
                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                d
                                                                                                                                                                                                (vkMaxVertexInputAttributes
                                                                                                                                                                                                   x)
                                                                                                                                                                                                .
                                                                                                                                                                                                showString
                                                                                                                                                                                                  ", "
                                                                                                                                                                                                  .
                                                                                                                                                                                                  showString
                                                                                                                                                                                                    "vkMaxVertexInputBindings = "
                                                                                                                                                                                                    .
                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                      d
                                                                                                                                                                                                      (vkMaxVertexInputBindings
                                                                                                                                                                                                         x)
                                                                                                                                                                                                      .
                                                                                                                                                                                                      showString
                                                                                                                                                                                                        ", "
                                                                                                                                                                                                        .
                                                                                                                                                                                                        showString
                                                                                                                                                                                                          "vkMaxVertexInputAttributeOffset = "
                                                                                                                                                                                                          .
                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                            d
                                                                                                                                                                                                            (vkMaxVertexInputAttributeOffset
                                                                                                                                                                                                               x)
                                                                                                                                                                                                            .
                                                                                                                                                                                                            showString
                                                                                                                                                                                                              ", "
                                                                                                                                                                                                              .
                                                                                                                                                                                                              showString
                                                                                                                                                                                                                "vkMaxVertexInputBindingStride = "
                                                                                                                                                                                                                .
                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                  d
                                                                                                                                                                                                                  (vkMaxVertexInputBindingStride
                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                  .
                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                    .
                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                      "vkMaxVertexOutputComponents = "
                                                                                                                                                                                                                      .
                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                        d
                                                                                                                                                                                                                        (vkMaxVertexOutputComponents
                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                        .
                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                          .
                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                            "vkMaxTessellationGenerationLevel = "
                                                                                                                                                                                                                            .
                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                              d
                                                                                                                                                                                                                              (vkMaxTessellationGenerationLevel
                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                              .
                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                  "vkMaxTessellationPatchSize = "
                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                    (vkMaxTessellationPatchSize
                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                        "vkMaxTessellationControlPerVertexInputComponents = "
                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                          (vkMaxTessellationControlPerVertexInputComponents
                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                              "vkMaxTessellationControlPerVertexOutputComponents = "
                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                (vkMaxTessellationControlPerVertexOutputComponents
                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                    "vkMaxTessellationControlPerPatchOutputComponents = "
                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                      (vkMaxTessellationControlPerPatchOutputComponents
                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                          "vkMaxTessellationControlTotalOutputComponents = "
                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                            (vkMaxTessellationControlTotalOutputComponents
                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                "vkMaxTessellationEvaluationInputComponents = "
                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                  (vkMaxTessellationEvaluationInputComponents
                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                      "vkMaxTessellationEvaluationOutputComponents = "
                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                        (vkMaxTessellationEvaluationOutputComponents
                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                            "vkMaxGeometryShaderInvocations = "
                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                              (vkMaxGeometryShaderInvocations
                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                  "vkMaxGeometryInputComponents = "
                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                    (vkMaxGeometryInputComponents
                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                        "vkMaxGeometryOutputComponents = "
                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                          (vkMaxGeometryOutputComponents
                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                              "vkMaxGeometryOutputVertices = "
                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                (vkMaxGeometryOutputVertices
                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                    "vkMaxGeometryTotalOutputComponents = "
                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                      (vkMaxGeometryTotalOutputComponents
                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                          "vkMaxFragmentInputComponents = "
                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                            (vkMaxFragmentInputComponents
                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                "vkMaxFragmentOutputAttachments = "
                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                  (vkMaxFragmentOutputAttachments
                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                      "vkMaxFragmentDualSrcAttachments = "
                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                        (vkMaxFragmentDualSrcAttachments
                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                            "vkMaxFragmentCombinedOutputResources = "
                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                              (vkMaxFragmentCombinedOutputResources
                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                  "vkMaxComputeSharedMemorySize = "
                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                    (vkMaxComputeSharedMemorySize
                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                        "vkMaxComputeWorkGroupCountArray = ["
                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                                                                          (map
                                                                                                                                                                                                                                                                                                                                             (vkMaxComputeWorkGroupCountArray
                                                                                                                                                                                                                                                                                                                                                x)
                                                                                                                                                                                                                                                                                                                                             [1
                                                                                                                                                                                                                                                                                                                                              ..
                                                                                                                                                                                                                                                                                                                                              3])
                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                          showChar
                                                                                                                                                                                                                                                                                                                                            ']'
                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                "vkMaxComputeWorkGroupInvocations = "
                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                                                  (vkMaxComputeWorkGroupInvocations
                                                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                      "vkMaxComputeWorkGroupSizeArray = ["
                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                        (map
                                                                                                                                                                                                                                                                                                                                                           (vkMaxComputeWorkGroupSizeArray
                                                                                                                                                                                                                                                                                                                                                              x)
                                                                                                                                                                                                                                                                                                                                                           [1
                                                                                                                                                                                                                                                                                                                                                            ..
                                                                                                                                                                                                                                                                                                                                                            3])
                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                        showChar
                                                                                                                                                                                                                                                                                                                                                          ']'
                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                              "vkSubPixelPrecisionBits = "
                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                (vkSubPixelPrecisionBits
                                                                                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                    "vkSubTexelPrecisionBits = "
                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                                                                                      (vkSubTexelPrecisionBits
                                                                                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                          "vkMipmapPrecisionBits = "
                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                                                                                            (vkMipmapPrecisionBits
                                                                                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                "vkMaxDrawIndexedIndexValue = "
                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                                                                                  (vkMaxDrawIndexedIndexValue
                                                                                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                      "vkMaxDrawIndirectCount = "
                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                        (vkMaxDrawIndirectCount
                                                                                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                            "vkMaxSamplerLodBias = "
                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                                                                                              (vkMaxSamplerLodBias
                                                                                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                  "vkMaxSamplerAnisotropy = "
                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                                                                                    (vkMaxSamplerAnisotropy
                                                                                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                        "vkMaxViewports = "
                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                                                                                                                                          (vkMaxViewports
                                                                                                                                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                              "vkMaxViewportDimensionsArray = ["
                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                                                                (map
                                                                                                                                                                                                                                                                                                                                                                                                                   (vkMaxViewportDimensionsArray
                                                                                                                                                                                                                                                                                                                                                                                                                      x)
                                                                                                                                                                                                                                                                                                                                                                                                                   [1
                                                                                                                                                                                                                                                                                                                                                                                                                    ..
                                                                                                                                                                                                                                                                                                                                                                                                                    2])
                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                showChar
                                                                                                                                                                                                                                                                                                                                                                                                                  ']'
                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                      "vkViewportBoundsRangeArray = ["
                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                                                        (map
                                                                                                                                                                                                                                                                                                                                                                                                                           (vkViewportBoundsRangeArray
                                                                                                                                                                                                                                                                                                                                                                                                                              x)
                                                                                                                                                                                                                                                                                                                                                                                                                           [1
                                                                                                                                                                                                                                                                                                                                                                                                                            ..
                                                                                                                                                                                                                                                                                                                                                                                                                            2])
                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                        showChar
                                                                                                                                                                                                                                                                                                                                                                                                                          ']'
                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                              "vkViewportSubPixelBits = "
                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                                                                                (vkViewportSubPixelBits
                                                                                                                                                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                    "vkMinMemoryMapAlignment = "
                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                                                                                                                                                      (vkMinMemoryMapAlignment
                                                                                                                                                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                          "vkMinTexelBufferOffsetAlignment = "
                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                                                                                                                                                            (vkMinTexelBufferOffsetAlignment
                                                                                                                                                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                "vkMinUniformBufferOffsetAlignment = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                                                                                                                                                  (vkMinUniformBufferOffsetAlignment
                                                                                                                                                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                      "vkMinStorageBufferOffsetAlignment = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                                                                                        (vkMinStorageBufferOffsetAlignment
                                                                                                                                                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                            "vkMinTexelOffset = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                                                                                                                                                              (vkMinTexelOffset
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "vkMaxTexelOffset = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (vkMaxTexelOffset
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "vkMinTexelGatherOffset = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (vkMinTexelGatherOffset
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "vkMaxTexelGatherOffset = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (vkMaxTexelGatherOffset
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "vkMinInterpolationOffset = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (vkMinInterpolationOffset
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "vkMaxInterpolationOffset = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (vkMaxInterpolationOffset
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "vkSubPixelInterpolationOffsetBits = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (vkSubPixelInterpolationOffsetBits
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "vkMaxFramebufferWidth = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (vkMaxFramebufferWidth
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "vkMaxFramebufferHeight = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (vkMaxFramebufferHeight
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "vkMaxFramebufferLayers = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (vkMaxFramebufferLayers
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "vkFramebufferColorSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (vkFramebufferColorSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "vkFramebufferDepthSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (vkFramebufferDepthSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "vkFramebufferStencilSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (vkFramebufferStencilSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "vkFramebufferNoAttachmentsSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (vkFramebufferNoAttachmentsSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "vkMaxColorAttachments = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (vkMaxColorAttachments
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "vkSampledImageColorSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (vkSampledImageColorSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "vkSampledImageIntegerSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (vkSampledImageIntegerSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "vkSampledImageDepthSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (vkSampledImageDepthSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "vkSampledImageStencilSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (vkSampledImageStencilSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "vkStorageImageSampleCounts = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (vkStorageImageSampleCounts
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "vkMaxSampleMaskWords = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (vkMaxSampleMaskWords
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "vkTimestampComputeAndGraphics = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (vkTimestampComputeAndGraphics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "vkTimestampPeriod = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (vkTimestampPeriod
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "vkMaxClipDistances = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (vkMaxClipDistances
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "vkMaxCullDistances = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (vkMaxCullDistances
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "vkMaxCombinedClipAndCullDistances = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (vkMaxCombinedClipAndCullDistances
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        "vkDiscreteQueuePriorities = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          (vkDiscreteQueuePriorities
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "vkPointSizeRangeArray = ["
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (map
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   (vkPointSizeRangeArray
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   [1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ..
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    2])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showChar
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ']'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "vkLineWidthRangeArray = ["
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (map
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (vkLineWidthRangeArray
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           [1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ..
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            2])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showChar
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ']'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              "vkPointSizeGranularity = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (vkPointSizeGranularity
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    "vkLineWidthGranularity = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (vkLineWidthGranularity
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "vkStrictLines = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            (vkStrictLines
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "vkStandardSampleLocations = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  (vkStandardSampleLocations
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "vkOptimalBufferCopyOffsetAlignment = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (vkOptimalBufferCopyOffsetAlignment
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "vkOptimalBufferCopyRowPitchAlignment = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (vkOptimalBufferCopyRowPitchAlignment
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ", "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                showString
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "vkNonCoherentAtomSize = "
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  showsPrec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    d
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (vkNonCoherentAtomSize
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       x)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    showChar
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      '}'

data VkSemaphoreCreateInfo = VkSemaphoreCreateInfo## ByteArray##

instance Eq VkSemaphoreCreateInfo where
        (VkSemaphoreCreateInfo## a) == (VkSemaphoreCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSemaphoreCreateInfo where
        (VkSemaphoreCreateInfo## a) `compare` (VkSemaphoreCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSemaphoreCreateInfo where
        sizeOf ~_ = #{size VkSemaphoreCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSemaphoreCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSemaphoreCreateInfo),
            I## a <- alignment (undefined :: VkSemaphoreCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSemaphoreCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSemaphoreCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkSemaphoreCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSemaphoreCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSemaphoreCreateInfo),
            I## a <- alignment (undefined :: VkSemaphoreCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSemaphoreCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSemaphoreCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSemaphoreCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkSemaphoreCreateInfo),
            I## a <- alignment (undefined :: VkSemaphoreCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSemaphoreCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSemaphoreCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkSemaphoreCreateInfo where
        type VkSTypeMType VkSemaphoreCreateInfo = VkStructureType
        vkSType (VkSemaphoreCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkSemaphoreCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkSemaphoreCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkSemaphoreCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkSemaphoreCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkSemaphoreCreateInfo where
        type VkPNextMType VkSemaphoreCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkSemaphoreCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkSemaphoreCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkSemaphoreCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkSemaphoreCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkSemaphoreCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkSemaphoreCreateInfo where
        type VkFlagsMType VkSemaphoreCreateInfo = VkSemaphoreCreateFlags
        vkFlags (VkSemaphoreCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkSemaphoreCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkSemaphoreCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkSemaphoreCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSemaphoreCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkSemaphoreCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkSemaphoreCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

instance Show VkSemaphoreCreateInfo where
        showsPrec d x
          = showString "VkSemaphoreCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " . showsPrec d (vkFlags x) . showChar '}'

data VkQueryPoolCreateInfo = VkQueryPoolCreateInfo## ByteArray##

instance Eq VkQueryPoolCreateInfo where
        (VkQueryPoolCreateInfo## a) == (VkQueryPoolCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkQueryPoolCreateInfo where
        (VkQueryPoolCreateInfo## a) `compare` (VkQueryPoolCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkQueryPoolCreateInfo where
        sizeOf ~_ = #{size VkQueryPoolCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkQueryPoolCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkQueryPoolCreateInfo),
            I## a <- alignment (undefined :: VkQueryPoolCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkQueryPoolCreateInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkQueryPoolCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkQueryPoolCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkQueryPoolCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkQueryPoolCreateInfo),
            I## a <- alignment (undefined :: VkQueryPoolCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkQueryPoolCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkQueryPoolCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkQueryPoolCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkQueryPoolCreateInfo),
            I## a <- alignment (undefined :: VkQueryPoolCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkQueryPoolCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkQueryPoolCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkQueryPoolCreateInfo where
        type VkSTypeMType VkQueryPoolCreateInfo = VkStructureType
        vkSType (VkQueryPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkQueryPoolCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkQueryPoolCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkQueryPoolCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkQueryPoolCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkQueryPoolCreateInfo where
        type VkPNextMType VkQueryPoolCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkQueryPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkQueryPoolCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkQueryPoolCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkQueryPoolCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkQueryPoolCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkQueryPoolCreateInfo where
        type VkFlagsMType VkQueryPoolCreateInfo = VkQueryPoolCreateFlags
        vkFlags (VkQueryPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkQueryPoolCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkQueryPoolCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkQueryPoolCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkQueryPoolCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkQueryPoolCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkQueryPoolCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkQueryType a where
        type VkQueryTypeMType a :: *

        vkQueryType :: a -> VkQueryTypeMType a

        vkQueryTypeByteOffset :: a -> Int

        readVkQueryType :: Mutable a -> IO (VkQueryTypeMType a)

        writeVkQueryType :: Mutable a -> VkQueryTypeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queryType'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueryType a

instance {-# OVERLAPPING #-} HasVkQueryType VkQueryPoolCreateInfo
         where
        type VkQueryTypeMType VkQueryPoolCreateInfo = VkQueryType
        vkQueryType (VkQueryPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkQueryType),
            I## o <- vkQueryTypeByteOffset (undefined :: VkQueryPoolCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkQueryType #-}
        vkQueryTypeByteOffset ~_
          = #{offset VkQueryPoolCreateInfo, queryType}

        {-# INLINE vkQueryTypeByteOffset #-}
        readVkQueryType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkQueryType),
            I## o <- vkQueryTypeByteOffset (undefined :: VkQueryPoolCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkQueryType #-}
        writeVkQueryType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkQueryTypeByteOffset (undefined :: VkQueryPoolCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkQueryType #-}

class HasVkQueryCount a where
        type VkQueryCountMType a :: *

        vkQueryCount :: a -> VkQueryCountMType a

        vkQueryCountByteOffset :: a -> Int

        readVkQueryCount :: Mutable a -> IO (VkQueryCountMType a)

        writeVkQueryCount :: Mutable a -> VkQueryCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'queryCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkQueryCount a

instance {-# OVERLAPPING #-} HasVkQueryCount VkQueryPoolCreateInfo
         where
        type VkQueryCountMType VkQueryPoolCreateInfo = Data.Word.Word32
        vkQueryCount (VkQueryPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueryCountByteOffset (undefined :: VkQueryPoolCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkQueryCount #-}
        vkQueryCountByteOffset ~_
          = #{offset VkQueryPoolCreateInfo, queryCount}

        {-# INLINE vkQueryCountByteOffset #-}
        readVkQueryCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueryCountByteOffset (undefined :: VkQueryPoolCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkQueryCount #-}
        writeVkQueryCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkQueryCountByteOffset (undefined :: VkQueryPoolCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkQueryCount #-}

instance {-# OVERLAPPING #-}
         HasVkPipelineStatistics VkQueryPoolCreateInfo where
        type VkPipelineStatisticsMType VkQueryPoolCreateInfo =
             VkQueryPipelineStatisticFlags
        vkPipelineStatistics (VkQueryPoolCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkQueryPipelineStatisticFlags),
            I## o <- vkPipelineStatisticsByteOffset
                      (undefined :: VkQueryPoolCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPipelineStatistics #-}
        vkPipelineStatisticsByteOffset ~_
          = #{offset VkQueryPoolCreateInfo, pipelineStatistics}

        {-# INLINE vkPipelineStatisticsByteOffset #-}
        readVkPipelineStatistics (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkQueryPipelineStatisticFlags),
            I## o <- vkPipelineStatisticsByteOffset
                      (undefined :: VkQueryPoolCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPipelineStatistics #-}
        writeVkPipelineStatistics (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPipelineStatisticsByteOffset
                      (undefined :: VkQueryPoolCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPipelineStatistics #-}

instance Show VkQueryPoolCreateInfo where
        showsPrec d x
          = showString "VkQueryPoolCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkQueryType = " .
                                  showsPrec d (vkQueryType x) .
                                    showString ", " .
                                      showString "vkQueryCount = " .
                                        showsPrec d (vkQueryCount x) .
                                          showString ", " .
                                            showString "vkPipelineStatistics = " .
                                              showsPrec d (vkPipelineStatistics x) . showChar '}'

data VkFramebufferCreateInfo = VkFramebufferCreateInfo## ByteArray##

instance Eq VkFramebufferCreateInfo where
        (VkFramebufferCreateInfo## a) == (VkFramebufferCreateInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkFramebufferCreateInfo where
        (VkFramebufferCreateInfo## a) `compare` (VkFramebufferCreateInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkFramebufferCreateInfo where
        sizeOf ~_ = #{size VkFramebufferCreateInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkFramebufferCreateInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkFramebufferCreateInfo),
            I## a <- alignment (undefined :: VkFramebufferCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkFramebufferCreateInfo##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkFramebufferCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkFramebufferCreateInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkFramebufferCreateInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkFramebufferCreateInfo),
            I## a <- alignment (undefined :: VkFramebufferCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkFramebufferCreateInfo##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkFramebufferCreateInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkFramebufferCreateInfo## ba)
          | I## n <- sizeOf (undefined :: VkFramebufferCreateInfo),
            I## a <- alignment (undefined :: VkFramebufferCreateInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkFramebufferCreateInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkFramebufferCreateInfo## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkFramebufferCreateInfo
         where
        type VkSTypeMType VkFramebufferCreateInfo = VkStructureType
        vkSType (VkFramebufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkFramebufferCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkFramebufferCreateInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkFramebufferCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkFramebufferCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkFramebufferCreateInfo
         where
        type VkPNextMType VkFramebufferCreateInfo =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkFramebufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkFramebufferCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkFramebufferCreateInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkFramebufferCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkFramebufferCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkFramebufferCreateInfo
         where
        type VkFlagsMType VkFramebufferCreateInfo =
             VkFramebufferCreateFlags
        vkFlags (VkFramebufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkFramebufferCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkFramebufferCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkFramebufferCreateInfo, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFramebufferCreateFlags),
            I## o <- vkFlagsByteOffset (undefined :: VkFramebufferCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkFramebufferCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

instance {-# OVERLAPPING #-}
         HasVkRenderPass VkFramebufferCreateInfo where
        type VkRenderPassMType VkFramebufferCreateInfo = VkRenderPass
        vkRenderPass (VkFramebufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: VkRenderPass),
            I## o <- vkRenderPassByteOffset
                      (undefined :: VkFramebufferCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkRenderPass #-}
        vkRenderPassByteOffset ~_
          = #{offset VkFramebufferCreateInfo, renderPass}

        {-# INLINE vkRenderPassByteOffset #-}
        readVkRenderPass (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkRenderPass),
            I## o <- vkRenderPassByteOffset
                      (undefined :: VkFramebufferCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkRenderPass #-}
        writeVkRenderPass (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkRenderPassByteOffset
                      (undefined :: VkFramebufferCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkRenderPass #-}

instance {-# OVERLAPPING #-}
         HasVkAttachmentCount VkFramebufferCreateInfo where
        type VkAttachmentCountMType VkFramebufferCreateInfo =
             Data.Word.Word32
        vkAttachmentCount (VkFramebufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkAttachmentCountByteOffset
                      (undefined :: VkFramebufferCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkAttachmentCount #-}
        vkAttachmentCountByteOffset ~_
          = #{offset VkFramebufferCreateInfo, attachmentCount}

        {-# INLINE vkAttachmentCountByteOffset #-}
        readVkAttachmentCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkAttachmentCountByteOffset
                      (undefined :: VkFramebufferCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkAttachmentCount #-}
        writeVkAttachmentCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkAttachmentCountByteOffset
                      (undefined :: VkFramebufferCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkAttachmentCount #-}

instance {-# OVERLAPPING #-}
         HasVkPAttachments VkFramebufferCreateInfo where
        type VkPAttachmentsMType VkFramebufferCreateInfo =
             Foreign.Ptr.Ptr VkImageView
        vkPAttachments (VkFramebufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkImageView),
            I## o <- vkPAttachmentsByteOffset
                      (undefined :: VkFramebufferCreateInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPAttachments #-}
        vkPAttachmentsByteOffset ~_
          = #{offset VkFramebufferCreateInfo, pAttachments}

        {-# INLINE vkPAttachmentsByteOffset #-}
        readVkPAttachments (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkImageView),
            I## o <- vkPAttachmentsByteOffset
                      (undefined :: VkFramebufferCreateInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPAttachments #-}
        writeVkPAttachments (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPAttachmentsByteOffset
                      (undefined :: VkFramebufferCreateInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPAttachments #-}

instance {-# OVERLAPPING #-} HasVkWidth VkFramebufferCreateInfo
         where
        type VkWidthMType VkFramebufferCreateInfo = Data.Word.Word32
        vkWidth (VkFramebufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkWidthByteOffset (undefined :: VkFramebufferCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkWidth #-}
        vkWidthByteOffset ~_
          = #{offset VkFramebufferCreateInfo, width}

        {-# INLINE vkWidthByteOffset #-}
        readVkWidth (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkWidthByteOffset (undefined :: VkFramebufferCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkWidth #-}
        writeVkWidth (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkWidthByteOffset (undefined :: VkFramebufferCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkWidth #-}

instance {-# OVERLAPPING #-} HasVkHeight VkFramebufferCreateInfo
         where
        type VkHeightMType VkFramebufferCreateInfo = Data.Word.Word32
        vkHeight (VkFramebufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkHeightByteOffset (undefined :: VkFramebufferCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkHeight #-}
        vkHeightByteOffset ~_
          = #{offset VkFramebufferCreateInfo, height}

        {-# INLINE vkHeightByteOffset #-}
        readVkHeight (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkHeightByteOffset (undefined :: VkFramebufferCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkHeight #-}
        writeVkHeight (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkHeightByteOffset (undefined :: VkFramebufferCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkHeight #-}

class HasVkLayers a where
        type VkLayersMType a :: *

        vkLayers :: a -> VkLayersMType a

        vkLayersByteOffset :: a -> Int

        readVkLayers :: Mutable a -> IO (VkLayersMType a)

        writeVkLayers :: Mutable a -> VkLayersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'layers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkLayers a

instance {-# OVERLAPPING #-} HasVkLayers VkFramebufferCreateInfo
         where
        type VkLayersMType VkFramebufferCreateInfo = Data.Word.Word32
        vkLayers (VkFramebufferCreateInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkLayersByteOffset (undefined :: VkFramebufferCreateInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkLayers #-}
        vkLayersByteOffset ~_
          = #{offset VkFramebufferCreateInfo, layers}

        {-# INLINE vkLayersByteOffset #-}
        readVkLayers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkLayersByteOffset (undefined :: VkFramebufferCreateInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkLayers #-}
        writeVkLayers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkLayersByteOffset (undefined :: VkFramebufferCreateInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkLayers #-}

instance Show VkFramebufferCreateInfo where
        showsPrec d x
          = showString "VkFramebufferCreateInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkRenderPass = " .
                                  showsPrec d (vkRenderPass x) .
                                    showString ", " .
                                      showString "vkAttachmentCount = " .
                                        showsPrec d (vkAttachmentCount x) .
                                          showString ", " .
                                            showString "vkPAttachments = " .
                                              showsPrec d (vkPAttachments x) .
                                                showString ", " .
                                                  showString "vkWidth = " .
                                                    showsPrec d (vkWidth x) .
                                                      showString ", " .
                                                        showString "vkHeight = " .
                                                          showsPrec d (vkHeight x) .
                                                            showString ", " .
                                                              showString "vkLayers = " .
                                                                showsPrec d (vkLayers x) .
                                                                  showChar '}'

data VkSubmitInfo = VkSubmitInfo## ByteArray##

instance Eq VkSubmitInfo where
        (VkSubmitInfo## a) == (VkSubmitInfo## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSubmitInfo where
        (VkSubmitInfo## a) `compare` (VkSubmitInfo## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSubmitInfo where
        sizeOf ~_ = #{size VkSubmitInfo}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSubmitInfo}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSubmitInfo),
            I## a <- alignment (undefined :: VkSubmitInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkSubmitInfo## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSubmitInfo## ba)
          | I## n <- sizeOf (undefined :: VkSubmitInfo) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSubmitInfo where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSubmitInfo),
            I## a <- alignment (undefined :: VkSubmitInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkSubmitInfo## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSubmitInfo## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSubmitInfo## ba)
          | I## n <- sizeOf (undefined :: VkSubmitInfo),
            I## a <- alignment (undefined :: VkSubmitInfo) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSubmitInfo## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSubmitInfo## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkSubmitInfo where
        type VkSTypeMType VkSubmitInfo = VkStructureType
        vkSType (VkSubmitInfo## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkSubmitInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_ = #{offset VkSubmitInfo, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkSubmitInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkSubmitInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkSubmitInfo where
        type VkPNextMType VkSubmitInfo = Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkSubmitInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkSubmitInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_ = #{offset VkSubmitInfo, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkSubmitInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkSubmitInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkWaitSemaphoreCount VkSubmitInfo
         where
        type VkWaitSemaphoreCountMType VkSubmitInfo = Data.Word.Word32
        vkWaitSemaphoreCount (VkSubmitInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkWaitSemaphoreCountByteOffset (undefined :: VkSubmitInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkWaitSemaphoreCount #-}
        vkWaitSemaphoreCountByteOffset ~_
          = #{offset VkSubmitInfo, waitSemaphoreCount}

        {-# INLINE vkWaitSemaphoreCountByteOffset #-}
        readVkWaitSemaphoreCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkWaitSemaphoreCountByteOffset (undefined :: VkSubmitInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkWaitSemaphoreCount #-}
        writeVkWaitSemaphoreCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkWaitSemaphoreCountByteOffset (undefined :: VkSubmitInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkWaitSemaphoreCount #-}

instance {-# OVERLAPPING #-} HasVkPWaitSemaphores VkSubmitInfo
         where
        type VkPWaitSemaphoresMType VkSubmitInfo =
             Foreign.Ptr.Ptr VkSemaphore
        vkPWaitSemaphores (VkSubmitInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSemaphore),
            I## o <- vkPWaitSemaphoresByteOffset (undefined :: VkSubmitInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPWaitSemaphores #-}
        vkPWaitSemaphoresByteOffset ~_
          = #{offset VkSubmitInfo, pWaitSemaphores}

        {-# INLINE vkPWaitSemaphoresByteOffset #-}
        readVkPWaitSemaphores (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSemaphore),
            I## o <- vkPWaitSemaphoresByteOffset (undefined :: VkSubmitInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPWaitSemaphores #-}
        writeVkPWaitSemaphores (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPWaitSemaphoresByteOffset (undefined :: VkSubmitInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPWaitSemaphores #-}

class HasVkPWaitDstStageMask a where
        type VkPWaitDstStageMaskMType a :: *

        vkPWaitDstStageMask :: a -> VkPWaitDstStageMaskMType a

        vkPWaitDstStageMaskByteOffset :: a -> Int

        readVkPWaitDstStageMask ::
                                Mutable a -> IO (VkPWaitDstStageMaskMType a)

        writeVkPWaitDstStageMask ::
                                 Mutable a -> VkPWaitDstStageMaskMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pWaitDstStageMask'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPWaitDstStageMask a

instance {-# OVERLAPPING #-} HasVkPWaitDstStageMask VkSubmitInfo
         where
        type VkPWaitDstStageMaskMType VkSubmitInfo =
             Foreign.Ptr.Ptr VkPipelineStageFlags
        vkPWaitDstStageMask (VkSubmitInfo## ba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPipelineStageFlags),
            I## o <- vkPWaitDstStageMaskByteOffset (undefined :: VkSubmitInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPWaitDstStageMask #-}
        vkPWaitDstStageMaskByteOffset ~_
          = #{offset VkSubmitInfo, pWaitDstStageMask}

        {-# INLINE vkPWaitDstStageMaskByteOffset #-}
        readVkPWaitDstStageMask (Mutable## mba)
          | I## _n <- sizeOf
                       (undefined :: Foreign.Ptr.Ptr VkPipelineStageFlags),
            I## o <- vkPWaitDstStageMaskByteOffset (undefined :: VkSubmitInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPWaitDstStageMask #-}
        writeVkPWaitDstStageMask (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPWaitDstStageMaskByteOffset (undefined :: VkSubmitInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPWaitDstStageMask #-}

instance {-# OVERLAPPING #-} HasVkCommandBufferCount VkSubmitInfo
         where
        type VkCommandBufferCountMType VkSubmitInfo = Data.Word.Word32
        vkCommandBufferCount (VkSubmitInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkCommandBufferCountByteOffset (undefined :: VkSubmitInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkCommandBufferCount #-}
        vkCommandBufferCountByteOffset ~_
          = #{offset VkSubmitInfo, commandBufferCount}

        {-# INLINE vkCommandBufferCountByteOffset #-}
        readVkCommandBufferCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkCommandBufferCountByteOffset (undefined :: VkSubmitInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkCommandBufferCount #-}
        writeVkCommandBufferCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkCommandBufferCountByteOffset (undefined :: VkSubmitInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkCommandBufferCount #-}

class HasVkPCommandBuffers a where
        type VkPCommandBuffersMType a :: *

        vkPCommandBuffers :: a -> VkPCommandBuffersMType a

        vkPCommandBuffersByteOffset :: a -> Int

        readVkPCommandBuffers :: Mutable a -> IO (VkPCommandBuffersMType a)

        writeVkPCommandBuffers ::
                               Mutable a -> VkPCommandBuffersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pCommandBuffers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPCommandBuffers a

instance {-# OVERLAPPING #-} HasVkPCommandBuffers VkSubmitInfo
         where
        type VkPCommandBuffersMType VkSubmitInfo =
             Foreign.Ptr.Ptr VkCommandBuffer
        vkPCommandBuffers (VkSubmitInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkCommandBuffer),
            I## o <- vkPCommandBuffersByteOffset (undefined :: VkSubmitInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPCommandBuffers #-}
        vkPCommandBuffersByteOffset ~_
          = #{offset VkSubmitInfo, pCommandBuffers}

        {-# INLINE vkPCommandBuffersByteOffset #-}
        readVkPCommandBuffers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkCommandBuffer),
            I## o <- vkPCommandBuffersByteOffset (undefined :: VkSubmitInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPCommandBuffers #-}
        writeVkPCommandBuffers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPCommandBuffersByteOffset (undefined :: VkSubmitInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPCommandBuffers #-}

instance {-# OVERLAPPING #-} HasVkSignalSemaphoreCount VkSubmitInfo
         where
        type VkSignalSemaphoreCountMType VkSubmitInfo = Data.Word.Word32
        vkSignalSemaphoreCount (VkSubmitInfo## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSignalSemaphoreCountByteOffset
                      (undefined :: VkSubmitInfo)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSignalSemaphoreCount #-}
        vkSignalSemaphoreCountByteOffset ~_
          = #{offset VkSubmitInfo, signalSemaphoreCount}

        {-# INLINE vkSignalSemaphoreCountByteOffset #-}
        readVkSignalSemaphoreCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSignalSemaphoreCountByteOffset
                      (undefined :: VkSubmitInfo)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSignalSemaphoreCount #-}
        writeVkSignalSemaphoreCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSignalSemaphoreCountByteOffset
                      (undefined :: VkSubmitInfo)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSignalSemaphoreCount #-}

instance {-# OVERLAPPING #-} HasVkPSignalSemaphores VkSubmitInfo
         where
        type VkPSignalSemaphoresMType VkSubmitInfo =
             Foreign.Ptr.Ptr VkSemaphore
        vkPSignalSemaphores (VkSubmitInfo## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSemaphore),
            I## o <- vkPSignalSemaphoresByteOffset (undefined :: VkSubmitInfo) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPSignalSemaphores #-}
        vkPSignalSemaphoresByteOffset ~_
          = #{offset VkSubmitInfo, pSignalSemaphores}

        {-# INLINE vkPSignalSemaphoresByteOffset #-}
        readVkPSignalSemaphores (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSemaphore),
            I## o <- vkPSignalSemaphoresByteOffset (undefined :: VkSubmitInfo) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPSignalSemaphores #-}
        writeVkPSignalSemaphores (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPSignalSemaphoresByteOffset (undefined :: VkSubmitInfo) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPSignalSemaphores #-}

instance Show VkSubmitInfo where
        showsPrec d x
          = showString "VkSubmitInfo {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkWaitSemaphoreCount = " .
                            showsPrec d (vkWaitSemaphoreCount x) .
                              showString ", " .
                                showString "vkPWaitSemaphores = " .
                                  showsPrec d (vkPWaitSemaphores x) .
                                    showString ", " .
                                      showString "vkPWaitDstStageMask = " .
                                        showsPrec d (vkPWaitDstStageMask x) .
                                          showString ", " .
                                            showString "vkCommandBufferCount = " .
                                              showsPrec d (vkCommandBufferCount x) .
                                                showString ", " .
                                                  showString "vkPCommandBuffers = " .
                                                    showsPrec d (vkPCommandBuffers x) .
                                                      showString ", " .
                                                        showString "vkSignalSemaphoreCount = " .
                                                          showsPrec d (vkSignalSemaphoreCount x) .
                                                            showString ", " .
                                                              showString "vkPSignalSemaphores = " .
                                                                showsPrec d (vkPSignalSemaphores x)
                                                                  . showChar '}'

data VkSurfaceCapabilitiesKHR = VkSurfaceCapabilitiesKHR## ByteArray##

instance Eq VkSurfaceCapabilitiesKHR where
        (VkSurfaceCapabilitiesKHR## a) == (VkSurfaceCapabilitiesKHR## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSurfaceCapabilitiesKHR where
        (VkSurfaceCapabilitiesKHR## a) `compare`
          (VkSurfaceCapabilitiesKHR## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSurfaceCapabilitiesKHR where
        sizeOf ~_ = #{size VkSurfaceCapabilitiesKHR}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSurfaceCapabilitiesKHR}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSurfaceCapabilitiesKHR),
            I## a <- alignment (undefined :: VkSurfaceCapabilitiesKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSurfaceCapabilitiesKHR##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSurfaceCapabilitiesKHR## ba)
          | I## n <- sizeOf (undefined :: VkSurfaceCapabilitiesKHR) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSurfaceCapabilitiesKHR where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSurfaceCapabilitiesKHR),
            I## a <- alignment (undefined :: VkSurfaceCapabilitiesKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSurfaceCapabilitiesKHR##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSurfaceCapabilitiesKHR## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSurfaceCapabilitiesKHR## ba)
          | I## n <- sizeOf (undefined :: VkSurfaceCapabilitiesKHR),
            I## a <- alignment (undefined :: VkSurfaceCapabilitiesKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSurfaceCapabilitiesKHR## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSurfaceCapabilitiesKHR## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

class HasVkMinImageCount a where
        type VkMinImageCountMType a :: *

        vkMinImageCount :: a -> VkMinImageCountMType a

        vkMinImageCountByteOffset :: a -> Int

        readVkMinImageCount :: Mutable a -> IO (VkMinImageCountMType a)

        writeVkMinImageCount ::
                             Mutable a -> VkMinImageCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minImageCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinImageCount a

instance {-# OVERLAPPING #-}
         HasVkMinImageCount VkSurfaceCapabilitiesKHR where
        type VkMinImageCountMType VkSurfaceCapabilitiesKHR =
             Data.Word.Word32
        vkMinImageCount (VkSurfaceCapabilitiesKHR## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMinImageCountByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinImageCount #-}
        vkMinImageCountByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, minImageCount}

        {-# INLINE vkMinImageCountByteOffset #-}
        readVkMinImageCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMinImageCountByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinImageCount #-}
        writeVkMinImageCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinImageCountByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinImageCount #-}

class HasVkMaxImageCount a where
        type VkMaxImageCountMType a :: *

        vkMaxImageCount :: a -> VkMaxImageCountMType a

        vkMaxImageCountByteOffset :: a -> Int

        readVkMaxImageCount :: Mutable a -> IO (VkMaxImageCountMType a)

        writeVkMaxImageCount ::
                             Mutable a -> VkMaxImageCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxImageCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxImageCount a

instance {-# OVERLAPPING #-}
         HasVkMaxImageCount VkSurfaceCapabilitiesKHR where
        type VkMaxImageCountMType VkSurfaceCapabilitiesKHR =
             Data.Word.Word32
        vkMaxImageCount (VkSurfaceCapabilitiesKHR## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxImageCountByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxImageCount #-}
        vkMaxImageCountByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, maxImageCount}

        {-# INLINE vkMaxImageCountByteOffset #-}
        readVkMaxImageCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxImageCountByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxImageCount #-}
        writeVkMaxImageCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxImageCountByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxImageCount #-}

class HasVkCurrentExtent a where
        type VkCurrentExtentMType a :: *

        vkCurrentExtent :: a -> VkCurrentExtentMType a

        vkCurrentExtentByteOffset :: a -> Int

        readVkCurrentExtent :: Mutable a -> IO (VkCurrentExtentMType a)

        writeVkCurrentExtent ::
                             Mutable a -> VkCurrentExtentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'currentExtent'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCurrentExtent a

instance {-# OVERLAPPING #-}
         HasVkCurrentExtent VkSurfaceCapabilitiesKHR where
        type VkCurrentExtentMType VkSurfaceCapabilitiesKHR = VkExtent2D
        vkCurrentExtent (VkSurfaceCapabilitiesKHR## ba)
          | I## _n <- sizeOf (undefined :: VkExtent2D),
            I## o <- vkCurrentExtentByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkCurrentExtent #-}
        vkCurrentExtentByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, currentExtent}

        {-# INLINE vkCurrentExtentByteOffset #-}
        readVkCurrentExtent (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkExtent2D),
            I## o <- vkCurrentExtentByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkCurrentExtent #-}
        writeVkCurrentExtent (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkCurrentExtentByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkCurrentExtent #-}

class HasVkMinImageExtent a where
        type VkMinImageExtentMType a :: *

        vkMinImageExtent :: a -> VkMinImageExtentMType a

        vkMinImageExtentByteOffset :: a -> Int

        readVkMinImageExtent :: Mutable a -> IO (VkMinImageExtentMType a)

        writeVkMinImageExtent ::
                              Mutable a -> VkMinImageExtentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'minImageExtent'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMinImageExtent a

instance {-# OVERLAPPING #-}
         HasVkMinImageExtent VkSurfaceCapabilitiesKHR where
        type VkMinImageExtentMType VkSurfaceCapabilitiesKHR = VkExtent2D
        vkMinImageExtent (VkSurfaceCapabilitiesKHR## ba)
          | I## _n <- sizeOf (undefined :: VkExtent2D),
            I## o <- vkMinImageExtentByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinImageExtent #-}
        vkMinImageExtentByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, minImageExtent}

        {-# INLINE vkMinImageExtentByteOffset #-}
        readVkMinImageExtent (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkExtent2D),
            I## o <- vkMinImageExtentByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinImageExtent #-}
        writeVkMinImageExtent (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinImageExtentByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinImageExtent #-}

class HasVkMaxImageExtent a where
        type VkMaxImageExtentMType a :: *

        vkMaxImageExtent :: a -> VkMaxImageExtentMType a

        vkMaxImageExtentByteOffset :: a -> Int

        readVkMaxImageExtent :: Mutable a -> IO (VkMaxImageExtentMType a)

        writeVkMaxImageExtent ::
                              Mutable a -> VkMaxImageExtentMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'maxImageExtent'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkMaxImageExtent a

instance {-# OVERLAPPING #-}
         HasVkMaxImageExtent VkSurfaceCapabilitiesKHR where
        type VkMaxImageExtentMType VkSurfaceCapabilitiesKHR = VkExtent2D
        vkMaxImageExtent (VkSurfaceCapabilitiesKHR## ba)
          | I## _n <- sizeOf (undefined :: VkExtent2D),
            I## o <- vkMaxImageExtentByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxImageExtent #-}
        vkMaxImageExtentByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, maxImageExtent}

        {-# INLINE vkMaxImageExtentByteOffset #-}
        readVkMaxImageExtent (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkExtent2D),
            I## o <- vkMaxImageExtentByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxImageExtent #-}
        writeVkMaxImageExtent (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxImageExtentByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxImageExtent #-}

instance {-# OVERLAPPING #-}
         HasVkMaxImageArrayLayers VkSurfaceCapabilitiesKHR where
        type VkMaxImageArrayLayersMType VkSurfaceCapabilitiesKHR =
             Data.Word.Word32
        vkMaxImageArrayLayers (VkSurfaceCapabilitiesKHR## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxImageArrayLayersByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMaxImageArrayLayers #-}
        vkMaxImageArrayLayersByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, maxImageArrayLayers}

        {-# INLINE vkMaxImageArrayLayersByteOffset #-}
        readVkMaxImageArrayLayers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMaxImageArrayLayersByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMaxImageArrayLayers #-}
        writeVkMaxImageArrayLayers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMaxImageArrayLayersByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMaxImageArrayLayers #-}

class HasVkSupportedTransforms a where
        type VkSupportedTransformsMType a :: *

        vkSupportedTransforms :: a -> VkSupportedTransformsMType a

        vkSupportedTransformsByteOffset :: a -> Int

        readVkSupportedTransforms ::
                                  Mutable a -> IO (VkSupportedTransformsMType a)

        writeVkSupportedTransforms ::
                                   Mutable a -> VkSupportedTransformsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'supportedTransforms'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSupportedTransforms a

instance {-# OVERLAPPING #-}
         HasVkSupportedTransforms VkSurfaceCapabilitiesKHR where
        type VkSupportedTransformsMType VkSurfaceCapabilitiesKHR =
             VkSurfaceTransformFlagsKHR
        vkSupportedTransforms (VkSurfaceCapabilitiesKHR## ba)
          | I## _n <- sizeOf (undefined :: VkSurfaceTransformFlagsKHR),
            I## o <- vkSupportedTransformsByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSupportedTransforms #-}
        vkSupportedTransformsByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, supportedTransforms}

        {-# INLINE vkSupportedTransformsByteOffset #-}
        readVkSupportedTransforms (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSurfaceTransformFlagsKHR),
            I## o <- vkSupportedTransformsByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSupportedTransforms #-}
        writeVkSupportedTransforms (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSupportedTransformsByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSupportedTransforms #-}

class HasVkCurrentTransform a where
        type VkCurrentTransformMType a :: *

        vkCurrentTransform :: a -> VkCurrentTransformMType a

        vkCurrentTransformByteOffset :: a -> Int

        readVkCurrentTransform ::
                               Mutable a -> IO (VkCurrentTransformMType a)

        writeVkCurrentTransform ::
                                Mutable a -> VkCurrentTransformMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'currentTransform'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCurrentTransform a

instance {-# OVERLAPPING #-}
         HasVkCurrentTransform VkSurfaceCapabilitiesKHR where
        type VkCurrentTransformMType VkSurfaceCapabilitiesKHR =
             VkSurfaceTransformFlagBitsKHR
        vkCurrentTransform (VkSurfaceCapabilitiesKHR## ba)
          | I## _n <- sizeOf (undefined :: VkSurfaceTransformFlagBitsKHR),
            I## o <- vkCurrentTransformByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkCurrentTransform #-}
        vkCurrentTransformByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, currentTransform}

        {-# INLINE vkCurrentTransformByteOffset #-}
        readVkCurrentTransform (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSurfaceTransformFlagBitsKHR),
            I## o <- vkCurrentTransformByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkCurrentTransform #-}
        writeVkCurrentTransform (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkCurrentTransformByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkCurrentTransform #-}

class HasVkSupportedCompositeAlpha a where
        type VkSupportedCompositeAlphaMType a :: *

        vkSupportedCompositeAlpha :: a -> VkSupportedCompositeAlphaMType a

        vkSupportedCompositeAlphaByteOffset :: a -> Int

        readVkSupportedCompositeAlpha ::
                                      Mutable a -> IO (VkSupportedCompositeAlphaMType a)

        writeVkSupportedCompositeAlpha ::
                                       Mutable a -> VkSupportedCompositeAlphaMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'supportedCompositeAlpha'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSupportedCompositeAlpha a

instance {-# OVERLAPPING #-}
         HasVkSupportedCompositeAlpha VkSurfaceCapabilitiesKHR where
        type VkSupportedCompositeAlphaMType VkSurfaceCapabilitiesKHR =
             VkCompositeAlphaFlagsKHR
        vkSupportedCompositeAlpha (VkSurfaceCapabilitiesKHR## ba)
          | I## _n <- sizeOf (undefined :: VkCompositeAlphaFlagsKHR),
            I## o <- vkSupportedCompositeAlphaByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSupportedCompositeAlpha #-}
        vkSupportedCompositeAlphaByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, supportedCompositeAlpha}

        {-# INLINE vkSupportedCompositeAlphaByteOffset #-}
        readVkSupportedCompositeAlpha (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkCompositeAlphaFlagsKHR),
            I## o <- vkSupportedCompositeAlphaByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSupportedCompositeAlpha #-}
        writeVkSupportedCompositeAlpha (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSupportedCompositeAlphaByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSupportedCompositeAlpha #-}

class HasVkSupportedUsageFlags a where
        type VkSupportedUsageFlagsMType a :: *

        vkSupportedUsageFlags :: a -> VkSupportedUsageFlagsMType a

        vkSupportedUsageFlagsByteOffset :: a -> Int

        readVkSupportedUsageFlags ::
                                  Mutable a -> IO (VkSupportedUsageFlagsMType a)

        writeVkSupportedUsageFlags ::
                                   Mutable a -> VkSupportedUsageFlagsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'supportedUsageFlags'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSupportedUsageFlags a

instance {-# OVERLAPPING #-}
         HasVkSupportedUsageFlags VkSurfaceCapabilitiesKHR where
        type VkSupportedUsageFlagsMType VkSurfaceCapabilitiesKHR =
             VkImageUsageFlags
        vkSupportedUsageFlags (VkSurfaceCapabilitiesKHR## ba)
          | I## _n <- sizeOf (undefined :: VkImageUsageFlags),
            I## o <- vkSupportedUsageFlagsByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSupportedUsageFlags #-}
        vkSupportedUsageFlagsByteOffset ~_
          = #{offset VkSurfaceCapabilitiesKHR, supportedUsageFlags}

        {-# INLINE vkSupportedUsageFlagsByteOffset #-}
        readVkSupportedUsageFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageUsageFlags),
            I## o <- vkSupportedUsageFlagsByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSupportedUsageFlags #-}
        writeVkSupportedUsageFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSupportedUsageFlagsByteOffset
                      (undefined :: VkSurfaceCapabilitiesKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSupportedUsageFlags #-}

instance Show VkSurfaceCapabilitiesKHR where
        showsPrec d x
          = showString "VkSurfaceCapabilitiesKHR {" .
              showString "vkMinImageCount = " .
                showsPrec d (vkMinImageCount x) .
                  showString ", " .
                    showString "vkMaxImageCount = " .
                      showsPrec d (vkMaxImageCount x) .
                        showString ", " .
                          showString "vkCurrentExtent = " .
                            showsPrec d (vkCurrentExtent x) .
                              showString ", " .
                                showString "vkMinImageExtent = " .
                                  showsPrec d (vkMinImageExtent x) .
                                    showString ", " .
                                      showString "vkMaxImageExtent = " .
                                        showsPrec d (vkMaxImageExtent x) .
                                          showString ", " .
                                            showString "vkMaxImageArrayLayers = " .
                                              showsPrec d (vkMaxImageArrayLayers x) .
                                                showString ", " .
                                                  showString "vkSupportedTransforms = " .
                                                    showsPrec d (vkSupportedTransforms x) .
                                                      showString ", " .
                                                        showString "vkCurrentTransform = " .
                                                          showsPrec d (vkCurrentTransform x) .
                                                            showString ", " .
                                                              showString
                                                                "vkSupportedCompositeAlpha = "
                                                                .
                                                                showsPrec d
                                                                  (vkSupportedCompositeAlpha x)
                                                                  .
                                                                  showString ", " .
                                                                    showString
                                                                      "vkSupportedUsageFlags = "
                                                                      .
                                                                      showsPrec d
                                                                        (vkSupportedUsageFlags x)
                                                                        . showChar '}'

data VkSurfaceFormatKHR = VkSurfaceFormatKHR## ByteArray##

instance Eq VkSurfaceFormatKHR where
        (VkSurfaceFormatKHR## a) == (VkSurfaceFormatKHR## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSurfaceFormatKHR where
        (VkSurfaceFormatKHR## a) `compare` (VkSurfaceFormatKHR## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSurfaceFormatKHR where
        sizeOf ~_ = #{size VkSurfaceFormatKHR}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSurfaceFormatKHR}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSurfaceFormatKHR),
            I## a <- alignment (undefined :: VkSurfaceFormatKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSurfaceFormatKHR## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSurfaceFormatKHR## ba)
          | I## n <- sizeOf (undefined :: VkSurfaceFormatKHR) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSurfaceFormatKHR where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSurfaceFormatKHR),
            I## a <- alignment (undefined :: VkSurfaceFormatKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSurfaceFormatKHR## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSurfaceFormatKHR## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSurfaceFormatKHR## ba)
          | I## n <- sizeOf (undefined :: VkSurfaceFormatKHR),
            I## a <- alignment (undefined :: VkSurfaceFormatKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSurfaceFormatKHR## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSurfaceFormatKHR## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkFormat VkSurfaceFormatKHR where
        type VkFormatMType VkSurfaceFormatKHR = VkFormat
        vkFormat (VkSurfaceFormatKHR## ba)
          | I## _n <- sizeOf (undefined :: VkFormat),
            I## o <- vkFormatByteOffset (undefined :: VkSurfaceFormatKHR) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFormat #-}
        vkFormatByteOffset ~_
          = #{offset VkSurfaceFormatKHR, format}

        {-# INLINE vkFormatByteOffset #-}
        readVkFormat (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFormat),
            I## o <- vkFormatByteOffset (undefined :: VkSurfaceFormatKHR) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFormat #-}
        writeVkFormat (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFormatByteOffset (undefined :: VkSurfaceFormatKHR) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFormat #-}

class HasVkColorSpace a where
        type VkColorSpaceMType a :: *

        vkColorSpace :: a -> VkColorSpaceMType a

        vkColorSpaceByteOffset :: a -> Int

        readVkColorSpace :: Mutable a -> IO (VkColorSpaceMType a)

        writeVkColorSpace :: Mutable a -> VkColorSpaceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'colorSpace'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkColorSpace a

instance {-# OVERLAPPING #-} HasVkColorSpace VkSurfaceFormatKHR
         where
        type VkColorSpaceMType VkSurfaceFormatKHR = VkColorSpaceKHR
        vkColorSpace (VkSurfaceFormatKHR## ba)
          | I## _n <- sizeOf (undefined :: VkColorSpaceKHR),
            I## o <- vkColorSpaceByteOffset (undefined :: VkSurfaceFormatKHR) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkColorSpace #-}
        vkColorSpaceByteOffset ~_
          = #{offset VkSurfaceFormatKHR, colorSpace}

        {-# INLINE vkColorSpaceByteOffset #-}
        readVkColorSpace (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkColorSpaceKHR),
            I## o <- vkColorSpaceByteOffset (undefined :: VkSurfaceFormatKHR) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkColorSpace #-}
        writeVkColorSpace (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkColorSpaceByteOffset (undefined :: VkSurfaceFormatKHR) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkColorSpace #-}

instance Show VkSurfaceFormatKHR where
        showsPrec d x
          = showString "VkSurfaceFormatKHR {" .
              showString "vkFormat = " .
                showsPrec d (vkFormat x) .
                  showString ", " .
                    showString "vkColorSpace = " .
                      showsPrec d (vkColorSpace x) . showChar '}'

data VkSwapchainCreateInfoKHR = VkSwapchainCreateInfoKHR## ByteArray##

instance Eq VkSwapchainCreateInfoKHR where
        (VkSwapchainCreateInfoKHR## a) == (VkSwapchainCreateInfoKHR## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkSwapchainCreateInfoKHR where
        (VkSwapchainCreateInfoKHR## a) `compare`
          (VkSwapchainCreateInfoKHR## b) = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkSwapchainCreateInfoKHR where
        sizeOf ~_ = #{size VkSwapchainCreateInfoKHR}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkSwapchainCreateInfoKHR}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkSwapchainCreateInfoKHR),
            I## a <- alignment (undefined :: VkSwapchainCreateInfoKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3,
                                                                       VkSwapchainCreateInfoKHR##
                                                                         ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkSwapchainCreateInfoKHR## ba)
          | I## n <- sizeOf (undefined :: VkSwapchainCreateInfoKHR) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkSwapchainCreateInfoKHR where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkSwapchainCreateInfoKHR),
            I## a <- alignment (undefined :: VkSwapchainCreateInfoKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3,
                                                                        VkSwapchainCreateInfoKHR##
                                                                          ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkSwapchainCreateInfoKHR## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkSwapchainCreateInfoKHR## ba)
          | I## n <- sizeOf (undefined :: VkSwapchainCreateInfoKHR),
            I## a <- alignment (undefined :: VkSwapchainCreateInfoKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkSwapchainCreateInfoKHR## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkSwapchainCreateInfoKHR## ba)
          = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkSwapchainCreateInfoKHR
         where
        type VkSTypeMType VkSwapchainCreateInfoKHR = VkStructureType
        vkSType (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkSwapchainCreateInfoKHR) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkSwapchainCreateInfoKHR) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkSwapchainCreateInfoKHR) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkSwapchainCreateInfoKHR
         where
        type VkPNextMType VkSwapchainCreateInfoKHR =
             Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkSwapchainCreateInfoKHR) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkSwapchainCreateInfoKHR) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkSwapchainCreateInfoKHR) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-} HasVkFlags VkSwapchainCreateInfoKHR
         where
        type VkFlagsMType VkSwapchainCreateInfoKHR =
             VkSwapchainCreateFlagsKHR
        vkFlags (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: VkSwapchainCreateFlagsKHR),
            I## o <- vkFlagsByteOffset (undefined :: VkSwapchainCreateInfoKHR) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkFlags #-}
        vkFlagsByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, flags}

        {-# INLINE vkFlagsByteOffset #-}
        readVkFlags (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSwapchainCreateFlagsKHR),
            I## o <- vkFlagsByteOffset (undefined :: VkSwapchainCreateInfoKHR) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkFlags #-}
        writeVkFlags (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkFlagsByteOffset (undefined :: VkSwapchainCreateInfoKHR) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkFlags #-}

class HasVkSurface a where
        type VkSurfaceMType a :: *

        vkSurface :: a -> VkSurfaceMType a

        vkSurfaceByteOffset :: a -> Int

        readVkSurface :: Mutable a -> IO (VkSurfaceMType a)

        writeVkSurface :: Mutable a -> VkSurfaceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'surface'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSurface a

instance {-# OVERLAPPING #-} HasVkSurface VkSwapchainCreateInfoKHR
         where
        type VkSurfaceMType VkSwapchainCreateInfoKHR = VkSurfaceKHR
        vkSurface (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: VkSurfaceKHR),
            I## o <- vkSurfaceByteOffset (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSurface #-}
        vkSurfaceByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, surface}

        {-# INLINE vkSurfaceByteOffset #-}
        readVkSurface (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSurfaceKHR),
            I## o <- vkSurfaceByteOffset (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSurface #-}
        writeVkSurface (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSurfaceByteOffset (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSurface #-}

instance {-# OVERLAPPING #-}
         HasVkMinImageCount VkSwapchainCreateInfoKHR where
        type VkMinImageCountMType VkSwapchainCreateInfoKHR =
             Data.Word.Word32
        vkMinImageCount (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMinImageCountByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkMinImageCount #-}
        vkMinImageCountByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, minImageCount}

        {-# INLINE vkMinImageCountByteOffset #-}
        readVkMinImageCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkMinImageCountByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkMinImageCount #-}
        writeVkMinImageCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkMinImageCountByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkMinImageCount #-}

class HasVkImageFormat a where
        type VkImageFormatMType a :: *

        vkImageFormat :: a -> VkImageFormatMType a

        vkImageFormatByteOffset :: a -> Int

        readVkImageFormat :: Mutable a -> IO (VkImageFormatMType a)

        writeVkImageFormat :: Mutable a -> VkImageFormatMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageFormat'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageFormat a

instance {-# OVERLAPPING #-}
         HasVkImageFormat VkSwapchainCreateInfoKHR where
        type VkImageFormatMType VkSwapchainCreateInfoKHR = VkFormat
        vkImageFormat (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: VkFormat),
            I## o <- vkImageFormatByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageFormat #-}
        vkImageFormatByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, imageFormat}

        {-# INLINE vkImageFormatByteOffset #-}
        readVkImageFormat (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkFormat),
            I## o <- vkImageFormatByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageFormat #-}
        writeVkImageFormat (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageFormatByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageFormat #-}

class HasVkImageColorSpace a where
        type VkImageColorSpaceMType a :: *

        vkImageColorSpace :: a -> VkImageColorSpaceMType a

        vkImageColorSpaceByteOffset :: a -> Int

        readVkImageColorSpace :: Mutable a -> IO (VkImageColorSpaceMType a)

        writeVkImageColorSpace ::
                               Mutable a -> VkImageColorSpaceMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageColorSpace'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageColorSpace a

instance {-# OVERLAPPING #-}
         HasVkImageColorSpace VkSwapchainCreateInfoKHR where
        type VkImageColorSpaceMType VkSwapchainCreateInfoKHR =
             VkColorSpaceKHR
        vkImageColorSpace (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: VkColorSpaceKHR),
            I## o <- vkImageColorSpaceByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageColorSpace #-}
        vkImageColorSpaceByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, imageColorSpace}

        {-# INLINE vkImageColorSpaceByteOffset #-}
        readVkImageColorSpace (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkColorSpaceKHR),
            I## o <- vkImageColorSpaceByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageColorSpace #-}
        writeVkImageColorSpace (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageColorSpaceByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageColorSpace #-}

instance {-# OVERLAPPING #-}
         HasVkImageExtent VkSwapchainCreateInfoKHR where
        type VkImageExtentMType VkSwapchainCreateInfoKHR = VkExtent2D
        vkImageExtent (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: VkExtent2D),
            I## o <- vkImageExtentByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageExtent #-}
        vkImageExtentByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, imageExtent}

        {-# INLINE vkImageExtentByteOffset #-}
        readVkImageExtent (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkExtent2D),
            I## o <- vkImageExtentByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageExtent #-}
        writeVkImageExtent (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageExtentByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageExtent #-}

class HasVkImageArrayLayers a where
        type VkImageArrayLayersMType a :: *

        vkImageArrayLayers :: a -> VkImageArrayLayersMType a

        vkImageArrayLayersByteOffset :: a -> Int

        readVkImageArrayLayers ::
                               Mutable a -> IO (VkImageArrayLayersMType a)

        writeVkImageArrayLayers ::
                                Mutable a -> VkImageArrayLayersMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageArrayLayers'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageArrayLayers a

instance {-# OVERLAPPING #-}
         HasVkImageArrayLayers VkSwapchainCreateInfoKHR where
        type VkImageArrayLayersMType VkSwapchainCreateInfoKHR =
             Data.Word.Word32
        vkImageArrayLayers (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkImageArrayLayersByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageArrayLayers #-}
        vkImageArrayLayersByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, imageArrayLayers}

        {-# INLINE vkImageArrayLayersByteOffset #-}
        readVkImageArrayLayers (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkImageArrayLayersByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageArrayLayers #-}
        writeVkImageArrayLayers (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageArrayLayersByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageArrayLayers #-}

class HasVkImageUsage a where
        type VkImageUsageMType a :: *

        vkImageUsage :: a -> VkImageUsageMType a

        vkImageUsageByteOffset :: a -> Int

        readVkImageUsage :: Mutable a -> IO (VkImageUsageMType a)

        writeVkImageUsage :: Mutable a -> VkImageUsageMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageUsage'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageUsage a

instance {-# OVERLAPPING #-}
         HasVkImageUsage VkSwapchainCreateInfoKHR where
        type VkImageUsageMType VkSwapchainCreateInfoKHR = VkImageUsageFlags
        vkImageUsage (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: VkImageUsageFlags),
            I## o <- vkImageUsageByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageUsage #-}
        vkImageUsageByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, imageUsage}

        {-# INLINE vkImageUsageByteOffset #-}
        readVkImageUsage (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkImageUsageFlags),
            I## o <- vkImageUsageByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageUsage #-}
        writeVkImageUsage (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageUsageByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageUsage #-}

class HasVkImageSharingMode a where
        type VkImageSharingModeMType a :: *

        vkImageSharingMode :: a -> VkImageSharingModeMType a

        vkImageSharingModeByteOffset :: a -> Int

        readVkImageSharingMode ::
                               Mutable a -> IO (VkImageSharingModeMType a)

        writeVkImageSharingMode ::
                                Mutable a -> VkImageSharingModeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'imageSharingMode'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkImageSharingMode a

instance {-# OVERLAPPING #-}
         HasVkImageSharingMode VkSwapchainCreateInfoKHR where
        type VkImageSharingModeMType VkSwapchainCreateInfoKHR =
             VkSharingMode
        vkImageSharingMode (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: VkSharingMode),
            I## o <- vkImageSharingModeByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkImageSharingMode #-}
        vkImageSharingModeByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, imageSharingMode}

        {-# INLINE vkImageSharingModeByteOffset #-}
        readVkImageSharingMode (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSharingMode),
            I## o <- vkImageSharingModeByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkImageSharingMode #-}
        writeVkImageSharingMode (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkImageSharingModeByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkImageSharingMode #-}

instance {-# OVERLAPPING #-}
         HasVkQueueFamilyIndexCount VkSwapchainCreateInfoKHR where
        type VkQueueFamilyIndexCountMType VkSwapchainCreateInfoKHR =
             Data.Word.Word32
        vkQueueFamilyIndexCount (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueFamilyIndexCountByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkQueueFamilyIndexCount #-}
        vkQueueFamilyIndexCountByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, queueFamilyIndexCount}

        {-# INLINE vkQueueFamilyIndexCountByteOffset #-}
        readVkQueueFamilyIndexCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkQueueFamilyIndexCountByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkQueueFamilyIndexCount #-}
        writeVkQueueFamilyIndexCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkQueueFamilyIndexCountByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkQueueFamilyIndexCount #-}

instance {-# OVERLAPPING #-}
         HasVkPQueueFamilyIndices VkSwapchainCreateInfoKHR where
        type VkPQueueFamilyIndicesMType VkSwapchainCreateInfoKHR =
             Foreign.Ptr.Ptr Data.Word.Word32
        vkPQueueFamilyIndices (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Word.Word32),
            I## o <- vkPQueueFamilyIndicesByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPQueueFamilyIndices #-}
        vkPQueueFamilyIndicesByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, pQueueFamilyIndices}

        {-# INLINE vkPQueueFamilyIndicesByteOffset #-}
        readVkPQueueFamilyIndices (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Word.Word32),
            I## o <- vkPQueueFamilyIndicesByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPQueueFamilyIndices #-}
        writeVkPQueueFamilyIndices (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPQueueFamilyIndicesByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPQueueFamilyIndices #-}

class HasVkPreTransform a where
        type VkPreTransformMType a :: *

        vkPreTransform :: a -> VkPreTransformMType a

        vkPreTransformByteOffset :: a -> Int

        readVkPreTransform :: Mutable a -> IO (VkPreTransformMType a)

        writeVkPreTransform :: Mutable a -> VkPreTransformMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'preTransform'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPreTransform a

instance {-# OVERLAPPING #-}
         HasVkPreTransform VkSwapchainCreateInfoKHR where
        type VkPreTransformMType VkSwapchainCreateInfoKHR =
             VkSurfaceTransformFlagBitsKHR
        vkPreTransform (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: VkSurfaceTransformFlagBitsKHR),
            I## o <- vkPreTransformByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPreTransform #-}
        vkPreTransformByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, preTransform}

        {-# INLINE vkPreTransformByteOffset #-}
        readVkPreTransform (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSurfaceTransformFlagBitsKHR),
            I## o <- vkPreTransformByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPreTransform #-}
        writeVkPreTransform (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPreTransformByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPreTransform #-}

class HasVkCompositeAlpha a where
        type VkCompositeAlphaMType a :: *

        vkCompositeAlpha :: a -> VkCompositeAlphaMType a

        vkCompositeAlphaByteOffset :: a -> Int

        readVkCompositeAlpha :: Mutable a -> IO (VkCompositeAlphaMType a)

        writeVkCompositeAlpha ::
                              Mutable a -> VkCompositeAlphaMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'compositeAlpha'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkCompositeAlpha a

instance {-# OVERLAPPING #-}
         HasVkCompositeAlpha VkSwapchainCreateInfoKHR where
        type VkCompositeAlphaMType VkSwapchainCreateInfoKHR =
             VkCompositeAlphaFlagBitsKHR
        vkCompositeAlpha (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: VkCompositeAlphaFlagBitsKHR),
            I## o <- vkCompositeAlphaByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkCompositeAlpha #-}
        vkCompositeAlphaByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, compositeAlpha}

        {-# INLINE vkCompositeAlphaByteOffset #-}
        readVkCompositeAlpha (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkCompositeAlphaFlagBitsKHR),
            I## o <- vkCompositeAlphaByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkCompositeAlpha #-}
        writeVkCompositeAlpha (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkCompositeAlphaByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkCompositeAlpha #-}

class HasVkPresentMode a where
        type VkPresentModeMType a :: *

        vkPresentMode :: a -> VkPresentModeMType a

        vkPresentModeByteOffset :: a -> Int

        readVkPresentMode :: Mutable a -> IO (VkPresentModeMType a)

        writeVkPresentMode :: Mutable a -> VkPresentModeMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'presentMode'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPresentMode a

instance {-# OVERLAPPING #-}
         HasVkPresentMode VkSwapchainCreateInfoKHR where
        type VkPresentModeMType VkSwapchainCreateInfoKHR = VkPresentModeKHR
        vkPresentMode (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: VkPresentModeKHR),
            I## o <- vkPresentModeByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPresentMode #-}
        vkPresentModeByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, presentMode}

        {-# INLINE vkPresentModeByteOffset #-}
        readVkPresentMode (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkPresentModeKHR),
            I## o <- vkPresentModeByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPresentMode #-}
        writeVkPresentMode (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPresentModeByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPresentMode #-}

class HasVkClipped a where
        type VkClippedMType a :: *

        vkClipped :: a -> VkClippedMType a

        vkClippedByteOffset :: a -> Int

        readVkClipped :: Mutable a -> IO (VkClippedMType a)

        writeVkClipped :: Mutable a -> VkClippedMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'clipped'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkClipped a

instance {-# OVERLAPPING #-} HasVkClipped VkSwapchainCreateInfoKHR
         where
        type VkClippedMType VkSwapchainCreateInfoKHR = VkBool32
        vkClipped (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkClippedByteOffset (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkClipped #-}
        vkClippedByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, clipped}

        {-# INLINE vkClippedByteOffset #-}
        readVkClipped (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkBool32),
            I## o <- vkClippedByteOffset (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkClipped #-}
        writeVkClipped (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkClippedByteOffset (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkClipped #-}

class HasVkOldSwapchain a where
        type VkOldSwapchainMType a :: *

        vkOldSwapchain :: a -> VkOldSwapchainMType a

        vkOldSwapchainByteOffset :: a -> Int

        readVkOldSwapchain :: Mutable a -> IO (VkOldSwapchainMType a)

        writeVkOldSwapchain :: Mutable a -> VkOldSwapchainMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'oldSwapchain'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkOldSwapchain a

instance {-# OVERLAPPING #-}
         HasVkOldSwapchain VkSwapchainCreateInfoKHR where
        type VkOldSwapchainMType VkSwapchainCreateInfoKHR = VkSwapchainKHR
        vkOldSwapchain (VkSwapchainCreateInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: VkSwapchainKHR),
            I## o <- vkOldSwapchainByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkOldSwapchain #-}
        vkOldSwapchainByteOffset ~_
          = #{offset VkSwapchainCreateInfoKHR, oldSwapchain}

        {-# INLINE vkOldSwapchainByteOffset #-}
        readVkOldSwapchain (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkSwapchainKHR),
            I## o <- vkOldSwapchainByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkOldSwapchain #-}
        writeVkOldSwapchain (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkOldSwapchainByteOffset
                      (undefined :: VkSwapchainCreateInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkOldSwapchain #-}

instance Show VkSwapchainCreateInfoKHR where
        showsPrec d x
          = showString "VkSwapchainCreateInfoKHR {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkFlags = " .
                            showsPrec d (vkFlags x) .
                              showString ", " .
                                showString "vkSurface = " .
                                  showsPrec d (vkSurface x) .
                                    showString ", " .
                                      showString "vkMinImageCount = " .
                                        showsPrec d (vkMinImageCount x) .
                                          showString ", " .
                                            showString "vkImageFormat = " .
                                              showsPrec d (vkImageFormat x) .
                                                showString ", " .
                                                  showString "vkImageColorSpace = " .
                                                    showsPrec d (vkImageColorSpace x) .
                                                      showString ", " .
                                                        showString "vkImageExtent = " .
                                                          showsPrec d (vkImageExtent x) .
                                                            showString ", " .
                                                              showString "vkImageArrayLayers = " .
                                                                showsPrec d (vkImageArrayLayers x) .
                                                                  showString ", " .
                                                                    showString "vkImageUsage = " .
                                                                      showsPrec d (vkImageUsage x) .
                                                                        showString ", " .
                                                                          showString
                                                                            "vkImageSharingMode = "
                                                                            .
                                                                            showsPrec d
                                                                              (vkImageSharingMode x)
                                                                              .
                                                                              showString ", " .
                                                                                showString
                                                                                  "vkQueueFamilyIndexCount = "
                                                                                  .
                                                                                  showsPrec d
                                                                                    (vkQueueFamilyIndexCount
                                                                                       x)
                                                                                    .
                                                                                    showString ", "
                                                                                      .
                                                                                      showString
                                                                                        "vkPQueueFamilyIndices = "
                                                                                        .
                                                                                        showsPrec d
                                                                                          (vkPQueueFamilyIndices
                                                                                             x)
                                                                                          .
                                                                                          showString
                                                                                            ", "
                                                                                            .
                                                                                            showString
                                                                                              "vkPreTransform = "
                                                                                              .
                                                                                              showsPrec
                                                                                                d
                                                                                                (vkPreTransform
                                                                                                   x)
                                                                                                .
                                                                                                showString
                                                                                                  ", "
                                                                                                  .
                                                                                                  showString
                                                                                                    "vkCompositeAlpha = "
                                                                                                    .
                                                                                                    showsPrec
                                                                                                      d
                                                                                                      (vkCompositeAlpha
                                                                                                         x)
                                                                                                      .
                                                                                                      showString
                                                                                                        ", "
                                                                                                        .
                                                                                                        showString
                                                                                                          "vkPresentMode = "
                                                                                                          .
                                                                                                          showsPrec
                                                                                                            d
                                                                                                            (vkPresentMode
                                                                                                               x)
                                                                                                            .
                                                                                                            showString
                                                                                                              ", "
                                                                                                              .
                                                                                                              showString
                                                                                                                "vkClipped = "
                                                                                                                .
                                                                                                                showsPrec
                                                                                                                  d
                                                                                                                  (vkClipped
                                                                                                                     x)
                                                                                                                  .
                                                                                                                  showString
                                                                                                                    ", "
                                                                                                                    .
                                                                                                                    showString
                                                                                                                      "vkOldSwapchain = "
                                                                                                                      .
                                                                                                                      showsPrec
                                                                                                                        d
                                                                                                                        (vkOldSwapchain
                                                                                                                           x)
                                                                                                                        .
                                                                                                                        showChar
                                                                                                                          '}'

data VkPresentInfoKHR = VkPresentInfoKHR## ByteArray##

instance Eq VkPresentInfoKHR where
        (VkPresentInfoKHR## a) == (VkPresentInfoKHR## b)
          = EQ == cmpImmutableContent a b

        {-# INLINE (==) #-}

instance Ord VkPresentInfoKHR where
        (VkPresentInfoKHR## a) `compare` (VkPresentInfoKHR## b)
          = cmpImmutableContent a b

        {-# INLINE compare #-}

instance Storable VkPresentInfoKHR where
        sizeOf ~_ = #{size VkPresentInfoKHR}

        {-# INLINE sizeOf #-}
        alignment ~_ = #{alignment VkPresentInfoKHR}

        {-# INLINE alignment #-}
        peek (Ptr addr)
          | I## n <- sizeOf (undefined :: VkPresentInfoKHR),
            I## a <- alignment (undefined :: VkPresentInfoKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> case copyAddrToByteArray## addr mba 0## n s1 of
                                          s2 -> case unsafeFreezeByteArray## mba s2 of
                                                    (## s3, ba ##) -> (## s3, VkPresentInfoKHR## ba ##))

        {-# INLINE peek #-}
        poke (Ptr addr) (VkPresentInfoKHR## ba)
          | I## n <- sizeOf (undefined :: VkPresentInfoKHR) =
            IO (\ s -> (## copyByteArrayToAddr## ba 0## addr n s, () ##))

        {-# INLINE poke #-}

instance VulkanMarshal VkPresentInfoKHR where
        freeze (Mutable## mba)
          | I## n <- sizeOf (undefined :: VkPresentInfoKHR),
            I## a <- alignment (undefined :: VkPresentInfoKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba' ##) -> case copyMutableByteArray## mba 0## mba' 0## n s1 of
                                           s2 -> case unsafeFreezeByteArray## mba' s2 of
                                                     (## s3, ba ##) -> (## s3, VkPresentInfoKHR## ba ##))

        {-# INLINE freeze #-}
        unsafeFreeze (Mutable## mba)
          = IO
              (\ s ->
                 case unsafeFreezeByteArray## mba s of
                     (## s', ba ##) -> (## s', VkPresentInfoKHR## ba ##))

        {-# INLINE unsafeFreeze #-}
        thaw (VkPresentInfoKHR## ba)
          | I## n <- sizeOf (undefined :: VkPresentInfoKHR),
            I## a <- alignment (undefined :: VkPresentInfoKHR) =
            IO
              (\ s ->
                 case newAlignedPinnedByteArray## n a s of
                     (## s1, mba ##) -> (## copyByteArray## ba 0## mba 0## n s1,
                                         Mutable## mba ##))

        {-# INLINE thaw #-}
        unsafeThaw (VkPresentInfoKHR## ba)
          = IO (\ s -> (## s, Mutable## (unsafeCoerce## ba) ##))

        {-# INLINE unsafeThaw #-}
        touchVkData a@(VkPresentInfoKHR## ba) = touchImmutableContent a ba

        {-# INLINE touchVkData #-}
        addVkDataFinalizer = addImmutableContentFinalizer

        {-# INLINE addVkDataFinalizer #-}

instance {-# OVERLAPPING #-} HasVkSType VkPresentInfoKHR where
        type VkSTypeMType VkPresentInfoKHR = VkStructureType
        vkSType (VkPresentInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkPresentInfoKHR) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSType #-}
        vkSTypeByteOffset ~_ = #{offset VkPresentInfoKHR, sType}

        {-# INLINE vkSTypeByteOffset #-}
        readVkSType (Mutable## mba)
          | I## _n <- sizeOf (undefined :: VkStructureType),
            I## o <- vkSTypeByteOffset (undefined :: VkPresentInfoKHR) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSType #-}
        writeVkSType (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSTypeByteOffset (undefined :: VkPresentInfoKHR) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSType #-}

instance {-# OVERLAPPING #-} HasVkPNext VkPresentInfoKHR where
        type VkPNextMType VkPresentInfoKHR = Foreign.Ptr.Ptr Data.Void.Void
        vkPNext (VkPresentInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkPresentInfoKHR) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPNext #-}
        vkPNextByteOffset ~_ = #{offset VkPresentInfoKHR, pNext}

        {-# INLINE vkPNextByteOffset #-}
        readVkPNext (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Void.Void),
            I## o <- vkPNextByteOffset (undefined :: VkPresentInfoKHR) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPNext #-}
        writeVkPNext (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPNextByteOffset (undefined :: VkPresentInfoKHR) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPNext #-}

instance {-# OVERLAPPING #-}
         HasVkWaitSemaphoreCount VkPresentInfoKHR where
        type VkWaitSemaphoreCountMType VkPresentInfoKHR = Data.Word.Word32
        vkWaitSemaphoreCount (VkPresentInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkWaitSemaphoreCountByteOffset
                      (undefined :: VkPresentInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkWaitSemaphoreCount #-}
        vkWaitSemaphoreCountByteOffset ~_
          = #{offset VkPresentInfoKHR, waitSemaphoreCount}

        {-# INLINE vkWaitSemaphoreCountByteOffset #-}
        readVkWaitSemaphoreCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkWaitSemaphoreCountByteOffset
                      (undefined :: VkPresentInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkWaitSemaphoreCount #-}
        writeVkWaitSemaphoreCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkWaitSemaphoreCountByteOffset
                      (undefined :: VkPresentInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkWaitSemaphoreCount #-}

instance {-# OVERLAPPING #-} HasVkPWaitSemaphores VkPresentInfoKHR
         where
        type VkPWaitSemaphoresMType VkPresentInfoKHR =
             Foreign.Ptr.Ptr VkSemaphore
        vkPWaitSemaphores (VkPresentInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSemaphore),
            I## o <- vkPWaitSemaphoresByteOffset (undefined :: VkPresentInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPWaitSemaphores #-}
        vkPWaitSemaphoresByteOffset ~_
          = #{offset VkPresentInfoKHR, pWaitSemaphores}

        {-# INLINE vkPWaitSemaphoresByteOffset #-}
        readVkPWaitSemaphores (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSemaphore),
            I## o <- vkPWaitSemaphoresByteOffset (undefined :: VkPresentInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPWaitSemaphores #-}
        writeVkPWaitSemaphores (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPWaitSemaphoresByteOffset (undefined :: VkPresentInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPWaitSemaphores #-}

class HasVkSwapchainCount a where
        type VkSwapchainCountMType a :: *

        vkSwapchainCount :: a -> VkSwapchainCountMType a

        vkSwapchainCountByteOffset :: a -> Int

        readVkSwapchainCount :: Mutable a -> IO (VkSwapchainCountMType a)

        writeVkSwapchainCount ::
                              Mutable a -> VkSwapchainCountMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'swapchainCount'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkSwapchainCount a

instance {-# OVERLAPPING #-} HasVkSwapchainCount VkPresentInfoKHR
         where
        type VkSwapchainCountMType VkPresentInfoKHR = Data.Word.Word32
        vkSwapchainCount (VkPresentInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSwapchainCountByteOffset (undefined :: VkPresentInfoKHR)
            =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkSwapchainCount #-}
        vkSwapchainCountByteOffset ~_
          = #{offset VkPresentInfoKHR, swapchainCount}

        {-# INLINE vkSwapchainCountByteOffset #-}
        readVkSwapchainCount (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Data.Word.Word32),
            I## o <- vkSwapchainCountByteOffset (undefined :: VkPresentInfoKHR)
            = peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkSwapchainCount #-}
        writeVkSwapchainCount (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkSwapchainCountByteOffset (undefined :: VkPresentInfoKHR)
            =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkSwapchainCount #-}

class HasVkPSwapchains a where
        type VkPSwapchainsMType a :: *

        vkPSwapchains :: a -> VkPSwapchainsMType a

        vkPSwapchainsByteOffset :: a -> Int

        readVkPSwapchains :: Mutable a -> IO (VkPSwapchainsMType a)

        writeVkPSwapchains :: Mutable a -> VkPSwapchainsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pSwapchains'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPSwapchains a

instance {-# OVERLAPPING #-} HasVkPSwapchains VkPresentInfoKHR
         where
        type VkPSwapchainsMType VkPresentInfoKHR =
             Foreign.Ptr.Ptr VkSwapchainKHR
        vkPSwapchains (VkPresentInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSwapchainKHR),
            I## o <- vkPSwapchainsByteOffset (undefined :: VkPresentInfoKHR) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPSwapchains #-}
        vkPSwapchainsByteOffset ~_
          = #{offset VkPresentInfoKHR, pSwapchains}

        {-# INLINE vkPSwapchainsByteOffset #-}
        readVkPSwapchains (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkSwapchainKHR),
            I## o <- vkPSwapchainsByteOffset (undefined :: VkPresentInfoKHR) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPSwapchains #-}
        writeVkPSwapchains (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPSwapchainsByteOffset (undefined :: VkPresentInfoKHR) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPSwapchains #-}

class HasVkPImageIndices a where
        type VkPImageIndicesMType a :: *

        vkPImageIndices :: a -> VkPImageIndicesMType a

        vkPImageIndicesByteOffset :: a -> Int

        readVkPImageIndices :: Mutable a -> IO (VkPImageIndicesMType a)

        writeVkPImageIndices ::
                             Mutable a -> VkPImageIndicesMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pImageIndices'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPImageIndices a

instance {-# OVERLAPPING #-} HasVkPImageIndices VkPresentInfoKHR
         where
        type VkPImageIndicesMType VkPresentInfoKHR =
             Foreign.Ptr.Ptr Data.Word.Word32
        vkPImageIndices (VkPresentInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Word.Word32),
            I## o <- vkPImageIndicesByteOffset (undefined :: VkPresentInfoKHR) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPImageIndices #-}
        vkPImageIndicesByteOffset ~_
          = #{offset VkPresentInfoKHR, pImageIndices}

        {-# INLINE vkPImageIndicesByteOffset #-}
        readVkPImageIndices (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr Data.Word.Word32),
            I## o <- vkPImageIndicesByteOffset (undefined :: VkPresentInfoKHR) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPImageIndices #-}
        writeVkPImageIndices (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPImageIndicesByteOffset (undefined :: VkPresentInfoKHR) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPImageIndices #-}

class HasVkPResults a where
        type VkPResultsMType a :: *

        vkPResults :: a -> VkPResultsMType a

        vkPResultsByteOffset :: a -> Int

        readVkPResults :: Mutable a -> IO (VkPResultsMType a)

        writeVkPResults :: Mutable a -> VkPResultsMType a -> IO ()

instance {-# OVERLAPPABLE #-}
         TypeError
           (ShowType a :<>:
              Text " does not seem to have field 'pResults'." :$$:
                Text
                  "Check Vulkan documentation for available fields of this type.") =>
         HasVkPResults a

instance {-# OVERLAPPING #-} HasVkPResults VkPresentInfoKHR where
        type VkPResultsMType VkPresentInfoKHR = Foreign.Ptr.Ptr VkResult
        vkPResults (VkPresentInfoKHR## ba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkResult),
            I## o <- vkPResultsByteOffset (undefined :: VkPresentInfoKHR) =
            unsafeDupablePerformIO
              (peek (Ptr (byteArrayContents## ba `plusAddr##` o)))

        {-# NOINLINE vkPResults #-}
        vkPResultsByteOffset ~_
          = #{offset VkPresentInfoKHR, pResults}

        {-# INLINE vkPResultsByteOffset #-}
        readVkPResults (Mutable## mba)
          | I## _n <- sizeOf (undefined :: Foreign.Ptr.Ptr VkResult),
            I## o <- vkPResultsByteOffset (undefined :: VkPresentInfoKHR) =
            peek (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o))

        {-# INLINE readVkPResults #-}
        writeVkPResults (Mutable## mba) x
          | I## _n <- sizeOf x,
            I## o <- vkPResultsByteOffset (undefined :: VkPresentInfoKHR) =
            poke (Ptr (byteArrayContents## (unsafeCoerce## mba) `plusAddr##` o)) x

        {-# INLINE writeVkPResults #-}

instance Show VkPresentInfoKHR where
        showsPrec d x
          = showString "VkPresentInfoKHR {" .
              showString "vkSType = " .
                showsPrec d (vkSType x) .
                  showString ", " .
                    showString "vkPNext = " .
                      showsPrec d (vkPNext x) .
                        showString ", " .
                          showString "vkWaitSemaphoreCount = " .
                            showsPrec d (vkWaitSemaphoreCount x) .
                              showString ", " .
                                showString "vkPWaitSemaphores = " .
                                  showsPrec d (vkPWaitSemaphores x) .
                                    showString ", " .
                                      showString "vkSwapchainCount = " .
                                        showsPrec d (vkSwapchainCount x) .
                                          showString ", " .
                                            showString "vkPSwapchains = " .
                                              showsPrec d (vkPSwapchains x) .
                                                showString ", " .
                                                  showString "vkPImageIndices = " .
                                                    showsPrec d (vkPImageIndices x) .
                                                      showString ", " .
                                                        showString "vkPResults = " .
                                                          showsPrec d (vkPResults x) . showChar '}'
